!===================================================================
!
! VEC{ATOM}: ATOM vectors
!
! Copyright (C) Dylan Jayatilaka, 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!===================================================================

module VEC{ATOM}

   USE dftd3_api

   implicit none

   ! Atom connection table
   connections_for :: VEC{EVEC{INT}}@, private

   ! Atom group connection table, to save work
 ! group_connections_for :: VEC{EVEC{INT}}@, private

contains

!  ==========
!  Allocation
!  ==========

   create(dim) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Allocate vector
   end

   create(lb,ub) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Allocate the vector with lower bound "lb", upper bound "ub"
   end

   destroy ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Deallocate the vector
   end

   destroy_ptr_part ::: PURE
   ! Destroy the pointer parts of self
      self :: INOUT

      a :: INT

      do a = 1,.dim
         self(a).destroy_ptr_part
      end

   end

   destroy_bases ::: PURE
   ! Destroy all the bases
      self :: INOUT
      .destroy_basis_part
      .destroy_slaterbasis_part
      .destroy_coppensbasis_part
   end

   destroy_basis_part ::: PURE
   ! Destroy the gaussian basis parts of self
      self :: INOUT
      a :: INT
      do a = 1,.dim
         self(a).basis.destroy
      end
   end

   destroy_slaterbasis_part ::: PURE
   ! Destroy the slaterbasis parts of self
      self :: INOUT
      a :: INT
      do a = 1,.dim
         self(a).slaterbasis.destroy
      end
   end

   destroy_coppensbasis_part ::: PURE
   ! Destroy the coppensbasis parts of self
      self :: INOUT
      a :: INT
      do a = 1,.dim
         self(a).coppensbasis.destroy
      end
   end

   destroy_NAO_matrices ::: leaky, PURE
   ! Destroy the (unique-atom) NAOs
      self :: INOUT
      a :: INT
      do a = 1,.dim
         self(a).destroy_NAO_matrices
      end
   end

   destroy_ANO_matrices ::: leaky, PURE
   ! Destroy the (unique-atom) ANOs
      self :: INOUT
      a :: INT
      do a = 1,.dim
         self(a).destroy_ANO_matrices
      end
   end

   destroy_interpolators ::: leaky, PURE
   ! Destroy the (unique-atom) ANO interpolators
      self :: INOUT
      a :: INT
      do a = 1,.dim
         self(a).destroy_interpolators
      end
   end

   destroy_shell_info ::: leaky, PURE
   ! Destroy the (unique-atom) shell info
      self :: INOUT
      a :: INT
      do a = 1,.dim
         self(a).destroy_shell_info
      end
   end

   destroy_atom_data ::: leaky, PURE
   ! Destroy the (non-unique) ANO data
      self :: INOUT
      a :: INT
      do a = 1,.dim
         self(a).destroy_atom_data
      end
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
   end

!  ======================
!  Shrink, expand, append
!  ======================

   shrink(dim,chop_start) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Shrink allocatable "self" to dimension "dim" from the end.
   ! Contents are retained. If "chop_start" is present and TRUE,
   ! "self" is chopped from the start, and the contents from the end
   ! are retained.
   end

   expand(dim,grow_start) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Expand allocatable "self" to dimension "dim" adding to the end.
   ! If "grow_start" is present and TRUE, then "self" is expanded from
   ! the start, keeping the same lower bound.
   end

   append(v) ::: get_from(VEC{OBJECT}), leaky, pure
   ! Append the contents of vector "v" to allocatable "self".
   end

   append(value) ::: get_from(VEC{OBJECT}), leaky, pure
   ! Appends the scalar "value" onto the end of allocatable "self".
   end

   prune_element(k) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Removes the element at position "k" from allocatable "self".
   ! Elements after that position are moved downward.
   end

!  ==========
!  Set labels
!  ==========

   set_atom_data_from_labels(labels) ::: PURE
   ! Set "labels" for the atoms and also their atomic numbers.
      self :: INOUT
      labels :: VEC{STR}, IN

   ENSURE(labels.dim==.dim,"wrong length for labels")

      a :: INT

      do a = 1,.dim
         self(a).set_atom_data_from_label(labels(a))
      end

   end

   set_is_cap_atom(val) ::: pure
   ! Set whether the atom is a "capping" atom for fragmantation
   ! calculations.
      self :: INOUT
      val :: BIN, IN
      self(:).is_cap_atom = val
   end

   set_labels(labels) ::: PURE
   ! Set the "labels" ONLY for the atoms; use the above routine to set the
   ! atomic numbers as well.
      self :: INOUT
      labels :: VEC{STR}, IN

   ENSURE(labels.dim==.dim,"wrong length for labels")

      self%label = labels

   end

   set_recognised_labels(list) ::: leaky, PURE
   ! Set "list" to be the list of recognised labels. If all labels 
   ! are recognised then "list" is not created.
      self :: INOUT
      list :: VEC{INT}@, OUT

      n :: INT

      do n = 1,.dim
         if (NOT self(n).has_recognised_label) cycle
         list.append(n)
      end
      if (list.dim==.dim) list.destroy

   end

   set_use_interpolators(use_interp) ::: pure
   ! Read whether to use interpolators for spherical atom densities
      self :: INOUT
      use_interp :: BIN, IN

      a :: INT

      self%use_interpolator = use_interp

      if (.has_all_slater_bases)  then
         do a = 1,.dim
            self(a).slaterbasis.set_use_interpolators(use_interp)
         end
      end

      if (.has_all_coppens_bases) then
         do a = 1,.dim
            self(a).coppensbasis.set_use_interpolators(use_interp)
         end
      end

   end

   set_unique_tags ::: PURE
   ! Set the unique tags.
      self :: INOUT

      Z_list :: VEC{EVEC{INT}}@
      a,k,n,nk :: INT

      ! Get the atom Z list
      .make_atom_Z_list(Z_list)

      ! Label atoms consecutively Xn, X=symbol, n=1,...
      do k = 1,Z_list.dim

         nk = Z_list(k).element.dim

         do n = 1,nk

            ! Atom index
            a = Z_list(k)[n]

            ! Skip dummy
            if (self(a).is_a_dummy_atom) cycle

            ! Set tag
            if (nk==1) then; self(a)%tag = trim(self(a).chemical_symbol)
            else;            self(a)%tag = trim(self(a).chemical_symbol) // trim(n.to_str)
            end

         end

      end

      ! Clean
      Z_list.destroy

   end

   set_basis_suffix(suffix) ::: PURE
   ! Set the "basis_label" to be a library-style label using "suffix"
      self :: INOUT
      suffix :: STR, IN

      val :: STR
      a :: INT

      do a = 1,.dim
         val = self(a).library_basis_label(suffix)
         self(a).set_basis_label(val)
      end

   end

!  =========
!  Set kinds
!  =========

   update_kinds(n_kind) ::: PURE
   ! Set the kinds and whether the atoms are basis-unique.
   ! . They are the same kind if they have the same kind of basis
   !   and same atomic number.
   ! . This is used for ANO or other QM type calculations.
      self :: INOUT
      n_kind :: INT, optional, OUT

      k,a,b :: INT

      ! Initially all different kind
      do a = 1,.dim
         self(a).set_kind(a)
      end

      ! Kind index
      k = 0

      ! Loop on atoms "a"
      do a = 1,.dim

         ! Already found this kind?
         if (self(a).kind<=k) cycle

         ! New kind
         k = k + 1
         self(a).set_kind(k)
         self(a).set_is_unique_kind(TRUE)

         ! Set non-unique kinds
         do b = a+1,.dim

            if (self(b).kind<=k) cycle
            if (NOT .same_kind_of_atoms(a,b)) cycle

            self(b).set_kind(k)
            self(b).set_is_unique_kind(FALSE)

         end

      end

      if (present (n_kind)) n_kind = k

   end

   set_is_unique_kind(val) ::: PURE
   ! Generic set
      self :: INOUT
      val :: BIN, IN

      a :: INT

      do a = 1,.dim
         self(a).set_is_unique_kind(val)
      end

   end

   set_basis_kind(val) ::: PURE
   ! Generic set
      self :: INOUT
      val :: STR, IN

      a :: INT

      do a = 1,.dim
         self(a).set_basis_kind(val)
      end

   end

!  ==========================
!  Set whether data/info made
!  ==========================

   set_atom_data_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>self%atom_data_made)
   ! Generic set
   end

!  =============
!  Set positions
!  =============

   set_positions_from_vector(v) ::: PURE
   ! Set the positions from "v", a flat vector, where the xyz
   ! positions increment fastest
      self :: INOUT
      v :: VEC{REAL}, IN

   ENSURE(v.dim==3*.dim,"wrong size, v")

      .set_positions_to(reshape(v, [3, .dim]))

   end

   set_positions_to(mx) ::: PURE
   ! Set the positions from matrix "mx". The shape must be (3xN).
      self :: INOUT
      mx :: MAT{REAL}, IN

   ENSURE(mx.dim1==3,   "dim1 is not 3")
   ENSURE(mx.dim2==.dim,"dim2 is incompatible")

      a :: INT

      do a = 1,.dim
         self(a).set_position(mx(:,a))
      end

   end

   set_position_errors_to(me) ::: PURE
   ! Set the position_erroros from matrix "mx". The shape must be (3xN).
      self :: INOUT
      me :: MAT{REAL}, IN

   ENSURE(me.dim1==3,   "dim1 is not 3")
   ENSURE(me.dim2==.dim,"dim2 is incompatible")

      a :: INT

      do a = 1,.dim
         self(a).set_position_error(me(:,a))
      end

   end

!  ====================
!  Set site occupancies
!  ====================

   set_site_occupancies(val) ::: PURE
   ! Generic set
      self :: INOUT
      val :: VEC{REAL}, IN

   ENSURE(val.dim==.dim,"wrong size for occupancies")

      a :: INT

      do a = 1,.dim
         self(a).set_site_occupancy(val(a))
      end

   end

   set_site_disorder_groups(val) ::: PURE
   ! Generic set
      self :: INOUT
      val :: VEC{INT}, IN

   ENSURE(val.dim==.dim,"wrong size for occupancies")

      a :: INT

      do a = 1,.dim
         self(a).set_site_disorder_group(val(a))
      end

   end

!  ===============
!  Set axis system
!  ===============

   set_axis_system_to(val) ::: PURE
   ! Generic set
      self :: INOUT
      val :: STR, IN

      a :: INT

      do a = 1,.dim
         self(a).set_axis_system_to(val)
      end

   end

   set_pos_axis_system_to(val) ::: PURE
   ! Generic set
      self :: INOUT
      val :: STR, IN

      a :: INT

      do a = 1,.dim
         self(a).set_pos_axis_system_to(val)
      end

   end

   set_ADP_axis_system_to(val) ::: PURE
   ! Generic set
      self :: INOUT
      val :: STR, IN

      a :: INT

      do a = 1,.dim
         self(a).set_ADP_axis_system_to(val)
      end

   end

   set_ADPn_axis_system_to(val) ::: PURE
   ! Generic set
      self :: INOUT
      val :: STR, IN

      a :: INT

      do a = 1,.dim
         self(a).set_ADPn_axis_system_to(val)
      end

   end

!  ============
!  pADP/ADP set
!  ============

   set_ADP_tensor(val) ::: PURE
   ! Generic set
      self :: INOUT
      val :: REAL, IN

      a :: INT

      do a = 1,.dim
         self(a).set_ADP_tensor(val)
      end

   end

! Set U_iso

   set_isotropic_H_ADP ::: PURE
   ! Set the isotropic hydrogen ADPs
      self :: INOUT

      a :: INT

      do a = 1,.dim
         if (self(a).atomic_number==1) then
            self(a).set_isotropic_ADP
         end
      end

   end

   set_isotropic_ADPs(tags) ::: PURE
   ! Set isotropic ADPs for the atoms wich have tags given in "tags"
      self :: INOUT
      tags :: VEC{STR}, IN

      a :: INT

      do a = 1,.dim
         if (any(self(a).tag==tags)) then
            self(a).set_isotropic_ADP
         end
      end

   end

   set_U_iso(val) ::: PURE
   ! Generic set
      self :: INOUT
      val :: REAL, IN

      a :: INT

      do a = 1,.dim
         self(a).set_U_iso(val)
      end

   end

   set_U_iso(val) ::: PURE
   ! Generic set
      self :: INOUT
      val :: VEC{REAL}, IN

      a :: INT

      do a = 1,.dim
         self(a).set_U_iso(val(a))
      end

   end

   set_U_iso_error(err) ::: PURE
   ! Generic set
      self :: INOUT
      err :: VEC{REAL}, IN

   ENSURE(err.dim==.dim,"wrong size for occupancies")

      a :: INT

      do a = 1,.dim
         self(a).set_U_iso_error(err(a))
      end

   end

! Reset pADPs

   reset_pADPs_and_errors(dim) ::: leaky, PURE
   ! Allocate the positional-ADP parameters to a set size "dim".
   ! NOTE: assigning 4th order tags implies 3rd order.
      self :: INOUT
      dim :: INT, IN

      n,a :: INT

      ! Make sure at least 9 long.
      n = max(dim,9)

      ! Reset each pADP
      do a = 1,.dim
         self(a).reset_pADPs_and_errors(n)
      end

   end

   reset_pADPs_and_errors(anharm3_tags,anharm4_tags) ::: leaky, PURE
   ! Allocate the positional-ADP parameters based on the given tags.
   ! NOTE: assigning 4th order tags implies 3rd order.
      self :: INOUT
      anharm3_tags :: VEC{STR}@, IN
      anharm4_tags :: VEC{STR}@, IN

      t,a :: INT
      tag :: STR

      ! Find the 4th-order tags, resize pADP_vector, and set to 0
      ! If the atoms are already fourth order do nothing.
      if (anharm4_tags.allocated) then

         do t = 1,anharm4_tags.dim
            tag = anharm4_tags(t)
            a   = self(:).tag.index_of(tag)
            ENSURE(a>0,"no atom for 4th-order tag: "//trim(tag))
            self(a).reset_pADPs_and_errors(34)
         end

      end

      ! Find the 3rd-order tags, resize pADP_vector, and set to 0
      ! If they were already 3rd or 4th order, do nothing
      if (anharm3_tags.allocated) then

         do t = 1,anharm3_tags.dim
            tag = anharm3_tags(t)
            a   = self(:).tag.index_of(tag)
            ENSURE(a>0,"no atom for 3rd-order tag: "//trim(tag))
            self(a).reset_pADPs_and_errors(19)
         end

      end

      ! Make sure at least 9 long.
      do a = 1,.dim
         self(a).reset_pADPs_and_errors(9)
      end

   end

! Set pADPs

   set_pADP_vector_to(X) ::: leaky, PURE
   ! Set the pADP vector from vector "X".
   ! NOTE: positions and ADP_tensors are set!
      self :: INOUT
      X :: VEC{REAL}, IN

   ENSURE(X.dim==.no_of_pADPs,"wrong size, X")

      a,f,l :: INT

      l = 0
      do a = 1,.dim

         ! Limits
         f = l + 1
         l = l + self(a).no_of_pADPs

         ! Leaky
         self(a).set_pADP_vector_to(X(f:l))

      end

   end

   set_pADP_errors_to(covariance_mx,H_U_iso) ::: PURE
   ! Set the pADP errors from vector "dX".
      self :: INOUT
      covariance_mx :: MAT{REAL}, IN
      H_U_iso :: BIN, IN

   ENSURE(covariance_mx.dim1==.no_of_pADPs,"wrong size, cov")

      a,f,l,n :: INT

      l = 0
      do a = 1,.dim

         ! Limits; make sure we have refinement setting correct!
         n = self(a).no_of_pADPs
         f = l + 1
         l = l + n

         ! Not leaky
         self(a).set_pADP_errors_to(covariance_mx(f:l,f:l),H_U_iso)

      end

   end

   zero_pADP_errors ::: PURE
   ! Set the pADP_errors
      self :: INOUT

      a :: INT

      do a = 1,.dim
         self(a).zero_pADP_error
      end

   end

   check_position_and_pADP
   ! Check if the .position and .pADP vector are consistent
      self :: IN

      a :: INT

      do a = 1,.dim
         self(a).check_position_and_pADP
      end

   end

!  =====
!  Modes
!  =====

   initialize_local_H_modes(L)
   ! Initialize local H modes as columns. These come in triples.
   ! The first is the XH stretch. The next two are the two XH bends.
      self :: INOUT
      L :: MAT{REAL}, OUT

   ENSURE(L.dim1==3*.dim,"wrong size, dim1")
   ENSURE(L.dim2==3*count(self.atomic_number==1),"wrong size, dim2")

      unit :: MAT{REAL}(3,3)
      r1,r2,r3 :: VEC{REAL}(3)
      h,i,x, fh,lh :: INT

      ! Make the connection table
      .make_connection_table ! NOT PURE

      ! Initialise L
      L = ZERO

      ! Set unit vectors
      unit.to_unit_mx

      ! Make the H modes
      i  = 0
      lh = 0

      do h = 1,.dim

         fh = lh + 1
         lh = lh + 3

         ! Only look for a = H atom
         if(self(h).atomic_number>1) cycle

         ! Make sure H atom connects one other
         if (connections_for(h).element.dim>1) then
            DIE("H atom connected tomore than one other")
         end

         ! Get XH vector
         x  = connections_for(h)[1]
         r1 = self(h).position - self(x).position
         r1.normalise

         ! Get the two perpendicular vectors
         r2.to_cross_product_of(r1,unit(:,1))
         if (r2.is_zero) &
         r2.to_cross_product_of(r1,unit(:,2))
         r2.normalise
         r3.to_cross_product_of(r1,r2)

         ! Set L
         L(fh:lh,i+1) = r1
         L(fh:lh,i+2) = r2
         L(fh:lh,i+3) = r3

         ! Next H mode
         i = i + 3

      end

      ! Clean
      connections_for.destroy

   end

!  ============
!  pADP/ADP put
!  ============

   put_pADP_vector_to(X,fac) ::: PURE
   ! Put the whole pADP vector into vector "X".
   ! If present, include length-conversion factor "fac".
      self :: IN
      X :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(X.dim==.no_of_pADPs,"wrong size, X")

      a,f,l :: INT

      l = 0

      do a = 1,.dim

         ! Limits
         f = l + 1
         l = l + self(a).no_of_pADPs

         ! Set
         self(a).put_pADP_vector_to(X(f:l),fac)

      end

   end

   put_pADP_errors_to(dX,fac) ::: PURE
   ! Put all the pADP errors into vector "dX".
   ! If present, include length-conversion factor "fac".
      self :: IN
      dX :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dX.dim==.no_of_pADPs,"wrong size, dX")

      a,f,l :: INT

      l = 0

      do a = 1,.dim

         ! Limits
         f = l + 1
         l = l + self(a).no_of_pADPs

         ! Set
         self(a).put_pADP_errors_to(dX(f:l),fac)

      end

   end

   put_pos_vector_to(X,fac) ::: PURE
   ! Put the position vector into matrix "X".
   ! If present, include length-conversion factor "fac".
      self :: IN
      X :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(X.dim1==.dim,"wrong size, X")
   ENSURE(X.dim2==3   ,"wrong size, X")

      a :: INT

      do a = 1,.dim
         self(a).put_pos_vector_to(X(a,:),fac)
      end

   end

   put_pos_errors_to(dX,fac) ::: PURE
   ! Put the position errors into matrix "dX".
   ! If present, include length conversion factor "fac".
      self :: IN
      dX :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dX.dim1==.dim,"wrong size, dX")
   ENSURE(dX.dim2==3   ,"wrong size, dX")

      a :: INT

      do a = 1,.dim
         self(a).put_pos_errors_to(dX(a,:),fac)
      end

   end

   put_pos_errors_to(dX,esd,fac) ::: PURE
   ! Put the position errors into matrix "dX" from the supplied
   ! "esd" vector made from a external refinement.
      self :: IN
      dX :: MAT{REAL}, OUT
      esd :: VEC{REAL}, IN
      fac :: REAL, optional, IN

   ENSURE(dX.dim1==.dim,"wrong size, dX")
   ENSURE(dX.dim2==3   ,"wrong size, dX")
   ENSURE(esd.dim==.no_of_pADPS,"wrong size, esd")

      a,k :: INT

      k = 0

      do a = 1,.dim

         dX(a,1) = esd(k+1)
         dX(a,2) = esd(k+2)
         dX(a,3) = esd(k+3)

         k = k + self(a).no_of_pADPs

      end

      if (present(fac)) dX = fac*dX

   end

   put_pADP2_vector_to(X,fac) ::: PURE
   ! Put the second-order pADP vector into matrix "X".
   ! If present, include length-conversion factor "fac".
      self :: IN
      X :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(X.dim1==.dim,"wrong size, X")
   ENSURE(X.dim2==9   ,"wrong size, X")

      a :: INT

      do a = 1,.dim
         self(a).put_pADP2_vector_to(X(a,:),fac)
      end

   end

   put_pADP2_errors_to(dX,fac) ::: PURE
   ! Put the pADP errors into matrix "dX".
   ! If present, include length conversion factor "fac".
      self :: IN
      dX :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dX.dim1==.dim,"wrong size, dX")
   ENSURE(dX.dim2==9   ,"wrong size, dX")

      a :: INT

      do a = 1,.dim
         self(a).put_pADP2_errors_to(dX(a,:),fac)
      end

   end

   put_ADP2_errors_to(dU,fac,esd) ::: PURE
   ! Put the ADP2 errors into matrix "dU" from the supplied
   ! "esd" vector made from a external refinement.
      self :: IN
      dU :: MAT{REAL}, OUT
      fac :: REAL, optional, IN
      esd :: VEC{REAL}, IN

   ENSURE(dU.dim1==.dim,"wrong dim1, dU")
   ENSURE(dU.dim2==6   ,"wrong dim2, dU")

      a,k :: INT

      k = 0

      do a = 1,.dim
      
         dU(a,1) = esd(k+4) 
         dU(a,2) = esd(k+5) 
         dU(a,3) = esd(k+6) 
         dU(a,4) = esd(k+7) 
         dU(a,5) = esd(k+8) 
         dU(a,6) = esd(k+9) 
      
         k = k + self(a).no_of_pADPs
      
      end

      ! Change units
      if (present(fac)) dU = fac*fac*dU

   end

   put_ADP2_errors_to(dU,list,fac,esd) ::: PURE
   ! Put the ADP2 errors into matrix "dU" from the supplied
   ! "esd" vector made from a external refinement. "list" is
   ! the sub list of atoms to use
      self :: IN
      dU :: MAT{REAL}, OUT
      list :: VEC{INT}, IN
      fac :: REAL, optional, IN
      esd :: VEC{REAL}, IN

   ENSURE(dU.dim1==list.dim,"wrong dim1, dU")
   ENSURE(dU.dim2==6       ,"wrong dim2, dU")
   ENSURE(esd.dim==.no_of_pADPS,"wrong size, esd")

      i,a,k :: INT

      k = 0

      do i = 1,list.dim

         a = list(i)
      
         k = .no_of_pADPs_up_to_atom(a)
      
         dU(i,1) = esd(k+4) 
         dU(i,2) = esd(k+5) 
         dU(i,3) = esd(k+6) 
         dU(i,4) = esd(k+7) 
         dU(i,5) = esd(k+8) 
         dU(i,6) = esd(k+9) 
      
      end

      ! Change units
      if (present(fac)) dU = fac*fac*dU

   end

   put_ADP2_vector_to(U,fac) ::: PURE
   ! Put the second-order ADP parameters into vector "U".
   ! If present, include length conversion factor "fac".
      self :: IN
      U :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(U.dim==6*.dim,"wrong size, U")

      a,f,l :: INT

      l = 0
      do a = 1,.dim
         f = l + 1
         l = l + 6
         self(a).put_ADP2_vector_to(U(f:l),fac)
      end

   end

   put_ADP2_errors_to(dU,fac) ::: PURE
   ! Put the ADP2 errors into vector "dU".
   ! If present, include length-conversion factor "fac".
      self :: IN
      dU :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dU.dim==6*.dim,"wrong size, dU")

      a,f,l :: INT

      l = 0
      do a = 1,.dim
         f = l + 1
         l = l + 6
         self(a).put_ADP2_errors_to(dU(f:l),fac)
      end

   end

   put_ADP2_vector_to(U,fac) ::: PURE
   ! Put the second-order ADP vector into matrix "U".
   ! If present, include length-conversion factor "fac".
   ! This routine used for making tables
      self :: IN
      U :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(U.dim1==.dim,"wrong size, U")
   ENSURE(U.dim2==6   ,"wrong size, U")

      a :: INT

      do a = 1,.dim
         self(a).put_ADP2_vector_to(U(a,:),fac)
      end

   end

   put_ADP2_errors_to(dU,fac) ::: PURE
   ! Put the ADP2 errors into matrix "dU".
   ! If present, include length conversion factor "fac".
   ! This routine used for making tables
      self :: IN
      dU  :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dU.dim1==.dim,"wrong size, dU")
   ENSURE(dU.dim2==6   ,"wrong size, dU")

      a :: INT

      do a = 1,.dim
         self(a).put_ADP2_errors_to(dU(a,:),fac)
      end

   end

   put_ADP3_vector_to(U,fac) ::: PURE
   ! Put the ADP3 parameters into vector "U".
   ! If present, include length conversion factor "fac".
      self :: IN
      U :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(U.dim==.no_of_ADP3s,"wrong size, X")

      a,f,l :: INT

      l = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP3s_and_errors) cycle

         ! Set ADP3's
         f = l + 1
         l = l + 10
         self(a).put_ADP3_vector_to(U(f:l),fac)

      end

   end

   put_ADP3_errors_to(dU,fac) ::: PURE
   ! Put the ADP3 errors into vector "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dU.dim==.no_of_ADP3s,"wrong size, dU")

      a,f,l :: INT

      l = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP3s_and_errors) cycle

         ! Set ADP3's
         f = l + 1
         l = l + 10
         self(a).put_ADP3_errors_to(dU(f:l),fac)

      end

   end

   put_ADP3_vector_to(U,fac) ::: PURE
   ! Put the ADP3 parameters into matrix "U".
   ! If present, include length conversion factor "fac".
      self :: IN
      U :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(U.dim1==.no_of_ADP3_atoms,"wrong size, U")
   ENSURE(U.dim2==10               ,"wrong size, U")

      a,i :: INT

      i = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP3s_and_errors) cycle

         ! Set ADP3's
         i = i + 1
         self(a).put_ADP3_vector_to(U(i,:),fac)

      end

   end

   put_ADP3_errors_to(dU,fac) ::: PURE
   ! Put the ADP3 errors into matrix "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dU.dim1==.no_of_ADP3_atoms,"wrong size, dU")
   ENSURE(dU.dim2==10               ,"wrong size, U")

      a,i :: INT

      i = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP3s_and_errors) cycle

         ! Set ADP3's
         i = i + 1
         self(a).put_ADP3_errors_to(dU(i,:),fac)

      end

   end

   put_ADP4_vector_to(U,fac) ::: PURE
   ! Put the ADP4 parameters into vector "U".
   ! If present, include length conversion factor "fac".
      self :: IN
      U :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(U.dim==.no_of_ADP4s,"wrong size, X")

      a,f,l :: INT

      l = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP4s_and_errors) cycle

         ! Set ADP4's
         f = l + 1
         l = l + 15
         self(a).put_ADP4_vector_to(U(f:l),fac)

      end

   end

   put_ADP4_errors_to(dU,fac) ::: PURE
   ! Put the ADP4 errors into vector "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dU.dim==.no_of_ADP4s,"wrong size, dU")

      a,f,l :: INT

      l = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP4s_and_errors) cycle

         ! Set ADP4's
         f = l + 1
         l = l + 10
         self(a).put_ADP4_errors_to(dU(f:l),fac)

      end

   end

   put_ADP4_vector_to(U,fac) ::: PURE
   ! Put the ADP4 parameters into matrix "U".
   ! If present, include length conversion factor "fac".
      self :: IN
      U :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(U.dim1==.no_of_ADP4_atoms,"wrong size, U")
   ENSURE(U.dim2==15               ,"wrong size, U")

      a,i :: INT

      i = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP4s_and_errors) cycle

         ! Set ADP4's
         i = i + 1
         self(a).put_ADP4_vector_to(U(i,:),fac)

      end

   end

   put_ADP4_errors_to(dU,fac) ::: PURE
   ! Put the ADP4 errors into matrix "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dU.dim1==.no_of_ADP4_atoms,"wrong size, dU")
   ENSURE(dU.dim2==15               ,"wrong size, dU")

      a,i :: INT

      i = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP4s_and_errors) cycle

         ! Set ADP4's
         i = i + 1
         self(a).put_ADP4_errors_to(dU(i,:),fac)

      end

   end

! Put pADPx atom list

   put_ADP3_atom_list_to(list) ::: PURE
   ! Put the ADP3 atom list to "list".
      self :: IN
      list :: VEC{INT}, OUT

   ENSURE(list.dim==.no_of_ADP3_atoms,"wrong size, list")

      a,i :: INT

      i = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP3s_and_errors) cycle

         ! List of atoms
         i = i + 1
         list(i) = a

      end

   end

   put_ADP4_atom_list_to(list) ::: PURE
   ! Put the ADP4 atom list to "list".
      self :: IN
      list :: VEC{INT}, OUT

   ENSURE(list.dim==.no_of_ADP4_atoms,"wrong size, list")

      a,i :: INT

      i = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP4s_and_errors) cycle

         ! List of atoms
         i = i + 1
         list(i) = a

      end

   end

!  ===============
!  Coordinate info
!  ===============

   coordinates(skip_dummies) result (res) ::: leaky, PURE
   ! Create the 3 x .dim coordinate matrix pointer
      self :: IN
      skip_dummies :: BIN, optional, IN
      res :: MAT{REAL}@

      n_atom :: INT
      skip :: BIN

      skip = FALSE
      if (present(skip_dummies)) skip = skip_dummies

      if (skip) then
         n_atom = .no_of_nondummy_atoms
         res.create(3,n_atom)
         .put_coordinates_to(res,positions_as_rows=FALSE,skip_dummies=TRUE)
      else
         res.create(3,.dim)
         .put_coordinates_to(res,positions_as_rows=FALSE)
      end

   end

   put_coordinates_to(mx,positions_as_rows,skip_dummies) ::: PURE
   ! Put the atom coordinates in a matrix "mx".
   ! If positions_as_rows=TRUE  then "mx" is dim x 3
   ! If positions_as_rows=FALSE then "mx" is 3 x dim
   ! If skip_dummies=FALSE then dim = .dim1 (default)
   ! If skip_dummies=TRUE  then dim = .no_of_nondummy_atoms
      self :: IN
      mx :: MAT{REAL}, OUT
      positions_as_rows :: BIN, IN
      skip_dummies :: BIN, optional, IN

      i,a :: INT
      skip :: BIN

      skip = FALSE
      if (present(skip_dummies)) skip = skip_dummies

      if (NOT skip) then

         ! Put all atoms
         if (positions_as_rows) then
            ENSURE(mx.dim1==.dim AND mx.dim2==3,"wrong shape, mx")
            do a = 1,.dim
               mx(a,:) = self(a).position
            end
         else
            ENSURE(mx.dim2==.dim AND mx.dim1==3,"wrong shape, mx")
            do a = 1,.dim
               mx(:,a) = self(a).position
            end
         end

      else

         ! Put non-dummy atoms
         if (positions_as_rows) then
            ENSURE(mx.dim1==.no_of_nondummy_atoms AND mx.dim2==3,"wrong shape, mx")
            i = 0
            do a = 1,.dim
               if (self(a).is_a_dummy_atom) cycle
               i = i + 1
               mx(i,:) = self(a).position
            end
         else
            ENSURE(mx.dim2==.no_of_nondummy_atoms AND mx.dim1==3,"wrong shape, mx")
            i = 0
            do a = 1,.dim
               if (self(a).is_a_dummy_atom) cycle
               i = i + 1
               mx(:,i) = self(a).position
            end
         end

      end

   end

   coordinate_vector result (res) ::: PURE
   ! Return the coordinates as a flat vector "res" where the xyz
   ! positions increment fastest, useful for optimisations
      self :: IN
      res :: VEC{REAL}(3*.dim)
      .put_coordinate_vector_to(res)
   end

   put_coordinate_vector_to(v) ::: PURE
   ! Put the coordinates as a flat vector in "v" where the xyz
   ! positions increment fastest, useful for optimisations
      self :: IN
      v :: VEC{REAL}, OUT

   ENSURE(v.dim==3*.dim,"wrong size, v")

      k,i :: INT

      k = 0

      do i = 1,.dim

         v(k+1) = self(i).position(1)
         v(k+2) = self(i).position(2)
         v(k+3) = self(i).position(3)
        
         k = k + 3

      end

   end

!  ========
!  Finalize
!  ========

   update ::: PURE
   ! Update/finalize, as far as possible.
      self :: INOUT

      ! Update the labels?
      .update_labels

      ! Make atom kinds/unique atoms
      ! Should we always set the kinds?
      .update_kinds

      ! Set groups
      ! Probs here? --dylan 5/14
      if (any(self(:).group==0)) .set_connected_groups

      ! Set any dispersion coefficients
      if (ATOM:xray_dispersion_entered()) .set_tabular_dispersion

   end

   update_labels ::: private, PURE
   ! Update the labels and/or tags.
   ! NOTE: Only update the labels if the label data are not
   ! unique, so as to preserve previous unique labels (and
   ! hopefully kinds) which can happen if a subset of a
   ! processed atom list is being updated.
   ! NOTE: It is assumed that is you set a different label
   ! you really mean that the atom is a different kind.
      self :: INOUT

      unique_labels,unique_tags :: BIN

      ! Unique labels?
      unique_labels = .has_unique_labels
      unique_tags   = .has_unique_tags

      ! Set unique labels/tags
      if (unique_labels) then

         ! Set unique tags from labels
         if (NOT unique_tags) self(:)%tag = self(:)%label

      else ! not unique labels

         ! Set unique tags if needed
         if (NOT unique_tags) .set_unique_tags

         ! Set labels from tags
         self(:)%label = self(:)%tag

      end

   end

!  ==============================
!  Basis size information methods
!  ==============================

   no_of_shells result (res) ::: pure
   ! Work out and return the number of gaussian shells in the basis
   ! set for the molecule
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).basis.shell.dim
      end

   end

   no_of_shell_pairs result (res) ::: PURE
   ! Return the number of shell pairs in the concatenated  basis set
      self :: IN
      res :: INT

      n_shell :: INT

      n_shell = .no_of_shells
      ENSURE(n_shell<=sqrt(TWO)*(huge(1))**HALF,"too many shells")

      res = n_shell*(n_shell+1)/2

   end

   no_of_shell_quartets result (res) ::: PURE
   ! Return the number of shell quartets in the b concatenated asis set 
   ! Note, "res" will die at 22    shells for integer(2).
   !       "res" will die at 361   shells for integer(4).
   !       "res" will die at 92681 shells for integer(8).
      self :: IN
      res :: INT

      n_pairs :: INT

      n_pairs = .no_of_shell_pairs
      ENSURE(n_pairs<=sqrt(TWO)*(huge(1))**HALF,"too many shells")

      res = n_pairs*(n_pairs+1)/2

   end

   no_of_primitive_shells result (res) ::: pure
   ! Work out and return the number of primitive gaussian shells in
   ! the concatenated basis sets
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_primitive_shells
      end

   end

   no_of_basis_functions result (res) ::: pure
   ! Work out and return the number of basis functions in the concatenated
   ! basis set for the atom list.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_basis_functions
      end

   end

   no_of_sph_basis_functions result (res) ::: pure
   ! Work out and return the number of spherical basis functions in
   ! the concatenated basis set for the atom list.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_sph_basis_functions
      end

   end

   no_of_primitives result (res) ::: pure
   ! Work out and return the number of primitives in the concatenated
   ! basis sets.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_primitives
      end

   end

   no_of_sph_primitives result (res) ::: pure
   ! Work out and return the number of spherical primitives in the
   ! concatenated basis sets.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_sph_primitives
      end

   end

!  =======================
!  List-based I/O Routines
!  =======================

   read_list_keywords ::: get_from(VEC{OBJECT}), recursive, leaky
   ! This version is for allocatable arrays.
   ! Read in and process list-based keywords from "stdin". List-based keywords
   ! are those that are intended to apply to each individual element of the list
   ! through a list of "keys" stored in the associated list-element type module.
   ! NOTE: this routine will create the list, if required.
   end

   process_list_keyword(keyword) ::: get_from(VEC{OBJECT}), leaky
   ! This version is for allocatable arrays.
   ! Process a list-type "keyword", common to all list-type objects.
   end

   read_data ::: get_from(VEC{OBJECT}), leaky
   ! This version is for allocatable arrays.
   ! Repeatedly process the "keys" to read in the data list. 
   ! Opening and closing braces are needed.
   end

   read_data_sans_braces ::: get_from(VEC{OBJECT}), leaky
   ! This version is for allocatable arrays.
   ! Repeatedly process the "keys" to read in the data list. 
   ! Opening and closing braces are not needed.
   end

   read_data_BL_terminated ::: get_from(VEC{OBJECT}), leaky
   ! This version is for allocatable arrays.
   ! Repeatedly process the "keys" to read in the data list. Opening
   ! braces are not needed, but a blank line (BL) is used as an
   ! end-of-list terminator.
   end

   data_length_BL_terminated result (length) ::: get_from(VEC{OBJECT})
   ! This version is for allocatable arrays.
   ! Read ahead in stdin to get the "length" of the data list. The
   ! data list begins with the first data item, *not* a "{" symbol.
   ! The data list must be terminated by a blank line (BL).
   end

   data_length result (length) ::: get_from(VEC{OBJECT})
   ! This version is for allocatable arrays.
   ! Read ahead in stdin to get the "length" of the data list, i.e. the number
   ! of data items in the list. The data must begin with the first data item,
   ! *not* a "{" symbol.  The order of data items comprising the list is given
   ! by keys defined in the associated list-element type module. The data list
   ! must be terminated by a "}" symbol.
   end

   read_altered_data ::: get_from(VEC{OBJECT}), leaky
   ! This version is for allocatable arrays.
   ! Read in a sublist of the complete list, and alter the data for that
   ! sublist.  The order of the data items in the sublist is given by the "keys"
   ! defined in the associated list-element type module.
   end

   read_append_data ::: get_from(VEC{OBJECT}), leaky
   ! This version is for allocatable arrays.
   ! Read in a set of data to append to an existing set.
   end

   process_keys ::: get_from(VEC{OBJECT}), leaky
   ! This version is for allocatable arrays.
   ! Process the "keys" on each element of the list.
   end

   process_keys_once ::: get_from(VEC{OBJECT})
   ! This version is for allocatable arrays.
   ! Process the "keys" just once on an anonymous object. This is useful if the
   ! "keys" set global variables in the list module (e.g. the default order of
   ! lists *within* the list data) as opposed to being keys pertaining to each
   ! element of the list.
   end

   keys_created result (res) ::: get_from(VEC{OBJECT})
   ! This version is for allocatable arrays.
   ! Return TRUE if the list-element keys are created.
   end

   set_keys(the_keys) ::: get_from(VEC{OBJECT})
   ! This version is for allocatable arrays.
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(VEC{OBJECT}), leaky
   ! This version is for allocatable arrays.
   ! This is for destroying the "keys" externally.
   end

   read_keys ::: get_from(VEC{OBJECT}), leaky
   ! This version is for allocatable arrays.
   ! Read a new set of keys
   end

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input. (This code is for non-pointer self objects).
   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file. (This code is for non-pointer self
   ! objects).
   end

!  ===========================
!  Non-list based I/O routines
!  ===========================

   read_keywords ::: get_from(VEC{OBJECT}), recursive, leaky
   ! This version is for allocatable arrays.
   ! Read in and process normal (non list-type) keywords from "stdin".
   end

   process_keyword(keyword) ::: leaky
   ! Process a normal (non list-type) "keyword".
      self :: allocatable, INOUT
      keyword :: STR, IN

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
      case("}") ! do nothing.
      case("dump                          "); .dump("atoms")
      case("find_and_put_n_terminal_atoms "); .find_and_put_N_terminal_atoms
      case("find_and_put_protein_backbone "); .find_and_put_protein_backbone
      case("put                           "); .put
      case("put_bond_angle_table          "); .put_bond_angle_table
      case("put_bond_length_table         "); .put_bond_length_table
      case("put_coordinates               "); .put_coordinates
      case("put_coordinates_and_charges   "); .put_coordinates_and_charges
      case("put_invariom_labels           "); .put_invariom_labels
      case("put_smiles_invariom_labels    "); .put_smiles_invariom_labels
    ! case("put_mm_info                   "); .put_mm_info
      case("put_torsion_angle_table       "); .put_torsion_angle_table
    ! case("put_protein_sequence          "); .put_protein_sequence
    ! case("put_restraint_atoms           "); .put_restraint_atoms
      case("read_cif                      "); .read_CIF
      case("redirect                      "); .redirect
      case("revert                        "); .revert
      case("set_covalent_radii_ccdc       "); ATOM:set_covalent_radii_ccdc
      case("use_interpolators=            "); .read_use_interpolators
      case default;               UNKNOWN(word)
      end

   end

! CIF

   read_CIF ::: leaky
   ! Read information from a Crystallographic Information File whose
   ! name is read from "stdin".
      self :: allocatable, INOUT

      name :: STR

      ! Read name cif name from stdin
      stdin.read(name)

      ! Read CIF
      .read_CIF(name)

   end

   read_CIF(name) ::: leaky
   ! Read information from a Crystallographic Information File "name"
      self :: allocatable, INOUT
      name :: STR, IN

      cif :: CIF@
      found :: BIN

      ! Create the CIF and find data
      cif.create(name)
      cif.open
      cif.find_data_block(found)
      ENSURE(found,"no crystal data block found")

      ! Read
      .read_CIF(cif)

      ! Clean
      cif.destroy

   end

   read_CIF(cif) ::: leaky
   ! Read information from a Crystallographic Information File "name"
      self :: allocatable, INOUT
      cif :: CIF, INOUT

      if (NOT cif.is_mmCIF) then
         .read_smCIF(cif)
      else
         .read_mmCIF(cif)
      end

   end

! smCIF

   read_smCIF(cif) ::: leaky
   ! Read information from a small-molecule Crystallographic
   ! Information File "name"
      self :: allocatable, OUT
      cif :: CIF, INOUT

      ! Read atom positions
      .read_smCIF_atoms(cif)

      ! Read ADPs including U_iso/B_iso
      .read_smCIF_ADPs(cif)

      ! Read dispersion
      VEC{ATOM}::read_smCIF_dispersion(cif)

   end

   read_smCIF_atoms(cif) ::: leaky
   ! Read information from a small-molecule Crystallographic
   ! Information File, "cif".
      self :: allocatable, OUT
      cif :: CIF, INOUT

      fail :: BIN

      fail = FALSE
      .read_smCIF_atoms_cart(cif,fail)

      if (NOT fail) return

      fail = FALSE
      .read_smCIF_atoms_xtal(cif,fail)

   ENSURE(NOT fail,"failed")

   end

   read_smCIF_atoms_cart(cif,fail) ::: leaky
   ! Read Tonto information from a small-molecule "cif".  Cartesian
   ! format extends existing items in the standard CIF dictionary.
   ! NOTE: self is destroyed and created from this file!
      self :: allocatable, OUT
      cif :: CIF, INOUT
      fail :: BIN, OUT

      fl,fc,fe,fo :: BIN
      IDs,labels :: VEC{STR}@
      pos,err :: MAT{REAL}@

      ! Read the site labels FIRST because these seem to correlate with
      ! the anisotropic U's.
      cif.read_looped_item("_atom_site_Cartn_label",labels,fl)

      fail = NOT fl 
      if (fail) return

      ! Destroy the old atom list (if there)
      .destroy

      ! Create the new atom list
      .create(labels.dim)
      .set_atom_data_from_labels(labels)
      labels.destroy

      ! Read the coordinates
      IDs.create(3)
      IDs = ["_atom_site_Cartn_x", &
             "_atom_site_Cartn_y", &
             "_atom_site_Cartn_z"  ]
      cif.read_looped_items(IDs,pos,found=fc)
      IDs.destroy

      fail = NOT fc
      if (fail) return

      ! Set the positions & space for errors
      .set_pos_axis_system_to("cartesian")
      .reset_pADPs_and_errors(9)
      pos.convert_from("angstrom")
      .set_positions_to(pos)
      pos.destroy

      ! Set the pADP_errors. This even does APD errors,
      ! not just positions.
      ! ERROR: change and merge with ADP setting
    ! .set_pADP_errors_to


      ! Read errors
      IDs.create(3)
      IDs = ["_atom_site_Cartn_x_esu", &
             "_atom_site_Cartn_y_esu", &
             "_atom_site_Cartn_z_esu"  ]
      cif.read_looped_items(IDs,err,found=fe)
      IDs.destroy

      if (fe) then

         ! Set the positions
         err.convert_from("angstrom")
         .set_position_errors_to(err)
         pos.destroy

      end

      ! Read occupancies and disorder group
      IDs.create(2)
      IDs = ["_atom_site_Cartn_occupancy     ", &
             "_atom_site_Cartn_disorder_group"]
      cif.read_looped_items(IDs,err,transpose=TRUE,found=fo)
      IDs.destroy

      if (fo) then

         ! Set the occupancies
         .set_site_occupancies(err(:,1))
         .set_site_disorder_groups(nint(err(:,2)))
         err.destroy

      end

      ! Clean
      IDs.destroy

      ! Update?
      .update

   end

   read_smCIF_atoms_xtal(cif,fail) ::: leaky
   ! Read information from a small-molecul Crystallographic
   ! Information File, "cif".  It is an error if there are no atom
   ! coordinates in the file.  It is NOT an error if the ADP (thermal)
   ! tensors are missing.
   ! NOTE: self is destroyed and created from this file!
      self :: allocatable, OUT
      cif :: CIF, INOUT
      fail :: BIN, OUT

      fl,fc,fs,fd,fo :: BIN
      IDs,labels,symbols :: VEC{STR}@
      disorder_group :: MAT{STR}@
      pos,err :: MAT{REAL}@
      dg :: STR
      i :: INT

      ! Find atom labels somehow
      cif.read_looped_item("_atom_site_label",labels,fl)                    ! Std
      if (NOT fl) cif.read_looped_item("_atom_site_Cryst_label",labels,fc)  ! Tonto
      if (NOT fc) cif.read_looped_item("_atom_site_type_symbol",symbols,fs) ! Desperate

      fail = (NOT fl) AND (NOT fc) AND (NOT fs)

      ! Destroy the old atom list (if there)
      .destroy

      ! Create new atom list & read labels
      if (labels.allocated) then
         .create(labels.dim)
         .set_atom_data_from_labels(labels)      ! This may not work
      else if (symbols.allocated) then
         .create(symbols.dim)
         .set_atom_data_from_labels(symbols)     ! For Z's
         if (labels.allocated) .set_labels(labels) ! For U's
      end

      labels.destroy
      symbols.destroy

      ! Read the site coordinates, and possibly occupancies
      cif.find_looped_item("_atom_site_occupancy",fo)
      if (fo) then
         IDs.create(4)
         IDs = ["_atom_site_fract_x  ", &
                "_atom_site_fract_y  ", &
                "_atom_site_fract_z  ", &
                "_atom_site_occupancy"]
         cif.read_looped_items(IDs,pos,err,found=fc)
      else
         IDs.create(3)
         IDs = ["_atom_site_fract_x  ", &
                "_atom_site_fract_y  ", &
                "_atom_site_fract_z  "]
         cif.read_looped_items(IDs,pos,err,found=fc)
      end
      IDs.destroy

      fail = NOT fc
      if (fail) return

      ! Assign the positions and pADPs
      .set_pos_axis_system_to("crystal")
      .reset_pADPs_and_errors(9)
      .set_positions_to(pos(1:3,:))
      .set_position_errors_to(err(1:3,:))
      if (fo) .set_site_occupancies(pos(4,:))
      err.destroy
      pos.destroy

      ! Read the disorder, group if there
      cif.find_looped_item("_atom_site_disorder_group",fd)
      if (fd) then
         IDs.create(1)
         IDs = ["_atom_site_disorder_group"]
         cif.read_looped_items(IDs,disorder_group)
         ENSURE(disorder_group.dim2==.dim,"inconsistent # of _atom_site_disorder_groups")
         do i = 1,disorder_group.dim2
            dg = disorder_group(1,i)
            if      (dg==".")   then; self(i).set_site_disorder_group(0)
            else if (dg.is_int) then; self(i).set_site_disorder_group(dg.to_int)
            end
         end
         disorder_group.destroy
         IDs.destroy
      end

      ! Clean
      IDs.destroy

      ! Update?
      .update

   end

   read_smCIF_ADPs(cif) ::: leaky
   ! Read ADP information from the small-molecule "cif" file.
   ! NOTE: must read atoms first!
      self :: INOUT
      cif :: CIF, INOUT

   DIE_IF(self(:).label.no_of_unique_elements/=.dim,"not all ADP site symbols are unique!")

      ! Read 4th order anharmonic ADPs
      .read_smCIF_ADP4(cif)

      ! Read 3rd order anharmonic ADPs
      .read_smCIF_ADP3(cif)

      ! Read 2nd order ADPs
      .read_smCIF_ADP2(cif)

   end

   read_smCIF_ADP2(cif) ::: leaky
   ! Read ADP2 information from the small-molecule "cif" file.
      self :: INOUT
      cif :: CIF, INOUT

   DIE_IF(self(:).label.no_of_unique_elements/=.dim,"not all ADP site symbols are unique!")

      fail :: BIN

      fail = FALSE
      
      ! Read cartesian 2nd order ADPs
      .read_smCIF_ADP2_cart(cif,fail)

      if (NOT fail) return

      ! Read standard/crystal U's as last resort
      .read_smCIF_ADP2_xtal(cif,fail)

   end

   read_smCIF_ADP2_cart(cif,fail) ::: private, leaky
   ! Read the cartesian ADP information from the small-molecule "cif".
      self :: INOUT
      cif :: CIF, INOUT
      fail :: BIN, OUT

   DIE_IF(self(:).label.no_of_unique_elements/=.dim,"not all ADP site symbols are unique!")

      fi,fd,fu,fl :: BIN
      IDs,esd,labels :: VEC{STR}@
      i,ind :: INT
      U,dU :: MAT{REAL}@
      U_iso,d_U_iso :: VEC{REAL}@
      lab :: STR

      
      ! Read Cartn U_iso values
      cif.read_looped_item("_atom_site_Cartn_U_iso_or_equiv",      U_iso,found=fi)
      cif.read_looped_item("_atom_site_Cartn_U_iso_or_equiv_esu",d_U_iso,found=fd)

      ! Are they there?
      if (fi AND fd) then

         ! Make space
         .reset_pADPs_and_errors(9)

         ! Convert
           U_iso.convert_from("angstrom^2")
         d_U_iso.convert_from("angstrom^2")

         ! Set
         .set_U_iso(U_iso)
         .set_U_iso_error(d_U_iso)

         ! Clean
         d_U_iso.destroy
           U_iso.destroy

      end

      ! Read Cartn ADP2 tensor
      IDs.create(6)
      esd.create(6)
      do i = 1,6
         lab = ATOM:ADP_label(i,form="underscore-123-repeated")
         lab = "_atom_site_Cartn_ADP2_"//trim(lab)
         IDs(i) = trim(lab)
         esd(i) = trim(lab)//"_esu"
      end
      cif.read_looped_item("_atom_site_Cartn_ADP2_U_label",labels,fl)
      cif.read_looped_items(IDs, U,found=fu)
      cif.read_looped_items(esd,dU,found=fd)
      esd.destroy
      IDs.destroy

      ! Are they there?
      fail = NOT (fl AND fu AND fd)

      if (NOT fail) then

         ! Change U units to au^2
          U.convert_from("angstrom^2")
         dU.convert_from("angstrom^2")

         ! Match the anisotropic U labels and assign the U tensors
         do i = 1,labels.dim

            ! Find matching index "ind"
            ind = self(:).label.index_of(labels(i))
            DIE_IF(ind==0,"unmatching atom_site_Cartn_ADP_U_label, "//trim(labels(i)))

            ! Assign ADP
            self(ind).reset_pADPs_and_errors(9)
            self(ind).set_ADP_tensor(U(:,i))
            if (self(ind).covariance_mx.allocated) then
               self(ind).set_pADP_errors_to(self(ind).covariance_mx,FALSE)
            else
               self(ind).set_ADP2_errors_to(dU)
            end

         end
   
         ! Set the crystal axis system. For anharmonic ADPs (if any)
         ! the form "g" or "u" was already detected and set.
         .set_ADP_axis_system_to("cartesian")

      end

      ! Clean
      if (fd) dU.destroy
      if (fu)  U.destroy
      if (fl) labels.destroy

   end

   read_smCIF_ADP2_xtal(cif,fail) ::: private, leaky
   ! Read fractional ADP information from the small-molecule "cif".
   ! It is an error if there are no atom coordinates in the file.
   ! It is NOT an error if the ADP (thermal) tensors are missing.
      self :: INOUT
      cif :: CIF, INOUT
      fail :: BIN, OUT

   DIE_IF(self(:).label.no_of_unique_elements/=.dim,"not all ADP site symbols are unique!")

      fi,fu,fl :: BIN
      IDs,labels :: VEC{STR}@
      i,ind :: INT
      U,dU :: MAT{REAL}@
      U_iso,d_U_iso :: VEC{REAL}@
      fac :: REAL
      lab :: STR

      ! Read U_iso values
      cif.read_looped_item("_atom_site_U_iso_or_equiv",U_iso,d_U_iso,found=fi)

      ! Are they there?
      if (fi) then

         ! Convert B factor
         if (cif.U_iso_is_B_iso) then
            fac = ONE/(EIGHT*PI*PI)
            U_iso   = fac*  U_iso
            d_U_iso = fac*d_U_iso
         end

         ! Make space
         .reset_pADPs_and_errors(9)

         ! We are in the crystal axis system
         .set_ADP_axis_system_to("crystal")

         ! Set
         U_iso.convert_from("angstrom^2")
         .set_U_iso(U_iso)
         U_iso.destroy

         ! Set errors
         if (d_U_iso.allocated) then
            d_U_iso.convert_from("angstrom^2")
            .set_U_iso_error(d_U_iso)
            d_U_iso.destroy
         end


      end

      ! Read U tensor
      IDs.create(6)
      do i = 1,6
         lab = ATOM:ADP_label(i,form="underscore-123-repeated")
         IDs(i) = "_atom_site_aniso_"//trim(lab)
      end
      cif.read_looped_item("_atom_site_aniso_label",labels,fl)
      cif.read_looped_items(IDs,U,dU,found=fu)
      IDs.destroy

      ! Are they there?
      fail = NOT (fl AND fu)

      ! Read the ADP2s
      if (NOT fail) then
   
         ! Convert B factors
         if (cif.U_is_B) then
            fac = ONE/(EIGHT*PI*PI)
            U   = fac*U
         end
   
         ! Change U units to au^2
          U.convert_from("angstrom^2")
         dU.convert_from("angstrom^2")
   
         ! Match the anisotropic U labels and assign the U tensors
         do i = 1,labels.dim
   
            ! Find matching index "ind"
            ind = self(:).label.index_of(labels(i))
            DIE_IF(ind==0,"unmatching atom_site_aniso_label, "//trim(labels(i)))
   
            ! Assign ADP
            self(ind).reset_pADPs_and_errors(9)
            self(ind).set_ADP_tensor(U(:,i))
            self(ind).set_ADP2_errors_to(dU(:,i))
   
         end
   
         ! Set the crystal axis system. For anharmonic ADPs (if any)
         ! the form "g" or "u" was already detected and set.
         .set_ADP_axis_system_to("crystal")
   
      end

      ! Clean
      if (fu) then
        dU.destroy
         U.destroy
      end

      if (fl) labels.destroy

   end

   read_smCIF_ADP3(cif) ::: private, leaky
   ! Detect if the small-molecule "cif" file has anharmonic ADP3s,
   ! either dimensionless "g" (crystal) or dimensioned "u" (cartesian)
   ! Gram-Charlier coefficients. The cif.GC_format will be set to this
   ! value, accordingly. It looks for "u" format first.
      self :: INOUT
      cif :: CIF, INOUT

      GC_format :: VEC{STR}(2) = ["u", "g"]
      fmt :: INT
      f3 :: BIN

      do fmt = 1,GC_format.dim

         ! Detect fmt
         cif.set_GC_format(GC_format(fmt))
         .read_smCIF_ADP3_helper(cif,f3)

         ! If fmt found exit
         if (f3) exit

      end

   end

   read_smCIF_ADP3_helper(cif,f3) ::: private, leaky
   ! Detect if stdout has ADP3s in the specified "cif.GC_format", either
   ! dimensionless "g" cartesian "u" form; and if so set "f3" TRUE,
   ! and set the ADP3's of "self".
      self :: INOUT
      cif :: CIF, INOUT
      f3 :: BIN, OUT

   ENSURE(cif.GC_format.is_one_of(["u","g"]),"incorrect fmt")

      labels,IDs,esd :: VEC{STR}@
      U,dU :: MAT{REAL}@
      fl,fu,fd :: BIN
      fac :: REAL
      lab :: STR
      i,ind :: INT

      cif.read_looped_item(trim(cif.GC3_label)//"label",labels,fl)

      ! Any ADP3's to read?
      f3 = fl
      if (NOT fl) return

      select case (cif.GC_format)

      case ("u") 

         ! U format ... should by C format?
         IDs.create(10)
         esd.create(10)
         do i = 1,10
            lab = ATOM:ADP3_index_label(i,form="123-repeated")
            lab = trim(cif.GC3_label)//trim(lab)
            IDs(i) = trim(lab)
            esd(i) = trim(lab)//"_esu"
         end

         ! Read U & dU
         cif.read_looped_items(IDs, U,found=fu)
         cif.read_looped_items(esd,dU,found=fd)

         ! Found?
         f3 = fl AND fu AND fd

         ! Clean
         esd.destroy
         IDs.destroy

         ! Unit conversion?
         if (f3) then
             U.convert_from("angstrom^3")
            dU.convert_from("angstrom^3")
         end

      case ("g")
      
         ! G format
         IDs.create(10)
         do i = 1,10
            lab = ATOM:ADP3_index_label(i,form="123-repeated")
            lab = trim(cif.GC3_label)//trim(lab)
            IDs(i) = trim(lab)
         end

         ! Read U & dU
         cif.read_looped_items(IDs,U,dU,found=fu)

         ! Found?
         f3 = fu AND fl

         ! Clean
         IDs.destroy

      end

      !!!!!!!!!!!!!!!!!!
      if (NOT f3) return
      !!!!!!!!!!!!!!!!!!

      ! Read scale factor & scale
      cif.read_item(trim(cif.GC3_label)//"scale_factor",fac)
      cif.set_GC3_scale_factor(fac)
       U =  U/cif.GC3_scale_factor
      dU = dU/cif.GC3_scale_factor

      ! Match the labels and assign the U3 tensors
      do i = 1,labels.dim

         ! Find matching index "ind"
         ind = self(:).label.index_of(labels(i))
         DIE_IF(ind==0,"unmatching label, "//trim(labels(i)))

         ! Assign ADP
         self(ind).reset_pADPs_and_errors(19)
         self(ind).set_ADP3_vector_to( U(:,i))
         self(ind).set_ADP3_errors_to(dU(:,i))

         ! Assign axes for later conversion
         if (cif.GC_format=="u") then
            self(ind).set_ADPn_axis_system_to("cartesian")
         else
            self(ind).set_ADPn_axis_system_to("crystal")
         end

      end

      ! Clean up
       U.destroy
      dU.destroy
      labels.destroy

   end

   read_smCIF_ADP4(cif) ::: private, leaky
   ! Detect if the "cif" file has anharmonic ADP4s, either
   ! dimensionless "g" (crystal) or dimensioned "u" (cartesian)
   ! Gram-Charlier coefficients. The cif.GC_format will be set to this
   ! value, accordingly. It looks for "u" format first.
      self :: INOUT
      cif :: CIF, INOUT

      GC_format :: VEC{STR}(2) = ["u", "g"]
      fmt :: INT
      f4 :: BIN

      do fmt = 1,GC_format.dim

         ! Detect fmt
         cif.set_GC_format(GC_format(fmt))
         .read_smCIF_ADP4_helper(cif,f4)

         ! If fmt found exit
         if (f4) exit

      end

   end

   read_smCIF_ADP4_helper(cif,f4) ::: private, leaky
   ! Detect if stdout has ADP4s in the specified "cif.GC_format", either
   ! dimensionless "g" cartesian "u" form; and if so set "f4" TRUE,
   ! and set the ADP4's of "self".
      self :: INOUT
      cif :: CIF, INOUT
      f4 :: BIN, OUT

   ENSURE(cif.GC_format.is_one_of(["u","g"]),"incorrect fmt")

      labels,IDs,esd :: VEC{STR}@
      U,dU :: MAT{REAL}@
      fl,fu,fd :: BIN
      lab :: STR
      fac :: REAL
      i,ind :: INT

      cif.read_looped_item(trim(cif.GC4_label)//"label",labels,fl)

      ! Any ADP4's to read?
      f4 = fl
      if (NOT fl) return

      select case (cif.GC_format)

      case ("u") 

         ! U format ... should by C format?
         IDs.create(15)
         esd.create(15)
         do i = 1,15
            lab = ATOM:ADP4_index_label(i,form="123-repeated")
            lab = trim(cif.GC4_label)//trim(lab)
            IDs(i) = trim(lab)
            esd(i) = trim(lab)//"_esu"
         end

         ! Read U & dU
         cif.read_looped_items(IDs, U,found=fu)
         cif.read_looped_items(esd,dU,found=fd)

         ! Found?
         f4 = fl AND fu AND fd

         ! Clean
         esd.destroy
         IDs.destroy

         ! Unit conversion?
         if (f4) then
             U.convert_from("angstrom^4")
            dU.convert_from("angstrom^4")
         end

      case ("g")
      
         ! G format
         IDs.create(15)
         do i = 1,15
            lab = ATOM:ADP4_index_label(i,form="123-repeated")
            lab = trim(cif.GC4_label)//trim(lab)
            IDs(i) = trim(lab)
         end

         ! Read U & dU
         cif.read_looped_items(IDs,U,dU,found=fu)

         ! Found?
         f4 = fu AND fl

         ! Clean
         IDs.destroy

      end

      !!!!!!!!!!!!!!!!!!
      if (NOT f4) return
      !!!!!!!!!!!!!!!!!!

      ! Read scale factor & scale
      cif.read_item(trim(cif.GC4_label)//"scale_factor",fac)
      cif.set_GC4_scale_factor(fac)
       U =  U/cif.GC4_scale_factor
      dU = dU/cif.GC4_scale_factor

      ! Match the labels and assign the U4 tensors
      do i = 1,labels.dim

         ! Find matching index "ind"
         ind = self(:).label.index_of(labels(i))
         DIE_IF(ind==0,"unmatching label, "//trim(labels(i)))

         ! Assign ADP
         self(ind).reset_pADPs_and_errors(34)
         self(ind).set_ADP4_vector_to( U(:,i))
         self(ind).set_ADP4_errors_to(dU(:,i))

         ! Assign axes for later conversion
         if (cif.GC_format=="u") then
            self(ind).set_ADPn_axis_system_to("cartesian")
         else
            self(ind).set_ADPn_axis_system_to("crystal")
         end

      end

      ! Clean up
       U.destroy
      dU.destroy
      labels.destroy

   end

   read_smCIF_dispersion(cif) ::: selfless, leaky
   ! Read the anomalous dispersion coefficients (if present)
   ! from the small-molecule "cif" file.
      cif :: CIF, INOUT

      IDs :: VEC{STR}@
      f_real,f_imag :: VEC{REAL}@
      fs,fr,fi :: BIN
      a,Z :: INT

      ! Read CIF
      cif.read_looped_item("_atom_type_symbol",IDs,found=fs)
      cif.read_looped_item("_atom_type_scat_dispersion_real",f_real,found=fr)
      cif.read_looped_item("_atom_type_scat_dispersion_imag",f_imag,found=fi)

      ! Are they there?
      if (fs AND fr AND fi) then

         do a = 1,IDs.dim

            ! Get the atomic number Z
            Z = ATOM:atomic_number_from_label(IDs(a))

            ! Skip unrecognised element label
            if (Z==0) then
               WARN("atom_type_symbol "//trim(IDs(a))//" unrecognised for anamalous dispersion")
               cycle
            end

            ! Set them in the table
            ATOM:set_dispersion_coefficients(Z,f_real(a),f_imag(a))

         end

      end

      ! Clean
      if (fi) f_imag.destroy
      if (fr) f_real.destroy
      if (fs) IDs.destroy

   end

! mmCIF

   read_mmCIF(cif) ::: leaky
   ! Read information from a macromolwcular Crystallographic
   ! Information File "name"
      self :: allocatable, OUT
      cif :: CIF, INOUT

      fail :: BIN

      ! Read atom positions
      .read_mmCIF_atoms(cif,fail)
    
      ! Read ADPs including U_iso/B_iso
    ! .read_mmCIF_ADP2(cif,fail)

      ! Read dispersion
      VEC{ATOM}::read_mmCIF_dispersion(cif)

   end

   read_mmCIF_atoms(cif,fail) ::: leaky
   ! Read Tonto information from a macromolecular "cif".  Cartesian
   ! NOTE: self is destroyed and created from this file!
      self :: allocatable, OUT
      cif :: CIF, INOUT
      fail :: BIN, OUT

      n_atoms,i, val :: INT
      fl,fc :: BIN
      ind :: VEC{INT}@
      IDs :: VEC{STR}@
      labels :: MAT{STR}@
      data :: MAT{REAL}@
      lab :: STR

      ! Read the site id's FIRST.
      cif.read_looped_item("_atom_site.id",ind,fl)

      fail = NOT fl 
      if (fail) then
         ind.destroy
         return
      end

      ! Success: id's are there
      n_atoms = ind.dim

      ! Destroy the old atom list (if there)
      .destroy

      ! Create the new atom list
      .create(n_atoms)

      ! Read the labels
      IDs.create(6)
      IDs = [ &
         "_atom_site.type_symbol    ", &
         "_atom_site.label_atom_id  ", &
         "_atom_site.label_comp_id  ", &
         "_atom_site.label_seq_id   ", &
         "_atom_site.label_asym_id  ", &
         "_atom_site.label_entity_id"  &
         ]
      cif.read_looped_items(IDs,labels,found=fc)
      IDs.destroy

      fail = NOT fc 
      if (fail) then
         labels.destroy
         return
      end

      ! Success: Replace .'s with #
      where (labels==".") labels = "#"

      ! Set the atom labels 
      do i = 1,n_atoms

         ! Set protein-specific data
         self(i).set_atom_sequence_id(ind(i))
         self(i).set_compound_id(labels(3,i))
         val = labels(4,i).to_int
         self(i).set_compound_sequence_id(val)
         self(i).set_group(val)
         self(i).set_asym_id(labels(5,i))
         self(i).set_entity_id(labels(6,i))

         ! Set the label, Tonto style
         lab = trim(labels(2,i))                   ! CA
         lab = trim(lab)//"-"//trim(ind(i).to_str) ! CA-2
         lab = trim(lab)//"-"//trim(labels(3,i))   ! CA-2-MET
         lab = trim(lab)//"-"//trim(labels(4,i))   ! CA-2-MET-1
       ! Use below to change labels ...
       ! lab = trim(labels(1,i))                   ! C
       ! lab = trim(lab)//"-"//trim(labels(5,i))   ! C-2-CA-MET-1-A
       ! lab = trim(lab)//"-"//trim(labels(6,i))   ! C-2-CA-MET-1-A-1
         self(i).set_label(lab,skip_mass=TRUE)

         ! Set atomic number from chemical symbol
         ! WARNING: AN has to come after setting unique label
         lab = labels(1,i)(1:2)
         lab(1:1).to_upper_case
         lab(2:2).to_lower_case
         self(i).set_atomic_number_and_mass(lab) 

      end

      ! Clean
      labels.destroy
      ind.destroy


      ! Read the coordinates, occupancy, B value
      IDs.create(4)
      IDs = [ &
         "_atom_site.Cartn_x  ", &
         "_atom_site.Cartn_y  ", &
         "_atom_site.Cartn_z  ", &
         "_atom_site.occupancy"  &
         ]
      cif.read_looped_items(IDs,data,found=fc)
      IDs.destroy

      fail = NOT fc
      if (fail) return

      ! Set the positions
      .set_pos_axis_system_to("cartesian")
      .reset_pADPs_and_errors(9)
      data(1:3,:).convert_from("angstrom")
      .set_positions_to(data(1:3,:))

      ! Set occupancy
      .set_site_occupancies(data(4,:))
      data.destroy

      ! Read errors (if there)
    ! IDs.create(3)
    ! IDs = ["_atom_site.Cartn_x_esd", &
    !        "_atom_site.Cartn_y_esd", &
    !        "_atom_site.Cartn_z_esd"  ]
    ! cif.read_looped_items(IDs,data,found=fe)
    ! IDs.destroy

    ! if (fe) then
    !    ! Set the positions
    !    data.convert_from("angstrom")
    !    .set_position_errors_to(data)
    !    data.destroy
    ! end

      ! Update?
      .update

   end

   read_mmCIF_ADP2(cif,fail) ::: leaky
   ! Read fractional ADP information from the macromolecular "cif".
   ! It is an error if there are no atom coordinates in the file.
      self :: INOUT
      cif :: CIF, INOUT
      fail :: BIN, OUT

      fi,fu :: BIN
      IDs :: VEC{STR}@
      a,i :: INT
      U :: MAT{REAL}@
      U_iso :: VEC{REAL}@
      ind :: VEC{INT}@
      fac :: REAL
      lab :: STR

      ! Read the site id's
      cif.read_looped_item("_atom_site_anisotrop.id",ind,fi)

      fail = NOT fi 
      if (fail) return

      ! Read U_iso values
      cif.read_looped_item("_atom_site.U_iso_or_equiv",U_iso,found=fi)

      ! Read B_iso values if U_iso's are not there ...
      if (NOT fi) then

         cif.read_looped_item("_atom_site.B_iso_or_equiv",U_iso,found=fi)

         fac = ONE/(EIGHT*PI*PI)
         U_iso   = fac*  U_iso

      end

      ! If there set the values
      if (fi) then

         ! We are in the crystal axis system
         .set_ADP_axis_system_to("crystal")

         ! Set
         U_iso.convert_from("angstrom^2")
         .set_U_iso(U_iso)
         U_iso.destroy

      end

      ! Read U tensor
      IDs.create(6)
      do i = 1,6
         lab = ATOM:ADP_label(i,form="123-repeated-square-braces")
         IDs(i) = "_atom_site_anisotrop.U_"//trim(lab)
      end
      cif.read_looped_items(IDs,U,found=fu)
      IDs.destroy

      ! Read B tensor in U is not there ...
      if (NOT fu) then

         IDs.create(6)
         do i = 1,6
            lab = ATOM:ADP_label(i,form="123-repeated-square-braces")
            IDs(i) = "_atom_site_anisotrop.B_"//trim(lab)
         end
         cif.read_looped_items(IDs,U,found=fu)
         IDs.destroy

         ! Rescale B's
         fac = ONE/(EIGHT*PI*PI)
         U_iso   = fac*  U_iso

      end

      ! Are they there?
      fail = NOT fu

      ! Read the ADP2s
      if (NOT fail) then
   
         ! Change U units to au^2
         U.convert_from("angstrom^2")
   
         ! Assign the U tensors
         do i = 1,.dim
   
            ! Get atom index
            a = ind(i)
   
            ! Assign ADP
            self(a).reset_pADPs_and_errors(9)
            self(a).set_ADP_tensor(U(:,i))
   
         end
   
         ! Set the crystal axis system. For anharmonic ADPs (if any)
         ! the form "g" or "u" was already detected and set.
         .set_ADP_axis_system_to("crystal")
   
      end

      ! Clean
      U.destroy
      U_iso.destroy
      ind.destroy

   end

   read_mmCIF_dispersion(cif) ::: selfless, leaky
   ! Read the anomalous dispersion coefficients (if present)
   ! from the small-molecule "cif" file.
      cif :: CIF, INOUT

      IDs :: VEC{STR}@
      f_real,f_imag :: VEC{REAL}@
      fs,fr,fi :: BIN
      a,Z :: INT

      ! Read CIF
      cif.read_looped_item("_atom_type.symbol",IDs,found=fs)
      cif.read_looped_item("_atom_type.scat_dispersion_real",f_real,found=fr)
      cif.read_looped_item("_atom_type.scat_dispersion_imag",f_imag,found=fi)

      ! Are they there?
      if (fs AND fr AND fi) then

         do a = 1,IDs.dim

            ! Get the atomic number Z
            Z = ATOM:atomic_number_from_label(IDs(a))

            ! Skip unrecognised element label
            if (Z==0) then
               WARN("atom_type_symbol "//trim(IDs(a))//" unrecognised for anamalous dispersion")
               cycle
            end

            ! Set them in the table
            ATOM:set_dispersion_coefficients(Z,f_real(a),f_imag(a))

         end

      end

      ! Clean
      if (fi) f_imag.destroy
      if (fr) f_real.destroy
      if (fs) IDs.destroy

   end


   read_use_interpolators
   ! Read whether to use interpolators for spherical atom densities
      self :: allocatable, INOUT
      use_interp :: BIN

      stdin.read(use_interp)

      if (.deallocated) return

      .set_use_interpolators(use_interp)

   end

!  =============
!  Resolve bases
!  =============

   resolve_bases(basis,suffix) ::: template, PURE
   ! Resolve the basis sets for each atom -- by pointer assigning its basis to
   ! the element in "basis" which matches either the atoms .basis_label, or else
   ! matches a label constructed in a standard way, by joining the atom chemical
   ! symbol with the ":suffix" string.
      self :: INOUT
      basis :: VEC{TYPE?}@, IN
      suffix :: STR, optional, IN

      a :: INT

      do a = 1,.dim
         self(a).resolve_basis(basis,suffix)
      end

   end

   resolve_bases(basis,suffix) ::: get_from(VEC{ATOM}, TYPE?=>BASIS), PURE
   ! Resolve the basis sets for each atom -- by pointer assigning its basis to
   ! the element in "basis" which matches either the atoms .basis_label, or else
   ! matches a label constructed in a standard way, by joining the atom chemical
   ! symbol with the ":suffix" string.
   end

   resolve_bases(basis,suffix) ::: get_from(VEC{ATOM}, TYPE?=>SLATERBASIS), PURE
   ! Resolve the basis sets for each atom -- by pointer assigning its basis to
   ! the element in "basis" which matches either the atoms .basis_label, or else
   ! matches a label constructed in a standard way, by joining the atom chemical
   ! symbol with the ":suffix" string.
   end

   resolve_bases(basis,suffix) ::: get_from(VEC{ATOM}, TYPE?=>COPPENSBASIS), PURE
   ! Resolve the basis sets for each atom -- by pointer assigning its basis to
   ! the element in "basis" which matches either the atoms .basis_label, or else
   ! matches a label constructed in a standard way, by joining the atom chemical
   ! symbol with the ":suffix" string.
   end

!  ===================
!  Axis system changes
!  ===================

   change_axis_system_to(axis_system,cell,change_ESDs) ::: PURE
   ! Change the atom axis systems to the desired "axis_system".
   ! If "change_ESDs" is present and TRUE, the ESDs are changed
   ! in a straighforward way using the unit_cell, otherwise not.
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN
    ! H_U_iso :: BIN, IN
      change_ESDs :: BIN, optional, IN

      a :: INT

      do a = 1,.dim
       ! self(a).change_axis_system_to(axis_system,cell,H_U_iso,change_ESDs)
         self(a).change_axis_system_to(axis_system,cell,change_ESDs)
      end

   end

   change_ADP2_axis_system_to(axis_system,cell,change_ESDs) ::: PURE
   ! Change the ADP2 axis systems to the desired "axis_system".
   ! If "change_ESDs" is present and TRUE, the ESDs are changed
   ! in a straighforward way using the unit_cell, otherwise not.
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN
    ! H_U_iso :: BIN, IN
      change_ESDs :: BIN, optional, IN

      a :: INT

      do a = 1,.dim
       ! self(a).change_ADP2_axis_system_to(axis_system,cell,H_U_iso,change_ESDs)
         self(a).change_ADP2_axis_system_to(axis_system,cell,change_ESDs)
      end

   end

!  ===============
!  Change geometry
!  ===============

   extend_bond_lengths(z1,z2,factor) ::: PURE
   ! Uniformly extend the bond lengths between all BONDED atoms with
   ! atomic number "z1" and "z2" by a "factor". Only the coordinates
   ! of the atoms with atomic number "z2" are altered.
      self :: INOUT
      z1,z2 :: INT, IN
      factor :: REAL, IN

      z1_ind,z2_ind,a1,a2 :: INT
      r21,new :: VEC{REAL}(3)

      if (all(self(:).atomic_number/=z1) OR all(self(:).atomic_number/=z2)) return

      ! First occurence of the atoms
      z1_ind = self(:).atomic_number.index_of_value(z1)
      z2_ind = self(:).atomic_number.index_of_value(z2)

      do a1 = z1_ind,.dim

         if (self(a1).atomic_number/=z1) cycle

         do a2 = z2_ind,.dim

            if (self(a2).atomic_number/=z2) cycle

            if (NOT .bonded(a1,a2)) cycle

            r21 = self(a2).position - self(a1).position
            new = self(a1).position + factor*r21
            self(a2).set_position(new)

         end

      end

   end

   set_bond_lengths(z1,z2,length) ::: PURE
   ! Uniformly set the bond lengths between all BONDED atoms with atomic number
   ! "z1" and "z2" to be "length". Only the coordinates of the atoms with atomic
   ! number "z2" are altered.
      self :: INOUT
      z1,z2 :: INT, IN
      length :: REAL, IN

      z1_ind,z2_ind,a1,a2 :: INT
      r21,new :: VEC{REAL}(3)

      if (all(self(:).atomic_number/=z1) OR all(self(:).atomic_number/=z2)) return

      ! First occurence of the atoms
      z1_ind = self(:).atomic_number.index_of_value(z1)
      z2_ind = self(:).atomic_number.index_of_value(z2)

      do a1 = z1_ind,.dim

         if (self(a1).atomic_number/=z1) cycle

         do a2 = z2_ind,.dim

            if (self(a2).atomic_number/=z2) cycle

            if (NOT .bonded(a1,a2)) cycle

            r21 = self(a2).position - self(a1).position
            r21.normalise
            new = self(a1).position + length*r21
            self(a2).set_position(new)

         end

      end

   end

   set_bond_length(a,b,length) ::: PURE
   ! Set the bond length between atoms "a" and and "b" to be "length"
   ! by modifying the position of atom "b".
      self :: INOUT
      a,b :: INT, IN
      length :: REAL, IN

      rab,new :: VEC{REAL}(3)

      ! Normalised vector A->B
      rab = self(b).position - self(a).position
      rab.normalise

      ! New vector A->B
      rab = length*rab

      ! Get new position
      new = self(a).position + rab

      ! Set new position
      self(b).set_position(new)

   end

!  ===================
!  Information methods
!  ===================

   no_of_dummy_atoms result (res) ::: pure
   ! Return the number of dummy atoms
      self :: IN
      res :: INT

      if (.dim==0) then
         res = 0
      else
         res = count(ATOM:is_a_dummy_atom(self))
      end

   end

   dummy_atoms result (ind) ::: pure
   ! Return the list of dummy atoms
      self :: IN
      ind :: VEC{INT}(.no_of_dummy_atoms)

      i :: INT

      if (.no_of_dummy_atoms==0) return

      i = 0
      ind = pack([(i, i=1,.dim)],mask=ATOM:is_a_dummy_atom(self))

   end

   no_of_nondummy_atoms result (res) ::: pure
   ! Return the number of non-dummy atoms
      self :: IN
      res :: INT

      if (.dim==0) then
         res = 0
      else
         res = count(ATOM:is_a_nondummy_atom(self))
      end

   end

   nondummy_atoms result (ind) ::: pure
   ! Return TRUE if all atoms have unique labels
      self :: IN
      ind :: VEC{INT}(.no_of_nondummy_atoms)

      i :: INT

      if (.no_of_nondummy_atoms==0) return

      i = 0
      ind = pack([(i, i=1,.dim)],mask=ATOM:is_a_nondummy_atom(self))

   end

   no_of_atoms_with_bases result (res) ::: pure
   ! Return the number of atoms with bases
      self :: IN
      res :: INT
      res = count(ATOM:has_basis(self))
   end

   atoms_with_bases result (ind) ::: pure
   ! Return TRUE if all atoms have unique labels
      self :: IN
      ind :: VEC{INT}(.no_of_atoms_with_bases)

      i :: INT

      i = 0
      ind = pack([(i, i=1,.dim)],mask=ATOM:has_basis(self))

   end

   chemical_formula(with_spaces) result (res) ::: PURE
   ! Return the chemical formula for the molecule, as a string, in
   ! alphabetical order of elements
      self :: IN
      with_spaces :: BIN, optional, IN
      res :: STR

   ENSURE(.dim > 0,"Must have at least one atom for a chemical formula")

      a, na :: INT
      spaces :: BIN
      symbol :: VEC{STR}@

      ! Do we want spaces between the elements?
      spaces = FALSE
      if (present(with_spaces)) spaces = with_spaces

      ! Get alphabetical list of chemical symbols
      symbol.create(.dim)
      do a = 1,.dim
         symbol(a) = self(a).chemical_symbol
      end
      symbol.quick_sort

      ! Make the chemical symbol
      res = " "
      a = 1
      do
         if (a>.dim) exit
         na = count(symbol==symbol(a))
         if (spaces AND res/=" ") then; res = trim(res) // " " // trim(symbol(a))
         else;                          res = trim(res) //        trim(symbol(a))
         end
         if (na>1) &
            res = trim(res) // trim(na.to_str)
         a = a + na
      end

      ! Clean up
      symbol.destroy

   end

   molecular_weight result (res) ::: pure
   ! Return the molceular weight for this atomvec
      self :: IN
      res :: REAL

      a :: INT

      res = ZERO

      do a = 1,.dim
         res = res + self(a).mass
      end

   end

   get_mean_neutron_numbers(NN)
   ! Get the atom coordinates in a matrix object "coord"
      self :: IN
      NN :: VEC{REAL}, OUT

      a :: INT

      do a = 1,.dim
         NN(a) = self(a).mean_neutron_number
      end

   end

   no_of_H_atoms result (res) ::: pure
   ! Return the number of H atoms
      self :: IN
      res :: INT

      res = count(ATOM:is_a_H_atom(self))

   end

   no_of_non_H_atoms result (res) ::: pure
   ! Return the number of non H atoms
      self :: IN
      res :: INT

      res = count(ATOM:is_not_a_H_atom(self))

   end

   list_of_non_H_atoms result (res) ::: leaky, PURE
   ! Return the list of indices of non-H atoms
      self :: IN
      res :: VEC{INT}@

      n,a,i :: INT

      n = .no_of_non_H_atoms

      res.create(n)
      i = 0
      do a = 1,.dim
         if (self(a).is_not_a_H_atom) then
            i = i + 1
            res(i) = a
         end
      end

   end

   indices_of_non_H_atom_for_atom result (res) ::: leaky, PURE
   ! Return the list of indices of non-H atoms as a function of the
   ! atom index in the total list of atoms; the inverse of previous.
      self :: IN
      res :: VEC{INT}@

      a,i :: INT

      res.create(.dim)
      res = 0

      i = 0
      do a = 1,.dim
         if (self(a).is_not_a_H_atom) then
            i = i + 1
            res(a) = i
         end
      end

   end

   no_of_nonmetal_atoms result (res) ::: pure
   ! Return the number of non-dummy atoms
      self :: IN
      res :: INT
      res = count(ATOM:is_a_nonmetal(self))
   end

   no_of_metalloid_atoms result (res) ::: pure
   ! Return the number of non-dummy atoms
      self :: IN
      res :: INT
      res = count(ATOM:is_a_metalloid(self))
   end

   no_of_metal_atoms result (res) ::: pure
   ! Return the number of non-dummy atoms
      self :: IN
      res :: INT
      res = count(ATOM:is_a_metal(self))
   end

   list_of_metal_atoms result (res) ::: leaky, PURE
   ! Return the indices of the metal atoms
      self :: IN
      res :: VEC{INT}@

      n,a,i :: INT

      n = .no_of_metal_atoms

      res.create(n)

      i = 0
      do a = 1,n
         if (NOT self(a).is_a_metal) cycle
         i = i + 1
         res(i) = a
      end

   end

!  =====================
!  Symbols, labels, tags
!  =====================

   unique_tags(list) result (res) ::: leaky, PURE
   ! Return the unique tags
      self :: IN
      list :: VEC{INT}, IN
      res :: VEC{STR}@

      i :: INT

      res.create(list.dim)
      do i = 1,list.dim
         res(i) = self(i).tag
      end

   end

   non_H_atom_tags result (tags) ::: leaky, PURE
   ! Return the list of non-H atom tags
      self :: IN
      tags :: VEC{STR}@

      list :: VEC{INT}@
      n :: INT

      n = .no_of_non_H_atoms

      tags.create(n)

      ! Get the list
      list = .list_of_non_H_atoms

      ! Get the tags
      tags = self(list).tag

   end

   chemical_symbols result (res) ::: PURE
   ! Return an array of the chemical symbols for each atom
      self :: IN
      res :: VEC{STR}(size(self))
      res = ATOM:chemical_symbol(self)
   end

   has_dummy_labels result (res) ::: PURE
   ! Return TRUE if any atom has a dummy charge labels
      self :: IN
      res :: BIN
      res = any(ATOM:has_a_dummy_label(self))
   end

   has_core_electrons result (res) ::: PURE
   ! Return TRUE if any atom has non-zero core electrons, implying
   ! ECPs are being used.
      self :: IN
      res :: BIN
      res = any(self(:).n_core_electrons>1)
   end

! pADP's

   no_of_NPD_ADPs result (res) ::: PURE
   ! Return the number of non-positive definite ADPs
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         if (self(a).has_NPD_ADP) res = res + 1
      end

   end

   no_of_flat_ADPs result (res) ::: PURE
   ! Return the number of flat ADPs
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         if (self(a).has_flat_ADP) res = res + 1
      end

   end

   no_of_pADPs result (res) ::: pure
   ! Return the number of positional and ADP parameters.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).no_of_pADPs
      end

   end

   put_no_of_pADPs_per_atom_to(res) ::: PURE
   ! Return the number of positional and ADP parameters for each atom
      self :: IN
      res :: VEC{INT}, OUT

   ENSURE(res.dim==.dim,"wrong size, res")

      a :: INT

      do a = 1,.dim
         res(a) = self(a).no_of_pADPs
      end

   end

   no_of_pADPs_up_to_atom(a) result (res) ::: PURE
   ! Return the no. of the pADPs up to but *not* including atom "a".
      self :: IN
      a :: INT, IN
      res :: INT

   ENSURE(a>0,"a must be +ve")
   ENSURE(a<=.dim,"a too large")

      b,n :: INT

      res = 0
      do b = 1,a-1
         n = self(b).no_of_pADPs
         res = res + n
      end

   end

   no_of_pADPs_up_to_atom(a,list) result (res) ::: PURE
   ! Return the no. of the pADPs up to but *not* including atom "a".
      self :: IN
      a :: INT, IN
      list :: VEC{INT}, IN
      res :: INT

   ENSURE(a>0,"a must be +ve")
   ENSURE(a<=list.dim,"a too large")

      b,n :: INT

      res = 0
      do b = 1,a-1
         n = self(list(b)).no_of_pADPs
         res = res + n
      end

   end

   max_no_of_pADPs_per_atom result (res) ::: pure
   ! Return the *maximum* number of pADP parameters per atom
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         res = max(res,self(a).no_of_pADPs)
      end

   end

   get_atom_for_pADP_index(par_index,res,last_index) ::: PURE
   ! Return the atom for the cumulative position-ADP index "par_index".
   ! Also return the cumulative index up to the previous atom.
      self :: IN
      par_index :: INT, IN
      res :: INT, OUT
      last_index :: INT, OUT

   ENSURE(par_index>0,"par_index must be +ve")
   ENSURE(par_index<=.no_of_pADPs,"par_index too large")

      a,n,l :: INT

      n = 0
      l = 0

      do a = 1,.dim
         n = self(a).no_of_pADPs
         l = l + n
         if (par_index>l) cycle
         exit
      end

      res = a
      last_index = l - n

   end

   tag_pADP_label(par_index) result (res) ::: PURE
   ! Return the unique tag with the parameter (positional-ADP) label
   ! for the *cumulative* parameter index "par_index"
      self :: IN
      par_index :: INT, IN
      res :: STR

      a,ind :: INT

      .get_atom_for_pADP_index(par_index,a,ind)

      ind = par_index - ind
      res = self(a).tag_pADP_label(ind)

   end

   tag_pADP_labels result (res) ::: leaky, PURE
   ! Return *all* the tags and positional-ADP labels.
      self :: IN
      res :: VEC{STR}@

      a,n,i,l,dim :: INT

      ! No. of parameters
      dim = .no_of_pADPs

      ! Leaky
      res.create(dim)

      ! Get the labels
      l = 0
      do a = 1,.dim
         n = self(a).no_of_pADPs
         do i = 1,n
            res(l+i) = self(a).tag_pADP_label(i)
         end
         l = l + n
      end

   end

   tag_pADP_labels(par_indices) result (res) ::: leaky, PURE
   ! Return the tag and positional-ADP parameter with  the indices
   ! "par_indices"
      self :: IN
      par_indices :: VEC{INT}, IN
      res :: VEC{STR}@

      i :: INT

      ! Create the label arrays (leaky)
      res.create(par_indices.dim)

      ! Get the labels
      do i = 1,par_indices.dim
         res(i) = .tag_pADP_label(par_indices(i))
      end

   end

! ADP's

   no_of_ADP3s result (res) ::: pure
   ! Return the number of ADP3 parameters.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         if (NOT self(a).has_ADP3s_and_errors) cycle
         res = res + 10
      end

   end

   no_of_ADP3_atoms result (res) ::: pure
   ! Return the number of atoms with ADP3 parameters.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         if (NOT self(a).has_ADP3s_and_errors) cycle
         res = res + 1
      end

   end


   no_of_ADP4s result (res) ::: pure
   ! Return the number of ADP4 parameters.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         if (NOT self(a).has_ADP4s_and_errors) cycle
         res = res + 15
      end

   end

   no_of_ADP4_atoms result (res) ::: pure
   ! Return the number of atoms with ADP4 parameters.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         if (NOT self(a).has_ADP4s_and_errors) cycle
         res = res + 1
      end

   end

!  ================
!  Nuclear energies
!  ================

   sum_of_nuclear_charges result (res) ::: pure
   ! Return the sum of the nuclear_charges
   ! Note: dummy atoms may have non-zero nuclear charge
      self :: IN
      res :: REAL
      res = sum(self(:).nuclear_charge)
   end

   sum_of_core_electrons result (res) ::: pure
   ! Return the sum of the nuclear_charges
   ! Note: dummy atoms may have non-zero nuclear charge
      self :: IN
      res :: REAL
      res = sum(self(:).n_core_electrons)
   end

   nuclear_repulsion_energy result (res) ::: pure
   ! Return the nuclear repulsion energy.
      self :: IN
      res :: REAL

      i,j :: INT
      qi,qj :: REAL
      r :: VEC{REAL}(3)

      res = ZERO
      do i = 1,.dim
         qi = self(i).nuclear_charge
         do j = 1,i-1
            qj = self(j).nuclear_charge
            r   =  self(j).position - self(i).position
            res = res + qi*qj/sqrt(dot_product(r,r))
         end
      end

   end

   nuclear_repulsion_energy(atoms) result (res) ::: pure
   ! Return the nuclear repulsion energy felt by the group of atoms
   ! "a" in the field of all the nuclei in "self"
      self :: IN
      atoms :: VEC{INT}, IN
      res :: REAL

      a,i,j :: INT
      qi,qj :: REAL
      r :: VEC{REAL}(3)

      res = ZERO
      do i = 1,atoms.dim
         a  = atoms(i)
         qi = self(a).nuclear_charge
         do j = 1,.dim
            if (any(atoms==j)) cycle
            qj = self(j).nuclear_charge
            r =  self(j).position - self(a).position
            res = res + qi*qj/sqrt(dot_product(r,r))
         end
      end

      res = HALF*res ! only count half the interaction energy
      res = res + self(atoms).nuclear_repulsion_energy

   end

   nuclear_repulsion_energy(atoms,nuclei) result (res) ::: pure
   ! Return the nuclear repulsion energy felt by the group of atoms
   ! "a" in the field of all the nuclei in "nuclei"
      self :: IN
      atoms, nuclei :: VEC{INT}, IN
      res :: REAL

      a, i,j,k, n_atoms, n_field :: INT
      qi,qj :: REAL
      r :: VEC{REAL}(3)


      res = ZERO

      n_atoms = size(atoms)
      n_field = size(nuclei)
      do i=1,n_atoms
         a  = atoms(i)
         qi = self(a).nuclear_charge
         do k=1,n_field
            j = nuclei(k)
            if (any(atoms==j)) cycle
            qj = self(j).nuclear_charge
            r =  self(j).position - self(a).position
            res = res + qi*qj/sqrt(dot_product(r,r))
         end
      end

      res = res + self(atoms).nuclear_repulsion_energy

   end

   nuclear_repulsion_for_atom(a) result (res) ::: pure
   ! Return the nuclear repulsion energy felt by atom "a" in the field
   ! of all the nuclei in "self"
      self :: IN
      a :: INT, IN
      res :: REAL

      j :: INT
      qa,qj,r2 :: REAL
      r :: VEC{REAL}(3)

      res = ZERO

      qa = self(a).nuclear_charge
      do j = 1,.dim
         if (j==a) cycle
         qj  = self(j).nuclear_charge
         r   = self(j).position - self(a).position
         r2  = dot_product(r,r)
         res = res + qj*qa/sqrt(r2)
      end

   end

   nuclear_repulsion_for_atoms(list) result (res) ::: pure
   ! Return the nuclear repulsion energy for the atoms whose indices
   ! are in "list".
      self :: IN
      list :: VEC{INT}, IN
      res :: REAL

      i,j,a,b :: INT
      qa,qb,r2 :: REAL
      ra,rb,r :: VEC{REAL}(3)

      res = ZERO

      if (list.dim==1) return

      do i = 1,list.dim
         a = list(i)
         qa = self(a).nuclear_charge
         ra = self(a).position
         do j = 1,i-1
            b = list(j)
            qb = self(b).nuclear_charge
            rb = self(b).position
            r   = rb - ra
            r2  = dot_product(r,r)
            res = res + qa*qb/sqrt(r2)
         end
      end

   end

!  ======================
!  Center of mass & shape
!  ======================

   center_of_mass result (res) ::: pure
   ! Return the center of mass
      self :: IN
      res :: VEC{REAL}(3)

      a :: INT
      mw :: REAL

      res = ZERO
      do a = 1,.dim
         res = res + self(a).position*self(a).mass
      end
      mw  = ONE/.molecular_weight
      res = res*mw

   end

   move_origin_to_center_of_mass ::: PURE
   ! Move the origin to the center of mass
      self :: INOUT
      .translate_by(-.center_of_mass)
   end

   change_to_principal_axes ::: PURE
   ! Move the origin to the center of mass and change the coordinates
   ! to be with respect to the principal axes
      self :: INOUT

      pm :: VEC{REAL}(3)
      pa :: MAT{REAL}(3,3)

      .translate_by(-.center_of_mass) 
      .make_principal_moments(pm,pa)
      .change_coordinate_axes(pa)

   end

   change_to_principal_top_axes ::: PURE
   ! Move the origin to the center of mass and change the coordinates to be with
   ! respect to the principal top axes i.e. in the case of symmetric tops the
   ! last axis is the unique axes.
      self :: INOUT

      pm :: VEC{REAL}(3)
      pa :: MAT{REAL}(3,3)
      reorder :: BIN

      .translate_by(-.center_of_mass)
      .make_principal_moments(pm,pa,reorder)
      .change_coordinate_axes(pa)

   end

   change_coordinate_axes(axes) ::: PURE
   ! Change the coordinates of the atoms to be with respect to the columns of
   ! "axes", which must be an orthogonal matrix.
      self :: INOUT
      axes :: MAT{REAL}(3,3), IN

      a :: INT

      do a = 1,.dim
         self(a).change_coordinate_axes(axes)
      end

   end

   displacement_mass_vector result (res) ::: pure
   ! Return the length 3*.dim mass vector used for weighting the
   ! cartesian force contant matrix
      self :: IN
      res :: VEC{REAL}(3*.dim)

      a,i,ia :: INT

      ia = 0
      do a = 1,.dim
      do i = 1,3
         ia = ia + 1
         res(ia) = self(a).mass
      end
      end

   end

   mass result (res) ::: pure
   ! Return the mass of the molecule
      self :: IN
      res :: REAL

      a :: INT

      res = ZERO
      do a = 1,.dim
         res = res + self(a).mass
      end

   end

   reduced_mass result(mu) ::: PURE
   ! Return the center of mass
      self :: IN
      mu :: REAL

      a :: INT

      mu = ZERO
      do a = 1,.dim
         mu = mu + ONE/self(a).mass
      end
      mu = ONE/mu

   end

   make_inertia_tensor(it) ::: PURE
   ! Make the moment of inertia tensor wrt the center of mass
      self :: IN
      it :: MAT{REAL}(3,3), OUT

      m :: MAT{REAL}(3,3)
      com,r :: VEC{REAL}(3)
      trace :: REAL
      a :: INT

      com = .center_of_mass

      it = ZERO
      do a = 1,.dim
         r = self(a).position - com
         m = spread(r,dim=1,ncopies=3)*spread(r,dim=2,ncopies=3)
         m = self(a).mass * m
         trace = m.trace
         m = -m
         m.increment_diagonal_by(trace)
         it = it + m
      end

   end

   make_inertial_axes(axes) ::: PURE
   ! Make the inertial "axes".
      self :: IN
      axes :: MAT{REAL}(3,3), OUT

      pm :: VEC{REAL}(3)

      .make_principal_moments(pm,axes)

   end

   make_principal_moments(pm,pa,reorder) ::: PURE
   ! Make the principal moments "pm" and principal axes "pm" wrt the center of
   ! mass.  If "reorder" is present then the principal axes are made to be right
   ! handed. Also:
   ! - For sperical tops, the local x,y,z axes are the pricipal axes
   ! - For symmetric tops, the C axis is unique
   ! - For asymmetric tops, the pricipal axes are aligned close to the local
   !    x,y,z axes
      self :: IN
      pm :: VEC{REAL}(3), OUT
      pa :: MAT{REAL}(3,3), OUT
      reorder :: BIN, optional, IN

      pn :: VEC{REAL}(3)
      it :: MAT{REAL}(3,3)

      ! Make the inertia tensor and axes
      .make_inertia_tensor(it)
      it.diagonalize_by_jacobi(pm,pa)

      ! Set small moments to zero
      if (NOT present(reorder)) return

      where (pm<TOL(6))
         pm = ZERO
      end

      ! Make principal axes close to x,y,z
      if (abs(pa(1,2)) > abs(pa(1,1))) then
         pa.swap_columns(1,2)
         pm.swap_elements(1,2)
      end
      if (abs(pa(1,3)) > abs(pa(1,1))) then
         pa.swap_columns(1,3)
         pm.swap_elements(1,3)
      end
      if (abs(pa(2,3)) > abs(pa(2,2))) then
         pa.swap_columns(2,3)
         pm.swap_elements(2,3)
      end

      ! Use normalised moments for now
      pn = pm/maxval(abs(pm))

      if (.is_spherical_top(pn)) then

            ! Spherical top? ... axes are x,y,z
            pa.to_unit_mx

      else if (.is_symmetric_top(pn)) then

         ! Symmetric top? ... C axis is unique
         if (abs(pn(1)-pn(3)) < TOL(2)) then
            pa.swap_columns(2,3)
            pm.swap_elements(2,3)
         else if (abs(pn(2)-pn(3)) < TOL(2)) then
            pa.swap_columns(1,3)
            pm.swap_elements(1,3)
         end

      end

      ! Make positive diagonals
      if (pa(1,1)<ZERO AND pa(2,2)<ZERO) then
         pa(:,1) = -pa(:,1)
         pa(:,2) = -pa(:,2)
      end

      ! Lehthanded system?
      if (pa.determinant>ZERO) return

      ! Make axes are right handed
      if (abs(pm(1)-pm(2)) < TOL(6)) then

         ! Swap columns 1,2 if equal moments
         pm.swap_elements(1,2)
         pa.swap_columns(1,2)

      else if (abs (pm(2)-pm(3)) < TOL(6)) then

         ! Swap columns 2,3 if equal moments
         pm.swap_elements(2,3)
         pa.swap_columns(2,3)
      else

         ! Reverse all C axis
         pa(:,3) = -pa(:,3)

      end

   end

   make_shape_tensor(st) ::: PURE
   ! Make the shape tensor "st" wrt the center of atoms. This is the
   ! same as the moment of inertia tensor except that each atom is
   ! assumed to have unit mass.
      self :: IN
      st :: MAT{REAL}(3,3), OUT

      m :: MAT{REAL}(3,3)
      c,r :: VEC{REAL}(3)
      a :: INT

      c = .center_of_atoms

      st = ZERO
      do a = 1,.dim
         r = self(a).position - c
         m = spread(r,dim=1,ncopies=3)*spread(r,dim=2,ncopies=3)
         m.increment_diagonal_by(-m.trace)
         st = st - m
      end

   end

   make_shape_moments(sm,sa) ::: PURE
   ! Make the shape moments "sm" and principal shape axes "sa" wrt the
   ! center of atoms. The shape axes are the same as the principal
   ! moment of inertia axes except that each atom is assumed to have
   ! unit mass. The principal shape axes are made right handed.
      self :: IN
      sm :: VEC{REAL}(3), OUT
      sa :: MAT{REAL}(3,3), OUT

      st :: MAT{REAL}(3,3)

      .make_shape_tensor(st)

      st.diagonalize_by_jacobi(sm,sa)

      ! Make axes are close to x,y,z
      if (abs(sa(1,2)) > abs(sa(1,1))) then
         sa.swap_columns(1,2)
         sm.swap_elements(1,2)
      end
      if (abs(sa(1,3)) > abs(sa(1,1))) then
         sa.swap_columns(1,3)
         sm.swap_elements(1,3)
      end
      if (abs(sa(2,3)) > abs(sa(2,2))) then
         sa.swap_columns(2,3)
         sm.swap_elements(2,3)
      end

      ! Make axes +ve
      if (sa(1,1)<ZERO)        sa(:,1) = -sa(:,1)
      if (sa(2,2)<ZERO)        sa(:,2) = -sa(:,2)
      if (sa.determinant<ZERO) sa(:,3) = -sa(:,3)

   end

!  ===========
!  Shape tests
!  ===========

   is_linear(pm) result (res) ::: PURE
   ! Return TRUE if the geometry is linear.
   ! Needs principal moments of inertia "pm"
      self :: IN
      pm :: VEC{REAL}(3), optional, IN
      res :: BIN

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)

      if (present(pm)) then; mi = pm
      else;                  .make_principal_moments(mi,ma,reorder=TRUE)
      end
      res = any(mi==ZERO)

   end

   is_spherical_top(pm) result (res) ::: PURE
   ! Return TRUE if the geometry is a spherical top
   ! Needs principal moments of inertia "pm"
      self :: IN
      pm :: VEC{REAL}(3), optional, IN
      res :: BIN

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)

      if (present(pm)) then; mi = pm
      else;                  .make_principal_moments(mi,ma,reorder=TRUE)
      end
      res = .no_of_same_principal_moments(mi)==3

   end

   is_symmetric_top(pm) result (res) ::: PURE
   ! Return TRUE if the geometry is a symmetric top
   ! Needs principal moments of inertia "pm"
      self :: IN
      pm :: VEC{REAL}(3), optional, IN
      res :: BIN

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)

      if (present(pm)) then
         mi = pm
      else
         .make_principal_moments(mi,ma)
      end
      res = .no_of_same_principal_moments(mi)==1

   end

   is_prolate_top(pm) result (res) ::: PURE
   ! Return TRUE if the geometry is a prolate top
   ! Needs principal moments of inertia "pm" after alignment
      self :: IN
      pm :: VEC{REAL}(3), optional, IN
      res :: BIN

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)

      if (present(pm)) then; mi = pm
      else;                  .make_principal_moments(mi,ma,reorder=TRUE)
      end
      res = .is_symmetric_top(pm) AND (mi(3)<mi(1))

   end

   is_oblate_top(pm) result (res) ::: PURE
   ! Return TRUE if the geometry is a oblate top
   ! Needs principal moments of inertia "pm" after alignment
      self :: IN
      pm :: VEC{REAL}(3), optional, IN
      res :: BIN

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)

      if (present(pm)) then; mi = pm
      else;                  .make_principal_moments(mi,ma,reorder=TRUE)
      end
      res = .is_symmetric_top(pm) AND (mi(3)>mi(1))

   end

   is_asymmetric_top(pm) result (res) ::: PURE
   ! Return TRUE if the geometry is a asymmetric top
   ! Needs principal moments of inertia "pm"
      self :: IN
      pm :: VEC{REAL}(3), optional, IN
      res :: BIN

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)

      if (present(pm)) then; mi = pm
      else;                  .make_principal_moments(mi,ma,reorder=TRUE)
      end
      res = .no_of_same_principal_moments(mi)==0

   end

   no_of_same_principal_moments(pm) result(same) ::: PURE
   ! Return the number of "same" pairs of principal moments of inertia.
   ! Needs principal moments of inertia "pm"
      self :: IN
      pm :: VEC{REAL}(3), optional, IN
      same :: INT

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)
      i,j :: INT

      if (present(pm)) then; mi = pm
      else;                  .make_principal_moments(mi,ma,reorder=TRUE)
      end

      same = 0
      do i = 1,3
      do j = 1,i-1
         if (abs(mi(i)-mi(j))<=TOL(2)) then
            same = same + 1
         end
      end
      end

   end

!  =============
!  Box centering
!  =============

   center_of_atoms(axes) result (center) ::: PURE
   ! Return the centroid of the atom positions in "center". If "axes" is present
   ! then the "center" is expressed with respect to the new "axes", where the
   ! columns of "axes" are the coordinates of the new axes in terms of the old.
      self :: IN
      axes :: MAT{REAL}(3,3), optional, IN
      center :: VEC{REAL}(3)

      a :: INT
      c :: VEC{REAL}(3)

      center = ZERO
      do a = 1,.dim
         center = center + self(a).position
      end
      center = center/.dim

      if (present(axes)) then
         c = center
         center.to_product_of(axes,c,transpose_a=TRUE)
      end

   end

   move_origin_to_center_of_atoms ::: PURE
   ! Move the origin to the center of atoms
      self :: INOUT
      .translate_by(-.center_of_atoms)
   end

   bounding_cube_width result (width) ::: PURE
   ! Return "width" which is a width of a side of a cube in which the
   ! molecule nicely sits. Suitable for generating plot widths.
      self :: IN
      width :: REAL

      center,dist :: VEC{REAL}(3)
      length :: REAL
      a :: INT

      width = ZERO
      center = .center_of_atoms
      do a = 1,.dim
         dist = self(a).position - center
         length = dist.norm + self(a).bragg_slater_radius*BOHR_PER_ANGSTROM*TWO
         length = max(length, dist.norm*TWO)
         width  = max(width,length)
      end
      width = TWO*width

   end

   bounding_box_widths(axes) result(box) ::: PURE

   ! Return "box" which are three widths of a side of a box in which
   ! the molecule nicely sits. If "axes" is present, the "box"
   ! coordinates are expressed in terms of the new "axes", where the
   ! columns of "axes" are the coordinates of the new axes in terms of
   ! the old. These "axes" may be (typically) the principal moment
   ! axes. This routine is suitable for generating plot widths.
      self :: IN
      axes :: MAT{REAL}(3,3), optional, IN

      box :: VEC{REAL}(3)

      center,v,dist :: VEC{REAL}(3)
      a :: INT

      box = ZERO

      center = .center_of_atoms

      do a = 1,.dim

         ! Position relative to center
         dist = self(a).position - center

         ! Position in new axis system
         if (present(axes)) then
            v = dist
            dist.to_product_of(axes,v,transpose_a=TRUE)
         end

         ! Flip to +ve quadrant and add boundary
         dist = abs(dist)
         dist = dist + self(a).bragg_slater_radius*BOHR_PER_ANGSTROM*TWO

         ! Get box width
         box  = max(box,dist)

      end

      box = FOUR*box

   end

!  ===========================================
!  Presence/absence of features and properties
!  ===========================================

   has_sequence_numbers result (res) ::: PURE
   ! Return TRUE if any atom in the list has a non zero sequence number
      self :: IN
      res :: BIN
      res = any(self.atom_sequence_id > 1)
   end

   has_covariance_mxs result (res) ::: PURE
   ! Return TRUE if all atom have covariance_mx's defined.
      self :: allocatable, IN
      res :: BIN

      i :: INT

      if (.deallocated) then

         res = FALSE
        
      else

         res = TRUE
         do i = 1,.dim
            if (self(i).covariance_mx.deallocated) then
               res = FALSE
               exit
            end
         end

      end

   end

   has_nonzero_position_errors result (res) ::: PURE
   ! Return TRUE if all atom have non-zero position errors
      self :: IN
      res :: BIN

      i :: INT

      res = TRUE
      do i = 1,.dim
         if (REAL:is_zero(self(i).position_error.norm)) then
            res = FALSE
            exit
         end
      end

   end

   has_nonzero_ADP_tensors result (res) ::: PURE
   ! Return TRUE if any atom has a non-zero ADP tensor
      self :: IN
      res :: BIN

      i :: INT

      res = FALSE
      do i = 1,.dim
         if (all(self(i).ADP_tensor==ZERO)) cycle
         res = TRUE
         exit
      end

   end

   has_nonzero_U_iso result (res) ::: PURE
   ! Return TRUE if any atom in the list has a non zero U_iso
      self :: IN
      res :: BIN
      res = any(self.U_iso>ZERO)
   end

   has_nonzero_ADPs result (res) ::: PURE
   ! Return TRUE if any atom in the list has a non zero ADP tensor
   ! OR non zero isotropic thermal factor.
      self :: IN
      res :: BIN
      res = .has_nonzero_ADP_tensors OR .has_nonzero_U_iso
   end

   has_nonzero_pos_errors result (res) ::: PURE
   ! Return TRUE if *any* atom has a non-zero position errors
      self :: IN
      res :: BIN

      a :: INT

      res = FALSE
      do a = 1,.dim
         if (NOT self(a).has_pADPs_and_errors) cycle
         if (REAL:is_zero(self(a).pADP_errors(1:3).norm)) cycle
         res = TRUE
         exit
      end

   end

   has_nonzero_pADP2_errors result (res) ::: PURE
   ! Return TRUE if *any* atom has a non-zero pADP2 errors
      self :: IN
      res :: BIN

      a :: INT

      res = FALSE
      do a = 1,.dim
         if (NOT self(a).has_pADPs_and_errors) cycle
         if (REAL:is_zero(self(a).pADP_errors(1:9).norm)) cycle
         res = TRUE
         exit
      end

   end

   has_nonzero_ADP3_errors result (res) ::: PURE
   ! Return TRUE if *any* atom has a non-zero pADP3 error
      self :: IN
      res :: BIN

      a :: INT

      res = FALSE
      do a = 1,.dim
         if (NOT self(a).has_ADP3s_and_errors) cycle
         if (REAL:is_zero(self(a).pADP_errors(10:19).norm)) cycle
         res = TRUE
         exit
      end

   end

   has_nonzero_ADP4_errors result (res) ::: PUTE
   ! Return TRUE if *any* atom has a non-zero ADP4 error
      self :: IN
      res :: BIN

      a :: INT

      res = FALSE
      do a = 1,.dim
         if (NOT self(a).has_ADP4s_and_errors) cycle
         if (REAL:is_zero(self(a).pADP_errors(20:34).norm)) cycle
         res = TRUE
         exit
      end

   end

   has_any_ADP3s_and_errors result (res) ::: pure
   ! Return TRUE if there are *any* ADP3s
      self :: IN
      res :: BIN

      a :: INT

      res = FALSE
      do a = 1,.dim
         if (NOT self(a).has_ADP3s_and_errors) cycle
         res = TRUE
         exit
      end

   end

   has_any_ADP4s_and_errors result (res) ::: pure
   ! Return TRUE if there are *any* ADP4s
      self :: IN
      res :: BIN

      a :: INT

      res = FALSE
      do a = 1,.dim
         if (NOT self(a).has_ADP4s_and_errors) cycle
         res = TRUE
         exit
      end

   end

   has_residue_codes result (res) ::: PURE
   ! Return TRUE if any atom in the list has a residue names
      self :: IN
      res :: BIN
      res = any(self(:).compound_id /= " " )
   end

   has_restraints result (res) ::: PURE
   ! Return TRUE if any atom in the list has a restrained position
   ! or restrained force constants
      self :: IN
      res :: BIN
      res = any(self(:).restraining_force_constant/=ZERO)
   end

   has_dipoles result (has) ::: PURE
   ! Return TRUE if any of the atoms have dipoles
      self :: IN
      has :: BIN

      a :: INT

      has = FALSE
      do a = 1,.dim
         has = self(a).has_dipole
         if (has) exit
      end

   end

   has_polarisabilities result (has) ::: PURE
   ! Return TRUE if any of the atoms have polarisabilities
      self :: IN
      has :: BIN

      a :: INT

      has = FALSE
      do a = 1,.dim
         has = self(a).has_polarisability
         if (has) exit
      end

   end

   has_any_dispersion result (res) ::: PURE
   ! Return TRUE if any atom has an anomalous scattering factor
      self :: IN
      res :: BIN
      res = any(ATOM:has_dispersion(self(:)))
   end

!  ====================
!  ADP inquiry methods
!  ====================

   has_NPD_ADP result (res) ::: PURE
   ! Return TRUE if the ADP is non-zero and non-positive definite.
      self :: IN
      res :: VEC{BIN}(.dim)

      a :: INT

      do a = 1,.dim
         res(a) = self(a).has_NPD_ADP
      end

   end

   has_flat_ADP(ratio) result (res) ::: PURE
   ! Return TRUE if the ADP is flat i.e. the the max to
   ! the min eigenvalue is greater than "ratio" (or FOUR
   ! if not supplied).
      self :: IN
      ratio :: REAL, optional, IN
      res :: VEC{BIN}(.dim)

      a :: INT

      do a = 1,.dim
         res(a) = self(a).has_flat_ADP(ratio)
      end

   end

   ADP_principal_axis_ratio result (res)  ::: PURE
   ! Return the actual max/min ADP principal axis ratio
   ! (or 1000 if the min eigenvalue is zero).
      self :: IN
      res :: VEC{REAL}(.dim)

      a :: INT

      do a = 1,.dim
         res(a) = self(a).ADP_principal_axis_ratio
      end

   end

   ADP_type(refine_H_U_iso) result (res) ::: PURE 
   ! Return whether the atom is refined "Uani" or "Uiso"
      self :: IN
      refine_H_U_iso :: BIN, IN
      res :: VEC{STR}(.dim)

      a :: INT

      if (NOT refine_H_U_iso OR all(self(:).atomic_number>1)) then

         res = "Uani"

      else

         do a = 1,.dim
            if (self(a).atomic_number>1) then; res(a) = "Uani"
            else;                              res(a) = "Uiso"
            end
         end

      end

   end

!  ================
!  Bases and labels
!  ================

   has_unique_labels result (has) ::: PURE
   ! Return TRUE if all non-dummy atoms have unique labels.
   ! A dummy atom has zero charge, no basis and a dummy-type label.
      self :: IN
      has :: BIN

      unique_labels,unique_x_kind :: BIN
      dum :: VEC{INT}@
      n :: INT

      n = .no_of_nondummy_atoms

      if (n==0) then

         has = TRUE

      else

         dum.create(n)
         dum = .nondummy_atoms
         unique_labels = NOT self(dum).label.has_repetitions
         unique_x_kind =     self.has_unique_xtal_kinds(dum)
         has = unique_labels AND unique_x_kind
         dum.destroy

      end

   end

   get_1st_repeated_labels(li,lj) ::: PURE
   ! Return the indices of the first repeated labels
   ! in "li" and "lj".
      self :: IN
      li,lj :: INT, OUT

      dum :: VEC{INT}@
      n :: INT

      n = .no_of_nondummy_atoms

      if (n==0) then

         li = 0
         lj = 0

      else

         dum.create(n)
         dum = .nondummy_atoms
         self(dum).label.get_1st_repetition(li,lj)
         dum.destroy

      end

   end

   has_unique_tags result (has) ::: PURE
   ! Return TRUE if all non-dummy atoms have unique tags.
   ! A dummy atom has zero charge, no basis and a dummy-type label.
      self :: IN
      has :: BIN

      dum :: VEC{INT}@
      n :: INT

      n = .no_of_nondummy_atoms

      if (.no_of_nondummy_atoms==0) then

         has = TRUE

      else

         dum.create(n)
         dum = .nondummy_atoms
         has = NOT self(dum).tag.has_repetitions AND NOT any(self(dum).tag==" ")
         dum.destroy

      end

   end

   has_unique_kinds result (has) ::: pure
   ! Return TRUE if all atoms have unique kinds
      self :: IN
      has :: BIN
      has = NOT self(:).kind.has_repetitions
   end

   has_unique_xtal_kinds result (unq) ::: pure
   ! Return TRUE if all atoms have unique *xtal* kinds
      self :: IN
      unq :: BIN

      a,b :: INT

      unq = TRUE
      do a = 2,.dim
      do b = 1,a-1
         if (NOT self(a).is_xtal_identical_to(self(b))) cycle
         unq = FALSE
         return
      end
      end

   end

   has_unique_xtal_kinds(list) result (unq) ::: pure
   ! Return TRUE if all atoms have unique *xtal* kinds
      self :: IN
      list :: VEC{INT}, IN
      unq :: BIN

      a,b :: INT

      unq = TRUE
      do a = 2,list.dim
      do b = 1,a-1
         if (NOT self(list(a)).is_xtal_identical_to(self(list(b)))) cycle
         unq = FALSE
         return
      end
      end

   end

   get_1st_repeated_xtal_kinds(ka,kb) ::: pure
   ! Return the indices of the first repeated xtal kinds
   ! in "ka" and "kb".
      self :: IN
      ka,kb :: INT, OUT

      a,b :: INT

      ka = 0
      kb = 0
      do a = 2,.dim
      do b = 1,a-1
         if (NOT self(a).is_xtal_identical_to(self(b))) cycle
         ka = a
         kb = b
         return
      end
      end

   end

   has_all_bases result (has) ::: pure
   ! Return TRUE if all atoms have a basis on one kind or another.
      self :: IN
      has :: BIN
      has = .has_all_gaussian_bases OR .has_all_slater_bases OR .has_all_coppens_bases
   end

   has_all_gaussian_bases result (has) ::: pure
   ! Return TRUE if all atom gaussian basis data exists
      self :: IN
      has :: BIN

      a :: INT

      has = TRUE
      do a = 1,.dim
         has = self(a).basis.allocated
         if (NOT has) exit
      end

   end

   has_all_slater_bases result (has) ::: pure
   ! Return TRUE if all atom slater basis data exists
      self :: IN
      has :: BIN

      a :: INT

      has = TRUE
      do a = 1,.dim
         has = self(a).slaterbasis.allocated
         if (NOT has) exit
      end

   end

   has_all_coppens_bases result (has) ::: pure
   ! Return TRUE if all atom slater basis data exists
      self :: IN
      has :: BIN

      a :: INT

      has = TRUE
      do a = 1,.dim
         has = self(a).coppensbasis.allocated
         if (NOT has) exit
      end

   end

   has_all_density_data result(has) ::: pure
   ! Return TRUE if all atoms have some kind of atom density data, either
   ! slaterbasis, coppensbasis or gausian ANO data. This routine does NOT check
   ! that they are all the same kind of data!
      self :: IN
      has :: BIN

      has = .has_all_slater_bases &
         OR .has_all_coppens_bases &
         OR .has_all_ANO_matrices

   end

   has_all_shell_info result (res) ::: PURE
   ! Return TRUE if all shell info is there for every atom.
      self :: IN
      res :: BIN
      res = all(ATOM:has_shell_info(self))
   end


   minimum_basis_exponents result (res) ::: PURE
   ! Return the minimum exponent in the basis.
      self :: IN
      res :: VEC{REAL}(.dim)

      i :: INT

      do i = 1,.dim
         res(i) = self(i).minimum_basis_exponent
      end

   end


   tag_xyz_basis_fn_part result (res) ::: PURE
   ! Return a character representation for the cartesian product part
   ! of the gaussians in this shell.
      self :: IN
      res :: VEC{STR}(.no_of_basis_functions)

      a,i,f,l, width,spaces :: INT
      labels :: VEC{STR}@

      l = 0
      do a = 1,.dim
         f = l + 1
         l = l + self(a).basis.no_of_basis_functions
         labels = self(a).basis.xyz_basis_fn_part
         width  = maxval(len_trim(labels)) + 1
         do i = f,l
            spaces = width - len_trim(labels(i-f+1))
            res(i) = trim(self(a).tag) // repeat(" ",spaces) // trim(labels(i-f+1))
         end
      end

   end

   basis_labels result (labels) ::: leaky, PURE
   ! Return a list of basis set "labels". Missing labels are returned blank.
      self :: IN
      labels :: VEC{STR}@

      i :: INT

      labels.create(size(self))
      do i = 1,.dim
         if (self(i).basis_label/=" ") then; labels(i) = self(i).basis_label
         else;                               labels(i) = " "
         end
      end

   end

   library_basis_labels(suffix) result (labels) ::: leaky, PURE
   ! Return a list of library basis set labels, the atoms element name with
   ! ":suffix" appended to it. Only a unique list of basis labels is returned.
      self :: IN
      suffix :: STR, IN
      labels :: VEC{STR}@

      i :: INT

      labels.create(.dim)
      do i = 1,.dim
         labels(i) = self(i).library_basis_label(suffix)
      end
      labels.remove_repetitions

   end

   library_basis_labels(Z_max,suffix) result (labels) ::: selfless, leaky, PURE
   ! Return a list of library basis set labels, for the atoms with
   ! atomic numbers up to "Z_max", with ":suffix" appended to it. Only
   ! a unique list of basis labels is returned.
      Z_max :: INT, IN
      suffix :: STR, IN

      labels :: VEC{STR}@
      Z :: INT

      labels.create(Z_max)
      do Z = 1,Z_max
         labels(Z) = ATOM:library_basis_label(Z,suffix)
      end

   end

!  ======================
!  ANOs and interpolators
!  ======================

   has_all_NAO_matrices result (res) ::: pure
   ! Return TRUE if the NAOs are made for every atom.
      self :: IN
      res :: BIN

      a :: INT

      res = TRUE
      do a = 1,.dim
         res = self(a).has_NAO_matrices
         if (NOT res) exit
      end

   end

   has_all_ANO_matrices result (res) ::: pure
   ! Return TRUE if the ANOs are made for every atom.
      self :: IN
      res :: BIN

      a :: INT

      res = TRUE
      do a = 1,.dim
         res = self(a).has_ANO_matrices
         if (NOT res) exit
      end

   end

   has_all_atom_data result (res) ::: pure
   ! Return TRUE if the ANOs are made for every atom.
      self :: IN
      res :: BIN
      res = all(self(:).atom_data_made)
   end

!  =============
!  Interpolators
!  =============

   has_all_slater_interpolators result(has) ::: pure
   ! Return TRUE if all atoms have slaterbases which have interpolators.
      self :: IN
      has :: BIN

      a :: INT

      has = TRUE
      do a = 1,.dim
         has = self(a).slaterbasis.allocated
         if (NOT has) exit
         has = self(a).slaterbasis.interpolator.allocated
         if (NOT has) exit
      end

   end

   has_all_coppens_interpolators result(has) ::: pure
   ! Return TRUE if all atoms have coppensbases which have interpolators.
      self :: IN
      has :: BIN

      a :: INT

      has = TRUE
      do a = 1,.dim
         has = self(a).coppensbasis.allocated
         if (NOT has) exit
         has = self(a).coppensbasis.interpolator.allocated
         if (NOT has) exit
      end

   end

   has_interpolators_any_kind result(has) ::: pure
   ! Return TRUE if all atoms have slaterbases which have interpolators, or all
   ! atoms have coppensbases with interpolators.
      self :: IN
      has :: BIN

      has_i,has_s,has_c :: BIN

      has_i = .has_all_interpolators
      has_s = .has_all_slater_interpolators
      has_c = .has_all_coppens_interpolators

      has   = has_i OR has_s OR has_c

   end

   has_all_interpolators result(has) ::: pure
   ! Return TRUE if all atoms have interpolators.
      self :: IN
      has :: BIN

      a :: INT

      has = TRUE
      do a = 1,.dim
         has = self(a).interpolator.allocated
         if (NOT has) exit
      end

   end

   max_interpolator_table_length(tol) result (res)
   ! Returns the maximum interpolator table length for a given table cutoff
   ! tolerance "tol".  This table length is used for setting the cluster radius,
   ! for calculations where the cluster size must be determined so that the
   ! Hirshfeld surface is accurate.
      self :: IN
      tol :: REAL, IN
      res :: REAL

   ENSURE(self(1).basis_kind.is_one_of(["slater  ","coppens ","gaussian"]),"unknown basis_kind")

      last :: REAL
      i :: INT

      res = ZERO

      select case (self(1).basis_kind)

      case ("slater")
         ENSURE(.has_all_slater_bases,"missing slater bases")
         do i = 1,.dim
            last = self(i).slaterbasis.interpolator_table_length(tol)
            res  = max(res,last)
         end

      case ("coppens")
         ENSURE(.has_all_coppens_bases,"missing coppens bases")
         do i = 1,.dim
            last = self(i).coppensbasis.interpolator_table_length(tol)
            res  = max(res,last)
         end

      case ("gaussian")
         ENSURE(.has_all_ANO_matrices,"missing atom ANOs")
         do i = 1,.dim
            last = self(i).interpolator_table_length(tol)
            res  = max(res,last)
         end

      end

   end

!  =================
!  Axes and disorder
!  =================

   has_cartesian_axes result (res) ::: pure
   ! Return TRUE if all atom pisitions *and* ADP (thermal) tensors are
   ! in the cartesian axis system.
      self :: IN
      res :: BIN

      pos,ADP :: BIN
      a :: INT

      res = TRUE
      do a = 1,.dim

         pos = self(a).pos_axis_system=="cartesian"
         ADP = self(a).ADP_axis_system=="cartesian"
         res = pos AND ADP

         if (self(a).has_ADP3s) res = res AND self(a).ADPn_axis_system=="cartesian"
         if (self(a).has_ADP4s) res = res AND self(a).ADPn_axis_system=="cartesian"

         if (NOT res) exit

      end

   end

   has_cartesian_ADP_axes result (res) ::: pure
   ! Return TRUE if all atom ADP (thermal) tensors are in the
   ! cartesian axis system.
      self :: IN
      res :: BIN

      a :: INT

      res = TRUE
      do a = 1,.dim
         res = self(a).ADP_axis_system=="cartesian"
         if (NOT res) exit
      end

   end

   has_crystal_ADP_axes result(has) ::: pure
   ! Return TRUE if all atom ADP (thermal) tensors are in the crystal axis system.
      self :: IN
      has :: BIN

      a :: INT

      has = TRUE
      do a = 1,.dim
         has = self(a).ADP_axis_system=="crystal"
         if (NOT has) exit
      end

   end

   has_disorder result (has) ::: pure
   ! Return TRUE if any atom has disorder i.e. an occupancy which is not one.
      self :: IN
      has :: BIN
      has = NOT self(:).site_occupancy.has_all_equal_to(ONE)
   end

   atom_index_from_position(pos) result (res) ::: PURE
   ! Return the index of atom from its position "pos".
   ! If no position is found return zero.
      self :: IN
      pos :: VEC{REAL}(3), IN
      res :: INT

      a :: INT
      found :: BIN

      res = 0
      found = FALSE
      do a = 1,.dim
         found = pos.same_as(self(a).position)
         if (found) then
            res = a
            exit
         end
      end

   end

!  =====
!  Radii
!  =====

   covalent_radii_ccdc result (res) ::: PURE
   ! Returns the CCDC covalent radius for this atom
      self :: IN
      res :: VEC{REAL}(.dim)

      a :: INT

      do a = 1,.dim
         res(a) = self(a).covalent_radius_ccdc
      end

   end

   vdw_radii_ccdc result (res) ::: PURE
   ! Returns the CCDC vdw radius for this atom
      self :: IN
      res :: VEC{REAL}(.dim)

      a :: INT

      do a = 1,.dim
         res(a) = self(a).vdw_radius_ccdc
      end

   end

   get_covalent_radii_ccdc(radii) ::: PURE
   ! Returns the CCDC covalent radius for this atom
      self :: IN
      radii :: VEC{REAL}(.dim), OUT

      a :: INT

      do a = 1,.dim
         radii(a) = self(a).covalent_radius_ccdc
      end

   end

   get_vdw_radii_ccdc(radii) ::: pure
   ! Returns the CCDC vdw radius for this atom
      self :: IN
      radii :: VEC{REAL}(.dim), OUT

      a :: INT

      do a = 1,.dim
         radii(a) = self(a).vdw_radius_ccdc
      end

   end

!  =======================
!  Spackman's coefficients
!  =======================

   get_Spackman86_a_coeffs_in(coeff) ::: pure
   ! Returns the GKR a-coefficients
      self :: IN
      coeff :: VEC{REAL}, OUT

      i :: INT

      do i = 1,.dim
         coeff(i) = ATOM::Spackman86_a_6_dispersion_coeff(self(i))
      end

   end

   get_Spackman86_b_coeffs_in(coeff) ::: pure
   ! Returns the GKR a-coefficients
      self :: IN
      coeff :: VEC{REAL}, OUT

      i :: INT

      do i = 1,.dim
         coeff(i) = ATOM::Spackman86_b_repulsion_coeff(self(i))
      end

   end

   get_Spackman86_c_coeffs_in(coeff) ::: pure
   ! Returns the GKR a-coefficients
      self :: IN
      coeff :: VEC{REAL}, OUT

      i :: INT

      do i = 1,.dim
         coeff(i) = ATOM::Spackman86_c_repulsion_coeff(self(i))
      end

   end

!  =====================
!  Grimme's coefficients
!  =====================

   get_Grimme06_a_coeffs_in(coeff) ::: pure
   ! Returns the Grimme a-coefficients
      self :: IN
      coeff :: VEC{REAL}, OUT

      i :: INT

      do i = 1,.dim
         coeff(i) = ATOM::Grimme06_a_6_dispersion_coeff(self(i))
      end

   end

   get_Grimme06_r_coeffs_in(coeff) ::: pure
   ! Returns the Grimme a-coefficients
      self :: IN
      coeff :: VEC{REAL}, OUT

      i :: INT

      do i = 1,.dim
         coeff(i) = ATOM::Grimme06_r_0_dispersion_coeff(self(i))
      end

   end


!  ================================
!  Moments, fields, field gradients
!  ================================

   nuclear_dipole_moment result (res) ::: PURE
   ! Return the dipole moment obtained from the atomic numbers.
   ! Dummy nuclear charges are not included
      self :: IN
      res :: VEC{REAL}(3)

      a :: INT

      res = ZERO
      do a = 1,.dim
         res = res + self(a).atomic_number*self(a).position
      end

   end

   nuclear_quadrupole_moment result (res) ::: PURE
   ! Return the quadrupole moment obtained from the nuclear charges
   ! as a vector, in the order: xx, yy, zz, xy, xz, yz
   ! Dummy nuclear charges are not included
      self :: IN
      res :: VEC{REAL}(6)

      Z :: REAL
      a :: INT

      res = ZERO
      do a = 1,.dim
         Z = self(a).atomic_number
         res(1) = res(1) + Z * self(a).position(1) * self(a).position(1)
         res(2) = res(2) + Z * self(a).position(2) * self(a).position(2)
         res(3) = res(3) + Z * self(a).position(3) * self(a).position(3)
         res(4) = res(4) + Z * self(a).position(1) * self(a).position(2)
         res(5) = res(5) + Z * self(a).position(1) * self(a).position(3)
         res(6) = res(6) + Z * self(a).position(2) * self(a).position(3)
      end

   end

   nuclear_octupole_moment result (res) ::: PURE
   ! Return the octupole moment obtained from the nuclear charges as a vector,
   ! in the order: xxx, yyy, zzz, xxy, xxz, yyx, yyz, zzx, zzy, xyz
   ! Dummy nuclear charges are not included
      self :: IN
      res :: VEC{REAL}(10)

      Z :: REAL
      a :: INT

      res = ZERO
      do a = 1,.dim
         Z = self(a).atomic_number
         res(1)  = res(1)  + Z * self(a).position(1) * self(a).position(1) * self(a).position(1)
         res(2)  = res(2)  + Z * self(a).position(2) * self(a).position(2) * self(a).position(2)
         res(3)  = res(3)  + Z * self(a).position(3) * self(a).position(3) * self(a).position(3)
         res(4)  = res(4)  + Z * self(a).position(1) * self(a).position(1) * self(a).position(2)
         res(5)  = res(5)  + Z * self(a).position(1) * self(a).position(1) * self(a).position(3)
         res(6)  = res(6)  + Z * self(a).position(2) * self(a).position(2) * self(a).position(1)
         res(7)  = res(7)  + Z * self(a).position(2) * self(a).position(2) * self(a).position(3)
         res(8)  = res(8)  + Z * self(a).position(3) * self(a).position(3) * self(a).position(1)
         res(9)  = res(9)  + Z * self(a).position(3) * self(a).position(3) * self(a).position(2)
         res(10) = res(10) + Z * self(a).position(1) * self(a).position(2) * self(a).position(3)
      end

   end


   nuclear_E_field_at_positions(pos) result (res) ::: PURE
   ! Return the nuclear contribution to the electric field from "self"
   ! at the positions "pos" as a (3 x .dim) array
   ! NOTE: "pos" should not be a nuclear position!
      self :: IN
      pos :: MAT{REAL}, IN
      res :: MAT{REAL}(3,pos.dim2)

      Z,r :: REAL
      a,b :: INT
      ab :: VEC{REAL}(3)

      res = ZERO
      do a = 1,pos.dim2
      do b = 1,.dim
         Z  = self(b).nuclear_charge
         ab = pos(:,a) - self(b).position
         r  = ab.norm
         res(:,a) = res(:,a) + Z*ab/(r*r*r)
      end
      end

   end

   add_nuclear_E_field_at_points_to(res,pt) ::: PURE
   ! Add the nuclear contribution to the electric field from "self" at
   ! the positions "pos" to (3 x .dim) array "res" 
   ! NOTE: "pos" should not be a nuclear position!
      self :: IN
      pt   :: MAT{REAL}, IN
      res  :: MAT{REAL}(3,pt.dim1), INOUT

      Z,r :: REAL
      a,b :: INT
      ab  :: VEC{REAL}(3)

      do b = 1,.dim
      do a = 1,pt.dim1
         Z  = self(b).nuclear_charge
         ab = pt(a,:) - self(b).position
         r  = ab.norm
         res(:,a) = res(:,a) + Z*ab/(r*r*r)
      end
      end

   end

   nuclear_E_field_at_nuclei result (res) ::: PURE
   ! Return the nuclear contribution to the electric fields
   ! at the positions of the nuclei as a (3 x .dim) array
      self :: IN
      res :: MAT{REAL}(3,.dim)

      Z,r :: REAL
      a,b :: INT
      ab  :: VEC{REAL}(3)

      res = ZERO
      do a = 1,.dim
      do b = 1,.dim
         if (b==a) cycle ! skip
         Z  = self(b).nuclear_charge
         ab = self(a).position - self(b).position
         r  = ab.norm
         res(:,a) = res(:,a) + Z*ab/(r*r*r)
      end
      end

   end

   nuclear_E_field_at_nuclei_of(atoms) result (res) ::: PURE
   ! Return the nuclear contribution to the electric fields
   ! from "self" at the positions of the nuclei of "atoms"
      self  :: IN
      atoms :: VEC{ATOM}, IN
      res   :: MAT{REAL}(3,atoms.dim)

      pos :: MAT{REAL}@

      pos = atoms.coordinates
      res = .nuclear_E_field_at_positions(pos)
      pos.destroy

   end

   nuclear_EFG_at_nuclei result (res) ::: PURE
   ! Return the nuclear contribution to the electric fields gradient
   ! (EFG) at the nuclei as a (6 x .dim) array
      self :: IN
      res :: MAT{REAL}(6,size(self))

      Z,r,r3,r5 :: REAL
      a,b :: INT
      ab :: VEC{REAL}(3)

      res = ZERO

      do a = 1,.dim
      do b = 1,.dim

         if (b==a) cycle

         Z  = self(b).nuclear_charge

         ab = self(a).position - self(b).position
         r  = ab.norm
         r3 =  r*r*r
         r5 = r3*r*r

         res(1,a) = res(1,a) - Z * (THREE*ab(1)*ab(1)/r5 - ONE/r3)
         res(2,a) = res(2,a) - Z * (THREE*ab(2)*ab(2)/r5 - ONE/r3)
         res(3,a) = res(3,a) - Z * (THREE*ab(3)*ab(3)/r5 - ONE/r3)
         res(4,a) = res(4,a) - Z * (THREE*ab(1)*ab(2)/r5)
         res(5,a) = res(5,a) - Z * (THREE*ab(1)*ab(3)/r5)
         res(6,a) = res(6,a) - Z * (THREE*ab(2)*ab(3)/r5)

      end
      end

   end

!  ========================
!  Atom kinds, unique atoms
!  ========================

   same_kind_of_atoms(a,b) result (res) ::: pure
   ! Return true if atoms "a" and "b" are the same kind
   ! . They are the same kind if they have the same kind of basis
   !   and same atomic number.
   ! . This is used for ANO or other QM type calculations.
      self :: IN
      a,b :: INT, IN
      res :: BIN
      res = self(a).is_same_kind_as(self(b))
   end

   make_atom_Z_list(Z_list) ::: leaky, PURE
   ! Make the atom Z list ... Z_list(k).element(c) is the c-th atom of
   ! the same atomic number (atomic numbers in decreasing order).
      self :: IN
      Z_list :: VEC{EVEC{INT}}@, OUT

      n_kind, n,k,Z_n :: INT
      Z,unique_Z :: VEC{INT}@

      ! Atomic numbers
      Z.create(.dim)
      Z = self(:).atomic_number

      ! Sorted unique atomic numvers
      unique_Z.to_unique_elements_of(Z)
      unique_Z.quick_sort(decreasing_order=TRUE)

      ! Assign each atom to its kind in
      ! decreasing order
      n_kind = unique_Z.dim
      Z_list.create(n_kind,0)
      do n = 1,.dim
         Z_n = self(n).atomic_number
         do k = 1,n_kind
            if (Z_n==unique_Z(k)) then
                Z_list(k).element.append(n)
                exit
            end
         end
      end

      ! Clean up
      unique_Z.destroy
      Z.destroy

   end

   make_atom_kind_list(atom_kind,n_kind) ::: PURE
   ! Make the atom=kind list ... atom_kind(k) is the kind index of
   ! the k-th atom, as determined by .same_kind_of_atoms(k,l)
      self :: IN
      atom_kind :: VEC{INT}, OUT
      n_kind :: INT, OUT

   ENSURE(atom_kind.dim==.dim,"atom_kind is incorrectly dimensioned")

      n_atom,n,k,l :: INT

      n_atom = .dim
      atom_kind = [ (n, n=1,n_atom) ]

      k = 0
      do n = 1,n_atom

         ! Found kind for atom n?
         if (atom_kind(n)<=k) cycle

         ! Set kind
         k = k + 1
         atom_kind(n) = k

         ! Set non-unique kinds
         do l = n+1,n_atom
            if (atom_kind(l)<=k) cycle
            if (NOT .same_kind_of_atoms(l,n)) cycle
            atom_kind(l) = k
         end

      end

      n_kind = k

   end

   make_unique_atom_list(unique_atom) ::: PURE
   ! "unique_atom(k)" is the index of the first atom which represents
   ! all the the atoms which are of the same kind, k. This requires
   ! "is_unique_kind" to have been made via "update_kinds".
      self :: IN
      unique_atom :: VEC{INT}, OUT

   ENSURE(unique_atom.dim==maxval(self(:).kind),"unique atom incorrectly dimensioned")

      n_kind,k,n :: INT

      n_kind = maxval(self(:).kind)

      ! Make the list
      unique_atom = 0
      k = 0
      do n = 1,.dim
         if (NOT self(n).is_unique_kind) cycle
         k = k + 1
         unique_atom(k) = n
      end

   end

   are_distinct(a,b) result (res) ::: pure
   ! Return true if atoms "a" and "b" are crystallographically
   ! distinct based on occupancy and atomic number
      self :: IN
      a,b :: INT, IN
      res :: BIN

      res = self(a).atomic_number      /=self(b).atomic_number       &
        OR  self(a).site_disorder_group/=self(b).site_disorder_group &
        OR NOT self(a).site_occupancy.equals(self(b).site_occupancy)

   end

!  ===========
!  Atom groups
!  ===========

   has_site_groups result (res) ::: pure
   ! Return TRUE if any crstal site dirder groups have been defined
      self :: IN
      res :: BIN

      if (any(self(:).site_disorder_group>0)) then; res = TRUE
      else;                                         res = FALSE
      end

   end

   has_groups result (res) ::: pure
   ! Return TRUE if more than one atom group has been defined.
   ! This only counts if there is more than one group!
      self :: IN
      res :: BIN

      if (any(self(:).group>1)) then; res = TRUE
      else;                           res = FALSE
      end

   end

   no_of_groups result (res) ::: pure
   ! Return the number of groups
      self :: IN
      res :: INT
      res = maxval(self(:).group)
   end

   set_connected_groups ::: PURE
   ! Search through the list of atoms and assign each atom the same
   ! group number if the atom is a part of the same connected
   ! molecule.
      self :: INOUT

      atoms_bonded_to_atom :: VEC{EVEC{INT}}@
      group_for :: VEC{INT}@
      n_atoms, a,b,c,n, ga,gb :: INT
      n_group, g :: INT

      ! Can only proceed in cartesian axes
      if (NOT all(ATOM:is_in_cartesian_system(self))) return

      ! Make the bond list
      .make_connection_table(atoms_bonded_to_atom)

      ! Assume every atom it's own molecule
      n_atoms = .dim
      group_for.to_sequence(1,n_atoms)

      ! Loop on all atoms "a"
      do a = 1,n_atoms

         ! Group "ga" foratom "a" 
         ga = group_for(a)

         ! No of atoms bonded to atom "a"
         n = atoms_bonded_to_atom(a).element.dim

         ! Loop over bonded atoms
         do c = 1,n

            b  = atoms_bonded_to_atom(a)[c]
            gb = group_for(b)

            if      (gb>ga) then
               where (group_for==gb) group_for = ga
            else if (gb<ga) then
               where (group_for==ga) group_for = gb
            end

         end

      end

      ! Make groups consecutive
      n = maxval(group_for)
      group_for = -group_for
      n_group = 0
      do g = -1,-n,-1
         if (any(group_for==g)) then
            n_group = n_group + 1
            where (group_for==g) group_for = n_group
         end
      end

      ! Assign
      self.set_groups_to(group_for)

      ! Clean
      group_for.destroy
      atoms_bonded_to_atom.destroy

   end

   make_atom_group_list(atom_group) ::: leaky
   ! This routine finds all the atoms in the same group and makes
   ! their indices as a atom_group of integers. The result is a
   ! "atom_group" of atom_group of integers. NOTE that "atom_group" is
   ! created.
      self :: IN
      atom_group :: VEC{EVEC{INT}}@, OUT

      n_group,g,n,i :: INT
      group_indices :: VEC{INT}@

      ! Extract the group indices
      group_indices.create(.dim)
      group_indices = self.group
      n_group = group_indices.no_of_unique_elements

      ! Create the atom_group list of indices
      atom_group.create(n_group)

      ! All atoms in one group, size .dim
      if (n_group==1) then
         atom_group(1).element.create(.dim)
         atom_group(1).element = [ (i, i=1,.dim) ]
      ! Atoms in different groups, size n_group
      else
        do g = 1,n_group
           n = count(group_indices==g)
           DIE_IF(n==0,"group indices are not sequential!")
           atom_group(g).element.create(n)
           atom_group(g).element = pack( [ (i, i=1,.dim) ], group_indices==g)
        end
      end

      ! Clean
      group_indices.destroy

   end

   set_group_to(g) ::: pure
   ! Set the atom "group" index to "g".
      self :: INOUT
      g :: INT, IN

      a :: INT

      do a = 1,.dim
         self(a).set_group(g)
      end

   end

   set_groups_to(groups) ::: pure
   ! Set the atom "group" index to "groups".
      self :: INOUT
      groups :: VEC{INT}, IN

      a :: INT

      do a = 1,.dim
         self(a).set_group(groups(a))
      end

   end

   no_of_compounds result (res) ::: pure
   ! Return the number of different compound_id's
      self :: IN
      res :: INT
      res = maxval(self(:).compound_sequence_id)
   end

!  =========================
!  Shell information methods
!  =========================

   make_shell_limits(first,last) ::: leaky, PURE
   ! Get the shell function limit vectors "first" and "last" for
   ! corresponding to the concatenated vector of atomvec shells.
      self :: IN
      first,last :: VEC{INT}@, OUT

      n_shell, a,as,n,ss,f,l :: INT

      n_shell = .no_of_shells
      
      first.create(n_shell)
      last.create(n_shell)

      ss = 0
      l  = 0

      do a = 1,.dim

         n = self(a).basis.shell.dim

         do as = 1,n
            ss = ss + 1
            f  = l + 1
            l  = f + self(a).basis.shell(as).n_bf - 1
            first(ss) = f
            last(ss)  = l
         end

      end

   end

   make_shell_limits(first,last,momentum) ::: leaky, PURE
   ! Get the shell function limit vectors "first" and "last" for
   ! corresponding to the concatenated vector of atomvec shells. Also
   ! get the angular "momentum" for the shell.
      self :: IN
      first,last,momentum :: VEC{INT}@, OUT

      n_shell, a,as,n,ss,f,l :: INT

      n_shell = .no_of_shells
      first.create(n_shell)
      last.create(n_shell)
      momentum.create(n_shell)

      ss = 0
      l  = 0

      do a = 1,.dim

         n = self(a).basis.shell.dim

         do as = 1,n
            ss = ss + 1
            f = l + 1
            l = f + self(a).basis.shell(as).n_bf - 1
            first(ss) = f
            last(ss)  = l
            momentum(ss) = self(a).basis.shell(as).l
         end

      end

   end

   make_atom_basis_fn_limits(first,last) ::: leaky, PURE
   ! Get the first and last basis functions for each atom in "self"
   ! (treating the basis set as the flattened list of basis functions
   ! on each atom)
      self :: IN
      first,last :: VEC{INT}@, OUT

      a,as,n,l :: INT

      first.create(.dim)
      last.create(.dim)

      l = 0
      do a = 1,.dim

         n = self(a).basis.shell.dim

         first(a) = l + 1
         do as = 1,n
            l = l + self(a).basis.shell(as).n_bf
         end
         last(a) = l
      end

   end

   make_primitive_limits(frst,last,atom,lmom,expo) ::: leaky, PURE
   ! Get the primitive function limit vectors "frst" and "last" and
   ! other data pertaining to the primitive function corresponding to
   ! the concatenated bases of all the atoms.
      self :: IN
      frst :: VEC{INT}@, OUT
      last :: VEC{INT}@, OUT
      atom :: VEC{INT}@, OUT
      lmom :: VEC{INT}@, OUT
      expo :: VEC{REAL}@, OUT

      nps,a,as,ap,p,f,l :: INT

      nps = .no_of_primitive_shells

      frst.create(nps)
      last.create(nps)
      atom.create(nps)
      lmom.create(nps)
      expo.create(nps)

      p = 0
      l = 0

      do a = 1,.dim
      do as = 1,self(a).basis.shell.dim

         do ap = 1,self(a).basis.shell(as).n_cc

            p = p + 1
            f = l + 1
            l = l + self(a).basis.shell(as).n_bf

            frst(p) = f
            last(p) = l
            atom(p) = a
            lmom(p) = self(a).basis.shell(as).l
            expo(p) = self(a).basis.shell(as).exponent(ap)

         end

      end
      end

   end

!  ========================
!  Basis shell info methods
!  ========================

   make_basis_shell_for_shell(res,basis) ::: leaky, PURE
   ! Return "res" which has the index of the first shell in .basis
   ! (treating .basis as a flattened list of shells) for a given shell
   ! index in the molecular basis set (treated as the flattened list
   ! of shells in the .atom list). 
      self :: INOUT
      res  :: VEC{INT}@, OUT
      basis :: VEC{BASIS}, IN

      sh,a,as,f :: INT

      ! Index array
      res.create(.no_of_shells)

      ! Loop over atoms
      sh = 0
      do a = 1,.dim

         ! Index of first shell in "basis" which matches atoms basis
         f = basis.first_shell_for_basis(label=trim(self(a).basis.label))

         ! Loop over this atoms shells
         do as = 1,self(a).basis.shell.dim
            sh = sh + 1
            res(sh) = f + as -1
         end

      end

   end

!  ==============================
!  Atom-shell information methods
!  ==============================

   atom_for_shell(s) result (a) ::: pure
   ! Return the *atom* number "a" corresponding to the
   ! flattened shell number "s"
      self :: IN
      s :: INT, IN
      a :: INT

      ss,n :: INT

      ss = 0
      do a = 1,.dim
         n = self(a).basis.shell.dim
         ss = ss + n
         if (s<=ss) exit
      end

   end

   make_atom_for_shell(res) ::: leaky, PURE
   ! Return a vector of *atom* numbers corresponding to the
   ! flattened shell numbers
      self :: IN
      res :: VEC{INT}@, OUT

      a,s,n :: INT

      res.create(.no_of_shells)

      s = 0
      do a = 1,.dim
         n = self(a).basis.shell.dim
         res(s+1:s+n) = a
         s = s + n
      end

   end

   atom_shell_for_shell(s) result (as) ::: pure
   ! Return the *atom* shell number "as" corresponding to the
   ! flattened shell number "s"
      self :: IN
      s :: INT, IN
      as :: INT

      a,ss,n :: INT

      n = 0
      ss = 0
      do a = 1,.dim
         n = self(a).basis.shell.dim
         ss = ss + n
         if (s<=ss) exit
      end

      as = s - ss + n

   end

   make_atom_shell_for_shell(res) ::: leaky, PURE
   ! Return a vector of *atom* shell numbers corresponding to the
   ! flattened shell vector
      self :: IN
      res :: VEC{INT}@, OUT

      a,ss,n,as :: INT

      res.create(.no_of_shells)

      ss = 0
      do a = 1,.dim
         n = self(a).basis.shell.dim
         do as = 1,n
            res(ss+as) = as
         end
         ss = ss + n
      end

   end

   first_shell_for_atom(a) result (res) ::: pure
   ! Return the index of the first shell for atom "a"
      self :: IN
      a :: INT, IN
      res :: INT

      at,n :: INT

      res = 1
      do at = 1,(a-1)
         n = self(a).basis.shell.dim
         res = res + n
      end

   end

   make_shell_for_atom_limits(first,last) ::: pure
   ! Return the indices of the first and last shell for each atom
      self :: IN
      first,last :: VEC{INT}, OUT

      ss,a,n :: INT

      ss = 0
      do a = 1,.dim
         first(a) = ss + 1
         n = self(a).basis.shell.dim
         ss = ss + n
         last(a) = ss
      end

   end

   make_first_shell_for_atom(res) ::: leaky, PURE
   ! Return the indices of the first shell for each atom
      self :: IN
      res :: VEC{INT}@, OUT

      ss,a,n :: INT

      res.create(.dim)

      ss = 0
      do a = 1,.dim
         n = self(a).basis.shell.dim
         res(a) = ss + 1
         ss = ss + n
      end

   end

!  ===============
!  Invariom labels
!  ===============

   neighbours_of(a,range_factor) result (res) ::: leaky, pure
   ! Return the list of atoms bonded to atom "a".
      self :: IN
      a :: INT, IN
      range_factor :: REAL, optional, IN
      res :: VEC{INT}@

      b :: INT

      do b = 1,.dim
         if (b==a) cycle
         if (NOT .bonded(a,b,range_factor)) cycle
         res.append(b)
      end

   end

   is_next_neighbour_chiral(a) result (res) ::: leaky, pure
   ! Return TRUE if there are four next nearest neighbours for the
   ! atom "a", and if they are all different.
      self :: IN
      a :: INT, IN
      res :: BIN

      neighbour :: VEC{INT}@
      Z :: VEC{INT}(4)

      neighbour = .neighbours_of(a)

      if (neighbour.deallocated) then
         res = FALSE
      else if (neighbour.dim==4) then
         Z = self(neighbour).atomic_number
         res = NOT Z.has_repetitions
      else
         res = FALSE
      end

   end

   next_neighbour_handedness_of(a) result (res) ::: leaky, PURE
   ! Return the handedness of the atom "a" based only on the four
   ! connecting atoms around it.
      self :: IN
      a :: INT, IN
      res :: STR

      n :: INT
      p2,p3,p4,pc :: VEC{REAL}(3)
      Z,order :: VEC{INT}(4)
      neighbour :: VEC{INT}@

      neighbour = .neighbours_of(a)
      ENSURE(neighbour.allocated,"there are no neighbours")
      n = neighbour.dim
      ENSURE(neighbour.dim==4,"must have four neighbours, n = "//trim(n.to_str))

      Z = self(neighbour).atomic_number
      Z.quick_sort(order)
      neighbour = neighbour(order)

      p2 = self(neighbour(2)).position - self(a).position
      p3 = self(neighbour(3)).position - self(a).position
      p4 = self(neighbour(4)).position - self(a).position
      pc = p4.cross(p3)

      if (p2.dot(pc)>ZERO) then; res = "R"
      else;                      res = "S"
      end

   end


   invariom_labels result (res) ::: leaky, PURE
   ! Return the invariom label for the atom "a"
      self :: IN
      res :: VEC{STR}@

      a :: INT

      res.create(.dim)
      do a = 1,.dim
         res(a) = .invariom_label_of(a)
      end

   end

   invariom_label_of(a) result (res) ::: PURE
   ! Return the invariom label for the atom "a"
      self :: IN
      a :: INT, IN
      res :: STR

      i,j,n,m,f2,l2,p :: INT
      Z,bond,order,neighbour,Z2,bond2,order2,neighbour2 :: VEC{INT}@
      bonds,bonds2,mesomer,ZZ :: VEC{STR}@
      special,do_2nd_neighbour :: BIN
      special_Z :: VEC{INT}(3)
      symbol :: STR

      special_Z = [1,15,16]

      ! Start with the R or S symbol, if the atom is chiral
      if (.is_next_neighbour_chiral(a)) then; res = trim(.next_neighbour_handedness_of(a))//"-"
      else;                                   res = " "
      end

      ! Start with "a" atoms chemical symbol
      res = trim(res)//self(a).chemical_symbol

      ! Get indices of the nearest neighbours; return if no neighbours
      neighbour = .neighbours_of(a)
      if (neighbour.deallocated) return
      neighbour.prune(a)
      if (neighbour.dim==0) return

      ! Create arrays to store the bond order (times 10) and string
      ! form of bond order
      n = neighbour.dim
      bond.create(n)
      bonds.create(n)

      ! Get the atomic numbers Z of neighbors and order them in
      ! decreasing bond-order/atomic number
      Z.create(n)
      order.create(n)

      Z = self(neighbour).atomic_number
      .allred_rochow_bond_orders(a,neighbour,bond,bonds)
      Z = 1000*bond + Z
      Z.quick_sort(order,decreasing_order=TRUE)
      neighbour = neighbour(order)
      bond  = bond(order)
      bonds = bonds(order)

      order.destroy
      Z.destroy

      f2 = 0
      special = FALSE

      if (any(special_Z==self(a).atomic_number)) then
         ! If special Z atoms switch on next nearest neighbour
         f2 = 1
         l2 = bond.dim
         special = TRUE
      else
         ! Find out how many mesomeric bonds there are
         f2 = bond.index_of_value(15)
         l2 = 0
         if (f2>0) then
            if      (f2==bond.dim) then;       l2 = f2
            else if (bond(bond.dim)==15) then; l2 = bond.dim
            else;                              l2 = bond(f2+1:).index_of_value_ne_to(15)
                                               l2 = f2 + l2 - 1
            end
         end
      end

      do_2nd_neighbour = f2>0 AND l2>=f2

      ! If we should do second nearest neighbours ...
      if (do_2nd_neighbour) then

         mesomer.create(f2,l2); mesomer = " "
         ZZ.create(f2,l2);      ZZ = "0"

         ! Loop over second nearest neighbour atoms or mesomeric atoms
         do i = f2,l2

            ! Get indices of the 2nd nearest neighbours; return if no neighbours
            neighbour2 = .neighbours_of(neighbour(i))
            ENSURE(neighbour2.allocated,"mesomeric atom has no neighbours")

            ! We don't want the original first neighbour
            neighbour2.prune(a)
            if (neighbour2.dim==0) then
               neighbour2.destroy
               cycle
            end

            ! Order the 2nd nearest neighbours in decreasing bond-order/atomic number
            m = neighbour2.dim
            bond2.create(m)
            bonds2.create(m)
            Z2.create(m)
            order2.create(m)
            Z2 = self(neighbour2).atomic_number
            .allred_rochow_bond_orders(neighbour(i),neighbour2,bond2,bonds2)
            Z2 = 1000*bond2 + Z2
            Z2.quick_sort(order2,decreasing_order=TRUE)
            neighbour2 = neighbour2(order2)
            Z2 = Z2(order2)
            bond2 = bond2(order2)
            bonds2 = bonds2(order2)

           ! Make and store the unsorted mesomer 2nd nearest neighbour invariom names
            mesomer(i) = achar(91)
            do j = 1,m
               symbol = self(neighbour2(j)).chemical_symbol
               mesomer(i) = trim(mesomer(i))// &
                            trim(bonds2(j))// &
                            trim(symbol.lower_cased)
            end
            mesomer(i) = trim(mesomer(i))//achar(93)

            ! Make the 2nd nearest neighbour ordering string ZZ
            p = 1
            do j = 1,m
               ZZ(i)(p:p+3) = trim(Z2(j).to_str)
               p = p + 4
            end

            order2.destroy
            Z2.destroy
            bonds2.destroy
            bond2.destroy
            neighbour2.destroy
         end

         ! Now reorder the mesomer strings according to ZZ
         if (l2>f2) then
            order.create(f2,l2)
            ZZ.quick_sort(order,decreasing_order=TRUE)
            order = order + f2 - 1
            neighbour(f2:l2) = neighbour(order)
            mesomer(f2:l2) = mesomer(order)
            order.destroy
         end

         ZZ.destroy

      end

      ! Now everything is sorted; just make the invariom label
      res = res.trim_blanks_from_start
      do i = 1,n
         symbol = self(neighbour(i)).chemical_symbol
         res = trim(res)//trim(bonds(i))//trim(symbol.lower_cased)
         if (bond(i)==15 OR special) then
            res = trim(res)//trim(mesomer(i))
         end
      end

   end

   put_invariom_labels
   ! Print out the invariom labels
      self :: IN

      a :: INT

      do a = 1,.dim
         stdout.show("label for atom "//trim(a.to_str)//" = ",.invariom_label_of(a))
      end

   end

   allred_rochow_bond_orders(a,neighbours,bond,bonds) ::: PURE
   ! Given at atom "a" and its "neighbours" return the allred-rochow
   ! bond distinguishing parameters "bond" (times 10) and the
   ! cooresponding string form.
      self :: IN
      a :: INT, IN
      neighbours :: VEC{INT}, IN
      bond :: VEC{INT}, OUT
      bonds :: VEC{STR}, OUT

   ENSURE(0<a AND a <=.dim,"index a out of range")
   ENSURE(bond.dim==neighbours.dim,"bond array, wrong size")
   ENSURE(bonds.dim==neighbours.dim,"bond array, wrong size")

      i,b :: INT
      br :: REAL

      do i = 1,neighbours.dim
         b = .bond_distinguisher(a,neighbours(i))
         bond(i) = b
         if (b==15) then
            br = b/TEN
            bonds(i) = br.to_str("f3.1")
         else
            b = b/10
            bonds(i) = b.to_str
         end
      end

   end

   bond_distinguisher(a,b) result (res) ::: PURE
   ! Return true if "self" is bonded to "b".  If present, "range_factor" is used
   ! to determine the distance range in which the atoms are regarded as bonded.
   ! This uses the CCDC method, as documented on their web page.
      self :: IN
      a,b :: INT, IN
      res :: INT

      d,chi,cra,crb,ena,enb :: REAL

      d = .bond_distance(a,b)*ANGSTROM_PER_BOHR

      cra = self(a).invariom_covalent_radius
      crb = self(b).invariom_covalent_radius

      ena = self(a).allred_rochow_en
      enb = self(b).allred_rochow_en

      chi = cra + crb - 0.08 * abs(ena-enb) - d

      res = 0
           if (chi <= 0.0847 ) then; res = 10
      else if (chi <= 0.184 )  then; res = 15
      else if (chi <= 0.27 )   then; res = 20
      else if (chi >  0.27 )   then; res = 30
      end

   end


   smiles_invariom_labels result (res) ::: leaky, PURE
   ! Return the invariom label for the atom "a"
      self :: IN
      res :: VEC{STR}@

      a :: INT

      res.create(.dim)
      do a = 1,.dim
         res(a) = .smiles_invariom_label_of(a)
      end

   end

   smiles_invariom_label_of(a) result (res) ::: PURE
   ! Return the invariom label for the atom "a"
      self :: IN
      a :: INT, IN
      res :: STR

      i,j,n,m,f2,l2,p :: INT
      Z,bond,order,neighbour,Z2,bond2,order2,neighbour2 :: VEC{INT}@
      bonds,bonds2,mesomer,ZZ :: VEC{STR}@
      special,do_2nd_neighbour :: BIN
      special_Z :: VEC{INT}(3)
      symbol :: STR

      special_Z = [1,15,16]

      ! Start with the R or S symbol, if the atom is chiral
      if (.is_next_neighbour_chiral(a)) then; res = trim(.next_neighbour_handedness_of(a))//"-"
      else;                                   res = " "
      end

      ! Start with "a" atoms chemical symbol
      res = trim(res)//self(a).chemical_symbol

      ! Get indices of the nearest neighbours; return if no neighbours
      neighbour = .neighbours_of(a)
      if (neighbour.deallocated) return

      neighbour.prune(a)
      if (neighbour.dim==0) return

      ! Create arrays to store the bond order (times 10) and string
      ! form of bond order
      n = neighbour.dim
      bond.create(n)
      bonds.create(n)

      ! Get the atomic numbers Z of neighbors and order them in
      ! decreasing bond-order/atomic number
      Z.create(n)
      order.create(n)
      Z = self(neighbour).atomic_number
      .smiles_bond_orders(a,neighbour,bond,bonds)
      Z = 1000*bond + Z
      Z.quick_sort(order,decreasing_order=TRUE)
      neighbour = neighbour(order)
      bond  = bond(order)
      bonds = bonds(order)
      order.destroy; Z.destroy

      f2 = 0
      special = FALSE
      if (any(special_Z==self(a).atomic_number)) then
         ! If special Z atoms switch on next nearest neighbour
         f2 = 1
         l2 = bond.dim
         special = TRUE
      else
         ! Find out how many mesomeric bonds there are
         f2 = bond.index_of_value(15)
         l2 = 0
         if (f2>0) then
            if      (f2==bond.dim) then;       l2 = f2
            else if (bond(bond.dim)==15) then; l2 = bond.dim
            else;                              l2 = bond(f2+1:).index_of_value_ne_to(15)
                                               l2 = f2 + l2 - 1
            end
         end
      end

      do_2nd_neighbour = f2>0 AND l2>=f2

      ! If we should do second nearest neighbours ...
      if (do_2nd_neighbour) then

         mesomer.create(f2,l2); mesomer = " "
         ZZ.create(f2,l2);      ZZ = "0"

         ! Loop over second nearest neighbour atoms or mesomeric atoms
         do i = f2,l2

            ! Get indices of the 2nd nearest neighbours; return if no neighbours
            neighbour2 = .neighbours_of(neighbour(i))
            ENSURE(neighbour2.allocated,"mesomeric atom has no neighbours")

            ! We don't want the original first neighbour
            neighbour2.prune(a)
            if (neighbour2.dim==0) then
               neighbour2.destroy
               cycle
            end

            ! Order the 2nd nearest neighbours in decreasing bond-order/atomic number
            m = neighbour2.dim
            bond2.create(m)
            bonds2.create(m)
            Z2.create(m)
            order2.create(m)
            Z2 = self(neighbour2).atomic_number
            .smiles_bond_orders(neighbour(i),neighbour2,bond2,bonds2)
            Z2 = 1000*bond2 + Z2
            Z2.quick_sort(order2,decreasing_order=TRUE)
            neighbour2 = neighbour2(order2)
            Z2 = Z2(order2)
            bond2 = bond2(order2)
            bonds2 = bonds2(order2)

           ! Make and store the unsorted mesomer 2nd nearest neighbour invariom names
            mesomer(i) = "("
            do j = 1,m
               symbol = self(neighbour2(j)).chemical_symbol
               mesomer(i) = trim(mesomer(i))// &
                            trim(bonds2(j))// &
                            trim(symbol.lower_cased)
            end
            mesomer(i) = trim(mesomer(i))//")"

            ! Make the 2nd nearest neighbour ordering string ZZ
            p = 1
            do j = 1,m
               ZZ(i)(p:p+3) = trim(Z2(j).to_str)
               p = p + 4
            end

            order2.destroy
            Z2.destroy
            bonds2.destroy
            bond2.destroy
            neighbour2.destroy
         end

         ! Now reorder the mesomer strings according to ZZ
         if (l2>f2) then
            order.create(f2,l2)
            ZZ.quick_sort(order,decreasing_order=TRUE)
            order = order + f2 - 1
            neighbour(f2:l2) = neighbour(order)
            mesomer(f2:l2) = mesomer(order)
            order.destroy
         end

         ZZ.destroy

      end

      ! Now everything is sorted; just make the invariom label
      res = res.trim_blanks_from_start
      res = trim(res)//"("
      do i = 1,n
         symbol = self(neighbour(i)).chemical_symbol
         res = trim(res)//trim(bonds(i))//trim(symbol.lower_cased)
         if (bond(i)==15 OR special) then
            res = trim(res)//trim(mesomer(i))
         end
      end
      res = trim(res)//")"

   end

   put_smiles_invariom_labels
   ! Print out the invariom labels
      self :: IN

      a :: INT

      do a = 1,.dim
         stdout.show("label for atom "//trim(a.to_str)//" = ",.smiles_invariom_label_of(a))
      end

   end

   smiles_bond_orders(a,neighbours,bond,bonds) ::: PURE
   ! Given at atom "a" and its "neighbours" return the allred-rochow
   ! bond distinguishing parameters "bond" (times 10) and the
   ! cooresponding string form.
      self :: IN
      a :: INT, IN
      neighbours :: VEC{INT}, IN
      bond :: VEC{INT}, OUT
      bonds :: VEC{STR}, OUT

   ENSURE(0<a AND a <=.dim,"index a out of range")
   ENSURE(bond.dim==neighbours.dim,"bond array, wrong size")
   ENSURE(bonds.dim==neighbours.dim,"bond array, wrong size")

      i,b :: INT

      do i = 1,neighbours.dim

         b = .bond_distinguisher(a,neighbours(i))
         bond(i) = b

         select case (b)
         case (10);    bonds(i) = "-"
         case (15);    bonds(i) = ":"
         case (20);    bonds(i) = "="
         case (25);    bonds(i) = "%"
         case (30);    bonds(i) = "#"
         case default; bonds(i) = "?"
         end

      end

   end


!  =================
!  Protein detection
!  =================

   find_and_put_N_terminal_atoms
   ! Print the indices of the N terminal atoms.
      self :: IN

      list :: VEC{INT}@

      .make_connection_table(skip_hydrogen=TRUE)

      .find_and_put_N_terminal_atoms(list)

      stdout.text("List of N terminal atoms:")
      stdout.put(list)

      list.destroy
      connections_for.destroy

   end

   find_and_put_N_terminal_atoms(list) ::: leaky
   ! Print the indices of the protein backbone atoms.
      self :: IN
      list :: VEC{INT}@, OUT

   ENSURE(connections_for.allocated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      N,Cp0,Ca,Cb,Cp,N1,Ot,Ct :: INT
      N_terminal :: BIN

      list.create(0)

      do N = 1,.dim
        if (self(N).atomic_number/=7) cycle
        Cp0 = 0
        if (NOT .is_protein_backbone_N(N,Cp0,Ca,Cb,Cp,N1,Ot,Ct,N_terminal,try=TRUE)) cycle
        if (NOT N_terminal) cycle
        list.append(N)
      end

   end


   find_and_put_protein_backbone
   ! Return the of indices of the N terminal atoms.
      self :: IN

      backbone :: VEC{EVEC{INT}}@

      .make_connection_table(skip_hydrogen=TRUE)
      .find_and_put_protein_backbone(backbone)

      backbone.destroy
      connections_for.destroy

   end

   find_and_put_protein_backbone(backbone) ::: leaky
   ! Return the "backbone" of atom indices in each protein backbone.
      self :: IN
      backbone :: VEC{EVEC{INT}}@, OUT

   ENSURE(connections_for.allocated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      terminal :: VEC{INT}@
      N_terminal :: BIN
      i, N,Cp0,Ca,Cb,Cp,N1,Ot,Ct :: INT

      .find_and_put_N_terminal_atoms(terminal)

      backbone.create(terminal.dim,1)

      do i = 1,terminal.dim

        N = terminal(i)
        backbone(i)[1] = N
        Cp0 = 0

        do
           if (NOT .is_protein_backbone_N(N,Cp0,Ca,Cb,Cp,N1,Ot,Ct,N_terminal,try=TRUE)) exit
           if      (Ot/=0) then
              backbone(i).element.append([Ca,Cp,Ot])
              exit
           else if (Ct/=0) then
              backbone(i).element.append([Ca,Cp,Ct])
              exit
           else
              backbone(i).element.append([Ca,Cp,N1])
              N = N1
              Cp0 = Cp
           end
        end

        stdout.show("Backbone for protein strand =",i)
        stdout.put(backbone(i)[:])

      end

      terminal.destroy

   end

!   find_protein_backbone_from_N(N,C,found,Ca,Cc,N1,Ot)
!   ! Given the index "N" of a nitrogen atom and possibly the index "C"
!   ! of a connected carbon atom, return "found" as TRUE if that
!   ! nitrogen atom is part of a protein backbone. Also return the
!   ! index "Ca" of the C-alpha carbon, the index "Cc" of the C-carboxy
!   ! carbon, and either "N1" the next nitrogen in the backbone, or
!   ! "Ot" the terminal oxygen in the backbone. This assumes a
!   ! connection table has been made.
!     N,C :: INT, IN
!     found :: BIN, OUT
!     Ca,Cc,N1,Ot :: INT, OUT
!
!   ENSURE(connections_for.allocated,"no connection table")
!   ENSURE(connections_for.dim==.dim,"wrong size connection table")
!   ENSURE(N>0 AND N<=.dim,"N index out of range")
!   ENSURE(self(N).atomic_number==7,"N is not the index of a nitrogen atom")
!   ENSURE(C>=0 AND C<=.dim,"C index out of range")
!
!     nn,na,ia,nc,ic,O2,X :: INT
!
!     ! Set defaults
!     found = FALSE
!     Ca = 0; Cc = 0; N1 = 0; Ot = 0
!
!     ! Check if C is bonded to N
!     if (C>0) then
!        DIE_IF(NOT self(N).is_bonded_to(self(C)),"N is not bonded to C")
!     end
!
!     ! # of connections for N
!     nn = connections_for(N).element.dim
!
!     ! A backbone N must have 1 connection and can't have
!     ! more than 2 connections
!     if (nn<=0) return
!     if (nn >2) return
!
!     ! Get the index of C-alpha atom
!     Ca = connections_for(N)[1]
!     if (Ca==C) then
!        DIE_IF(nn<2,"not enough connections to N = "//trim(N.to_str))
!        Ca = connections_for(N)[2]
!     end
!
!     ! C-alpha must be a carbon
!     if (self(Ca).atomic_number/=6) return
!
!     ! # of  connections for C-alpha
!     na = connections_for(Ca).element.dim
!
!     ! C-alpha must have 2 connections (GLY) or 3 connections
!     if (na/=3 AND na/=2) return
!
!     ! Now find C-carboxy carbon
!     do ia = 1,na
!        Cc = connections_for(Ca)[ia]          ! Index of C-carboxy
!        if (Cc==N) cycle                      ! Cc can't be the first N
!        if (self(Cc).atomic_number/=6) cycle  ! Cc must be a carbon
!        nc = connections_for(Cc).element.dim
!        if (nc/=3) cycle                      ! C-carboxy must have 3 connections
!        O2 = 0                                ! It must have a =O
!        N1 = 0                                ! It must have a -N, or
!        Ot = 0                                ! It must have a terminal -OH
!        do ic = 1,nc
!           X = connections_for(Cc)[ic]
!           if (X==Ca) cycle
!           if (self(X).atomic_number==7) N1 = X
!           if (self(X).atomic_number==8) then
!              if (Ot==0) then; O2 = X
!              else;            Ot = X
!              end
!           end
!        end
!        found = O2/=0 AND (N1/=0 OR Ot/=0)
!        if (found) exit
!     end
!   end


   is_protein_backbone_N(N,Cp0,Ca,Cb,Cp,N1,Ot,Ct,N_terminal,try) result (res)
   ! Return TRUE if "N" is the index of a nitrogen atom in the
   ! backbone of a protein, Cp0-N-Ca-Cp-(N1,Ot,Ct), given also
   ! (possibly) the index "Cp0" of a connected C prime carbon atom.
   ! Return the index "Ca" of the C-alpha carbon, the index of the
   ! beta carbon "Cb" (if it exists), the index "Cp" of the next C
   ! prime carboxy carbon, and either "N1" the next nitrogen in the
   ! backbone, or "Ot" the terminal oxygen in the backbone. If "N" is
   ! an N-terminal atom, return "N_terminal" as TRUE. This assumes a
   ! connection table has been made.
      self :: IN
      N,Cp0 :: INT, IN
      Ca,Cb,Cp,N1,Ot,Ct :: INT, OUT
      N_terminal :: BIN, OUT
      try :: BIN, optional, IN
      res :: BIN

   ENSURE(connections_for.allocated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(N>0 AND N<=.dim,"N index out of range")
   ENSURE(self(N).atomic_number==7,"N is not the index of a nitrogen atom")
   ENSURE(Cp0>=0 AND Cp0<=.dim,"Cp0 index out of range")

      C1,C2,C3,O1, O11,Ca1,N11 :: INT

      res = FALSE
      N_terminal = FALSE

      if (.has_1_connection(N,6,Ca)) then

         ! One connection to N: Terminal N-Ca connection
         res = .is_protein_C_alpha(Ca,N,Cb,Cp,O1,N1,Ot,Ct)
         N_terminal = TRUE

      else if (.has_2_connections(N,6,6,C1,C2)) then

         ! Two connections to N: Backbone or terminal PRO C1-N-C2 connection
         Ca = 0
         if      (C1==Cp0) then; Ca = C2
         else if (C2==Cp0) then; Ca = C1
         end
        
         ! We found Cp0, so we know Ca
         if (Ca/=0) then
            res = .is_protein_C_alpha(Ca,N,Cb,Cp,O1,N1,Ot,Ct)
        
         ! Find which of C1 and C2 is Ca. If requested, determine which
         ! of C1 and C2 is NOT a Cp, which implies N_terminal. Also
         ! check for a terminal proline.
         else
            if      (.is_protein_C_alpha(C1,N,Cb,Cp,O1,N1,Ot,Ct)) then
               res = TRUE
               Ca = C1
               if (.has_ring(N,C2,[6,6,6])) N_terminal = TRUE
               if (NOT N_terminal AND present(try)) &
                  N_terminal = NOT .is_protein_C_prime_carbon(C2,N,O11,Ca1,N11)
            else if (.is_protein_C_alpha(C2,N,Cb,Cp,O1,N1,Ot,Ct)) then
               res = TRUE
               Ca = C2
               if (.has_ring(N,C1,[6,6,6])) N_terminal = TRUE
               if (NOT N_terminal AND present(try)) &
                  N_terminal = NOT .is_protein_C_prime_carbon(C1,N,O11,Ca1,N11)
            end
        
         end

      else if (.has_3_connections(N,6,6,6,C1,C2,C3)) then

         ! Three connections to N: Backbone PRO N-C1C2C3 connection
         ! NOTE: this only works if Cp0 is given
         if      (C1==Cp0) then; C1 = C2; C2 = C3; C3 = 0
         else if (C2==Cp0) then; C2 = C3; C3 = 0
         else if (C3==Cp0) then; C3 = 0
         end
         if (C3==0) then
            if      (.is_protein_C_alpha(C1,N,Cb,Cp,O1,N1,Ot,Ct)) then
               if (.has_ring(N,C2,[6,6,6])) then
                  Ca = C1
                  res = TRUE
               end
            else if (.is_protein_C_alpha(C2,N,Cb,Cp,O1,N1,Ot,Ct)) then
               if (.has_ring(N,C1,[6,6,6])) then
                  Ca = C2
                  res = TRUE
               end
            end
         end

      end

   end

   is_protein_C_alpha(Ca,N,Cb,Cp,O1,N1,Ot,Ct) result (res)
   ! Return TRUE if "Ca" is the index of a C-alpha atom in the
   ! backbone of a protein. You must supply the connected nitrogen
   ! atom "N". Returned are the index of the beta carbon "Cb", the
   ! index of the next C prime carboxy carbon "Cp", the connected
   ! oxygen atom "O1", and either the next nitrogen in the
   ! backbone "N1", or "Ot" the terminal oxygen in the backbone.
   ! NOTE: this is useful for travelling from N terminal to C terminal
   ! Diagram: N-CaCb-Cp=O1-(N1,Ot,Ct)
      self :: IN
      Ca,N :: INT, IN
      Cb,Cp,O1,N1,Ot,Ct :: INT, OUT
      res :: BIN

   ENSURE(connections_for.allocated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(N>0 AND N<=.dim,"N index out of range")
   ENSURE(Ca>=0 AND Ca<=.dim,"Ca index out of range")

      C1,C2,C3 :: INT

      res = FALSE

      ! GLY N-Ca-Cp connection
      if (.has_2_connections(Ca,N,6,Cp)) then
        if      (.is_CCOO_carbon(Cp,Ca,Ot,O1)) then ! two terminal oxygens
           N1 = 0
           Ct = 0
           Cb = 0
           res = TRUE
        else if (.is_CCON_carbon(Cp,Ca,O1,N1)) then ! Cp has =O and next nitrogen
           Ot = 0
           Ct = 0
           Cb = 0
           res = TRUE
        else if (.is_CCOC_carbon(Cp,Ca,O1,Ct)) then ! terminal methyl
           N1 = 0
           Ot = 0
           Cb = 0
           res = TRUE
        else if (.has_2_connections(Cp,Ca,7,N1)) then ! Cp has no oxygen
           Ot = 0
           Ct = 0
           Cb = 0
           res = TRUE
        end

      ! Any other residue, which of C1 and C2 is Cp?
      else if (.has_3_connections(Ca,N,6,6,C1,C2)) then
        if      (.is_CCOO_carbon(C1,Ca,Ot,O1)) then ! two terminal oxygens
           Cp = C1
           Cb = C2
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C1,Ca,O1,N1)) then ! Cp=C1 has =O and next nitrogen
           Cp = C1
           Cb = C2
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C1,Ca,O1,Ct)) then ! terminal methyl
           Cp = C1
           Cb = C2
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.is_CCOO_carbon(C2,Ca,Ot,O1)) then
           Cp = C2
           Cb = C1
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C2,Ca,O1,N1)) then
           Cp = C2
           Cb = C1
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C2,Ca,O1,Ct)) then ! terminal methyl
           Cp = C2
           Cb = C1
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.has_2_connections(C1,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C1
           Cb = C2
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.has_2_connections(C2,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C2
           Cb = C1
           Ot = 0
           Ct = 0
           res = TRUE
        end

      ! For non-standard branched residues, which of C1, C2, C3 is Cp?
      else if (.has_4_connections(Ca,N,6,C1,C2,C3)) then
        if      (.is_CCOO_carbon(C1,Ca,Ot,O1)) then
           Cp = C1
           Cb = 0
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C1,Ca,O1,N1)) then
           Cp = C1
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C1,Ca,O1,Ct)) then ! terminal methyl
           Cp = C1
           Cb = 0
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.is_CCOO_carbon(C2,Ca,Ot,O1)) then
           Cp = C2
           Cb = 0
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C2,Ca,O1,N1)) then
           Cp = C2
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C2,Ca,O1,Ct)) then ! terminal methyl
           Cp = C2
           Cb = 0
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.is_CCOO_carbon(C3,Ca,Ot,O1)) then
           Cp = C3
           Cb = 0
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C3,Ca,O1,N1)) then
           Cp = C3
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C3,Ca,O1,Ct)) then ! terminal methyl
           Cp = C3
           Cb = 0
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.has_2_connections(C1,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C1
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.has_2_connections(C2,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C2
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.has_2_connections(C3,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C3
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        end
      end
   end

   is_protein_C_prime_carbon(Cp,N,O,Ca,N1) result (res)
   ! Return TRUE if "Cp" is the index of a N-Cp-Ca-N1 carbon, where
   ! "N" is the index of a nitrogen bonded to "Cp". If TRUE, "O",
   ! "Ca" and "N1" are returned as the index of the bonded oxygen,
   ! alpha Carbon and previous nitrogen respectively.
      self :: IN
      Cp,N :: INT, IN
      O,Ca,N1 :: INT, OUT
      res :: BIN

   ENSURE(connections_for.allocated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"Cp index out of range")
   ENSURE( N>=0 AND  N<=.dim," N index out of range")

      Cb,Cb1,s,x,i :: INT
      list :: VEC{INT}@

      x = 6
      s = 7
      O  = 0
      Ca = 0
      N1 = 0
      res = FALSE

      if (.has_3_connections(Cp,N,8,6,O,Ca)) then      ! Cp=ON connection

        res = VEC{ATOM}:has_1_connection(O,Cp) AND &
            ( .has_2_connections(Ca,Cp,7,N1) &
           OR .has_3_connections(Ca,Cp,7,6,N1,Cb) &
           OR .has_4_connections(Ca,Cp,s,x,x,N1,Cb,Cb1) )

      else if (::has_a_connection(Cp,N)) then           ! Cp has no O connection

       if (.has_Z_connections(Cp,6,list)) then
          do i = 1,list.dim
             Ca = list(i)
             res = .has_2_connections(Ca,Cp,7,N1) &
              OR   .has_3_connections(Ca,Cp,7,6,N1,Cb) &
              OR   .has_4_connections(Ca,Cp,s,x,x,N1,Cb,Cb1)
              if (res) exit
          end
          list.destroy
       end

      end

   end

   is_NCOC_carbon(Cp,N,O,Ca,N1) result (res)
   ! Return TRUE if "Cp" is the index of a N-Cp=O-Ca-N1 carbon, where
   ! "N" is the index of a nitrogen bonded to "Cp". If TRUE, "O",
   ! "Ca" and "N1" are returned as the index of the bonded oxygen,
   ! alpha Carbon and next nitrogen respectively.
      self :: IN
      Cp,N :: INT, IN
      O,Ca,N1 :: INT, OUT
      res :: BIN

   ENSURE(connections_for.allocated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"Cp index out of range")
   ENSURE( N>=0 AND  N<=.dim," N index out of range")

      Cb,Cb1,s,x :: INT

      x = 6
      s = 7
      N1 = 0

      if (.has_3_connections(Cp,N,8,6,O,Ca)) then      ! Cp=ON connection

        res = VEC{ATOM}:has_1_connection(O,Cp) AND &
            ( .has_2_connections(Ca,Cp,7,N1) &
           OR .has_3_connections(Ca,Cp,7,6,N1,Cb) &
           OR .has_4_connections(Ca,Cp,s,x,x,N1,Cb,Cb1) )

      else

        res = FALSE

      end

   end

   is_CCOO_carbon(Cp,Ca,O1,O2) result (res)
   ! Return TRUE if "Cp" is the index of a Ca-Cp=OO carbon, where "Ca"
   ! is the index of an (alpha) carbon bonded to "Cp". If TRUE, "O1" and
   ! "O2" are returned as the indices of the bonded oxygens.
      self :: IN
      Cp,Ca :: INT, IN
      O1,O2 :: INT, OUT
      res :: BIN

   ENSURE(connections_for.allocated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"Cp index out of range")
   ENSURE(Ca>=0 AND Ca<=.dim,"Ca index out of range")

      if (.has_3_connections(Cp,Ca,8,8,O1,O2)) then      ! Cp=O1O2 connection
         res = VEC{ATOM}:has_1_connection(O1,Cp) 
         res = VEC{ATOM}:has_1_connection(O2,Cp) AND res
      else
         res = FALSE
      end

   end

   is_CCOC_carbon(Cp,Ca,O1,C) result (res)
   ! Return TRUE if "Cp" is the index of a Ca-Cp=OC carbon, where "Ca"
   ! is the index of an (alpha) carbon bonded to "Cp". If TRUE, "O1" and
   ! "C" are returned as the indices of the bonded oxygen and terminal
   ! methyl.
      self :: IN
      Cp,Ca :: INT, IN
      O1,C :: INT, OUT
      res :: BIN

   ENSURE(connections_for.allocated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"Cp index out of range")
   ENSURE(Ca>=0 AND Ca<=.dim,"Ca index out of range")

      if (.has_3_connections(Cp,Ca,8,6,O1,C)) then      ! Cp=O1C connection
         res = VEC{ATOM}:has_1_connection(O1,Cp) 
         res = VEC{ATOM}:has_1_connection(C,Cp) AND res
      else
         res = FALSE
      end

   end

   is_CCON_carbon(Cp,Ca,O1,N1) result (res)
   ! Return TRUE if "Cp" is the index of a Ca-Cp=ON carbon, where "Ca"
   ! is the index of an (alpha) carbon bonded to "Cp". If TRUE, "O1" and
   ! "N1" are returned as the indices of the bonded oxygen and
   ! nitrogen atom.
      self :: IN
      Cp,Ca :: INT, IN
      O1,N1 :: INT, OUT
      res :: BIN

   ENSURE(connections_for.allocated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"C index out of range")

      res = .has_3_connections(Cp,Ca,8,7,O1,N1)

   end

!  =================
!  Connection tables
!  =================

   has_connection_table result (res) ::: selfless, pure
   ! Returns TRUE if the connection table connections_for is made.
      self :: IN
      res :: BIN
      res = connections_for.allocated
   end

   make_connection_table(skip_hydrogen,skip_self) ::: leaky
   ! Make the atom connection table "connections_for".  If
   ! "skip_hydrogen" is present and TRUE, connections are not made to
   ! any hydrogen atom.
      self :: IN
      skip_hydrogen :: BIN, optional, IN
      skip_self     :: BIN, optional, IN

      r :: REAL

      if (connections_for.allocated) return

      r = 0.5d0
      r.convert_from("angstrom")
      ATOM:set_atom_bonded_range_factor(r)
      .make_connection_table(connections_for,skip_hydrogen,skip_self) ! NOT PURE

   end

   make_connection_table(connections_for,skip_hydrogen,skip_self) ::: leaky, PURE
   ! Make the atom connection table "connections_for".  If
   ! "skip_hydrogen" is present and TRUE, connections are not made to
   ! any hydrogen atom.
      self :: IN
      connections_for :: VEC{EVEC{INT}}@, OUT
      skip_hydrogen :: BIN, optional, IN
      skip_self     :: BIN, optional, IN

      i,j,k :: INT
      skip_H,skip_s :: BIN

      ! Skip H's?
      skip_H = FALSE
      if (present(skip_hydrogen)) skip_H = skip_hydrogen

      ! Skip atom itself in the connections?
      skip_s = TRUE
      if (present(skip_self)) skip_s = skip_self

      ! Create connection table
      connections_for.create(.dim,0)

      ! Loop all atoms "i"
      do i = 1,.dim

        ! Skip H's?
        if (skip_H) then
           if (self(i).atomic_number==1) cycle
        end

        ! If skipping atom "i" look at next atom
        if (skip_s) then; k = i + 1
        else;             k = i
        end

        ! Loop possible connected atoms "k"
        do j = k,.dim

           ! Skip H's?
           if (skip_H) then
              if (self(j).atomic_number==1) cycle
           end

           ! Add connected atom?
           if (self(i).is_bonded_to(self(j)) OR j==i) then
              connections_for(i).element.append(j)
              connections_for(j).element.append(i)
           end

        end

      end

   end

   assign_connection_table(connections) ::: leaky, selfless
   ! Assign the atom connection connection_table to "connections".
      connections :: VEC{EVEC{INT}}@, IN

   ENSURE(connections.allocated,"no connection table")

      connections_for = connections ! NOT PURE

   end

   destroy_connection_table ::: leaky, selfless
   ! Clean the "connection_for" atom connection table

      connections_for.destroy ! NOT PURE

   end


!   has_group_connection_table result (res) ::: selfless, pure
!   ! Returns TRUE if the connection table connections_for is made.
!      self :: IN
!      res :: BIN
!
!      res = group_connections_for.allocated
!
!   end
!
!   make_group_connection_table ::: leaky
!   ! Make the atom group connection table "connections_for". 
!      self :: IN
!
!      r :: REAL
!
!      if (group_connections_for.allocated) return
!
!      r = 0.5d0
!      r.convert_from("angstrom")
!      ATOM:set_atom_bonded_range_factor(r)
!      .make_group_connection_table(group_connections_for)
!
!   end
!
!   make_group_connection_table(connections_for,skip_self) ::: leaky, PURE
!   ! Make the atom group connection table "connections_for".
!      self :: IN
!      connections_for :: VEC{EVEC{INT}}@
!      skip_self     :: BIN, optional, IN
!
!      n_group, i,j,k :: INT
!      skip_s :: BIN
!
!      ! Skip atom itself in the connections?
!      skip_s = TRUE
!      if (present(skip_self)) skip_s = skip_self
!
!      ! No. of groups
!      n_group =  .no_of_groups
!
!      ! Create connection table
!      connections_for.create(n_group,0)
!
!      ! Loop all groups "i"
!      do i = 1,n_group
!
!        ! If skipping atom "i" look at next atom
!        if (skip_s) then; k = i + 1
!        else;             k = i
!        end
!
!        ! Loop possible connected atoms "k"
!        do j = k,n_group
!
!           ! Add connected atom?
!           if (.bonded_groups(i,j) OR j==i) then
!              connections_for(i).element.append(j)
!              connections_for(j).element.append(i)
!           end
!
!        end
!
!      end
!
!   end
!
!   assign_group_connection_table(connections) ::: selfless
!   ! Assign the group connection table "group_connections_for" to
!   ! "connections".
!      connections :: VEC{EVEC{INT}}@
!
!   ENSURE(connections.allocated,"no connection table")
!
!      group_connections_for => connections
!
!   end
!
!   destroy_group_connection_table ::: leaky, selfless
!   ! Clean the "group_connections_for" connection table
!
!   ENSURE(group_connections_for.allocated,"no connection table")
!
!      group_connections_for.destroy
!
!   end

!  =====================
!  Atom connection tests
!  =====================

! Connections to any atom?

   has_a_connection(X,W) result (res) ::: selfless, pure
   ! Returns TRUE if the atom with index "X" is connected to the atom
   ! with index "W".
      X,W :: INT, IN
      res :: BIN
      res = any(connections_for(X)[:]==W)
   end

! Connections to an atom with atomic number "Z"

   has_Z_connection(X,Z) result (res) ::: pure
   ! Returns TRUE if the atom with index "X" is connected to an atom
   ! with atomic number "Z".
      self :: IN
      X,Z :: INT, IN
      res :: BIN
      res = any(self(connections_for(X)[:]).atomic_number==Z)
   end

   has_Z_connections(X,Z,list) result (res)
   ! Return "TRUE" if atom "X" has connections to atoms with atomic
   ! number "Z", and if so, return a "list" of the atom indices.
      self :: IN
      X,Z :: INT, IN
      list :: VEC{INT}@
      res :: BIN

      nx,i,Y :: INT

      res = FALSE
      nx = connections_for(X).element.dim

      if (nx==0) return

      list.create(0)
      res = FALSE
      do i = 1,nx
        Y = connections_for(X)[i]            ! Index of atom connected to X
        if (self(Y).atomic_number/=Z) cycle  ! Y must have atomic number Z
        list.append(Y)
        res = TRUE
      end

   end

! Zero connections

   has_0_connections(X) result (res) ::: selfless, pure
   ! Returns TRUE if the atom with index "X" no connection
      X :: INT, IN
      res :: BIN
      res = connections_for(X).element.dim == 0
   end

! One connections

   has_1_connection(X) result (res) ::: selfless, pure
   ! Returns TRUE if the atom with index "X" only has one connection
      X :: INT, IN
      res :: BIN
      res = connections_for(X).element.dim == 1
   end

   has_1_connection(X,Y) result (res) ::: selfless, pure
   ! Returns TRUE if the atom with index "X" only has one connection
   ! to an atom with index "Y".
      X,Y :: INT, IN
      res :: BIN

      res = connections_for(X).element.dim == 1
      if (NOT res) return

      res = connections_for(X)[1] == Y

   end

   has_1_connection(X,Z,Y) result (res)
   ! Returns TRUE if the atom with index "X" only has one connection
   ! to an atom with atomic number "Z". If there is a connection,
   ! return the index of the connected atom in "Y".
      self :: IN
      X,Z :: INT, IN
      Y   :: INT, OUT
      res :: BIN

      nx :: INT

      res = FALSE
      nx = connections_for(X).element.dim
      if (nx/=1) return

      Y = connections_for(X)[1]
      if (self(Y).atomic_number/=Z) then
         Y = 0
      else
         res = TRUE
      end

   end

! Two connections

   has_2_connections(X) result (res) ::: selfless, pure
   ! Returns TRUE if the atom with index "X" has two connections
      X :: INT, IN
      res :: BIN
      res = connections_for(X).element.dim == 2
   end

   has_2_connections(X,Y1,Y2) result (res) ::: selfless, pure
   ! Returns TRUE if the atom with index "X" has two connections:
   ! one to the atom with index "Y1", the other to the atom with
   ! index "Y2".
      X,Y1,Y2 :: INT, IN
      res :: BIN

      res = connections_for(X).element.dim == 2
      if (NOT res) return

      res = (connections_for(X)[1]==Y1 AND connections_for(X)[2]==Y2) &
         OR (connections_for(X)[2]==Y1 AND connections_for(X)[1]==Y2)

   end

   has_2_connections(X,W,Z,Y) result (res)
   ! Returns TRUE if the atom with index "X" has two connections:
   ! one to the atom with index "W", the other to an atom with atomic
   ! number "Z".If there is a latter connection, return the index of
   ! atom with atomic number "Z" in "Y".
      self :: IN
      X,W,Z :: INT, IN
      Y :: INT, OUT
      res :: BIN

      nx,Y1,Y2 :: INT

      Y = 0
      res = FALSE
      nx = connections_for(X).element.dim
      if (nx/=2) return

      Y1 = connections_for(X)[1]
      Y2 = connections_for(X)[2]

      if (Y1==W AND self(Y2).atomic_number==Z) then
         Y = Y2
         res = TRUE
      else if (Y2==W AND self(Y1).atomic_number==Z) then
         Y = Y1
         res = TRUE
      end

   end

   has_2_connections(X,Z1,Z2,Y1,Y2) result (res)
   ! Returns TRUE if the atom with index "X" has two connections: one
   ! to an atom with atomic number "Z1", the other to an atom with
   ! atomic number "Z2". If there are connectons, return the indices
   ! of these atoms as "Y1" and "Y2" respectively.
      self :: IN
      X,Z1,Z2 :: INT, IN
      Y1,Y2 :: INT, OUT
      res :: BIN

      A1,A2 :: INT

      Y1 = 0
      Y2 = 0
      res = FALSE
      if (connections_for(X).element.dim/=2) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]

      if(self(A1).atomic_number==Z1 AND self(A2).atomic_number==Z2) then
         Y1 = A1
         Y2 = A2
         res = TRUE
      else if (self(A2).atomic_number==Z1 AND self(A1).atomic_number==Z2) then
         Y1 = A2
         Y2 = A1
         res = TRUE
      end

   end

! Three connections

   has_3_connections(X) result (res) ::: selfless, pure
   ! Returns TRUE if the atom with index "X" has three connections
      X :: INT, IN
      res :: BIN
      res = connections_for(X).element.dim==3
   end

   has_3_connections(X,V,W,Z,Y) result (res)
   ! Returns TRUE if the atom with index "X" has three connections:
   ! two to atoms "V" and "W", and one to an atom with atomic
   ! numbers "Z".If there is this latter connection, return the
   ! index of this atom in "Y".
      self :: IN
      X,V,W,Z :: INT, IN
      Y :: INT, OUT
      res :: BIN

      A1,A2,A3,N1,N2,N3 :: INT

      Y = 0
      res = FALSE

      if (connections_for(X).element.dim/=3) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]
      A3 = connections_for(X)[3]

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number

      if      (A1==V AND A2==W  AND Z==N1) then; Y=A1; res = TRUE
      else if (A1==W AND A2==V  AND Z==N1) then; Y=A1; res = TRUE
      else if (A1==V AND A2==W  AND Z==N2) then; Y=A2; res = TRUE
      else if (A1==W AND A2==V  AND Z==N2) then; Y=A2; res = TRUE
      else if (A1==V AND A2==W  AND Z==N3) then; Y=A3; res = TRUE
      else if (A1==W AND A2==V  AND Z==N3) then; Y=A3; res = TRUE
      end

   end

   has_3_connections(X,W,Z1,Z2,Y1,Y2) result (res)
   ! Returns TRUE if the atom with index "X" has three connections:
   ! one to the atom with index "W", the other two to atoms with atomic
   ! numbers "Z1" and "Z2".If there are these latter connections,
   ! return the indices of atoms with atomic numbers "Z1" and "Z2"
   ! in "Y1" and "Y2".
      self :: IN
      X,W,Z1,Z2 :: INT, IN
      Y1,Y2 :: INT, OUT
      res :: BIN

      A1,A2,A3,N1,N2,N3 :: INT

      Y1 = 0
      Y2 = 0
      res = FALSE

      if (connections_for(X).element.dim/=3) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]
      A3 = connections_for(X)[3]

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number

      if      (A1==W AND Z1==N2 AND Z2==N3) then; Y1=A2; Y2=A3; res = TRUE
      else if (A1==W AND Z1==N3 AND Z2==N2) then; Y1=A3; Y2=A2; res = TRUE
      else if (A2==W AND Z1==N1 AND Z2==N3) then; Y1=A1; Y2=A3; res = TRUE
      else if (A2==W AND Z1==N3 AND Z2==N1) then; Y1=A3; Y2=A1; res = TRUE
      else if (A3==W AND Z1==N1 AND Z2==N2) then; Y1=A1; Y2=A2; res = TRUE
      else if (A3==W AND Z1==N2 AND Z2==N1) then; Y1=A2; Y2=A1; res = TRUE
      end

   end

   has_3_connections(X,Z1,Z2,Z3,Y1,Y2,Y3) result (res)
   ! Returns TRUE if the atom with index "X" has three connections:
   ! to atoms with atomic numbers "Z1", "Z2" and "Z3" with the atom
   ! indices returned in "Y1", "Y2" and "Y3".
      self :: IN
      X,Z1,Z2,Z3 :: INT, IN
      Y1,Y2,Y3 :: INT, OUT
      res :: BIN

      A1,A2,A3,N1,N2,N3 :: INT

      Y1 = 0
      Y2 = 0
      Y3 = 0
      res = FALSE

      if (connections_for(X).element.dim/=3) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]
      A3 = connections_for(X)[3]

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number

      if      (Z1==N1 AND Z2==N2 AND Z3==N3) then; Y1=A1; Y2=A2; Y3=A3; res = TRUE
      else if (Z1==N1 AND Z2==N3 AND Z3==N2) then; Y1=A1; Y2=A3; Y3=A2; res = TRUE
      else if (Z1==N2 AND Z2==N1 AND Z3==N3) then; Y1=A2; Y2=A1; Y3=A3; res = TRUE
      else if (Z1==N2 AND Z2==N3 AND Z3==N1) then; Y1=A2; Y2=A3; Y3=A1; res = TRUE
      else if (Z1==N3 AND Z2==N1 AND Z3==N2) then; Y1=A3; Y2=A1; Y3=A2; res = TRUE
      else if (Z1==N3 AND Z2==N2 AND Z3==N1) then; Y1=A3; Y2=A2; Y3=A1; res = TRUE
      end

   end

! Four connections

   has_4_connections(X) result (res) ::: selfless, pure
   ! Returns TRUE if the atom with index "X" has four connections
      X :: INT, IN
      res :: BIN
      res = connections_for(X).element.dim==4
   end

   has_4_connections(X,W,Z1,Z2,Z3,Y1,Y2,Y3) result (res)
   ! Returns TRUE if the atom with index "X" has four connections: one
   ! to the atom with index "W", the other three to atoms with atomic
   ! numbers "Z1", "Z2" and "Z3".If there are these latter
   ! connections, return the indices of atoms with thse atomic numbers
   ! in "Y1", "Y2" and "Y3" respectively.
      self :: IN
      X,W,Z1,Z2,Z3 :: INT, IN
      Y1,Y2,Y3 :: INT, OUT
      res :: BIN

      A1,A2,A3,A4,N1,N2,N3,N4 :: INT

      Y1 = 0
      Y2 = 0
      Y3 = 0
      res = FALSE

      if (connections_for(X).element.dim/=4) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]
      A3 = connections_for(X)[3]
      A4 = connections_for(X)[4]

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number
      N4 = self(A4).atomic_number

      if      (A1==W AND Z1==N2 AND Z2==N3 AND Z3==N4) then; Y1=A2; Y2=A3; Y3=A4; res = TRUE
      else if (A1==W AND Z1==N2 AND Z2==N4 AND Z3==N3) then; Y1=A2; Y2=A4; Y3=A3; res = TRUE
      else if (A1==W AND Z1==N3 AND Z2==N2 AND Z3==N4) then; Y1=A3; Y2=A2; Y3=A4; res = TRUE
      else if (A1==W AND Z1==N3 AND Z2==N4 AND Z3==N2) then; Y1=A3; Y2=A4; Y3=A2; res = TRUE
      else if (A1==W AND Z1==N4 AND Z2==N2 AND Z3==N3) then; Y1=A4; Y2=A2; Y3=A3; res = TRUE
      else if (A1==W AND Z1==N4 AND Z2==N3 AND Z3==N2) then; Y1=A4; Y2=A3; Y3=A2; res = TRUE
      else if (A2==W AND Z1==N1 AND Z2==N3 AND Z3==N4) then; Y1=A1; Y2=A3; Y3=A4; res = TRUE
      else if (A2==W AND Z1==N1 AND Z2==N4 AND Z3==N3) then; Y1=A1; Y2=A4; Y3=A3; res = TRUE
      else if (A2==W AND Z1==N3 AND Z2==N1 AND Z3==N4) then; Y1=A3; Y2=A1; Y3=A4; res = TRUE
      else if (A2==W AND Z1==N3 AND Z2==N4 AND Z3==N1) then; Y1=A3; Y2=A4; Y3=A1; res = TRUE
      else if (A2==W AND Z1==N4 AND Z2==N1 AND Z3==N3) then; Y1=A4; Y2=A1; Y3=A3; res = TRUE
      else if (A2==W AND Z1==N4 AND Z2==N3 AND Z3==N1) then; Y1=A4; Y2=A3; Y3=A1; res = TRUE
      else if (A3==W AND Z1==N2 AND Z2==N1 AND Z3==N4) then; Y1=A2; Y2=A1; Y3=A4; res = TRUE
      else if (A3==W AND Z1==N2 AND Z2==N4 AND Z3==N1) then; Y1=A2; Y2=A4; Y3=A1; res = TRUE
      else if (A3==W AND Z1==N1 AND Z2==N2 AND Z3==N4) then; Y1=A1; Y2=A2; Y3=A4; res = TRUE
      else if (A3==W AND Z1==N1 AND Z2==N4 AND Z3==N2) then; Y1=A1; Y2=A4; Y3=A2; res = TRUE
      else if (A3==W AND Z1==N4 AND Z2==N2 AND Z3==N1) then; Y1=A4; Y2=A2; Y3=A1; res = TRUE
      else if (A3==W AND Z1==N4 AND Z2==N1 AND Z3==N2) then; Y1=A4; Y2=A1; Y3=A2; res = TRUE
      else if (A4==W AND Z1==N2 AND Z2==N3 AND Z3==N1) then; Y1=A2; Y2=A3; Y3=A1; res = TRUE
      else if (A4==W AND Z1==N2 AND Z2==N1 AND Z3==N3) then; Y1=A2; Y2=A1; Y3=A3; res = TRUE
      else if (A4==W AND Z1==N3 AND Z2==N2 AND Z3==N1) then; Y1=A3; Y2=A2; Y3=A1; res = TRUE
      else if (A4==W AND Z1==N3 AND Z2==N1 AND Z3==N2) then; Y1=A3; Y2=A1; Y3=A2; res = TRUE
      else if (A4==W AND Z1==N1 AND Z2==N2 AND Z3==N3) then; Y1=A1; Y2=A2; Y3=A3; res = TRUE
      else if (A4==W AND Z1==N1 AND Z2==N3 AND Z3==N2) then; Y1=A1; Y2=A3; Y3=A2; res = TRUE
      end

   end

   has_4_connections(X,W,Z,Y1,Y2,Y3) result (res)
   ! Returns TRUE if the atom with index "X" has four connections: one
   ! to the atom with index "W", the other three to atoms with atomic
   ! number "Z".If there are these latter connections, return the
   ! indices of atoms with this atomic number in "Y1", "Y2" and "Y3"
   ! respectively.
      self :: IN
      X,W,Z :: INT, IN
      Y1,Y2,Y3 :: INT, OUT
      res :: BIN

      A1,A2,A3,A4,N1,N2,N3,N4 :: INT

      Y1 = 0
      Y2 = 0
      Y3 = 0
      res = FALSE

      if (connections_for(X).element.dim/=4) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]
      A3 = connections_for(X)[3]
      A4 = connections_for(X)[4]

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number
      N4 = self(A4).atomic_number

      if      (A1==W AND Z==N2 AND Z==N3 AND Z==N4) then; Y1=A2; Y2=A3; Y3=A4; res = TRUE
      else if (A2==W AND Z==N1 AND Z==N3 AND Z==N4) then; Y1=A1; Y2=A3; Y3=A4; res = TRUE
      else if (A3==W AND Z==N2 AND Z==N1 AND Z==N4) then; Y1=A2; Y2=A1; Y3=A4; res = TRUE
      else if (A4==W AND Z==N2 AND Z==N3 AND Z==N1) then; Y1=A2; Y2=A3; Y3=A1; res = TRUE
      end

   end

! Rings & chains

   has_ring(A,B,Z,R) result (res)
   ! Return TRUE if the atoms with indices "A" and "B" form part of a
   ! single connection ring of atoms whose atomic numbers after atom
   ! "B" are given in "Z". NOTE: "A" need not be single connected.
      self :: IN
      A,B :: INT, IN
      Z :: VEC{INT}, IN
      R :: VEC{INT}, optional, OUT
      res :: BIN

      i,W,X,Y :: INT

      W = A
      X = B

      do i = 1,Z.dim

         res = .has_2_connections(X,W,Z(i),Y)
         if (NOT res) return
         
         if (present(R)) R(i) = Y
         
         W = X
         X = Y

      end

      res = VEC{ATOM}:has_a_connection(X,A)

   end

   has_chain(A,B,Z,C) result (res)
   ! Return TRUE if the atoms with indices "A" and "B" form part of a
   ! single connection chain of atoms whose atomic numbers after atom
   ! "B" are given in "Z".
      self :: IN
      A,B :: INT, IN
      Z :: VEC{INT}, IN
      C :: VEC{INT}, optional, OUT
      res :: BIN

      i,W,X,Y :: INT

      res = FALSE

      W = A
      X = B

      do i = 1,Z.dim

         res = .has_2_connections(X,W,Z(i),Y)
         if (NOT res) return

         if (present(C)) C(i) = Y

         W = X
         X = Y

      end

   end

!  ====================
!  Amino acid detectors
!  ====================

   put_protein_sequence ::: leaky
   ! Return the "backbone" of atom indices in each protein backbone.
      self :: IN

      backbone :: VEC{EVEC{INT}}@
      terminal :: VEC{INT}@
      N_terminal :: BIN
      i, N,Cp0,Ca,Cb,Cp,N1,Ot,Ct :: INT

      .find_and_put_N_terminal_atoms(terminal)

      backbone.create(terminal.dim,1)

      do i = 1,terminal.dim

        N = terminal(i)
        backbone(i)[1] = N
        Cp0 = 0

        stdout.show("Sequence for protein strand =",i)

        do

           if (NOT .is_protein_backbone_N(N,Cp0,Ca,Cb,Cp,N1,Ot,Ct,N_terminal,try=TRUE)) exit

           if      (Ot/=0) then
              backbone(i).element.append([Ca,Cp,Ot])
              exit
           else if (Ct/=0) then
              backbone(i).element.append([Ca,Cp,Ct])
              exit
           else
              backbone(i).element.append([Ca,Cp,N1])
              N = N1
              Cp0 = Cp
           end

           if (Cb==0) then; stdout.text("GLY")
           else;            stdout.text(.protein_side_chain_3_code(Ca,Cb))
           end

        end

      end

      terminal.destroy
      backbone.destroy
      connections_for.destroy

   end

!   find_protein_backbone_from_N(N,C,found,Ca,Cc,N1,Ot)
!   ! Given the index "N" of a nitrogen atom and possibly the index "C"
!   ! of a connected carbon atom, return "found" as TRUE if that
!   ! nitrogen atom is part of a protein backbone. Also return the
!   ! index "Ca" of the C-alpha carbon, the index "Cc" of the C-carboxy
!   ! carbon, and either "N1" the next nitrogen in the backbone, or
!   ! "Ot" the terminal oxygen in the backbone. This assumes a
!   ! connection table has been made.
!     N,C :: INT, IN
!     found :: BIN, OUT
!     Ca,Cc,N1,Ot :: INT, OUT
!
!   ENSURE(connections_for.allocated,"no connection table")
!   ENSURE(connections_for.dim==.dim,"wrong size connection table")
!   ENSURE(N>0 AND N<=.dim,"N index out of range")
!   ENSURE(self(N).atomic_number==7,"N is not the index of a nitrogen atom")
!   ENSURE(C>=0 AND C<=.dim,"C index out of range")
!
!     nn,na,ia,nc,ic,O2,X :: INT
!
!     ! Set defaults
!     found = FALSE
!     Ca = 0; Cc = 0; N1 = 0; Ot = 0
!
!     ! Check if C is bonded to N
!     if (C>0) then
!        DIE_IF(NOT self(N).is_bonded_to(self(C)),"N is not bonded to C")
!     end
!
!     ! # of connections for N
!     nn = connections_for(N).element.dim
!
!     ! A backbone N must have 1 connection and can't have
!     ! more than 2 connections
!     if (nn<=0) return
!     if (nn >2) return
!
!     ! Get the index of C-alpha atom
!     Ca = connections_for(N)[1]
!     if (Ca==C) then
!        DIE_IF(nn<2,"not enough connections to N = "//trim(N.to_str))
!        Ca = connections_for(N)[2]
!     end
!
!     ! C-alpha must be a carbon
!     if (self(Ca).atomic_number/=6) return
!
!     ! # of  connections for C-alpha
!     na = connections_for(Ca).element.dim
!
!     ! C-alpha must have 2 connections (GLY) or 3 connections
!     if (na/=3 AND na/=2) return
!
!     ! Now find C-carboxy carbon
!     do ia = 1,na
!        Cc = connections_for(Ca)[ia]          ! Index of C-carboxy
!        if (Cc==N) cycle                      ! Cc can't be the first N
!        if (self(Cc).atomic_number/=6) cycle  ! Cc must be a carbon
!        nc = connections_for(Cc).element.dim
!        if (nc/=3) cycle                      ! C-carboxy must have 3 connections
!        O2 = 0                                ! It must have a =O
!        N1 = 0                                ! It must have a -N, or
!        Ot = 0                                ! It must have a terminal -OH
!        do ic = 1,nc
!           X = connections_for(Cc)[ic]
!           if (X==Ca) cycle
!           if (self(X).atomic_number==7) N1 = X
!           if (self(X).atomic_number==8) then
!              if (Ot==0) then; O2 = X
!              else;            Ot = X
!              end
!           end
!        end
!        found = O2/=0 AND (N1/=0 OR Ot/=0)
!        if (found) exit
!     end
!   end

   protein_side_chain_3_code(Ca,Cb) result (res)
   ! Returns the 3 letter code for a side chain connected at carbon
   ! atoms "Ca" and "Cb".
      self :: IN
      Ca,Cb :: INT, IN
      res :: STR

   ENSURE(Ca>=0 AND Ca<=.dim,"Ca index out of range")
   ENSURE(Cb>=0 AND Cb<=.dim,"Cb index out of range")
   ENSURE(self(Ca).atomic_number==6,"must suppy index of alpha carbon atom")
   ENSURE(self(Cb).atomic_number==6,"must suppy index of beta carbon atom")

      if (VEC{ATOM}:has_ALA(Ca,Cb)) then; res = "ALA"
      else if     (.has_ARG(Ca,Cb)) then; res = "ARG"
      else if     (.has_ASN(Ca,Cb)) then; res = "ASN"
      else if     (.has_ASP(Ca,Cb)) then; res = "ASP"
      else if     (.has_CYS(Ca,Cb)) then; res = "CYS"
      else if     (.has_GLN(Ca,Cb)) then; res = "GLN"
      else if     (.has_GLU(Ca,Cb)) then; res = "GLU"
      else if     (.has_HIS(Ca,Cb)) then; res = "HIS"
      else if     (.has_ILE(Ca,Cb)) then; res = "ILE"
      else if     (.has_LEU(Ca,Cb)) then; res = "LEU"
      else if     (.has_LYS(Ca,Cb)) then; res = "LYS"
      else if     (.has_MET(Ca,Cb)) then; res = "MET"
      else if     (.has_PHE(Ca,Cb)) then; res = "PHE"
      else if     (.has_SER(Ca,Cb)) then; res = "SER"
      else if     (.has_THR(Ca,Cb)) then; res = "THR"
      else if     (.has_TRP(Ca,Cb)) then; res = "TRP"
      else if     (.has_TYR(Ca,Cb)) then; res = "TYR"
      else if     (.has_VAL(Ca,Cb)) then; res = "VAL"
      else;                               res = "UNK"
      end

   end

   has_ALA(Ca,Cb) result (res) ::: selfless, pure
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ALA
      self :: IN
      Ca,Cb :: INT, IN
      res :: BIN
      res = VEC{ATOM}:has_1_connection(Cb,Ca)
   end

   has_ARG(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ARG
      self :: IN
      Ca,Cb :: INT, IN
      res :: BIN

      C :: VEC{INT}(4)
      Nz1,Nz2 :: INT

      res = .has_chain(Ca,Cb,[6,6,7,6],C)
      if (NOT res) return

      res = .has_3_connections(C(4),C(3),7,7,Nz1,Nz2)
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Nz1,C(4))
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Nz2,C(4))

   end

   has_ASN(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ASN
      self :: IN
      Ca,Cb :: INT, IN
      res :: BIN

      Cg,Og,Ng :: INT

      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return

      res = .has_3_connections(Cg,Cb,6,7,Og,Ng)
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Og,Cg)
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Ng,Cg)

   end

   has_ASP(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ASP
      self :: IN
      Ca,Cb :: INT, IN
      res :: BIN
      
      Cg,Og1,Og2 :: INT

      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return

      res = .has_3_connections(Cg,Cb,6,7,Og1,Og2)
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Og1,Cg)
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Og2,Cg)

   end

   has_CYS(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes CYS
      self :: IN
      Ca,Cb :: INT, IN
      res :: BIN

      Sg :: INT

      res = .has_2_connections(Cb,Ca,16,Sg)
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Sg,Cb)

   end

   has_GLN(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes GLN
      self :: IN
      Ca,Cb :: INT, IN
      res :: BIN

      C :: VEC{INT}(2)
      Ne,Oe :: INT

      res = .has_chain(Ca,Cb,[6,6],C)
      if (NOT res) return

      res = .has_3_connections(C(2),C(1),8,7,Oe,Ne)
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Ne,C(2))
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Oe,C(2))

   end

   has_GLU(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes GLU
      self :: IN
      Ca,Cb :: INT, IN
      res :: BIN

      C :: VEC{INT}(2)
      Oe1,Oe2 :: INT

      res = .has_chain(Ca,Cb,[6,6],C)
      if (NOT res) return

      res = .has_3_connections(C(2),C(1),8,8,Oe1,Oe2)
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Oe1,C(2))
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Oe2,C(2))

   end

   has_HIS(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes HIS
      self :: IN
      Ca,Cb :: INT, IN
      res :: BIN

      Cg,Nd,Cd :: INT

      res = .has_2_connections(Cb,Ca,16,Cg)
      if (NOT res) return

      res = .has_3_connections(Cg,Cb,7,6,Nd,Cd)
      if (NOT res) return

      res = .has_ring(Cg,Nd,[6,7,6])

   end

   has_ILE(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ILE
      self :: IN
      Ca,Cb :: INT, IN
      res :: BIN

      Cg1,Cg2,Cd :: INT

      res = .has_3_connections(Cb,Ca,6,6,Cg1,Cg2)
      if (NOT res) return

      if (VEC{ATOM}:has_1_connection(Cg1,Cb)) then

         res = .has_2_connections(Cg2,Cb,6,Cd)
         if (NOT res) return

         res = VEC{ATOM}:has_1_connection(Cd,Cg2)

      else if (VEC{ATOM}:has_1_connection(Cg2,Cb)) then

         res = .has_2_connections(Cg1,Cb,6,Cd)
         if (NOT res) return

         res = VEC{ATOM}:has_1_connection(Cd,Cg1)

      else

         res = FALSE

      end

   end

   has_LEU(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes LEU
      self :: IN
      Ca,Cb :: INT, IN
      res :: BIN

      Cg,Cd1,Cd2 :: INT

      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return

      res = .has_3_connections(Cg,Cb,6,7,Cd1,Cd2)
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Cd1,Cg)
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Cd2,Cg)

   end

   has_LYS(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes LYS
      self :: IN
      Ca,Cb :: INT, IN
      res :: BIN

      C :: VEC{INT}(4)

      res = .has_chain(Ca,Cb,[6,6,6,7],C)
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(C(4),C(3))

   end

   has_MET(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes MET
      self :: IN
      Ca,Cb :: INT, IN
      res :: BIN

      C :: VEC{INT}(3)

      res = .has_chain(Ca,Cb,[6,16,6],C)
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(C(3),C(2))

   end

   has_PHE(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes PHE
      self :: IN
      Ca,Cb :: INT, IN
      res :: BIN

      Cg,Cd1,Cd2 :: INT

      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return

      res = .has_3_connections(Cg,Cb,6,6,Cd1,Cd2)
      if (NOT res) return

      res = .has_ring(Cg,Cd1,[6,6,6,6])

   end

   has_SER(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes SER
      self :: IN
      Ca,Cb :: INT, IN
      res :: BIN

      Og :: INT

      res = .has_2_connections(Cb,Ca,8,Og)
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Og,Cb)

   end

   has_THR(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes THR
      self :: IN
      Ca,Cb :: INT, IN
      res :: BIN

      Cg,Og :: INT

      res = .has_3_connections(Cb,Ca,6,8,Cg,Og)
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Cg,Cb)
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Og,Cb)

   end

   has_TRP(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes TRP
      self :: IN
      Ca,Cb :: INT, IN
      res :: BIN

      C :: VEC{INT}(4)
      Cg,Cd1,Cd2,Ne,Ce1,Cf1 :: INT

      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return

      res = .has_3_connections(Cg,Cb,6,6,Cd1,Cd2)
      if (NOT res) return

      if (.has_2_connections(Cd1,Cg,7,Ne)) then

         res = .has_2_connections(Ne,Cd1,6,Ce1)
         if (NOT res) return

         res = .has_3_connections(Ce1,Ne,Cd2,6,Cf1)
         if (NOT res) return

         res = .has_chain(Ce1,Cf1,[6,6,6,6],C)
         if (NOT res) return

         res = C(4)==Cd2

      else if (.has_2_connections(Cd2,Cg,7,Ne)) then

         res = .has_2_connections(Ne,Cd2,6,Ce1)
         if (NOT res) return

         res = .has_3_connections(Ce1,Ne,Cd1,6,Cf1)
         if (NOT res) return

         res = .has_chain(Ce1,Cf1,[6,6,6,6],C)
         if (NOT res) return

         res = C(4)==Cd1

      else

         res = FALSE

      end

   end

   has_TYR(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes TYR
      self :: IN
      Ca,Cb :: INT, IN
      res :: BIN

      Cg,Cd1,Cd2,Ce1,Ce2,Cz,Oz :: INT

      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return

      res = .has_3_connections(Cg,Cb,6,6,Cd1,Cd2)
      if (NOT res) return

      res = .has_2_connections(Cd1,Cg,6,Ce1)
      if (NOT res) return

      res = .has_2_connections(Cd2,Cg,6,Ce2)
      if (NOT res) return

      res = .has_2_connections(Ce1,Cg,6,Cz)
      if (NOT res) return

      res = .has_2_connections(Ce2,Cg,6,Cz)
      if (NOT res) return

      res = .has_3_connections(Cz,Ce1,Ce2,8,Oz)
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Oz,Cz)

   end

   has_VAL(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes THR
      self :: IN
      Ca,Cb :: INT, IN
      res :: BIN

      Cg1,Cg2 :: INT

      res = .has_3_connections(Cb,Ca,6,6,Cg1,Cg2)
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Cg1,Cb)
      if (NOT res) return

      res = VEC{ATOM}:has_1_connection(Cg2,Cb)

   end

!  ========================
!  Bonds, distances, angles
!  ========================

   nearest_atom_to(pos) result (res) ::: pure
   ! Return the index of the nearest atom to point "pos".
      self :: IN
      pos :: VEC{REAL}(3), IN
      res :: INT

      a :: INT
      dpos :: VEC{REAL}(3)
      dmin,dist :: REAL

      res = 1

      dmin = huge(ONE)
      do a = 1,.dim

         dpos = pos - self(a).position
         dist = dpos.norm

         if (dist<dmin) then
            dmin = dist
            res  = a
         end

      end

   end

   bonded(a,b,range_factor,H_bonded) result (res) ::: pure
   ! Return true if "self" is bonded to "b".  If present, "range_factor" is used
   ! to determine the distance range in which the atoms are regarded as bonded.
   ! This uses the CCDC method, as documented on their web page.
      self :: IN
      a,b :: INT, IN
      range_factor :: REAL, IN, optional
      H_bonded :: BIN, IN, optional
      res :: BIN

      res = self(a).is_bonded_to(self(b),range_factor)

      ! Check if H-bonds are to be considered
      if (present(H_bonded)) then
      if (H_bonded) then
      if (NOT res) then
      if (self(a).atomic_number==1 OR self(b).atomic_number==1) then
         res = self(a).is_vdw_bonded_to(self(b),range_factor)
      end
      end
      end
      end

   end

   are_nearby(a,b,dist) result (res) ::: pure
   ! Return whether atoms "a" and "b" are nearby, i.e. within length "dist".
      self :: IN
      a,b :: INT, IN
      dist :: REAL, IN
      res :: BIN

      tmp :: VEC{REAL}(3)
      r2 :: REAL

      tmp = self(a).position - self(b).position
      tmp = abs(tmp)
      if      (tmp(1)>dist) then; res = FALSE
      else if (tmp(2)>dist) then; res = FALSE
      else if (tmp(3)>dist) then; res = FALSE
      else
         r2 = dot_product(tmp,tmp)
         res = (r2 < dist*dist)
      end

   end

   connected(a,b,c,d) result (res) ::: pure
   ! Return true if atoms "a" "b" "c" and "d" are connected together
      self :: IN
      a,b,c,d :: INT, IN
      res :: BIN

      res = .bonded(a,b) OR .bonded(a,c) OR .bonded(a,d)
      res = res AND ( .bonded(b,a) OR .bonded(b,c) OR .bonded(b,d) )
      res = res AND ( .bonded(c,a) OR .bonded(c,b) OR .bonded(c,d) )
      res = res AND ( .bonded(d,a) OR .bonded(d,b) OR .bonded(d,c) )

   end


   vdw_bonded(a,b,range_factor,vdw_range_pc) result (res) ::: pure
   ! Return true if "a" is vdw bonded to "b". Atoms which are
   ! covalently bonded are not van-der-waals bonded.  If present,
   ! "range_factor" is used to determine the distance range in which
   ! the atoms are regarded as covalent bonded. If present
   ! "vdw_range_pc" is the percentage increase in the vdw radius to be
   ! tolerated while still regarding the atoms vdw bonded (default
   ! 10%). This uses the CCDC method, as documented on their web page.
      self :: IN
      a,b :: INT, IN
      range_factor,vdw_range_pc :: REAL, optional, IN
      res :: BIN

      res = self(a).is_vdw_bonded_to(self(b),range_factor,vdw_range_pc)

   end

   is_vdw_bonded_to(list,range_factor,vdw_range_pc) result (res) ::: pure
   ! Return true if "self" has any atom vdw bonded to "list".
      self :: IN
      list :: VEC{ATOM}, IN
      range_factor,vdw_range_pc :: REAL, optional, IN
      res :: BIN

      a,b :: INT

      res = FALSE
      do a = 1,.dim
      do b = 1,list.dim
         res = self(a).is_vdw_bonded_to(list(b),range_factor,vdw_range_pc)
         if (res) exit
      end
      end

   end


   bonded_groups(g1,g2) result (res) ::: pure
   ! Return true if any of the atoms in group "g1" are bonded to any
   ! in group "g2".
      self :: IN
      g1,g2 :: INT, IN
      res :: BIN

      res = .no_of_bonds_between_groups(g1,g2) > 0

   end

   no_of_bonds_between_groups(g1,g2) result (res) ::: pure
   ! Return true if group "g1" is bonded to group "g2". 
      self :: IN
      g1,g2 :: INT, IN
      res :: INT

      n_group, a,b :: INT

      n_group = .no_of_groups

      res = 0

      group_A: do a = 1,n_group
         if (self(a).group/=g1) cycle
         group_B: do b = 1,n_group
           if (self(b).group/=g2) cycle
           if (NOT self(a).is_bonded_to(self(b))) cycle
           res = res + 1
         end do group_B
      end do group_A

   end

   list_of_bonds_between_groups(g1,g2) result (res) ::: pure
   ! Return the list of pairs of atom indices between group "g1" and
   ! group "g2" which are bonded.
      self :: IN
      g1,g2 :: INT, IN
      res :: MAT{INT}(.no_of_bonds_between_groups(g1,g2),2)

      n_group,n, a,b :: INT

      n_group = .no_of_groups

      n = 0

      group_A: do a = 1,n_group
         if (self(a).group/=g1) cycle
         group_B: do b = 1,n_group
           if (self(b).group/=g1) cycle
           if (NOT self(a).is_bonded_to(self(b))) cycle
           n = n + 1
           res(n,1) = a
           res(n,2) = b
         end do group_B
      end do group_A

   end


   bonded_to(group) result (res) ::: pure
   ! Return true if any of the atoms in "self" are bonded to any of
   ! the atoms in "group". 
      self :: IN
      group :: VEC{ATOM}, IN
      res :: BIN

      res = .no_of_bonds_to(group) > 0

   end

   no_of_bonds_to(group) result (res) ::: pure
   ! Return the number of bonds from the atoms in "self" to those
   ! atoms in "group". 
      self :: IN
      group :: VEC{ATOM}, IN
      res :: INT

      a,b :: INT

      res = 0
      group_A: do a = 1,.dim
      group_B: do b = 1,group.dim
        if (NOT self(a).is_bonded_to(self(b))) cycle
        res = res + 1
      end do group_B
      end do group_A

   end

   list_of_bonds_to(group) result (res) ::: pure
   ! Return the list of pairs of atom indices between group "g1" and
   ! group "g2" which are bonded.
      self :: IN
      group :: VEC{ATOM}, IN
      res :: MAT{INT}(.no_of_bonds_to(group),2)

      n, a,b :: INT

      n = 0

      group_A: do a = 1,.dim
      group_B: do b = 1,group.dim
           if (NOT self(a).is_bonded_to(self(b))) cycle
           n = n + 1
           res(n,1) = a
           res(n,2) = b
      end do group_B
      end do group_A

   end


   has_vdw_bond result (res) ::: pure
   ! Return whether the atom list has two atoms involved in a
   ! (shortest) intermolecular bond. 
      self :: IN
      res :: BIN

      vdw :: VEC{INT}(2)

      vdw = .shortest_vdw_bond
      res = vdw(1)/=0 AND vdw(2)/=0
      ! More than one molecule?

   end

   shortest_vdw_bond result (res) ::: pure
   ! Return indices of the two atoms involved in the shortest
   ! IM van der waals bond. If there are none result is (0,0).
      self :: IN
      res :: VEC{INT}(2)

      a,b :: INT
      rab :: VEC{REAL}(3)
      dab,test :: REAL
      has_mols :: BIN

      res  = 0

      ! More than one molecule?
      has_mols = any(self(:).site_disorder_group>1) OR any(self(:).group>1)
      if (NOT has_mols) return

      test = HUGE(ONE)

      do a = 2,.dim
      do b = 1,a-1

         if (NOT .vdw_bonded(a,b)) cycle

         rab = self(a).position - self(b).position
         dab = rab.norm
         
         if (dab<test) then
            res(1) = a
            res(2) = b
            test   = dab
         end

      end
      end

   end

   shorten_shortest_vdw_bond ::: leaky, PURE
   ! Shorten the shortest intermolecular vdw bond to be the sum of the
   ! covalent bond lengths + 0.6 bohr, and apply the shift to all
   ! atoms in the group (there must be only two groups).
      self :: INOUT

   ENSURE(maxval(self(:).group)==2,"more than two groups")
   ENSURE(minval(self(:).group)==1,"there are not two groups")

      vdw :: VEC{INT}(2)
      a,b,g :: INT
      ra,rb :: REAL
      r,d,v :: VEC{REAL}(3)

      ! Shortest vdw bond
      vdw = .shortest_vdw_bond
      a = vdw(1)
      b = vdw(2)

      ! Distance vector between atoms
      r = self(a).position - self(b).position

      ! Desired distance vector
      ra = self(a).covalent_radius_ccdc
      rb = self(b).covalent_radius_ccdc
      d  = (r/r.norm) * (ra + rb + 0.6)

      ! Shift
      v = d - r

      ! Molecule index of atom "a"
      g = self(a).group

      ! Shift group "a"
      .translate_group(g,v)

   end


   no_of_bonds(range_factor,H_bonded) result (res) ::: pure
   ! Return the number of bonded atoms
      self :: IN
      range_factor :: REAL, optional, IN
      H_bonded :: BIN, optional, IN
      res :: INT

      a,b :: INT

      res = 0

      do a = 1,.dim
      do b = 1,a-1
         if (.bonded(a,b,range_factor,H_bonded)) res = res + 1
      end
      end

   end

   bond_distance(a,b,angstrom) result (res) ::: pure
   ! Return the bond distance between atoms "a" and "b"
      self :: IN
      a,b :: INT, IN
      angstrom :: BIN, optional, IN
      res :: REAL

      rab,rab2 :: VEC{REAL}(3)
      change :: BIN

      rab  = self(b).position - self(a).position
      rab2 = rab*rab
      res = sqrt(rab2(1) + rab2(2) + rab2(3))

      change = FALSE
      if (present (angstrom)) change = angstrom
      if (change) res = res * ANGSTROM_PER_BOHR

   end

   bond_distance(a,b,covariance,angstrom) result (res) ::: PURE
   ! Return the Hirshfeld test (and error) between atoms "a" and "b".
   ! The test is the first value, the error the second in res(:).
      self :: IN
      a,b :: INT, IN
      covariance :: MAT{REAL}, IN
      angstrom :: BIN, optional, IN
      res :: VEC{REAL}(2)

      rab,rab2 :: VEC{REAL}(3)
      der :: VEC{REAL}(6)
      cov :: MAT{REAL}(6,6)
      change :: BIN

      ! Bond length
      rab  = self(b).position - self(a).position
      rab2 = rab*rab
      res(1) = sqrt(rab2(1) + rab2(2) + rab2(3))

      ! Covariance
      covariance.put_blocks_to(cov,block_dim=3,block_list=[a,b])

      ! Bond length error
      .bond_distance_deriv(a,b,der)
      res(2) = sqrt(cov.dot(der,der))

      change = FALSE
      if (present (angstrom)) change = angstrom
      if (change) res = res * ANGSTROM_PER_BOHR

   end

   bond_distance_deriv(a,b,deriv) ::: pure
   ! Return the bond distance derivatives "deriv" wrt cartesian
   ! positions between atoms "a" and "b". The bond vector is rb - ra
      self :: IN
      a,b :: INT, IN
      deriv :: VEC{REAL}(6), OUT

      rab :: VEC{REAL}(3)
      dab :: REAL

      ! Vector rab and (inverse) length
      rab = self(b).position - self(a).position
      dab = sqrt(rab(1)*rab(1) + rab(2)*rab(2) + rab(3)*rab(3))
      dab = ONE/dab

      ! Derivative
      deriv(1:3) = -rab*dab ! wrt a
      deriv(4:6) =  rab*dab ! wrt b

   end


   no_of_angles result (res) ::: pure
   ! Return the number of angles within bond contact distance
      self :: IN
      res :: INT

      n,a,b,c :: INT

      n = .dim

      res = 0

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n
            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle
            res = res + 1
         end

      end
      end

   end

   bond_angle(a,b,c,degrees) result (res) ::: pure
   ! Return the bond angle between atoms "a" , "b" and "c".
   ! The central atom is "b". The angle is calculated as
   ! arccos(nba.nbc) . If "degrees" is present and TRUE,
   ! result is in degrees.
      self :: IN
      a,b,c :: INT, IN
      degrees :: BIN, optional, IN
      res :: REAL

      rba,rbc :: VEC{REAL}(3)
      change :: BIN

      rba = self(a).position - self(b).position
      rbc = self(c).position - self(b).position
      rba.normalise
      rbc.normalise
      res = rba.dot(rbc)
      res = res.arccos

      change = FALSE
      if (present (degrees)) change = degrees
      if (change) res = res * DEGREE_PER_RADIAN

   end

   no_of_angle_center_atoms result (res) ::: pure
   ! Return the number of list of atom indices B which belong to
   ! angles centers angle(ABC)
      self :: IN
      res :: INT

      n,a,b,c :: INT
      cnt :: VEC{BIN}@

      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n
            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle
            cnt(b) = TRUE
         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   angle_center_atoms result (res) ::: pure
   ! Return the list of atom indices B which belong to angles centers
   ! angle(ABC)
      self :: IN
      res :: VEC{INT}(.no_of_angle_center_atoms)

      n,a,b,c :: INT
      cnt :: VEC{BIN}@

      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n
            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle
            cnt(b) = TRUE
         end

      end
      end

      res = pack([( a, a=1,n)],mask=cnt)

      deallocate(cnt)

   end

   no_of_angle_outer_atoms result (res) ::: pure
   ! Return the number of list of atoms which are outer angle atoms
      self :: IN
      res :: INT

      n,a,b,c :: INT
      cnt :: VEC{BIN}@

      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n
            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle
            cnt(a) = TRUE
            cnt(c) = TRUE
         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   angle_outer_atoms result (res) ::: pure
   ! Return the list of atoms which are outer angle atoms
      self :: IN
      res :: VEC{INT}(.no_of_angle_outer_atoms)

      n,a,b,c :: INT
      cnt :: VEC{BIN}@

      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n
            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle
            cnt(a) = TRUE
            cnt(c) = TRUE
         end

      end
      end

      res = pack([( a, a=1,n)],mask=cnt)

      deallocate(cnt)

   end


   no_of_torsion_angles result (res) ::: pure
   ! Return the number of torsion angles within bond contact distance
      self :: IN
      res :: INT

      n,a,b,c,d :: INT

      n = .dim

      res = 0

      do a = 1,n
      do b = 1,n

         if (a==b) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (a==c OR b==c) cycle
            if (NOT .bonded(b,c)) cycle

            do d = 1,n
               if (a==d OR b==d OR c==d) cycle
               if (NOT .bonded(c,d)) cycle
               res = res + 1
            end

         end

      end
      end

      res = res/2

   end

   torsion_angle(a,b,c,d) result (res) ::: pure
   ! Return the torsion angle between atoms "a", "b", "c" and "d". The
   ! atoms are assumed connected like a--b--c--d and the angle
   ! returned is that between vectors (a-b) and (d-c) i.e. the torsion
   ! angle looking down the b--c bond.  torsion is positive if (a-b)
   ! is counterclockwise of (d-c). If "degrees" is present and TRUE,
   ! result is in degrees.  NOTE: If the result is -ONE, either
   ! a--b--c or b--c--d are colinear, and the variables "abc_colinear"
   ! and "bcd_colinear" are set.  See Tuzun et al (2000) J. Comp. Chem
   ! 21 p. 553-561
      self :: IN
      a,b,c,d :: INT, IN
      res :: REAL

      rba,rcb,rdc,tba,tdc :: VEC{REAL}(3)
      dot :: REAL

      ! Vectors point from d -> c -> b -> a
      rba = self(a).position - self(b).position
      rcb = self(b).position - self(c).position
      rdc = self(c).position - self(d).position
      rba.normalise
      rcb.normalise
      rdc.normalise

      tba.to_cross_product_of(rba,rcb)
      tdc.to_cross_product_of(rcb,rdc)

      ! Collinear test
      res = ZERO
      if (abs(tba.norm)<TOL(5)) then
         res = -ONE
      end
      if (abs(tdc.norm)<TOL(5)) then
         res = -ONE
      end
      if (res<ZERO) return

      tba.normalise
      tdc.normalise
      res = tba.dot(tdc)
      res = res.arccos

      ! Sign of angle: see Tozun et al eq. (11)
      ! And also Figure 1
      dot = -rdc.dot(tba)
      if (dot<ZERO) res = -res

   end

   torsion_angle(a,b,c,d,abc_colinear,bcd_colinear,degrees) result (res)
   ! Return the torsion angle between atoms "a", "b", "c" and "d". The
   ! atoms are assumed connected like a--b--c--d and the angle
   ! returned is that between vectors (a-b) and (d-c) i.e. the torsion
   ! angle looking down the b--c bond.  torsion is positive if (a-b)
   ! is counterclockwise of (d-c). If "degrees" is present and TRUE,
   ! result is in degrees.  NOTE: If the result is -ONE, either
   ! a--b--c or b--c--d are colinear, and the variables "abc_colinear"
   ! and "bcd_colinear" are set.  See Tuzun et al (2000) J. Comp. Chem
   ! 21 p. 553-561
      self :: IN
      a,b,c,d :: INT, IN
      abc_colinear,bcd_colinear :: BIN, OUT
      degrees :: BIN, optional, IN
      res :: REAL

      change :: BIN
      rba,rcb,rdc,tba,tdc :: VEC{REAL}(3)
      dot :: REAL

      abc_colinear = FALSE
      bcd_colinear = FALSE

      ! Vectors point from d -> c -> b -> a
      rba = self(a).position - self(b).position
      rcb = self(b).position - self(c).position
      rdc = self(c).position - self(d).position
      rba.normalise
      rcb.normalise
      rdc.normalise

      tba.to_cross_product_of(rba,rcb)
      tdc.to_cross_product_of(rcb,rdc)

      ! Collinear test
      res = ZERO
      if (abs(tba.norm)<TOL(5)) then
         res = -ONE
      end
      if (abs(tdc.norm)<TOL(5)) then
         res = -ONE
      end
      if (res<ZERO) return

      tba.normalise
      tdc.normalise
      res = dot_product(tba,tdc)
      res = res.arccos

      ! Sign of angle: see Tozun et al eq. (11)
      ! And also Figure 1
      dot = -dot_product(rdc,tba)
      if (dot<ZERO) res = -res

      change = FALSE
      if (present (degrees)) change = degrees
      if (change) res = res * DEGREE_PER_RADIAN

   end

   no_of_torsion_angle_1st_atoms result (res) ::: pure
   ! Return the number of list of indices of 1st atoms in a torsion angle
      self :: IN
      res :: INT

      a1,a2,a3,a4, n :: INT
      cnt :: VEC{BIN}@

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n
         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle
         do a3 = 1,n
            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle
            do a4 = 1,n
               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle
               cnt(a1) = TRUE
            end
         end
      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   torsion_angle_1st_atoms result (res) ::: pure
   ! Return the list of indices of 1st atoms in a torsion angle
      self :: IN
      res :: VEC{INT}(.no_of_torsion_angle_1st_atoms)

      a1,a2,a3,a4, n :: INT
      cnt :: VEC{BIN}@

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n
         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle
         do a3 = 1,n
            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle
            do a4 = 1,n
               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle
               cnt(a1) = TRUE
            end
         end
      end
      end

      res = pack([ (a1, a1=1,n) ],mask=cnt)

      deallocate(cnt)

   end

   no_of_torsion_angle_2nd_atoms result (res) ::: pure
   ! Return the number of list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: INT

      a1,a2,a3,a4, n :: INT
      cnt :: VEC{BIN}@

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n
         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle
         do a3 = 1,n
            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle
            do a4 = 1,n
               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle
               cnt(a2) = TRUE
            end
         end
      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   torsion_angle_2nd_atoms result (res) ::: pure
   ! Return the list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: VEC{INT}(.no_of_torsion_angle_2nd_atoms)

      a1,a2,a3,a4, n :: INT
      cnt :: VEC{BIN}@

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n
         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle
         do a3 = 1,n
            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle
            do a4 = 1,n
               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle
               cnt(a2) = TRUE
            end
         end
      end
      end

      res = pack([ (a1, a1=1,n) ],mask=cnt)

      deallocate(cnt)

   end

   no_of_torsion_angle_3rd_atoms result (res) ::: pure
   ! Return the number of list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: INT

      a1,a2,a3,a4, n :: INT
      cnt :: VEC{BIN}@

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n
         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle
         do a3 = 1,n
            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle
            do a4 = 1,n
               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle
               cnt(a3) = TRUE
            end
         end
      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   torsion_angle_3rd_atoms result (res) ::: pure
   ! Return the list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: VEC{INT}(.no_of_torsion_angle_3rd_atoms)

      a1,a2,a3,a4, n :: INT
      cnt :: VEC{BIN}@

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n
         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle
         do a3 = 1,n
            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle
            do a4 = 1,n
               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle
               cnt(a3) = TRUE
            end
         end
      end
      end

      res = pack([ (a1, a1=1,n) ],mask=cnt)

      deallocate(cnt)

   end

   no_of_torsion_angle_4th_atoms result (res) ::: pure
   ! Return the umber list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: INT

      cnt :: VEC{BIN}@
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n
         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle
         do a3 = 1,n
            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle
            do a4 = 1,n
               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle
               cnt(a4) = TRUE
            end
         end
      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   torsion_angle_4th_atoms result (res) ::: pure
   ! Return the list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: VEC{INT}(.no_of_torsion_angle_4th_atoms)

      a1,a2,a3,a4, n :: INT
      cnt :: VEC{BIN}@

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n
         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle
         do a3 = 1,n
            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle
            do a4 = 1,n
               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle
               cnt(a4) = TRUE
            end
         end
      end
      end

      res = pack([ (a1, a1=1,n) ],mask=cnt)

      deallocate(cnt)

   end

   has_all_Hs_single_bonded(has_Hs) result (res)
   ! Return TRUE if "self" has all H atom single bonded. If there are
   ! no H's then the result is TRUE but "has_Hs" is set FALSE..
      self :: IN
      has_Hs :: BIN, OUT
      res :: BIN

      a,b,n :: INT

      res = TRUE
      has_Hs = FALSE

      do a = 1,.dim

         if (self(a).atomic_number/=1) cycle
         has_Hs = TRUE

         n = 0
         do b = 1,.dim
            if (self(b).atomic_number<=1) cycle
            if (NOT self(a).is_bonded_to(self(b))) cycle
            n = n + 1
            if (n>1) exit
         end

         res = n==1
         if (NOT res) exit

      end

   end


   Spackman86_dispersion_energy(atom) result (res) ::: PURE
   ! Return Spackman's dispersion energy between "self" and "atom"s.
   ! See Spackman M. A. (1986) J. Chem. Phys. 85(11) p. 6579
      self :: IN
      atom :: VEC{ATOM}, IN
      res :: REAL

   ENSURE(self.has_all_Spackman86_a_coeffs,"self: missing Spackman a coefficients")
   ENSURE(atom.has_all_Spackman86_a_coeffs,"atom: missing Spackman a coefficients")

      i,j :: INT
      r,a_i,a_j :: REAL

      ! Loop over atom pairs
      res = ZERO
      do i = 1,.dim
         a_i = ATOM::Spackman86_a_6_dispersion_coeff(self(i))
         do j = 1,atom.dim
            a_j = ATOM::Spackman86_a_6_dispersion_coeff(atom(j))
            r = self(i).bond_distance_to(atom(j))
            res = res - a_i*a_j/r**6
         end
      end

   end

   Spackman86_repulsion_energy(atom) result (res) ::: PURE
   ! Return Spackman's repulsion energy between "self" and "atom"s.
   ! See Spackman M. A. (1986) J. Chem. Phys. 85(11) p. 6579
      self :: IN
      atom :: VEC{ATOM}, IN
      res  :: REAL

   ENSURE(self.has_all_Spackman86_b_c_coeffs,"self: missing Spackman b/c coefficients")
   ENSURE(atom.has_all_Spackman86_b_c_coeffs,"atom: missing Spackman b/c coefficients")

      i,j, Z_i,Z_j :: INT
      r,r_offset :: REAL
      b_i,b_j    :: REAL
      c_i,c_j    :: REAL

      res = ZERO

      ! Loop over pairs
      do i = 1,.dim

         Z_i = self(i).atomic_number
         b_i = ATOM::Spackman86_b_repulsion_coeff(self(i))
         c_i = ATOM::Spackman86_c_repulsion_coeff(self(i))

         do j = 1,atom.dim

            Z_j = atom(j).atomic_number
            b_j = ATOM::Spackman86_b_repulsion_coeff(atom(j))
            c_j = ATOM::Spackman86_c_repulsion_coeff(atom(j))

            r = self(i).bond_distance_to(atom(j))

            ! Modify distance r only for repulsion term
            ! for H atoms ... just an approximate hack
            r_offset = ZERO
            if (Z_i==1  OR  Z_j==1) r_offset = HALF  * BOHR_PER_ANGSTROM ! X-H interactions
            if (Z_i== 1 AND Z_j==1) r_offset = TENTH * BOHR_PER_ANGSTROM ! H-H interactions
            r = r + r_offset

            res = res + b_i*b_j*exp(-r*(c_i+c_j))

         end

      end

   end

   Grimme06_dispersion_energy(atom) result (res) ::: PURE
   ! Return Grimmes's dispersion energy between "self" and "atom"s.
   ! Based on C6 terms from Grimme (2006) J. Comp. Chem.  27(15) p. 1787
   ! E_disp = sum over atoms (C6 / r^6).
      self :: IN
      atom :: VEC{ATOM}, IN
      res :: REAL

    ENSURE(self.has_all_Grimme06_a_coeffs,"self: missing Grimme a coefficients")
    ENSURE(atom.has_all_Grimme06_a_coeffs,"atom: missing Grimme a coefficients")

      i,j :: INT
      rij,a_i,a_j,r_i, r_j :: REAL
      d,rr, damping_factor :: REAL

      res = ZERO
      d   = TWO*TEN ! Magic number

      ! Loop over pairs
      do i = 1,.dim

         a_i = ATOM::Grimme06_a_6_dispersion_coeff(self(i))
         r_i = ATOM::Grimme06_r_0_dispersion_coeff(self(i))

         do j = 1,atom.dim

            a_j = ATOM::Grimme06_a_6_dispersion_coeff(atom(j))
            r_j = ATOM::Grimme06_r_0_dispersion_coeff(atom(j))

            rr = (r_i + r_j)
            rij   = self(i).bond_distance_to(atom(j))
            damping_factor = (ONE / (ONE + exp(-d * (rij/(rr) - ONE))))
            res = res - (a_i*a_j/rij**6 * damping_factor)

         end

      end

   end

   dispersion_energy(atom) result (res)
   ! Return the dispersion energy from various formula.
   ! Refs?
      self :: IN
      atom :: VEC{ATOM}, IN
      res  :: REAL

      i, n1,n2 :: INT
      e1,e2, edisp :: REAL
      s6, rs6, s18, rs18, alp :: REAL

      coords :: MAT{REAL}@
      atomic_numbers :: VEC{INT}@
      version :: INT
      type(dftd3_calc) calc
      type(dftd3_input) input

      n1 = .dim
      n2 = atom.dim
      allocate(coords(3, n1 + n2))
      allocate(atomic_numbers(n1 + n2))

      ! Versions:
      ! 6: DFT-D3 with Becke-Johnson damping parameters
      ! 5: DFT-D3 with zero damping parameters
      ! 4: DFT-D3 with Becke-Johnson finite-damping, variant 2 with their radii
      ! 3: DFT-D3 with no damping
      ! 2: DFT-D2
      version = 4

      ! include 3 body terms
      input%threebody = FALSE

      ! Numerical gradients
      input%numgrad = FALSE

      ! Cutoffs (should parameterize these)
      !input%cutoff = sqrt(9000.0d0)
      !input%cutoff_cn = sqrt(1600.0d0)

      call dftd3_init(calc, input)
      ! D2
!     rs6 = 1.0d0
!     s18 = 0.0d0
!     alp = 20.0d0

      ! hf
    ! s6 = 1.0 
    ! rs6 =0.3385
    ! s18 =0.9171
    ! rs18=2.8830

      ! b3lyp
      s6   = 1.0 
      rs6  = 0.3981
      s18  = 1.9889
      rs18 = 4.4211
      alp  = ZERO ! Remove warning

      call dftd3_set_params(calc, [s6, rs6, s18, rs18, alp], version)

      atomic_numbers = [self(:).atomic_number, atom(:).atomic_number]

      do i = 1,n1
          coords(:, i) = self(i).position
      end

      do i = 1,n2
          coords(:, i+n1) = atom(i).position
      end

      edisp = ZERO
      e1    = ZERO
      e2    = ZERO
      call dftd3_dispersion(calc, coords, atomic_numbers, edisp)
      call dftd3_dispersion(calc, coords(:,1:n1), atomic_numbers(1:n1), e1)
      call dftd3_dispersion(calc, coords(:,n1+1:n1+n2), atomic_numbers(n1+1:n1+n2), e2)

      ! Do it
      res = edisp - e2 - e1

   end

   polarization_energy(F_sq, use_charged_values) result (res) ::: PURE
   ! Return simplified polarization energy
   ! Uses atomic polarizabilties from Thakkar and Lupinetti (2006)
      self :: IN
      F_sq :: VEC{REAL}, IN
      use_charged_values :: BIN, optional, IN
      res :: REAL

   ENSURE(self.has_all_Thakkar_atomic_polarizabilities,"self: missing Grimme a coefficients")

      polarizability :: REAL
      i :: INT

      res = ZERO
      do i = 1,.dim
         polarizability = ATOM::Thakkar_atomic_dipole_polarizability(self(i), use_charged_values)
         res = res + polarizability * F_sq(i)
      end
      res = -HALF * res

   end

   has_all_Spackman86_a_coeffs result (res) ::: pure
   ! Return TRUE if "self" has all dispersion coefficients.
      self :: IN
      res :: BIN
      res = all(ATOM::Spackman86_a_6_dispersion_coeff(self)/=ZERO)
   end

   has_all_Spackman86_b_c_coeffs result (res) ::: pure
   ! Return TRUE if "self" has all repulsion coefficients.
      self :: IN
      res :: BIN

      has_b,has_c :: BIN

      has_b = all(ATOM::Spackman86_b_repulsion_coeff(self) /= ZERO)
      has_c = all(ATOM::Spackman86_c_repulsion_coeff(self) /= ZERO)

      res = has_b AND has_c

   end

   has_all_Grimme06_a_coeffs result (res) ::: pure
   ! Return TRUE if "self" has all dispersion coefficients.
      self :: IN
      res :: BIN
      res = all(ATOM::Grimme06_a_6_dispersion_coeff(self) /= ZERO)
   end

   has_all_Thakkar_atomic_polarizabilities result (res) ::: pure
   ! Return TRUE if "self" has all atomic polarizabilities
      self :: IN
      res :: BIN
      res = all(ATOM::Thakkar_atomic_dipole_polarizability(self) /= ZERO)
   end

!  =====================================
!  Set anamalous dispersion coefficients
!  =====================================

!   set_dispersion_coefficients(wavelength)
!   ! set the anamalous dispersion coefficients at a certain
!   ! "wavelength" in bohr.
!      self :: inout
!      wavelength :: real, in
!
!      a :: int 
!
!      do a = 1,.dim
!         self(a).set_dispersion_coefficient(wavelength)
!      end
!
!   end

   set_tabular_dispersion ::: PURE
   ! set the anamalous dispersion coefficients enetered by the user in
   ! the table.
      self :: INOUT

      a :: INT

      do a = 1,.dim
         self(a).set_tabular_dispersion
      end

   end

!   has_all_dispersion result (res) ::: PURE
!   ! Return TRUE if all the elements in the unique atom list
!   ! have disperesion coefficient entries in the table.
!      self :: IN
!      res :: BIN
!
!      a :: INT
!
!      ! Any without?
!      res = TRUE
!      do a = 1,.dim
!         res = self(a).has_dispersion
!         if (NOT res) exit
!      end
!
!   end

!   has_part_tabular_dispersion result (res) ::: PURE
!   ! Return TRUE if nether all nor none of the elements in the unique
!   ! atom list have dispresion coefficient entries in the table.
!      self :: IN
!      res :: BIN
!
!      all,none :: BIN
!
!      all  = .has_all_tabular_dispersion
!      none = .has_no_tabular_dispersion
!      res  = (NOT all) AND (NOT none)
!
!   end

!   has_no_tabular_dispersion result (res) ::: PURE
!   ! Return TRUE if all of the elements in the unique atom list have
!   ! *no* disperesion coefficient entries in the table. No means
!   ! "none" here.
!      self :: IN
!      res :: BIN
!
!      n_kind,u :: INT
!      ulist :: VEC{INT}@
!
!      ! Unique atom list
!      n_kind = maxval(self(:).kind)
!      ulist.create(n_kind)
!      .make_unique_atom_list(ulist)
!
!      ! Any with
!      res = TRUE
!      do u = 1,n_kind
!         res = NOT self(ulist(u)).has_tabular_dispersion
!         if (res) exit
!      end
!
!      ! Clean
!      ulist.destroy
!
!   end

!   has_all_tabular_dispersion result (res) ::: PURE
!   ! Return TRUE if all the elements in the unique atom list
!   ! have disperesion coefficient entries in the table.
!      self :: IN
!      res :: BIN
!
!      n_kind,u :: INT
!      ulist :: VEC{INT}@
!
!      ! Unique atom list
!      n_kind = maxval(self(:).kind)
!      ulist.create(n_kind)
!      .make_unique_atom_list(ulist)
!
!      ! Any without?
!      res = TRUE
!      do u = 1,n_kind
!         res = self(ulist(u)).has_tabular_dispersion
!         if (NOT res) exit
!      end
!
!      ! Clean
!      ulist.destroy
!
!   end

   get_dispersion_correction(Fa,k_pts,rf) ::: PURE
   ! Adds the anomalous dispersion correction for every atom in "Fa"
   ! for a set of supplied "k_pts" which are the list of user-supplied
   ! (hkl)'s multiplied by all the symmetry operations. "rf" are the
   ! repetition factors  (site symmetry factor). 
      self :: IN
      Fa :: VEC{CPX}, INOUT
      k_pts :: MAT{REAL}, IN
      rf :: VEC{REAL}, IN

      a :: INT

      ! Loop over all atoms.
      ! Note that H U_iso refinement will not affect this section of code.
      do a = 1,.dim
         self(a).get_dispersion(Fa,k_pts,rf(a))
      end

   end

   add_dispersion_correction(Fc,k_pts,rf) ::: PURE
   ! Adds the dispersion correction for every atom into "Fc" for a set
   ! of supplied "k_pts" which are the list of user-supplied (hkl)'s
   ! multiplied by all the symmetry operations. "rf" are the
   ! repetition factors  (site symmetry factor). 
      self :: IN
      Fc :: VEC{CPX}, INOUT
      k_pts :: MAT{REAL}, IN
      rf :: VEC{REAL}, IN

      a :: INT

      ! Loop over all atoms.
      ! Note that H U_iso refinement will not affect this section of code.
      do a = 1,.dim
         self(a).add_dispersion(Fc,k_pts,rf(a))
      end

   end

!  ================================================
!  Position derivatives of bonds, distances, angles
!  ================================================

   bond_angle_deriv(a,b,c,deriv,abc_colinear)
   ! Return the bond angle derivatives "deriv" between atoms "a" , "b"
   ! and "c".  The central atom is "b". The angle is calculated as
   ! arccos(nba.nbc). See Tuzun et al (2000) J. Comp. Chem 21 p.
   ! 553-561 equation (6).
      self :: IN
      a,b,c :: INT, IN
      deriv :: VEC{REAL}(9), OUT
      abc_colinear :: BIN, optional, OUT

      rba,rbc,rx,ry :: VEC{REAL}(3)
      dba,dbc,cs,sn :: REAL

      if (present(abc_colinear)) abc_colinear = FALSE

      ! Vectors
      rba = self(a).position - self(b).position
      rbc = self(c).position - self(b).position

      ! Get lengths and normalise
      dba = ONE/rba.norm; rba = rba*dba
      dbc = ONE/rbc.norm; rbc = rbc*dbc

      ! sin part
      cs = dot_product(rba,rbc)
      sn = sqrt((ONE-cs)*(ONE+cs))
      if (abs(sn)<TOL(5)) then
         deriv = ZERO
         if (present(abc_colinear)) abc_colinear = TRUE
         return
      else
         sn = ONE/sn
      end

      ! I checked the formula below myself
      ! Derivtive wrt c: see (6b)
      ! NOTE: this equation is actually -Nabla1
      rx.to_cross_product_of(rbc,rba)
      ry.to_cross_product_of(rba,rx)
      deriv(1:3) = ry*dba

      ! Derivative wrt a: see (6a)
      ! NOTE: this equation is actually Nabla3
      rx.to_cross_product_of(rba,rbc)
      ry.to_cross_product_of(rbc,rx)
      deriv(7:9) = ry*dbc

      ! Derivative wrt b: use translational invariance
      deriv(4:6) = - deriv(1:3) - deriv(7:9)

      ! Divide by sin: see (6c)
      deriv = -sn*deriv

   end

   torsion_angle_deriv(a,b,c,d,deriv,abc_colinear,bcd_colinear)
   ! Return the torsion angle derivative "deriv" between atoms "a",
   ! "b", "c" and "d". NOTE: If the result is -ONE, either a--b--c or
   ! b--c--d are colinear, and the variables "abc_colinear" and
   ! "bcd_colinear" are set.  See Tuzun et al (2000) J. Comp. Chem 21
   ! p. 553-561 equation (9).
      self :: IN
      a,b,c,d :: INT, IN
      deriv :: VEC{REAL}(12), OUT
      abc_colinear,bcd_colinear :: BIN, optional, OUT

      rba,rcb,rdc,tba,tdc :: VEC{REAL}(3)
      dba,dcb,ddc, sin_abc,sin_bcd,cos_abc,cos_bcd, cc,bb :: REAL

      if (present(abc_colinear)) abc_colinear = FALSE
      if (present(bcd_colinear)) bcd_colinear = FALSE

      ! Vectors point from d -> c -> b -> a
      rba = self(a).position - self(b).position
      rcb = self(b).position - self(c).position
      rdc = self(c).position - self(d).position

      ! Lengths and normalise
      dba = rba.norm; rba = rba/dba
      dcb = rcb.norm; rcb = rcb/dcb
      ddc = rdc.norm; rdc = rdc/ddc

      ! Normals to planes
      tba.to_cross_product_of(rba,rcb)
      tdc.to_cross_product_of(rdc,rcb)

      ! Collinear test
      if (abs(tba.norm)<TOL(5)) then
         deriv = ZERO
         if (present(abc_colinear)) abc_colinear = TRUE
         return
      end
      if (abs(tdc.norm)<TOL(5)) then
         deriv = ZERO
         if (present(bcd_colinear)) bcd_colinear = TRUE
         return
      end

      ! sin's and cos's
      sin_abc = ONE/tba.norm
      sin_bcd = ONE/tdc.norm
      cos_abc = -dot_product(rba,rcb)
      cos_bcd = -dot_product(rcb,rdc)


      ! Gradient's
      deriv( 1: 3) = -tba*sin_abc*sin_abc/dba    ! wrt a: see (9a)
      deriv(10:12) = -tdc*sin_bcd*sin_bcd/ddc    ! wrt d: see (9b)
      cc = dba*cos_abc/dcb - ONE                 ! wrt b: see (9d)
      bb = ddc*cos_bcd/dcb
      deriv( 4: 6) = cc*deriv(1:3) - bb*deriv(10:12)
      deriv( 7: 9) = -deriv(1:3)-deriv(4:6)-deriv(10:12)

   end

!  ========================
!  Size information methods
!  ========================

   no_of_electrons result (res) ::: PURE
   ! If the atom list is *not* a single explicit "El" electron:
   ! . Return the number of electrons in the atom list assuming
   !   that it is *neutrally charged*. Any explicit "El" electrons
   !   are ignored i.e. they have no electrons.
   ! . Else return 1 ... the explicit "El" electron is assumed to be
   !   surrounded by one (beta) electron. This ensures a good initial
   !   guess is obtained for promolecule guess SCF calculations.
      self :: IN
      res :: INT

   ENSURE(.dim>0,"zero size atom list")

      res = sum(self(:).atomic_number)

   end

   no_of_electrons(list) result (res) ::: PURE
   ! If the atom list is *not* a single explicit "El" electron:
   ! . Return the number of electrons in the atom list assuming
   !   that it is *neutrally charged*. Any explicit "El" electrons
   !   are ignored i.e. they have no electrons.
   ! . Else return 1 ... the explicit "El" electron is assumed to be
   !   surrounded by one (beta) electron. This ensures a good initial
   !   guess is obtained for promolecule guess SCF calculations.
      self :: IN
      list :: VEC{INT}, IN
      res :: INT

   ENSURE(.dim>0,"zero size atom list")

      i :: INT

      res = 0
      do i = 1,list.dim
         res = res + self(list(i)).atomic_number
      end

   end

   no_of_occupied_NAOs(tol) result (res) ::: PURE
   ! Returns the number of non-zero occupied NAOs. For this purpose,
   ! zero is defined to be "tol" if present, or 1/14. See ROBY.
      self :: IN
      tol :: REAL, optional, IN
      res :: INT

   ENSURE(self(1).NAO_occupations.allocated,"no ANO occupations")

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).no_of_occupied_NAOs(tol)
      end

   end

   no_of_occupied_ANOs(ANOkind,tol) result (res) ::: PURE
   ! Returns the number of non-zero occupied atomic natural orbitals. For this
   ! purpose, zero is defined to be "tol" if present, or TOL(7) otherwise
      self :: IN
      ANOkind :: STR, optional, IN
      tol :: REAL, optional, IN
      res :: INT

   ENSURE(self(1).NO_occ_nos.allocated,"no occupation numbers")

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).no_of_occupied_NOs(ANOkind,tol)
      end

   end

!  ===============================
!  Basis set existence information
!  ===============================

   bases_are_resolved result (res) ::: template, pure
   ! Return TRUE if all basis sets are associated AND their shell list
   ! parts are also associated, dummy-atoms excepted
      self :: IN
      res :: BIN

      a :: INT

      res = TRUE

      do a = 1,.dim

         if (self(a).TEST?.is_created_and_resolved) cycle
         if (self(a).has_a_dummy_label) cycle

         res = FALSE
         exit

      end

   end

   bases_are_resolved result (res) ::: get_from(VEC{ATOM}:bases_are_resolved, TEST?=>basis), pure
   ! Return TRUE if all basis sets are associated AND their shell list
   ! parts are also associated, dummy-atoms excepted
   end

   slaterbases_are_resolved result (res) ::: get_from(VEC{ATOM}:bases_are_resolved, TEST?=>slaterbasis), pure
   ! Return TRUE if all basis sets are associated AND their shell list
   ! parts are also associated, dummy-atoms excepted
   end

   coppensbases_are_resolved result (res) ::: get_from(VEC{ATOM}:bases_are_resolved, TEST?=>coppensbasis), pure
   ! Return TRUE if all basis sets are associated AND their shell list
   ! parts are also associated, dummy-atoms excepted
   end

   bases_are_all_labeled result (res) ::: template, pure
   ! Return TRUE if all basis set labels exist (i.e. are not blank)
   ! Note: If a dummy atom has a basis it should have a label
      self :: IN
      res :: BIN

      a :: INT

      res = TRUE

      do a = 1,.dim

         if (self(a).TEST?.is_created_and_has_label) cycle
         if (self(a).has_a_dummy_label) cycle

         res = FALSE
         exit

      end

   end

   bases_are_all_labeled result (res) ::: get_from(VEC{ATOM}:bases_are_all_labeled, TEST?=>basis), pure
   ! Return TRUE if all basis set labels exist (i.e. are not blank)
   ! Note: If a dummy atom has a basis it should have a label
   end

   slaterbases_are_all_labeled result (res) ::: get_from(VEC{ATOM}:bases_are_all_labeled, TEST?=>slaterbasis), pure
   ! Return TRUE if all basis set labels exist (i.e. are not blank)
   ! Note: If a dummy atom has a basis it should have a label
   end

   coppensbases_are_all_labeled result (res) ::: get_from(VEC{ATOM}:bases_are_all_labeled, TEST?=>coppensbasis), pure
   ! Return TRUE if all basis set labels exist (i.e. are not blank)
   ! Note: If a dummy atom has a basis it should have a label
   end


   get_distance_to(atomvec,distance,t1,t2) ::: PURE
   ! Calculates the shortest distance between an atom in self and one in
   ! atomvec.  Will set the distance to zero if calculated to less than 10^-6.
   ! If present, t1 and t2 are the indices of the two closest atoms.
      self :: IN
      atomvec :: VEC{ATOM}, IN
      distance :: REAL, OUT
      t1,t2 :: INT, optional, OUT

   ENSURE(present(t1) EQV present(t2),"need 0 or 2 optional arguments")

      dist :: REAL
      i,j,dim1,dim2 :: INT
      difference :: VEC{REAL}(3)

      dim1 = .dim
      dim2 = size(atomvec)

      ! Do the first pair explicitly to set a starting distance.
      ! We also work with distance^2 until the end - saves computation.
      difference = self(1).position(:) - atomvec(1).position(:)
      distance   = dot_product(difference,difference)

      do i = 1,dim1
      do j = 1,dim2

         difference = self(i).position(:) - atomvec(j).position(:)
         dist       = dot_product(difference,difference)

         if (dist < TOL(6)) dist = ZERO

         if (dist < distance) then
            distance = dist
            if (present(t1)) then
               t1 = i
               t2 = j
            end
         end

      end
      end

      distance = sqrt(distance)

   end

   get_distance_to(pos,distance,t1) ::: PURE
   ! Calculates the shortest distance of "pos" to an atom in self.
   ! If present, t1 is the index of the closest atom.
      self :: IN
      pos :: VEC{REAL}(3), IN
      distance :: REAL, OUT
      t1 :: INT, optional, OUT

      dist :: REAL
      difference :: VEC{REAL}(3)
      i :: INT

      ! Do the first pair explicitly to set a starting distance.
      ! We also work with distance^2 until the end - saves computation.
      difference = self(1).position(:) - pos(:)
      distance   = dot_product(difference,difference)

      do i = 1, .dim

         difference = self(i).position(:) - pos(:)
         dist       = dot_product(difference,difference)

         if (dist < TOL(6)) dist = ZERO

         if (dist < distance) then
            distance = dist
            if (present(t1)) t1=i
         end

      end

      distance = sqrt(distance)

   end

   same_as(atomvec) result (res) ::: PURE
   ! Returns true if the two atomvecs contain the same atoms, though maybe in a
   ! different order.  Checks atomic number and position of each atom, but not
   ! the basis sets.
      self :: IN
      atomvec :: VEC{ATOM}, IN
      res :: BIN

      matched :: VEC{BIN}(size(self))
      match_pos,match_kind,match :: BIN
      n,q,dim :: INT

      res = FALSE
      dim = .dim
      if (dim/=size(atomvec)) return ! different number of atoms in each.
      matched = FALSE

      do n = 1, dim
         match=FALSE
         do q = 1, dim
            match_kind =  self(n).atomic_number == atomvec(q).atomic_number
            match_pos  =  self(n).position.same_as( atomvec(q).position, TOL(3) )
            if (match_pos AND match_kind AND (NOT matched(q))) then
               matched(q) = TRUE
               match = TRUE
               exit
            end
         end
         if (NOT match) return ! atom n doesn't have a match.
      end

      do q = 1, dim           ! If not all of q are matched then atomvecs not same.
         if (NOT matched(q)) return
      end

      res = TRUE

   end

!  =============
!  Crystal stuff
!  =============

   translate_by(v) ::: PURE
   ! Translate self by vector.
      self :: INOUT
      v :: VEC{REAL}(3), IN

      pos :: VEC{REAL}(3)
      a :: INT

      if (v.is_zero) return

      do a = 1,.dim
         pos = self(a).position + v
         self(a).set_position(pos)
      end

   end

   rotate_by(matrix) ::: PURE
   ! Rotate the atom positions by the rotation matrix
      self :: INOUT
      matrix :: MAT{REAL}(3,3), IN

      .rotate_positions_by(matrix)
      .rotate_ADP_tensors_by(matrix)

   end

   rotate_positions_by(matrix) ::: PURE
   ! Rotate the atom positions by the rotation matrix
      self :: INOUT
      matrix :: MAT{REAL}(3,3), IN

      a :: INT
      pos :: VEC{REAL}(3)

      do a = 1,.dim
         pos.to_product_of(matrix,self(a).position)
         self(a).set_position(pos)
      end

   end

   rotate_ADP_tensors_by(matrix) ::: PURE
   ! Rotate the atom ADP (thermal) tensors by the rotation matrix:
   ! this is the rotation matrix which transforms the cartesian
   ! position to a new position.
   ! WARNING: does not do ADP3 and ADP4 yet
      self :: INOUT
      matrix :: MAT{REAL}(3,3), IN

      a :: INT
      ADP :: MAT{REAL}(3,3)

      do a = 1,.dim
         self(a).ADP_tensor.back_transform_to(ADP,matrix)
         self(a).set_ADP_tensor(ADP)
      end

   end

   change_ADP_axis_system_to(axis_system,cell)
   ! Convert all ADP tensors into the desired "axis_system".
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN

      a :: INT

      do a = 1,.dim
         self(a).change_ADP_axis_system_to(axis_system,cell)
      end

   end

   default_multiplicity result (res)
   ! Return the default multiplicity
      self :: IN
      res :: REAL

      if (.dim==1) then
         res = self(1).ground_state_multiplicity
      else
         res = mod(.no_of_electrons,2) + 1
      end

   end

   translate_group(g,v) ::: PURE
   ! Translate group "g" by vector "v".
      self :: INOUT
      g :: INT, IN
      v :: VEC{REAL}(3), IN

      pos :: VEC{REAL}(3)
      a :: INT

      if (v.is_zero) return
      if (all(self(:).group/=g)) return

      do a = 1,.dim

         if (self(a).group/=g) cycle

         pos = self(a).position + v
         self(a).set_position(pos)

      end

   end

!  ====
!  Dump
!  ====

   dump(object_name) ::: get_from(VEC{OBJECT})
   ! Dump a vector object
   end

   dmpa(object_name) ::: get_from(VEC{OBJECT})
   ! Dump an allocatable vector object
   end

!  ==============
!  Output methods
!  ==============

   put
   ! Output atom information, without full basis set info
      self :: IN

      stdout.flush
      stdout.text("=====================")
      stdout.text("Atom list information")
      stdout.text("=====================")
      stdout.flush

      stdout.show("Chemical Formula       =",trim(.chemical_formula(with_spaces=TRUE)))
      stdout.show("No of atoms            =",size(self))
      stdout.show("No of electrons        =",.no_of_electrons)

      .put_coordinate_info

    ! if (.has_restraints)          .put_restraint_atoms

   end

   put_list
   ! Output atom information,
      self :: IN

      a :: INT
      title :: STR

      stdout.flush
      stdout.text("=====================")
      stdout.text("Atom list information")
      stdout.text("=====================")
      stdout.flush

      stdout.show("Chemical Formula       =",trim(.chemical_formula(with_spaces=TRUE)))
      stdout.show("No of atoms            =",size(self))
      stdout.show("No of electrons        =",.no_of_electrons)
      stdout.flush

      do a = 1,.dim
         title = "Atom "//trim(a.to_str)
         stdout.text(trim(title))
         stdout.text(repeat("=",len_trim(title)))
         self(a).put
         stdout.flush
      end

   end

   put_coordinate_info
   ! Output atom coordinate information, including bond lengths, angles
      self :: IN

      .put_coordinates

      if (.has_nonzero_ADP_tensors) .put_ADPs

      if (ATOM:xray_dispersion_entered()) .put_dispersion_factors

      .put_bond_length_table
      .put_bond_angle_table
      .put_torsion_angle_table

   end

!  ======================
!  Coordinate information
!  ======================

   put_coordinates(no_header)
   ! Output the atom coordinates information.
      self :: IN
      no_header :: BIN, optional, IN

      if      (.has_disorder) then; .put_coords_disorder_y(no_header)
      else if (.has_groups)   then; .put_coords_groups_y(no_header)
      else;                         .put_coords(no_header)
      end

   end

   put_coords(no_header) ::: private
   ! Output the atom coordinates information without disorder
      self :: IN
      no_header :: BIN, optional, IN

      fac :: REAL
      xyz,err :: MAT{REAL}@
      table :: VEC{TABLE_COLUMN}@
      la,lb,ka,kb :: INT
      cartesian,header,has_unique_labels :: BIN

      header = TRUE
      if (present(no_header)) header = NOT no_header

      ! Axis system
      cartesian = self(1).pos_axis_system=="cartesian"

      ! Use angstroms
      if (cartesian) then
         fac = STR:conversion_factor("angstrom")
      else
         fac = ONE
      end

      ! Table column data
      xyz.create(.dim,3)
      err.create(.dim,3)

      ! Get table column data
      .put_pos_vector_to(xyz,fac)
      .put_pos_errors_to(err,fac)

      ! Title
      if (header) then
      stdout.flush
      stdout.flush
      stdout.text("================")
      stdout.text("Atom coordinates")
      stdout.text("================")
      end

      ! Has unique labels?
      .get_1st_repeated_labels(la,lb)
      .get_1st_repeated_xtal_kinds(ka,kb)
      has_unique_labels = (la==0 AND ka==0) OR .dim==1

      ! Unique labels?
      if (has_unique_labels) then

         ! Unique labels
         if (header) then
         if (NOT cartesian) then
         stdout.flush
         stdout.text(". The coordinates are referred to cell axes")
         end
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush
         end

         ! Table headings
         table.create(5)
         table(1).set_heading("ID")
         table(2).set_heading("Z")
         table(2).set_subheading("/au")
         table(2).set_real_precision(1)
         table(3).set_heading("- x -")
         table(4).set_heading("- y -")
         table(5).set_heading("- z -")
         if (cartesian) then
         table(4).set_subheading("/A")
         end

         ! Set table column data
         table(1).set_values(self(:).label)
         table(2).set_real_precision(1)
         table(2).set_values(self(:).nuclear_charge)
         if (NOT .has_nonzero_pADP2_errors) then
         table(3).set_values(xyz(:,1))
         table(4).set_values(xyz(:,2))
         table(5).set_values(xyz(:,3))
         else
         table(3).set_values_and_errors(xyz(:,1),err(:,1))
         table(4).set_values_and_errors(xyz(:,2),err(:,2))
         table(5).set_values_and_errors(xyz(:,3),err(:,3))
         end

      else 

         ! Not unique labels
         if (header) then
         if (NOT cartesian) then
         stdout.flush
         stdout.text(". The coordinates are referred to cell axes")
         end
         stdout.flush
         stdout.text(". Unique atom labels were not set for each atom.")
         stdout.text("  Therefore, unique ID tags are provided.")
         if (la/=0) then
         stdout.flush
         stdout.text(". First repeated labels are for atoms "//trim(la.to_str)//" and "//trim(lb.to_str)//".")
         end
         if (ka/=0) then
         stdout.flush
         stdout.text(". First repeated xtal kinds are for atoms "//trim(ka.to_str)//" and "//trim(kb.to_str)//".")
         end
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush
         end

         ! Table headings
         table.create(6)
         table(1).set_heading("Label")
         table(2).set_heading("ID")
         table(2).set_subhead("tag")
         table(3).set_real_precision(1)
         table(3).set_heading("Z")
         table(3).set_subheading("/au")
         table(3).set_real_precision(1)
         table(4).set_heading("- x -")
         table(5).set_heading("- y -")
         table(6).set_heading("- z -")
         if (cartesian) then
         table(5).set_subheading("/A")
         end

         ! Set table column data
         table(1).set_values(self(:).label)
         table(2).set_values(self(:).tag)
         table(3).set_values(self(:).nuclear_charge)
         if (NOT .has_nonzero_pADP2_errors) then
         table(4).set_values(xyz(:,1))
         table(5).set_values(xyz(:,2))
         table(6).set_values(xyz(:,3))
         else
         table(4).set_values_and_errors(xyz(:,1),err(:,1))
         table(5).set_values_and_errors(xyz(:,2),err(:,2))
         table(6).set_values_and_errors(xyz(:,3),err(:,3))
         end

      end

      ! Make the table
      table.put

      ! Clean
      table.destroy
      err.destroy
      xyz.destroy

   end

   put_coords_disorder_y(no_header) ::: private
   ! Output the atom coordinates information with disorder
      self :: IN
      no_header :: BIN, optional, IN

      fac :: REAL
      xyz :: MAT{REAL}@
      Z,occ  :: VEC{REAL}@
      lab,ID :: VEC{STR}@
      grp    :: VEC{INT}@
      table :: VEC{TABLE_COLUMN}@
      la,lb,ka,kb :: INT
      cartesian,header,has_unique_labels :: BIN

      header = TRUE
      if (present(no_header)) header = NOT no_header

      ! Axis system
      cartesian = self(1).pos_axis_system=="cartesian"

      ! Use angstroms
      if (cartesian) then
         fac = STR:conversion_factor("angstrom")
      else
         fac = ONE
      end

      ! Title
      if (header) then
      stdout.flush
      stdout.flush
      stdout.text("================")
      stdout.text("Atom coordinates")
      stdout.text("================")
      end

      ! Table column data
      lab.create(.dim)
      ID.create(.dim)
      Z.create(.dim)
      grp.create(.dim)
      occ.create(.dim)
      xyz.create(.dim,3)

      ! Get table column data
      .put_coordinates_to(xyz,positions_as_rows=TRUE)
      xyz = xyz * fac

      ! Has unique labels?
      .get_1st_repeated_labels(la,lb)
      .get_1st_repeated_xtal_kinds(ka,kb)
      has_unique_labels = (la==0 AND ka==0) OR .dim==1

      ! Unique labels?
      if (has_unique_labels) then

         if (header) then
         if (NOT cartesian) then
         stdout.flush
         stdout.text(". The coordinates are referred to cell axes")
         end
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush
         end

         ! Table headings
         table.create(7)
         table(1).set_heading("ID")
         table(2).set_heading("Z")
         table(2).set_subhead("/au")
         table(2).set_real_precision(1)
         table(3).set_heading("Group")
         table(3).set_subhead("#")
         table(4).set_heading("Site")
         table(4).set_subhead("occupancy")
         table(5).set_heading("- x -")
         table(6).set_heading("- y -")
         table(7).set_heading("- z -")
         if (cartesian) then
         table(6).set_subhead("/A")
         end

         ! Set table column data
         table(1).set_values(self(:).label)
         table(2).set_real_precision(1)
         table(2).set_values(self(:).nuclear_charge)
         table(3).set_values(self(:).site_disorder_group)
         table(4).set_values(self(:).site_occupancy)
         table(5).set_values(xyz(:,1))
         table(6).set_values(xyz(:,2))
         table(7).set_values(xyz(:,3))

      else ! Not unique labels

         if (header) then
         if (NOT cartesian) then
         stdout.flush
         stdout.text(". The coordinates are referred to cell axes")
         end
         stdout.flush
         stdout.text(". Unique atom labels were not set for each atom.")
         stdout.text("  Therefore, unique ID tags are provided.")
         if (la/=0) then
         stdout.flush
         stdout.text(". First repeated labels are for atoms "//trim(la.to_str)//" and "//trim(lb.to_str)//".")
         end
         if (ka/=0) then
         stdout.flush
         stdout.text(". First repeated xtal kinds are for atoms "//trim(ka.to_str)//" and "//trim(kb.to_str)//".")
         end
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush
         end

         ! Table headings
         table.create(8)
         table(1).set_heading("Label")
         table(2).set_heading("ID")
         table(2).set_subhead("tag")
         table(3).set_heading("Z")
         table(3).set_subhead("/au")
         table(4).set_real_precision(1)
         table(4).set_heading("Group")
         table(4).set_subhead("#")
         table(5).set_heading("Site")
         table(5).set_subhead("occupancy")
         table(6).set_heading("- x -")
         table(7).set_heading("- y -")
         table(8).set_heading("- z -")
         if (cartesian) then
         table(7).set_subhead("/A")
         end

         ! Set table column data
         table(1).set_values(self(:).label)
         table(2).set_values(self(:).tag)
         table(3).set_real_precision(1)
         table(3).set_values(self(:).nuclear_charge)
         table(4).set_values(self(:).site_disorder_group)
         table(5).set_values(self(:).site_occupancy)
         table(6).set_values(xyz(:,1))
         table(7).set_values(xyz(:,2))
         table(8).set_values(xyz(:,3))

      end

      ! Make the table
      table.put

      ! Clean
      table.destroy
      xyz.destroy

   end

   put_coords_groups_y(no_header) ::: private
   ! Output the atom coordinates with groups (no disorder)
      self :: IN
      no_header :: BIN, optional, IN

      fac :: REAL
      xyz :: MAT{REAL}@
      table :: VEC{TABLE_COLUMN}@
      la,lb,ka,kb :: INT
      cartesian,header,has_unique_labels :: BIN

      header = TRUE
      if (present(no_header)) header = NOT no_header

      ! Axis system
      cartesian = self(1).pos_axis_system=="cartesian"

      ! Use angstroms
      if (cartesian) then
         fac = STR:conversion_factor("angstrom")
      else
         fac = ONE
      end

      ! Title
      if (header) then
      stdout.flush
      stdout.flush
      stdout.text("================")
      stdout.text("Atom coordinates")
      stdout.text("================")
      end

      ! Table column data
      xyz.create(.dim,3)

      ! Get table column data
      .put_coordinates_to(xyz,positions_as_rows=TRUE)
      xyz = xyz * fac

      ! Has unique labels?
      .get_1st_repeated_labels(la,lb)
      .get_1st_repeated_xtal_kinds(ka,kb)
      has_unique_labels = (la==0 AND ka==0) OR .dim==1

      ! Unique labels?
      if (has_unique_labels) then

         if (header) then
         if (NOT cartesian) then
         stdout.flush
         stdout.text(". The coordinates are referred to cell axes")
         end
         stdout.flush
         stdout.text(". This molecule has non trivial group indices, assigned")
         stdout.text("  explicitly or by CCDC connectivity criteria")
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush
         end

         ! Table headings
         table.create(6)
         table(1).set_heading("ID");    table(1).set_values(self(:).label)
         table(2).set_real_precision(1)
         table(2).set_heading("Z");     table(2).set_values(self(:).nuclear_charge)
         table(2).set_subhead("/au")
         table(3).set_heading("Grp");   table(3).set_values(self(:).group)
         table(3).set_subhead("#")
         table(4).set_heading("- x -"); table(4).set_values(xyz(:,1))
         table(5).set_heading("- y -"); table(5).set_values(xyz(:,2))
         table(6).set_heading("- z -"); table(6).set_values(xyz(:,3))
         if (cartesian) then
         table(5).set_subhead("/A")
         end

      else ! Not unique labels

         if (header) then
         if (NOT cartesian) then
         stdout.flush
         stdout.text(". The coordinates are referred to cell axes")
         end
         stdout.flush
         stdout.text(". This molecule has non trivial group indices, assigned")
         stdout.text("  explicity, or by CCDC connectivity criteria")
         stdout.flush
         stdout.text(". Unique atom labels were not set for each atom.")
         stdout.text("  Therefore, unique ID tags are provided.")
         if (la/=0) then
         stdout.flush
         stdout.text(". First repeated labels are for atoms "//trim(la.to_str)//" and "//trim(lb.to_str)//".")
         end
         if (ka/=0) then
         stdout.flush
         stdout.text(". First repeated xtal kinds are for atoms "//trim(ka.to_str)//" and "//trim(kb.to_str)//".")
         end
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush
         end

         ! Table headings
         table.create(7)
         table(1).set_heading("Label"); table(1).set_values(self(:).label)
         table(2).set_heading("ID");    table(2).set_values(self(:).tag)
         table(2).set_subhead("tag")
         table(3).set_real_precision(1)
         table(3).set_heading("Z");     table(3).set_values(self(:).nuclear_charge)
         table(3).set_subhead("/au")
         table(4).set_heading("Group"); table(4).set_values(self(:).group)
         table(4).set_subhead("#")
         table(5).set_heading("- x -"); table(5).set_values(xyz(:,1))
         table(6).set_heading("- y -"); table(6).set_values(xyz(:,2))
         table(7).set_heading("- z -"); table(7).set_values(xyz(:,3))
         if (cartesian) then
         table(6).set_subhead("/A")
         end

         ! Set table column data

      end

      ! Make the table
      table.put

      ! Clean
      table.destroy
      xyz.destroy

   end

   put_xyz_file(name, units)
   ! Output the coordinates in XYZ file format with "name" header
      self :: IN
      name :: STR, optional, IN
      units :: STR, optional, IN

      n,a :: INT
      filename, u :: STR
      pos :: VEC{REAL}(3)

      ! Filename
      filename = "geometry"
      if (present(name)) filename = name

      ! Units
      u = "angstroms"
      if (present(units)) u = units

      ! Redirect
      stdout.redirect(trim(filename)//".xyz")

      ! No. pf atoms
      n = .dim
      stdout.put(trim(n.to_str),width=3)
      stdout.flush

      ! Header
      stdout.put(trim(name),width=len_trim(name))
      stdout.flush

      ! Labels & coordinates
      do a = 1,n

         stdout.put(trim(self(a).chemical_symbol),width=3)
         pos = self(a).position
         stdout.put(pos(1).to_units(u),width=10,precision=5)
         stdout.put(pos(2).to_units(u),width=10,precision=5)
         stdout.put(pos(3).to_units(u),width=10,precision=5)
         stdout.flush

      end

      ! Revert
      stdout.revert

   end


   put_core_electrons 
   ! Output the no. of core electrons (if any)
      self :: IN

      table :: VEC{TABLE_COLUMN}@

      if (NOT .has_core_electrons) return

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("=====================================")
      stdout.text("Atom effective core potentials (ECPs)")
      stdout.text("=====================================")

      stdout.flush
      stdout.text(". Some atoms have effectivr core potentials (ECPs)")
      stdout.text(". The number of core electrons replaced is shown below")
      stdout.flush

      ! Table headings
      table.create(3)
      table(1).set_heading("tag")
      table(2).set_heading("Z")
      table(2).set_subheading("/au")
      table(3).set_heading("# of core")
      table(3).set_subhead("electrons")

      ! Set table column data
      table(1).set_values(self(:).tag)
      table(2).set_real_precision(1)
      table(2).set_values(self(:).nuclear_charge)
      table(3).set_values(self(:).n_core_electrons)


      ! Make the table
      table.put

      ! Clean
      table.destroy

   end


   put_bases
   ! Output the atom bases
      self :: IN

      table :: VEC{TABLE_COLUMN}@
      lab :: VEC{STR}@
      i :: INT

      if (NOT .bases_are_resolved) return

      ! Get table column data
      lab.create(.dim)
      do i = 1,.dim
         lab(i) = self(i).basis.label
      end

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("==========")
      stdout.text("Atom bases")
      stdout.text("==========")
      stdout.flush

      stdout.show("No. of atoms =",.dim)
      stdout.flush

      ! Table headings
      table.create(3)
      table(1).set_heading("ID")
      table(2).set_heading("Z")
      table(2).set_subheading("/au")
      table(2).set_real_precision(1)
      table(3).set_heading("Basis")
      table(3).set_subhead("label")

      ! Set table column data
      table(1).set_values(self(:).tag)
      table(2).set_values(self(:).nuclear_charge)
      table(3).set_values(lab)

      ! Make the table
      table.put

      ! Clean
      table.destroy
      lab.destroy

   end


   put_g09_input(name, units)
   ! Output the coordinates in XYZ file format with "name" header
      self :: IN
      name :: STR, optional, IN
      units :: STR, optional, IN

      n,a :: INT
      filename, u :: STR
      pos :: VEC{REAL}(3)

      ! Filename
      filename = "input"
      if (present(name)) filename = name
      u = "angstroms"
      if (present(units)) u = units

      ! Redirect
      stdout.redirect(trim(filename)//".gjf")

      ! No. pf atoms
      n = .dim
      stdout.text("#P B3LYP/6-31G(d,p) 6d 10f NoSymm FChk")
      stdout.flush
      ! Header
      stdout.text(trim(name))
      stdout.flush


      ! Labels & coordinates
      stdout.text("0 1")
      do a = 1,n

         stdout.put(trim(self(a).chemical_symbol),width=3)
         pos = self(a).position
         stdout.put(pos(1).to_units(u),width=10,precision=5)
         stdout.put(pos(2).to_units(u),width=10,precision=5)
         stdout.put(pos(3).to_units(u),width=10,precision=5)
         stdout.flush

      end

      stdout.flush
      ! Revert
      stdout.revert

   end


!   put_pdb(pdbfile)
!   ! Output the atoms in pdb file format to "pdbfile" (blame Birger)
!      pdbfile :: TEXTFILE*
!
!      i,in,ic,ip,len_code,len_pnum,element_len :: INT
!      label,element_name,residue_number,code,three_letter_code,position_symbol,position_number :: STR
!
!      ! Save PDB settings for later
!      pdbfile.save
!
!      ! Loop over atoms
!      do i = 1,.dim
!
!         ! The ATOM number
!         pdbfile.put("ATOM",width=4)
!         pdbfile.put(i,width=7)
!
!         ! Start to analyze the atom label
!         label = self(i).label
!       ! print *,"label =",trim(label)
!
!         ! Get start of atom index, hence the element name
!         label.replace_all("(",'')
!         label.replace_all(")",'')
!         in = label.index_of_digit
!         DIE_IF(in==0,"no atom index in atom label: "//trim(label))
!         ! Get rid of left bracket
!         element_name = label(1:in-1)
!       ! print *,"in =",in
!       ! print *,"element_name =",trim(element_name)
!
!         ! Get start of residue code, hence the residue number
!         ic = label(in:).index_of_nondigit
!         DIE_IF(ic==0,"no residue code in atom label: "//trim(label))
!         ic = ic + in - 1
!         residue_number = label(in:ic-1)
!       ! print *,"ic =",ic
!       ! print *,"residue_number =",trim(residue_number)
!
!         ! Get start of position symbol, hence residue code, position
!         ! symbol and position number (could be blank)
!         ! position symbols are alpha (a)
!         ! position symbols are beta (b)
!         ! position symbols are gamma (c,g)
!         ! position symbols are delta (d)
!         ! position symbols are epsilon (e)
!         ! position symbols are nu (n)
!         ! position symbols are terminal (t)
!         ! position symbols are zeta (z)
!         ! position symbols are peptide bond (')
!
!         ip = label(ic:).index_of_character_in("'abcgdentz")
!         if (ip/=0) then
!            ip = ip + ic - 1
!            code = label(ic:ip-1)
!            position_symbol = label(ip:ip)
!            position_number = label(ip+1:)
!         else
!            code = label(ic:)
!            position_symbol = " "
!            position_number = " "
!         end
!       ! print *,"ip =",ip
!       ! print *,"code =",trim(code)
!       ! print *,"position_symbol =",trim(position_symbol)
!       ! print *,"position_number =",trim(position_number)
!
!         ! Do some checks ...
!         len_code = len_trim(code)
!         DIE_IF(NOT (len_code==1 OR len_code==3),"residue code must be 1 or 3 characters: "//trim(label))
!         len_pnum = len_trim(position_number)
!         DIE_IF(len_pnum>1,"position number code cannot exceed 1 character: "//trim(label))
!         if (position_number/=" ") then
!         DIE_IF(NOT position_number.is_included_in("123456789"),"unknown position number: "//trim(label))
!         end
!
!         ! If the code is a one letter code, convert it
!         if (len_code == 3) then
!            select case (code)
!               case ("UNK","AIB","IVA","WAT","EOH","TER","DLE","DVA","FOR","ETA")
!               case ("ALA","ARG","GLN","GLY","VAL","LEU","ILE","SER","THR","CYS")
!               case ("MET","PRO","HIS","ASN","GLU","ASP","PHE","TRP","TYR","LYS")
!               case ("ACD","HSE","ACE","HYP","HYL","ALB","ALI","ABU","ARO","ORN")
!               case ("ASX","PCA","BAS","SAR","BET","TAU","THY","GLX","HET")
!               case default; DIE("unknown three letter residue code: "//trim(code))
!            end
!            three_letter_code = code
!         else if (len_code == 1) then
!            select case (code)
!               case ("X"); three_letter_code = "UNK"
!               case ("~"); three_letter_code = "WAT"
!               case ("_"); three_letter_code = "EOH"
!               case ("B"); three_letter_code = "DLE"
!               case ("O"); three_letter_code = "DVA"
!               case ("U"); three_letter_code = "AIB"
!               case ("A"); three_letter_code = "ALA"
!               case ("R"); three_letter_code = "ARG"
!               case ("Q"); three_letter_code = "GLN"
!               case ("G"); three_letter_code = "GLY"
!               case ("V"); three_letter_code = "VAL"
!               case ("L"); three_letter_code = "LEU"
!               case ("I"); three_letter_code = "ILE"
!               case ("J"); three_letter_code = "IVA"
!               case ("S"); three_letter_code = "SER"
!               case ("T"); three_letter_code = "THR"
!               case ("C"); three_letter_code = "CYS"
!               case ("M"); three_letter_code = "MET"
!               case ("P"); three_letter_code = "PRO"
!               case ("H"); three_letter_code = "HIS"
!               case ("N"); three_letter_code = "ASN"
!               case ("E"); three_letter_code = "GLU"
!               case ("D"); three_letter_code = "ASP"
!               case ("F"); three_letter_code = "PHE"
!               case ("W"); three_letter_code = "TRP"
!               case ("Y"); three_letter_code = "TYR"
!               case ("K"); three_letter_code = "LYS"
!               case ("Z"); three_letter_code = "TER"
!               case default; DIE("unknown one letter residue code: "//trim(code))
!            end
!         else
!            DIE("code must be one or three characters")
!         end
!
!         ! Print the new atom label from one read in
!         pdbfile.tab(width=1)
!         if (position_number==" ") then
!         pdbfile.tab(width=1)
!         else
!         pdbfile.put(position_number,width=1,left=TRUE)
!         end
!         pdbfile.put(element_name,width=len_trim(element_name),left=TRUE)
!         if (position_symbol.is_included_in("'abcgdentz")) then
!         position_symbol.to_upper_case
!         pdbfile.put(position_symbol,width=1,left=TRUE)
!         pdbfile.tab(width=1)
!         else
!         pdbfile.tab(width=2)
!         end
!         element_len = len_trim(element_name)
!         if (element_len == 1) then
!         pdbfile.tab(width=1)
!         end
!         pdbfile.put(three_letter_code,width=3,left=TRUE)
!         pdbfile.tab(width=2)
!         pdbfile.put(residue_number,width=4)
!         pdbfile.tab(width=4)
!         pdbfile.set_real_precision(3)
!         pdbfile.set_real_width(8)
!         pdbfile.put(self(i).position(1).to_units("angstrom"))
!         pdbfile.put(self(i).position(2).to_units("angstrom"))
!         pdbfile.put(self(i).position(3).to_units("angstrom"))
!         pdbfile.set_real_precision(2)
!         pdbfile.set_real_width(6)
!         pdbfile.put(self(i).site_occupancy)
!         pdbfile.put(8*PI*PI*self(i).U_iso)
!         pdbfile.put(self(i).chemical_symbol,width=12)
!         pdbfile.flush
!
!         ! Print Anisotropic U's if non-hydrogen
!         if (self(i).atomic_number==1) cycle
!
!         pdbfile.put("ANISOU",width=6)
!         pdbfile.put(i,width=5)
!         pdbfile.tab(width=1)
!         if (position_number==" ") then
!         pdbfile.tab(width=1)
!         else
!         pdbfile.put(position_number,width=1,left=TRUE)
!         end
!         pdbfile.put(element_name,width=len_trim(element_name),left=TRUE)
!         if (position_symbol.is_included_in("'ABCGDENTZ")) then
!         position_symbol.to_upper_case
!         pdbfile.put(position_symbol,width=1,left=TRUE)
!         pdbfile.tab(width=1)
!         else
!         pdbfile.tab(width=2)
!         end
!         element_len = len_trim(element_name)
!         if (element_len == 1) then
!         pdbfile.tab(width=1)
!         end
!         pdbfile.put(three_letter_code,width=3,left=TRUE)
!         pdbfile.tab(width=2)
!         pdbfile.put(residue_number,width=4)
!         pdbfile.tab(width=2)
!         pdbfile.set_int_width(7)
!
!         ! Order for the ADP's .......
!         ! u11 u22 u33 u12 u13 u23 XD-format
!         ! u11 u22 u33 u12 u23 u13 SHELX
!         ! u11 u22 u33 u13 u23 u12 PDB-format
!         pdbfile.put(nint(self(i).ADP_tensor(1,1).to_units("angstrom^2")*10000))
!         pdbfile.put(nint(self(i).ADP_tensor(2,2).to_units("angstrom^2")*10000))
!         pdbfile.put(nint(self(i).ADP_tensor(3,3).to_units("angstrom^2")*10000))
!         pdbfile.put(nint(self(i).ADP_tensor(1,3).to_units("angstrom^2")*10000))
!         pdbfile.put(nint(self(i).ADP_tensor(2,3).to_units("angstrom^2")*10000))
!         pdbfile.put(nint(self(i).ADP_tensor(1,2).to_units("angstrom^2")*10000))
!
!         ! Last thing on line, chemical symbol
!         pdbfile.put(self(i).chemical_symbol,width=8)
!
!         ! Flush the line
!         pdbfile.flush
!
!      end
!      pdbfile.unsave
!   end


   put_coordinates_and_charges
   ! Output the atom coordinate information
      self :: IN

      .put_coords_and_charges
      .put_coords_and_charges(angstrom=TRUE)

   end

   put_coords_and_charges(angstrom) ::: private
   ! Output the atom coordinates and charges
      self :: IN
      angstrom :: BIN, optional, IN

      i :: INT
      in_angstrom :: BIN

      in_angstrom = FALSE
      if (present(angstrom)) in_angstrom = angstrom

      stdout.flush
      if (NOT in_angstrom) then
      stdout.text("Atom list information:")
      else
      stdout.text("Atom list information (in angstrom):")
      end

      stdout.dash(int_fields=3,real_fields=4)
      stdout.put("#",int_width=TRUE)
      stdout.put("ID",int_width=TRUE)
      stdout.put("Z",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.put("charge")
      stdout.flush
      stdout.dash(int_fields=3,real_fields=4)
      do i = 1,.dim
         stdout.put(i)
         stdout.put(self(i).label,int_width=TRUE)
         stdout.put(self(i).nuclear_charge,int_width=TRUE)
         if (NOT in_angstrom) then
         stdout.put(self(i).position(1))
         stdout.put(self(i).position(2))
         stdout.put(self(i).position(3))
         else
         stdout.put(self(i).position(1).to_units("angstrom"))
         stdout.put(self(i).position(2).to_units("angstrom"))
         stdout.put(self(i).position(3).to_units("angstrom"))
         end
         stdout.put(self(i).charge)
         stdout.flush
      end
      stdout.dash(int_fields=3,real_fields=4)

   end


   put_kinds_and_groups
   ! Output the atom kinds and groups
      self :: IN

      table :: VEC{TABLE_COLUMN}@
      la,lb,ka,kb :: INT
      has_unique_labels :: BIN

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("=====================")
      stdout.text("Atom kinds and groups")
      stdout.text("=====================")

      ! Has unique labels?
      .get_1st_repeated_labels(la,lb)
      .get_1st_repeated_xtal_kinds(ka,kb)
      has_unique_labels = (la==0 AND ka==0) OR .dim==1

      ! Unique labels?
      if (has_unique_labels) then

         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush

         ! Table headings
         table.create(6)
         table(1).set_heading("ID")
         table(2).set_heading("Z")
         table(3).set_heading("Atom")
         table(3).set_subhead("kind")
         table(4).set_heading("Unique")
         table(4).set_subhead("kind?")
         table(5).set_heading("Molecule")
         table(5).set_subhead("group")
         table(6).set_heading("Disorder")
         table(6).set_subhead("group")

         ! Set table column data
         table(1).set_values(self(:).label)
         table(2).set_values(self(:).atomic_number)
         table(3).set_values(self(:).kind)
         table(4).set_values(self(:).is_unique_kind)
         table(5).set_values(self(:).group)
         table(6).set_values(self(:).site_disorder_group)

      else ! Not unique labels

         stdout.flush
         stdout.text(". Unique atom labels were not set for each atom.")
         stdout.text("  Therefore, unique symbol-number ID tags are used.")
         if (la/=0) then
         stdout.flush
         stdout.text(". First repeated labels are for atoms "//trim(la.to_str)//" and "//trim(lb.to_str)//".")
         end
         if (ka/=0) then
         stdout.flush
         stdout.text(". First repeated xtal kinds are for atoms "//trim(ka.to_str)//" and "//trim(kb.to_str)//".")
         end
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush

         ! Table headings
         table.create(7)
         table(1).set_heading("Label")
         table(2).set_heading("ID")
         table(2).set_subhead("tag")
         table(3).set_heading("Z")
         table(4).set_heading("Atom")
         table(4).set_subhead("kind")
         table(5).set_heading("Unique")
         table(5).set_subhead("kind?")
         table(6).set_heading("Molecule")
         table(6).set_subhead("group")
         table(7).set_heading("Disorder")
         table(7).set_subhead("group")

         ! Set table column data
         table(1).set_values(self(:).label)
         table(2).set_values(self(:).tag)
         table(3).set_values(self(:).atomic_number)
         table(4).set_values(self(:).kind)
         table(5).set_values(self(:).is_unique_kind)
         table(6).set_values(self(:).group)
         table(7).set_values(self(:).site_disorder_group)

      end

      ! Make the table
      table.put

      ! Clean
      table.destroy

   end

!  =====
!  ADP's
!  =====

   put_ADPs(no_header,covariance)
   ! Output the ADP information
   ! Output position and ADP errors if there.
   ! Always use Angstrom units for display.
      self :: IN
      covariance :: MAT{REAL}, optional, IN
      no_header :: BIN, optional, IN

      ! If there are errors, tghese should have been
      ! made beforehand and stored in pADP_errors.
      .put_ADP2s(no_header)

      if (present(covariance)) then
         .put_ADP2s_in_inertial_axes(covariance)
         .put_ADP2s_in_ADP2_principal_axes(covariance)
      end

      ! Show ADP3's if present
      if (.has_any_ADP3s_and_errors) then
         .put_ADP3s
         if (present(covariance)) then
         .put_ADP3s_in_inertial_axes(covariance)
         .put_ADP3s_in_ADP2_principal_axes(covariance)
         end
      end

      ! Show ADP4's if present
      if (.has_any_ADP4s_and_errors) then
         .put_ADP4s
         if (present(covariance)) then
         .put_ADP4s_in_inertial_axes(covariance)
         .put_ADP4s_in_ADP2_principal_axes(covariance)
         end
      end

   end


   put_ADP2s(no_header)
   ! Output the ADP information
   ! Output position and ADP errors if there.
   ! Always use Angstrom units for display.
      self :: IN
      no_header :: BIN, optional, IN

      Uc :: VEC{STR}@
      U,dU :: MAT{REAL}@
      is_flat,is_npd :: VEC{BIN}@
      ratio :: VEC{REAL}@
      U_iso,U_iso_e :: VEC{REAL}@
      M_ani,M_ani_e :: VEC{REAL}@
      table :: VEC{TABLE_COLUMN}@
      fac,fac2 :: REAL
      i :: INT
      cartesian,header :: BIN

      header = TRUE
      if (present(no_header)) header = NOT no_header

      ! Axis system
      cartesian = self(1).pos_axis_system=="cartesian"

      ! Use angstroms/angstrom^2
      if (cartesian) then;
         fac = STR:conversion_factor("angstrom")
      else
         fac = ONE
      end
      fac2 = fac*fac

      ! Create columns
      Uc.create(6)
      U.create(.dim,6)
      dU.create(.dim,6)

      ! Get columns
      ATOM:put_ADP2_labels_to(Uc)
      .put_ADP2_vector_to(U,fac)
      
      is_flat = self(:).has_flat_ADP
      is_npd  = self(:).has_NPD_ADP
      ratio   = self(:).ADP_principal_axis_ratio
      U_iso   = self(:).U_iso*fac2
      U_iso_e = self(:).U_iso_error*fac2
      M_ani   = self(:).M_ani*fac2
      M_ani_e = self(:).M_ani_error*fac2

      ! Title
      if (header) then
      stdout.flush
      stdout.text("=====================================")
      stdout.text("Atomic displacement parameters (ADPs)")
      stdout.text("=====================================")
      stdout.flush
      if (cartesian) then
      stdout.text(". The ADPs are referred to cartesian axes.")
      else
      stdout.text(". The ADPs are referred to unit cell axes.")
      end
      stdout.text(". The length units are in Angstrom.")
      stdout.text(". An ADP is deemed bad if the max-on-min axis ratio")
      stdout.text("  - is greater than 4 (i.e. flat)")
      stdout.text("  - or is non-positive-definite (i.e. NPD)")
      stdout.text(". M_ani is the square root of the usual anistropy")
      stdout.text("  in a 2nd order tensor. It has units Angstrom^2.")
      stdout.text(". NOTE: If the su in U_iso or M_ani is zero, it may")
      stdout.text("  mean that there is no covariance matrix was available")
      stdout.text("  there to calculate it e.g. if you used a non-CIF2 file.")
      stdout.flush
      stdout.show("No. of NPD  ADPs =",.no_of_NPD_ADPs)
      stdout.show("No. of Flat ADPs =",.no_of_flat_ADPs)
      stdout.flush
      end

      ! Set table headings & data
      table.create(12)
      table.set_column_spacing(2)

      ! Set table
      table(1).set_heading("ID")
      table(1).set_values(self(:).tag)

      if (NOT .has_nonzero_pADP2_errors) then

         ! Set table no errors
         do i = 1,6
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values(U(:,i))
         end
         table( 8).set_heading("U_iso")
         table( 8).set_values(U_iso)
         table( 9).set_heading("M_ani")
         table( 9).set_values(M_ani)

      else ! have position/ADP errors

         ! Get error column data
         .put_ADP2_errors_to(dU,fac)

         ! Set table with (errors)
         do i = 1,6
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values_and_errors(U(:,i),dU(:,i))
         end
         table( 8).set_heading("U_iso")
         table( 8).set_values_and_errors(U_iso,U_iso_e)
         table( 9).set_heading("M_ani")
         table( 9).set_values_and_errors(M_ani,M_ani_e)

      end

      ! Units headings
      table(4).set_subhead(trim("/A^2"))
      table(8).set_subhead(trim("/A^2"))
      table(9).set_subhead(trim("/A^2"))

      ! ADP diagonistics
      table(10).set_heading("NPD")
      table(10).set_subhead("  ?")
      table(10).set_values(is_npd)
      table(11).set_heading("Flat")
      table(11).set_subhead("   ?")
      table(11).set_values(is_flat)
      table(12).set_heading(" Axis")
      table(12).set_subhead("ratio")
      table(12).set_values(ratio)

      ! Make the table
      table.put

      ! Clean
      table.destroy

   end

   get_ADP2s_in_new_axes_in(U,dU,axes,cov) ::: leaky, PURE
   ! Rotate the ADP2s for each atom into the principal axis frame of
   ! each atom, where "cov" is the covariance matrix for all the
   ! parameters in the concatenated pADP vectors. 
      self :: IN
       U   :: MAT{REAL}@, OUT
      dU   :: MAT{REAL}@, OUT
      axes :: MAT{REAL}(3,3), IN
      cov  :: MAT{REAL}, IN

   ENSURE(cov.is_square,"covariance matrix is not square!")
   ENSURE(cov.dim1==.no_of_pADPs,"wrong size, covariance matrix!")

      adp2,new2 :: MAT{REAL}(3,3)
      vec2,lex2 :: VEC{REAL}(6)
      rcm :: MAT{REAL}(6,6)
      a,n :: INT

      ! Create columns
      n = .dim
       U.create(n,6)
      dU.create(n,6)

      ! Loop over atoms
      do a = 1,.dim

         ! Change ADP2s to new coord system
         adp2 = self(a).ADP_tensor
         adp2.change_basis_to(new2,axes)
         new2.zip_lower_triangle_to(vec2)
         GAUSSIAN_DATA:lower_pyramid_to_lexical_2(vec2,lex2)
         U(a,1:6) = lex2

         ! Rotate whole covariance matrix by "axes"
         rcm = .rotated_U2_covariance_mx_for_atom(a,axes,cov)

         ! Extract diagonal elements as errors
         rcm.put_diagonal_to(dU(n,1:6))

      end

      ! Square root sigma^2
      dU = sqrt(dU)

   end

   put_ADP2s_in_inertial_axes(cov)
   ! Rotate the ADP2s for each atom into the inertial axis frame,
   ! where "cov" is the covariance matrix for all the parameters in
   ! the concatenated pADP vectors. 
      self :: IN
      cov  :: MAT{REAL}, IN

   ENSURE(cov.is_square,"covariance matrix is not square!")
   ENSURE(cov.dim1==.no_of_pADPs,"wrong size, covariance matrix!")

      U,dU :: MAT{REAL}@
      axes :: MAT{REAL}(3,3)

      .make_inertial_axes(axes)
      .get_ADP2s_in_new_axes_in(U,dU,axes,cov) 

      ! Title
      stdout.flush
      stdout.text("=============================")
      stdout.text("ADP2s in inertial axis system")
      stdout.text("=============================")
      stdout.flush
      stdout.text(". ADPs are referred to cartesian axes.")

      stdout.flush
      stdout.text("Inertial axes in the cartesian system:")
      stdout.put(axes)

      ! Finally ... print table
      ! This routine scales the U & dU
      .put_ADP2s_helper(U,dU)

      ! Clean
      dU.destroy
       U.destroy

   end

   get_ADP2s_in_ADP2_principal_axes_in(U,dU,cov) ::: leaky, PURE
   ! Rotate the ADP2s for each atom into the principal axis frame of
   ! each atoms ADP2, where "cov" is the covariance matrix for all the
   ! parameters in the concatenated pADP vectors. 
      self :: IN
       U   :: MAT{REAL}@, OUT
      dU   :: MAT{REAL}@, OUT
      cov  :: MAT{REAL}, IN

   ENSURE(cov.is_square,"covariance matrix is not square!")
   ENSURE(cov.dim1==.no_of_pADPs,"wrong size, covariance matrix!")

      adp2,new2 :: MAT{REAL}(3,3)
      vec2,lex2 :: VEC{REAL}(6)
      eval :: VEC{REAL}(3)
      R   :: MAT{REAL}(3,3)
      rcm :: MAT{REAL}(6,6)
      a,n :: INT

      ! Create columns
      n = .dim
       U.create(n,6)
      dU.create(n,6)

      ! ADP2 atom index
      n  = 0

      ! Loop over atoms
      do a = 1,.dim

         ! ADP2 atom index
         n = n + 1

         ! Get ADP2 principal axes into "R"
       ! self(a).ADP_tensor.solve_symmetric_eigenproblem(eval,R)
         self(a).ADP_tensor.diagonalize_by_jacobi(eval,R)

         ! Change ADP2s to new coord system
         adp2 = self(a).ADP_tensor
         adp2.change_basis_to(new2,R)
         new2.zip_lower_triangle_to(vec2)
         GAUSSIAN_DATA:lower_pyramid_to_lexical_2(vec2,lex2)
         U(n,1:6) = lex2

         ! Rotate whole covariance matrix by "R"
         rcm = .rotated_U2_covariance_mx_for_atom(a,R,cov)

         ! Extract diagonal elements as errors
         rcm.put_diagonal_to(dU(n,1:6))

      end

      ! Square root sigma^2
      dU = sqrt(dU)

   end

   put_ADP2s_in_ADP2_principal_axes(cov)
   ! Rotate the ADP2s for each atom into the principal axis frame of
   ! each atom, where "cov" is the covariance matrix for all the
   ! parameters in the concatenated pADP vectors. 
      self :: IN
      cov :: MAT{REAL}, IN

   ENSURE(cov.is_square,"covariance matrix is not square!")
   ENSURE(cov.dim1==.no_of_pADPs,"wrong size, covariance matrix!")

      U,dU :: MAT{REAL}@

      .get_ADP2s_in_ADP2_principal_axes_in(U,dU,cov) 

      ! Title
      stdout.flush
      stdout.text("==================================")
      stdout.text("ADP2s in ADP2 principal axis frame")
      stdout.text("==================================")
      stdout.flush
      stdout.text(". ADPs are referred to cartesian axes.")
      stdout.text(". ESUs have been obtained from the covariances.")

      ! Finally ... print table
      ! This routine scales the U & dU
      .put_ADP2s_helper(U,dU)

      ! Clean
      dU.destroy
       U.destroy

   end

   rotated_U2_covariance_mx_for_atom(a,R,fcm) result(rcm) ::: PURE
   ! Given index of atom "a", and given a 3x3 rotation matrix "R" and
   ! given the *full* covariance matrix "fcm", return in "rcm" the U2
   ! covariance matrix for atom "a" rotated by matrix "R".
      self :: IN
      a   :: INT, IN
      R   :: MAT{REAL}(3,3), IN
      fcm :: MAT{REAL}, IN
      rcm :: MAT{REAL}(6,6)

   ENSURE(R.dim1==3,"wrong dim1, R")
   ENSURE(R.dim2==3,"wrong dim2, R")
   ENSURE(fcm.is_square,"full covariance matrix is not square")
   ENSURE(fcm.dim1==.no_of_pADPs,"wrong dimension, fcm")

      old,RR :: MAT{REAL}(6,6)
      off,f,l :: INT

      ! Offset into diagonal block
      off = .no_of_pADPs_up_to_atom(a) + 3
      f   = off + 1
      l   = off + 6

      ! Get the cov. matrix block
      old = fcm(f:l,f:l)

      ! Get transformation matrix "RR"
      GAUSSIAN_DATA:symmetric_tensor_2_product_mx(RR,R)

      ! Get the rotated U3 covariance matrix
      old.back_transform_to(rcm,RR)

   end

   put_ADP2s_helper(U,dU) ::: private
   ! Output the ADP2s U(N,6) and errors dU(N,6) (if present).
   ! N is tge number of atoms. U and dU in Bohr as usual.
      self :: IN 
      U  :: MAT{REAL}, INOUT
      dU :: MAT{REAL}, optional, INOUT

   ENSURE(U.dim1==.dim,"U dim1 not equal to no. of atoms with ADP2s")
   ENSURE(U.dim2==6   ,"U dim2 is not equal to 6")

      ID,Uc :: VEC{STR}@
      list :: VEC{INT}@
      table :: VEC{TABLE_COLUMN}@
      fac :: REAL
      i,n :: INT

      ! No. of atoms with ADP2s
      n = .dim

      ! Use angstroms/angstrom^2
      fac  = STR:conversion_factor("angstrom^2")

      ! Create columns
      list.create(n)
      ID.create(n)
      Uc.create(6)

      ! Get columns
      ID = self(:).tag
      ATOM:put_ADP2_labels_to(Uc)

      ! Scale & change to Angstrom
      U = fac*U

      ! Set table headings & data
      table.create(7)
      table.set_column_spacing(2)

      ! Set table
      table(1).set_heading("ID")
      table(1).set_values(ID)

      if (NOT present(dU)) then

         ! Set table
         do i = 1,6
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values(U(:,i))
         end

      else ! have position/ADP errors

         ! Scale errors
         dU = fac*dU

         ! Set table
         do i = 1,6
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values_and_errors(U(:,i),dU(:,i))
         end

      end

      ! Units headings
      table(6).set_subhead(trim("/A^2"))

      ! Make the table
      table.put

      ! Clean
      table.destroy
      Uc.destroy
      ID.destroy

   end


   put_ADP3s ::: private
   ! Output the ADP3 information. Always comes after the ADP
   ! information. Use Angstroms.
      self :: IN

      U,dU :: MAT{REAL}@
      n :: INT

      if (NOT .has_any_ADP3s_and_errors) return

      ! No. of atoms with ADP3s
      n = .no_of_ADP3_atoms

      ! Create columns
      U.create(n,10)
      dU.create(n,10)

      ! Get U3's and scale to Angstrom
      .put_ADP3_vector_to(U)

      ! Get error column data
      .put_ADP3_errors_to(dU)

      ! Print table
      .put_ADP3s(U,dU)

      ! Clean
      dU.destroy
      U.destroy

   end

   get_ADP3s_in_new_axes_in(U,dU,axes,cov) ::: leaky, PURE
   ! Rotate the ADP3s for each atom into the principal axis frame of
   ! each atom, where "cov" is the covariance matrix for all the
   ! parameters in the concatenated pADP vectors. 
      self :: IN
       U   :: MAT{REAL}@, OUT
      dU   :: MAT{REAL}@, OUT
      axes :: MAT{REAL}(3,3), IN
      cov  :: MAT{REAL}, IN

   ENSURE(cov.is_square,"covariance matrix is not square!")
   ENSURE(cov.dim1==.no_of_pADPs,"wrong size, covariance matrix!")

      adp3,new3 :: MAT3{REAL}(3,3,3)
      vec3,lex3 :: VEC{REAL}(10)
      rcm :: MAT{REAL}(10,10)
      a,n :: INT

      if (NOT .has_any_ADP3s_and_errors) return

      ! Create columns
      n = .no_of_ADP3_atoms
       U.create(n,10)
      dU.create(n,10)

      ! ADP3 atom index
      n  = 0

      ! Loop over atoms
      do a = 1,.dim

         if (NOT self(a).has_ADP3s_and_errors) cycle

         ! ADP3 atom index
         n = n + 1

         ! Change ADP3s to new coord system
         self(a).put_ADP3_vector_to(adp3)
         adp3.change_basis_to(new3,axes)
         new3.compress_to_pyramid(vec3)
         GAUSSIAN_DATA:lower_pyramid_to_lexical_3(vec3,lex3)
         U(n,1:10) = lex3

         ! Rotate whole covariance matrix by "axes"
         rcm = .rotated_U3_covariance_mx_for_atom(a,axes,cov)

         ! Extract diagonal elements as errors
         rcm.put_diagonal_to(dU(n,1:10))

      end

      ! Square root sigma^2
      dU = sqrt(dU)

   end

   put_ADP3s_in_inertial_axes(cov)
   ! Rotate the ADP3s for each atom into the inertial axis frame,
   ! where "cov" is the covariance matrix for all the parameters in
   ! the concatenated pADP vectors. 
      self :: IN
      cov  :: MAT{REAL}, IN

   ENSURE(cov.is_square,"covariance matrix is not square!")
   ENSURE(cov.dim1==.no_of_pADPs,"wrong size, covariance matrix!")

      U,dU :: MAT{REAL}@
      axes :: MAT{REAL}(3,3)

      if (NOT .has_any_ADP3s_and_errors) return

      .make_inertial_axes(axes)
      .get_ADP3s_in_new_axes_in(U,dU,axes,cov) 

      ! Title
      stdout.flush
      stdout.text("=============================")
      stdout.text("ADP3s in inertial axis system")
      stdout.text("=============================")
      stdout.flush
      stdout.text(". ADPs are referred to cartesian axes.")

      stdout.flush
      stdout.text("Inertial axes in the cartesian system:")
      stdout.put(axes)

      ! Finally ... print table
      ! This routine scales the U & dU
      .put_ADP3s(U,dU)

      ! Clean
      dU.destroy
       U.destroy

   end

   get_ADP3s_in_ADP2_principal_axes_in(U,dU,cov) ::: leaky, PURE
   ! Rotate the ADP3s for each atom into the principal axis frame of
   ! each atom, where "cov" is the covariance matrix for all the
   ! parameters in the concatenated pADP vectors. 
      self :: IN
       U   :: MAT{REAL}@, OUT
      dU   :: MAT{REAL}@, OUT
      cov  :: MAT{REAL}, IN

   ENSURE(cov.is_square,"covariance matrix is not square!")
   ENSURE(cov.dim1==.no_of_pADPs,"wrong size, covariance matrix!")

      adp3,new3 :: MAT3{REAL}(3,3,3)
      vec3,lex3 :: VEC{REAL}(10)
      eval :: VEC{REAL}(3)
      R   :: MAT{REAL}(3,3)
      rcm :: MAT{REAL}(10,10)
      a,n :: INT

      if (NOT .has_any_ADP3s_and_errors) return

      ! Create columns
      n = .no_of_ADP3_atoms
       U.create(n,10)
      dU.create(n,10)

      ! ADP3 atom index
      n  = 0

      ! Loop over atoms
      do a = 1,.dim

         if (NOT self(a).has_ADP3s_and_errors) cycle

         ! ADP3 atom index
         n = n + 1

         ! Get ADP2 principal axes into "R"
       ! self(a).ADP_tensor.solve_symmetric_eigenproblem(eval,R)
         self(a).ADP_tensor.diagonalize_by_jacobi(eval,R)

         ! Change ADP3s to new coord system
         self(a).put_ADP3_vector_to(adp3)
         adp3.change_basis_to(new3,R)
         new3.compress_to_pyramid(vec3)
         GAUSSIAN_DATA:lower_pyramid_to_lexical_3(vec3,lex3)
         U(n,1:10) = lex3

         ! Rotate whole covariance matrix by "R"
         rcm = .rotated_U3_covariance_mx_for_atom(a,R,cov)

         ! Extract diagonal elements as errors
         rcm.put_diagonal_to(dU(n,1:10))

      end

      ! Square root sigma^2
      dU = sqrt(dU)

   end

   put_ADP3s_in_ADP2_principal_axes(cov)
   ! Rotate the ADP3s for each atom into the principal axis frame of
   ! each atom, where "cov" is the covariance matrix for all the
   ! parameters in the concatenated pADP vectors. 
      self :: IN
      cov :: MAT{REAL}, IN

   ENSURE(cov.is_square,"covariance matrix is not square!")
   ENSURE(cov.dim1==.no_of_pADPs,"wrong size, covariance matrix!")

      U,dU :: MAT{REAL}@

      if (NOT .has_any_ADP3s_and_errors) return

      .get_ADP3s_in_ADP2_principal_axes_in(U,dU,cov) 

      ! Title
      stdout.flush
      stdout.text("==================================")
      stdout.text("ADP3s in ADP2 principal axis frame")
      stdout.text("==================================")
      stdout.flush
      stdout.text(". ADPs are referred to cartesian axes.")

      ! Finally ... print table
      ! This routine scales the U & dU
      .put_ADP3s(U,dU)

      ! Clean
      dU.destroy
       U.destroy

   end

   rotated_U3_covariance_mx_for_atom(a,R,fcm) result(rcm) ::: PURE
   ! Given index of atom "a", and given a 3x3 rotation matrix "R" and
   ! given the *full* covariance matrix "fcm", return in "rcm" the U3
   ! covariance matrix for atom "a" rotated by matrix "R".
      self :: IN
      a   :: INT, IN
      R   :: MAT{REAL}(3,3), IN
      fcm :: MAT{REAL}, IN
      rcm :: MAT{REAL}(10,10)

   ENSURE(R.dim1==3,"wrong dim1, R")
   ENSURE(R.dim2==3,"wrong dim2, R")
   ENSURE(fcm.is_square,"full covariance matrix is not square")
   ENSURE(fcm.dim1==.no_of_pADPs,"wrong dimension, fcm")

      old,RR :: MAT{REAL}(10,10)
      off,f,l :: INT

      ! Offset into diagonal block
      off = .no_of_pADPs_up_to_atom(a) + 9
      f   = off + 1
      l   = off + 10

      ! Get the cov. matrix block
      old = fcm(f:l,f:l)

      ! Get transformation matrix "RR"
      GAUSSIAN_DATA:symmetric_tensor_3_product_mx(RR,R)

      ! Get the rotated U3 covariance matrix
      old.back_transform_to(rcm,RR)

   end

   put_ADP3s(U,dU) ::: private
   ! Output the ADP3s U(N,10) and errors dU(N,10) (if present).
   ! N is thge number of atoms. U and dU in Bohr as usual.
      self :: IN 
      U  :: MAT{REAL}, INOUT
      dU :: MAT{REAL}, optional, INOUT

   ENSURE(U.dim1==.no_of_ADP3_atoms,"U dim1 not equal to no. of atoms with ADP3s")
   ENSURE(U.dim2==10  ,"U dim2 is not equal to 10")

      ID,Uc :: VEC{STR}@
      list :: VEC{INT}@
      table :: VEC{TABLE_COLUMN}@
      fac,sfac :: REAL
      i,n :: INT

      ! Scale factor
      sfac = CIF_GC3_SCALE_FACTOR
      stdout.flush
      stdout.text(". The cartesian ADP3s below have been scaled")
      stdout.show("  scale factor =",sfac)

      ! No. of atoms with ADP3s
      n = .no_of_ADP3_atoms

      ! Use angstroms/angstrom^2
      fac  = STR:conversion_factor("angstrom^3")

      ! Create columns
      list.create(n)
      ID.create(n)
      Uc.create(10)

      ! Get columns
      .put_ADP3_atom_list_to(list)
      ID = self(list).tag
      ATOM:put_ADP3_labels_to(Uc)

      ! Scale & change to Angstrom
      U = sfac*fac*U

      ! Set table headings & data
      table.create(11)
      table.set_column_spacing(2)

      ! Set table
      table(1).set_heading("ID")
      table(1).set_values(ID)

      if (NOT present(dU)) then

         ! Set table
         do i = 1,10
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values(U(:,i))
         end

      else ! have position/ADP errors

         ! Scale errors
         dU = sfac*fac*dU

         ! Set table
         do i = 1,10
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values_and_errors(U(:,i),dU(:,i))
         end

      end

      ! Units headings
      table(6).set_subhead(trim("/A^3"))

      ! Make the table
      table.put

      ! Clean
      table.destroy
      Uc.destroy
      ID.destroy
      list.destroy

   end

!   put_ADP3s_transposed ::: private
!   ! Output the ADP3 information. Always comes after the ADP
!   ! information. Use Angstroms.
!      self :: IN
!
!      U,dU :: MAT{REAL}@
!      n :: INT
!
!      if (NOT .has_any_ADP3s_and_errors) return
!
!      ! No. of atoms with ADP3s
!      n = .no_of_ADP3_atoms
!
!      ! Create columns
!      U.create(n,10)
!      dU.create(n,10)
!
!      ! Get U3's and scale to Angstrom
!      .put_ADP3_vector_to(U)
!
!      ! Get error column data
!      .put_ADP3_errors_to(dU)
!
!      ! Print table
!      .put_ADP3s_transposed(U,dU)
!
!      ! Clean
!      dU.destroy
!      U.destroy
!
!   end

!   put_ADP3s_transposed(U,dU) ::: private
!   ! Output the ADP3s U(N,10) and errors dU(N,10) (if present).
!   ! N is thge number of atoms. U and dU in Bohr as usual.
!      self :: IN 
!      U  :: MAT{REAL}, INOUT
!      dU :: MAT{REAL}, optional, INOUT
!
!   ENSURE(U.dim1==.no_of_ADP3_atoms,"U dim1 not equal to no. of atoms with ADP3s")
!   ENSURE(U.dim2==10  ,"U dim2 is not equal to 10")
!
!      ID,Uc :: VEC{STR}@
!      list :: VEC{INT}@
!      table :: VEC{TABLE_COLUMN}@
!      fac,sfac :: REAL
!      i,n :: INT
!
!      ! Scale factor
!      sfac = CIF_GC3_SCALE_FACTOR
!      stdout.flush
!      stdout.text(". The cartesian ADP3s below have been scaled")
!      stdout.show("  scale factor =",sfac)
!
!      ! No. of atoms with ADP3s
!      n = .no_of_ADP3_atoms
!
!      ! Use angstroms/angstrom^2
!      fac  = STR:conversion_factor("angstrom^3")
!
!      ! Create columns
!      list.create(n)
!      ID.create(n)
!      Uc.create(10)
!
!      ! Get columns
!      .put_ADP3_atom_list_to(list)
!      ID = self(list).tag
!      ATOM:put_ADP3_labels_to(Uc)
!
!      ! Scale & change to Angstrom
!      U = sfac*fac*U
!
!      ! Set table headings & data
!      table.create(n+1)
!      table.set_column_spacing(2)
!
!      ! Set table first column
!      table(1).set_heading("U3 ADP")
!      table(1).set_subhead("/A^3")
!      table(1).set_values(Uc)
!
!      if (NOT present(dU)) then
!
!         ! Set table
!         do i = 1,n
!         table(i+1).set_heading(self(list(i)).tag)
!         table(i+1).set_values(U(i,:))
!         end
!
!      else ! have position/ADP errors
!
!         ! Scale errors
!         dU = sfac*fac*dU
!
!         ! Set table
!         do i = 1,10
!         table(i+1).set_heading(self(list(i)).tag)
!         table(i+1).set_values_and_errors(U(i,:),dU(i,:))
!         end
!
!      end
!
!      ! Make the table
!      table.put
!
!      ! Clean
!      table.destroy
!      Uc.destroy
!      ID.destroy
!      list.destroy
!
!   end


   put_ADP4s ::: private
   ! Output the ADP4 information. Always comes after the ADP
   ! information. Use Angstroms.
      self :: IN

      U,dU :: MAT{REAL}@
      n :: INT

      if (NOT .has_any_ADP4s_and_errors) return

      ! No. of atoms with ADP4s
      n = .no_of_ADP4_atoms

      ! Create columns
      U.create(n,15)
      dU.create(n,15)

      ! Get U4's and scale to Angstrom
      .put_ADP4_vector_to(U)

      ! Get error column data
      .put_ADP4_errors_to(dU)

      ! Print table
      .put_ADP4s(U,dU)

      ! Clean
      dU.destroy
      U.destroy

   end

   get_ADP4s_in_new_axes_in(U,dU,axes,cov) ::: leaky, PURE
   ! Rotate the ADP4s for each atom into the principal axis frame of
   ! each atom, where "cov" is the covariance matrix for all the
   ! parameters in the concatenated pADP vectors. 
      self :: IN
       U   :: MAT{REAL}@, OUT
      dU   :: MAT{REAL}@, OUT
      axes :: MAT{REAL}(3,3), IN
      cov  :: MAT{REAL}, IN

   ENSURE(cov.is_square,"covariance matrix is not square!")
   ENSURE(cov.dim1==.no_of_pADPs,"wrong size, covariance matrix!")

      adp4,new4 :: MAT4{REAL}(3,3,3,3)
      vec4,lex4 :: VEC{REAL}(15)
      rcm :: MAT{REAL}(15,15)
      a,n :: INT

      if (NOT .has_any_ADP4s_and_errors) return

      ! Create columns
      n = .no_of_ADP4_atoms
       U.create(n,15)
      dU.create(n,15)

      ! ADP4 atom index
      n  = 0

      ! Loop over atoms
      do a = 1,.dim

         if (NOT self(a).has_ADP4s_and_errors) cycle

         ! ADP4 atom index
         n = n + 1

         ! Change ADP4s to new coord system
         self(a).put_ADP4_vector_to(adp4)
         adp4.change_basis_to(new4,axes)
         new4.compress_to_pyramid(vec4)
         GAUSSIAN_DATA:lower_pyramid_to_lexical_4(vec4,lex4)
         U(n,1:15) = lex4

         ! Rotate whole covariance matrix by "axes"
         rcm = .rotated_U4_covariance_mx_for_atom(a,axes,cov)

         ! Extract diagonal elements as errors
         rcm.put_diagonal_to(dU(n,1:15))

      end

      ! Square root sigma^2
      dU = sqrt(dU)

   end

   put_ADP4s_in_inertial_axes(cov)
   ! Rotate the ADP4s for each atom into the principal axis frame of
   ! each atom, where "cov" is the covariance matrix for all the
   ! parameters in the concatenated pADP vectors. 
      self :: IN
      cov :: MAT{REAL}, IN

   ENSURE(cov.is_square,"covariance matrix is not square!")
   ENSURE(cov.dim1==.no_of_pADPs,"wrong size, covariance matrix!")

      U,dU :: MAT{REAL}@
      axes :: MAT{REAL}(3,3)

      if (NOT .has_any_ADP4s_and_errors) return

      .make_inertial_axes(axes)
      .get_ADP4s_in_new_axes_in(U,dU,axes,cov)

      ! Title
      stdout.flush
      stdout.text("=============================")
      stdout.text("ADP4s in inertial axis system")
      stdout.text("=============================")
      stdout.flush
      stdout.text(". ADPs are referred to cartesian axes.")

      stdout.flush
      stdout.text("Inertial axes in the cartesian system:")
      stdout.put(axes)

      ! Finally ... print table
      ! This routine scales the U & dU
      .put_ADP4s(U,dU)

      ! Clean
      dU.destroy
       U.destroy

   end

   get_ADP4s_in_ADP2_principal_axes_in(U,dU,cov) ::: leaky, PURE
   ! Rotate the ADP4s for each atom into the principal axis frame of
   ! each atom, where "cov" is the covariance matrix for all the
   ! parameters in the concatenated pADP vectors. 
      self :: IN
       U   :: MAT{REAL}@, OUT
      dU   :: MAT{REAL}@, OUT
      cov  :: MAT{REAL}, IN

   ENSURE(cov.is_square,"covariance matrix is not square!")
   ENSURE(cov.dim1==.no_of_pADPs,"wrong size, covariance matrix!")

      adp4,new4 :: MAT4{REAL}(3,3,3,3)
      vec4,lex4 :: VEC{REAL}(15)
      eval :: VEC{REAL}(3)
      R   :: MAT{REAL}(3,3)
      rcm :: MAT{REAL}(15,15)
      a,n :: INT

      if (NOT .has_any_ADP4s_and_errors) return

      ! Create columns
      n = .no_of_ADP4_atoms
       U.create(n,15)
      dU.create(n,15)

      ! ADP4 atom index
      n  = 0

      ! Loop over atoms
      do a = 1,.dim

         if (NOT self(a).has_ADP4s_and_errors) cycle

         ! ADP4 atom index
         n = n + 1

         ! Get ADP2 principal axes into "R"
       ! self(a).ADP_tensor.solve_symmetric_eigenproblem(eval,R)
         self(a).ADP_tensor.diagonalize_by_jacobi(eval,R)

         ! Change ADP4s to new coord system
         self(a).put_ADP4_vector_to(adp4)
         adp4.back_transform_to(new4,R)
         new4.compress_to_pyramid(vec4)
         GAUSSIAN_DATA:lower_pyramid_to_lexical_4(vec4,lex4)
         U(n,1:15) = lex4

         ! Rotate whole covariance matrix by "R"
         rcm = .rotated_U4_covariance_mx_for_atom(a,R,cov)

         ! Extract diagonal elements as errors
         rcm.put_diagonal_to(dU(n,1:15))

      end

      ! Square root sigma^2
      dU = sqrt(dU)

   end

   put_ADP4s_in_ADP2_principal_axes(cov)
   ! Rotate the ADP4s for each atom into the principal axis frame of
   ! each atom, where "cov" is the covariance matrix for all the
   ! parameters in the concatenated pADP vectors. 
      self :: IN
      cov :: MAT{REAL}, IN

   ENSURE(cov.is_square,"covariance matrix is not square!")
   ENSURE(cov.dim1==.no_of_pADPs,"wrong size, covariance matrix!")

      U,dU :: MAT{REAL}@

      if (NOT .has_any_ADP4s_and_errors) return

      .get_ADP4s_in_ADP2_principal_axes_in(U,dU,cov)

      ! Title
      stdout.flush
      stdout.text("==================================")
      stdout.text("ADP4s in ADP2 principal axis frame")
      stdout.text("==================================")
      stdout.flush
      stdout.text(". ADPs are referred to cartesian axes.")

      ! Finally ... print table
      ! This routine scales the U & dU
      .put_ADP4s(U,dU)

      ! Clean
      dU.destroy
       U.destroy

   end

   rotated_U4_covariance_mx_for_atom(a,R,fcm) result(rcm) ::: PURE
   ! Given index of atom "a", and given a 3x3 rotation matrix "R" and
   ! given the *full* covariance matrix "fcm", return in "rcm" the U3
   ! covariance matrix for atom "a" rotated by matrix "R".
      self :: IN
      a   :: INT, IN
      R   :: MAT{REAL}(3,3), IN
      fcm :: MAT{REAL}, IN
      rcm :: MAT{REAL}(15,15)

   ENSURE(R.dim1==3,"wrong dim1, R")
   ENSURE(R.dim2==3,"wrong dim2, R")
   ENSURE(fcm.is_square,"full covariance matrix is not square")
   ENSURE(fcm.dim1==.no_of_pADPs,"wrong dimension, fcm")

      old,RR :: MAT{REAL}(15,15)
      off,f,l :: INT

      ! Offset into diagonal block
      off = .no_of_pADPs_up_to_atom(a) + 19
      f   = off + 1
      l   = off + 15

      ! Get the cov. matrix block
      old = fcm(f:l,f:l)

      ! Get transformation matrix "RR"
      GAUSSIAN_DATA:symmetric_tensor_4_product_mx(RR,R)

      ! Get the rotated U3 covariance matrix
      old.back_transform_to(rcm,RR)

   end

   put_ADP4s(U,dU) ::: private
   ! Output the ADP4s U(N,15) and errors dU(N,15) (if present).
   ! N is thge number of atoms. U and dU in Bohr as usual.
      self :: IN 
      U  :: MAT{REAL}, INOUT
      dU :: MAT{REAL}, optional, INOUT

   ENSURE(U.dim1==.no_of_ADP4_atoms,"U dim1 not equal to no. of atoms with ADP4s")
   ENSURE(U.dim2==15  ,"U dim2 is not equal to 15")

      ID,Uc :: VEC{STR}@
      list :: VEC{INT}@
      table :: VEC{TABLE_COLUMN}@
      fac,sfac :: REAL
      i,n :: INT

      ! Scale factor
      sfac = CIF_GC4_SCALE_FACTOR
      stdout.flush
      stdout.text(". The cartesian ADP4s below have been scaled")
      stdout.show("  scale factor =",sfac)

      ! No. of atoms with ADP4s
      n = .no_of_ADP4_atoms

      ! Use angstroms/angstrom^2
      fac  = STR:conversion_factor("angstrom^4")

      ! Create columns
      list.create(n)
      ID.create(n)
      Uc.create(15)

      ! Get columns
      .put_ADP4_atom_list_to(list)
      ID = self(list).tag
      ATOM:put_ADP4_labels_to(Uc)

      ! Scale & change to Angstrom
      U = sfac*fac*U

      ! Set table headings & data
      table.create(16)
      table.set_column_spacing(2)

      ! Set table
      table(1).set_heading("ID")
      table(1).set_values(ID)

      if (NOT present(dU)) then

         ! Set table
         do i = 1,15
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values(U(:,i))
         end

      else ! have position/ADP errors

         ! Scale errors
         dU = sfac*fac*dU

         ! Set table
         do i = 1,15
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values_and_errors(U(:,i),dU(:,i))
         end

      end

      ! Units headings
      table(8).set_subhead(trim("/A^4"))

      ! Make the table
      table.put

      ! Clean
      table.destroy
      Uc.destroy
      ID.destroy
      list.destroy

   end


   put_pADPs
   ! Output the pADP vector information
   ! Genrally used for debugging only.
      self :: IN

      mx :: MAT{REAL}@
      n :: INT
      fac :: REAL

      ! Use angstroms/angstrom^2
      fac = STR:conversion_factor("angstrom")

      ! No. of ADP's.
      n = .no_of_pADPs

      ! Get then
      mx.create(n,2)
      .put_pADP_vector_to(mx(:,1),fac)
      .put_pADP_errors_to(mx(:,2),fac)

      ! Title
      stdout.flush
      stdout.text("===================")
      stdout.text("Position/ADP vector")
      stdout.text("===================")
      stdout.flush
      stdout.text(". Column 1 is the pADP vector")
      stdout.text(". Column 2 are the corresponding errors")
      stdout.text(". The length unit is Angstrom")
      stdout.flush
      stdout.show("No. of pADPs =",n)
      stdout.flush

      ! Put
      stdout.put(mx)

   end


   put_dispersion_factors
   ! Output the anamalous dispersion coefficients for every unique
   ! element in the molecule. 
      self :: IN

      ulist :: VEC{INT}@
      ID :: VEC{STR}@
      f_r,f_i :: VEC{REAL}@
      table :: VEC{TABLE_COLUMN}@
      n_kind :: INT

      ! Unique atom list
      n_kind = maxval(self(:).kind)
      ulist.create(n_kind)
      .make_unique_atom_list(ulist)
      ID  = self(ulist).chemical_symbol
      f_r = self(ulist).f_r
      f_i = self(ulist).f_i

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("======================================")
      stdout.text("Anomalous dispersion f' and f'' values")
      stdout.text("======================================")

      stdout.flush
      stdout.show("No. of elements =",n_kind)
      stdout.flush
      stdout.text("WARNING: it is up to you to ensure these dispersion")
      stdout.text("coefficients below correspond to the wavelength used. ")
      stdout.flush

      ! Table headings
      table.create(3)
      table(1).set_heading("ID")
      table(2).set_heading("f'")
      table(3).set_heading("f''")

      ! Set table column data
      table(1).set_values(ID)
      table(2).set_values(f_r)
      table(3).set_values(f_i)

      ! Print the table
      table.put

      ! Clean
      table.destroy

   end

!  ============
!  Bond lengths
!  ============

   put_bond_length_table
   ! Output the bond length table.
      self :: IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{EVEC{INT}}@
      symbols,labels :: MAT{STR}@
      dash,dsh1 :: VEC{STR}@
      dist :: VEC{REAL}@
      pair :: MAT{INT}@
      no_of_bonds, n_kind,k1,k2,n_bonds :: INT
      has_unique_labels :: BIN

      ! Anything to do?
      if (.dim<2) return

      no_of_bonds = .no_of_bonds
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("============")
      stdout.text("Bond lengths")
      stdout.text("============")
      stdout.flush
      stdout.text(". The bond-detection criteria is the same as used")
      stdout.text("  by the Cambridge Structural Database (CSD).")
      if (NOT has_unique_labels) then
      stdout.flush
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number tags are used.")
      end
      stdout.flush
      stdout.show("No. of bonds =",no_of_bonds)

      if (no_of_bonds>VEC_ATOM_MAX_BONDS_IN_TABLE) then
      stdout.flush
      stdout.text("There are too many bonds to display in a table.")
      return
      end
      stdout.flush

      ! Get Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(7)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self(:).chemical_symbols)

      table(2).set_column_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_heading("B")
      table(3).set_width(table(1).width)
      table(3).set_left_justify(TRUE)

      table(4).set_heading("A")
      table(4).set_width_from(self(:).tag)

      table(5).set_column_spacing(0)
      table(5).set_heading("--")
      table(5).set_width(2)

      table(6).set_heading("B")
      table(6).set_width(table(4).width)
      table(6).set_left_justify(TRUE)

      table(7).set_heading("R(A--B)")
      table(7).set_subheading("/A")
      table(7).set_width_from(ONE)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_atoms(pair,dist,Z_list,k1,k2)
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_bonds,2)
         symbols = " "
         symbols(1,1) = self(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = self(Z_list(k2)[1]).chemical_symbol

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = self(pair(:,1)).tag
         labels(:,2) = self(pair(:,2)).tag

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table(1).set_values(symbols(:,1))
         table(2).set_values(dsh1)
         table(3).set_values(symbols(:,2))
         table(4).set_values(labels(:,1))
         table(5).set_values(dash)
         table(6).set_values(labels(:,2))
         table(7).set_values(dist)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      Z_list.destroy

   end

   put_bond_length_table(covariance,parentheses)
   ! Output the bond length table with errors, given the "covariance"
   ! matrix between all atomic positions. Set "paretheses" FALSE if
   ! you want errors without them.
      self :: IN
      covariance :: MAT{REAL}, IN
      parentheses :: BIN, optional, IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{EVEC{INT}}@
      symbols,labels :: MAT{STR}@
      dash,dsh1 :: VEC{STR}@
      dist,esds :: VEC{REAL}@
      pair :: MAT{INT}@
      no_of_bonds, n_kind,k1,k2,n_bonds :: INT
      use_brackets,has_unique_labels :: BIN

      ! Anything to do?
      if (.dim<2) return

      no_of_bonds = .no_of_bonds
      if (no_of_bonds<1) return

      ! Parentheses
      use_brackets = TRUE
      if (present(parentheses)) use_brackets = parentheses

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("============")
      stdout.text("Bond lengths")
      stdout.text("============")
      stdout.flush
      stdout.text(". The bond-detection criteria is the same as used")
      stdout.text("  by the Cambridge Structural Database (CSD).")
      if (NOT has_unique_labels) then
      stdout.flush
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number ID tags are used.")
      end
      stdout.flush
      stdout.show("No. of bonds =",no_of_bonds)
      stdout.flush

      ! Get Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      if (use_brackets) then; table.create(7)
      else;                   table.create(8)
      end

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self(:).chemical_symbols)

      table(2).set_column_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_heading("B")
      table(3).set_width(table(1).width)
      table(3).set_left_justify(TRUE)

      table(4).set_heading("A")
      table(4).set_width_from(self(:).tag)

      table(5).set_column_spacing(0)
      table(5).set_heading("--")
      table(5).set_width(2)

      table(6).set_heading("B")
      table(6).set_width(table(4).width)
      table(6).set_left_justify(TRUE)

      table(7).set_heading("R(A--B)")
      table(7).set_subheading("/A")
      table(7).set_width_from(ONE)

      if (NOT use_brackets) then
      table(8).set_heading("Error")
      table(8).set_width_from(ONE)
      end

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom Z classes, Z(k1) >= Z(k2)
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_atoms(pair,dist,esds,Z_list,k1,k2,covariance) ! leaky
         dist = dist*ANGSTROM_PER_BOHR
         esds = esds*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            esds.destroy
            dist.destroy
            pair.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_bonds,2)
         symbols = " "
         symbols(1,1) = self(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = self(Z_list(k2)[1]).chemical_symbol

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = self(pair(:,1)).tag
         labels(:,2) = self(pair(:,2)).tag

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table(1).set_values(symbols(:,1))
         table(2).set_values(dsh1)
         table(3).set_values(symbols(:,2))
         table(4).set_values(labels(:,1))
         table(5).set_values(dash)
         table(6).set_values(labels(:,2))
         if (use_brackets) then
         table(7).set_real_precision(stdout.real_precision) ! Must do, for every block
         table(7).set_values_and_errors(dist,esds)
         else
         table(7).set_values(dist)
         table(8).set_values(esds)
         end

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         esds.destroy
         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      Z_list.destroy

   end

   get_bonded(pair,dist,Z_list,k1,k2,range_factor) ::: template, leaky
   ! Get the Nx2 bonded-atom "pair"s, and the distances "dist" between
   ! them. The pair have "Z_list" groups "k1" and "k2", respectively.
      self :: IN
      pair :: MAT{INT}@, OUT
      dist :: VEC{REAL}@, OUT
      Z_list :: VEC{EVEC{INT}}, IN
      k1,k2 :: INT, IN
      range_factor :: REAL, optional, IN

   ENSURE(k1<=k2,"k2 is smaller than k1")

      i1,i2,a1,a2, n :: INT

      ! How many pairs, n, are there?
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (k1==k2 AND a2<=a1) cycle
            if (NOT .BONDED?(a1,a2,range_factor)) cycle

            ! Count
            n = n + 1

         end
      end

      ! Allocate
      pair.create(n,2)
      dist.create(n)

      ! Make the list
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (k1==k2 AND a2<=a1) cycle
            if (NOT .BONDED?(a1,a2,range_factor)) cycle

            ! Add the data
            n = n + 1
            pair(n,1) = a1
            pair(n,2) = a2
            dist(n)   = .bond_distance(a1,a2)

         end
      end

   end

   get_bonded_atoms(pair,dist,Z_list,k1,k2,range_factor) ::: get_from(VEC{ATOM}:get_bonded, BONDED?=>bonded), leaky
   ! Get the Nx2 bonded-atom "pair"s, and the distances "dist" between
   ! them. The pair have "Z_list" groups "k1" and "k2", respectively.
   end

   get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,range_factor) ::: get_from(VEC{ATOM}:get_bonded, BONDED?=>vdw_bonded), leaky
   ! Get the Nx2 bonded-atom "pair"s, and the distances "dist" between
   ! them. The pair have "Z_list" groups "k1" and "k2", respectively.
   end

   get_bonded_atoms(pair,dist,esds,Z_list,k1,k2,covariance,H_bonded) ::: leaky
   ! Get the Nx2 bonded-atom "pair"s, and the distances "dist" between
   ! them, and the associated "esds". The pair have "Z_list" groups of
   ! "k1" and "k2", respectively. The "covariance" matrix for *all*
   ! atom coordinates is also given.
      self :: IN
      pair :: MAT{INT}@, OUT
      dist,esds :: VEC{REAL}@, OUT
      Z_list :: VEC{EVEC{INT}}, IN
      k1,k2 :: INT, IN
      covariance :: MAT{REAL}, IN
      H_bonded :: BIN, optional, IN

   ENSURE(k1<=k2,"k2 is smaller than k1")
   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      i1,i2,a1,a2, n :: INT
      d :: VEC{REAL}(2)

      ! How many pairs, n, are there?
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (k1==k2 AND a2<=a1) cycle
            if (NOT .bonded(a1,a2,H_bonded=H_bonded)) cycle

            ! Count
            n = n + 1

         end
      end

      ! Allocate
      pair.create(n,2)
      dist.create(n)
      esds.create(n)

      ! Make the list
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (k1==k2 AND a2<=a1) cycle
            if (NOT .bonded(a1,a2,H_bonded=H_bonded)) cycle

            ! Get bond distance & error
            d = .bond_distance(a1,a2,covariance)

            ! Add the data
            n = n + 1
            pair(n,1) = a1
            pair(n,2) = a2
            dist(n)   = d(1)
            esds(n)   = d(2)

         end
      end

   end

   put_bond_length_with_error(a1,a2,covariance) ::: leaky
   ! Put the bond length with error between atoms "a1" and "a2".
   ! The "covariance" matrix is for *all* atomn.
      self :: IN
      a1,a2 :: INT, IN
      covariance :: MAT{REAL}, IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")
   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      d :: VEC{REAL}(2)

      ! Add the data
      d = .bond_distance(a1,a2,covariance,angstrom=TRUE)

      ! Output
      stdout.flush
      stdout.text("======================")
      stdout.text("Bond length with error")
      stdout.text("======================")
      stdout.show("Atom 1        =",self(a1).tag)
      stdout.show("Atom 2        =",self(a2).tag)
      stdout.show("Bond length   =",d(1))
      stdout.show("Error         =",d(2))

   end

!  ===============
!  Hirshfelds test
!  ===============

   Hirshfeld_test(a,b,angstrom) result (res) ::: PURE
   ! Return the Hirshfeld test between atoms "a" and "b"
      self :: IN
      a,b :: INT, IN
      angstrom :: BIN, optional, IN
      res :: REAL

      n :: VEC{REAL}(3)
      dU :: MAT{REAL}(3,3)
      change :: BIN

      ! Unit vector
      n = self(a).position - self(b).position
      n.normalise

      ! Difference in ADPs
      dU = self(a).ADP_tensor - self(b).ADP_tensor

      ! H test value
      res = dot_product(n,matmul(dU,n))

      change = FALSE
      if (present (angstrom)) change = angstrom
      if (change) res = res * ANGSTROM_PER_BOHR*ANGSTROM_PER_BOHR

   end

   Hirshfeld_test(a,b,covariance,angstrom) result (res) ::: PURE
   ! Return the Hirshfeld test (and error) between atoms "a" and "b".
   ! The test is the first value, the error the second in res(:).
      self :: IN
      a,b :: INT, IN
      covariance :: MAT{REAL}, IN
      angstrom :: BIN, optional, IN
      res :: VEC{REAL}(2)

   ENSURE(a/=b,"Atom indices are equal!")

      n  :: VEC{REAL}(3)
      delU :: MAT{REAL}(3,3)
      der :: VEC{REAL}(18)
      cov :: MAT{REAL}(18,18)
      change :: BIN

      ! Unit vector
      n = self(a).position - self(b).position
      n.normalise

      ! Difference in ADPs
      delU = self(a).ADP_tensor - self(b).ADP_tensor

      ! H test value
      res(1) = dot_product(n,matmul(delU,n))

      ! Covariance
      covariance.put_blocks_to(cov,block_dim=9,block_list=[a,b])

      ! Make bond distance error
      .Hirshfeld_test_deriv(a,b,der)
      res(2) = sqrt(dot_product(der,matmul(cov,der)))

      ! Change units?
      change = FALSE
      if (present (angstrom)) change = angstrom
      if (change) res = res * ANGSTROM_PER_BOHR*ANGSTROM_PER_BOHR

   end

   Hirshfeld_test_deriv(a,b,deriv) ::: PURE
   ! Return the Hirshfeld test derivatives "deriv" wrt all nine pADPs
   ! atoms "A" and "B" as a 2*9=18 vector in pADP order.
      self :: IN
      a,b :: INT, IN
      deriv :: VEC{REAL}(18), OUT

      n :: VEC{REAL}(3)
      dr :: VEC{REAL}(6)
      delU :: MAT{REAL}(3,3)
      dn :: MAT{REAL}(3,6)
      dU :: VEC{REAL}(12)
      i,j,k :: INT

      ! Derivatives of n wrt pos & U wrt U^{A,B}
      .Hirshfeld_test_n_deriv(a,b,n,dn)
      .Hirshfeld_test_U_deriv(a,b,dU)

      ! Delta U matrix
      delU = self(a).ADP_tensor - self(b).ADP_tensor

      ! Derivative of Hirshfeld test wrt positions
      dr = ZERO
      do i = 1,3
      do j = 1,3
      do k = 1,6
         dr(k) = dr(k) + delU(i,j)* (dn(i,k)*n(j) + n(i)*dn(j,k))
      end
      end
      end

      ! Full derivative
      deriv( 1: 3) = dr( 1: 3)
      deriv( 4: 9) = dU( 1: 6)
      deriv(10:12) = dr( 4: 6)
      deriv(13:18) = dU( 7:12)

   end

   Hirshfeld_test_n_deriv(a,b,n,dn) ::: private, PURE
   ! Return the normalised vector "n" from atoms B to A, and derivs of
   ! each component "dn" wrt position coordinates on atoms A and B as
   ! a 3+3=6 vector in the second index of "dn".
      self :: IN
      a,b :: INT, IN
      n :: VEC{REAL}(3), OUT
      dn :: MAT{REAL}(3,6), OUT

      rab,rab2 :: VEC{REAL}(3)
      dab,dab3 :: REAL
      i,j :: INT

      ! Vector rab 
      rab  = self(a).position - self(b).position

      ! Normalised vector
      n = rab
      n.normalise

      ! Intermediates
      rab2 = rab*rab
      dab  = sqrt(rab2(1) + rab2(2) + rab2(3))
      dab  = ONE/dab
      dab3 = dab*dab*dab

      ! Derivative wrt r_A
      dn = ZERO
      do i = 1,3
         dn(i,i) = dab
         do j = 1,3
            dn(i,j) = dn(i,j) - rab(i)*rab(j)*dab3
         end
      end

      ! Derivative wrt tor_B 
      dn(:,4:6) = -dn(:,1:3)

   end

   Hirshfeld_test_U_deriv(a,b,dU) ::: private, PURE
   ! Return the Hirshfeld test derivatives "dU" wrt all nine ADPs
   ! U^A and U^B on atoms "A" and "B" as a 6+6=12 vector in the usual
   ! order xx, yy, zz, xy, xz,yz.
      self :: IN
      a,b :: INT, IN
      dU :: VEC{REAL}(12), OUT

      n :: VEC{REAL}(3)

      ! Normalised vector 
      n = self(a).position - self(b).position
      n.normalise

      ! Derivative wrt U^A
      dU(1) = n(1)*n(1) 
      dU(2) = n(2)*n(2) 
      dU(3) = n(3)*n(3) 
      dU(4) = n(1)*n(2) 
      dU(5) = n(1)*n(3) 
      dU(6) = n(2)*n(3) 

      ! Derivative wrt to U^B
      dU(7:12) = -dU(1:6)

   end

   put_Hirshfeld_test
   ! Output the Hirshfeld test for all atom pairs.
      self :: IN

   DIE_IF(any(self(:).ADP_axis_system/="cartesian"),"ADP axis system must be cartesian")
   DIE_IF(self(1).has_zero_ADP_tensor,"An ADP tensor is zero!")

      IDa,IDb :: VEC{STR}@
      tab :: MAT{REAL}@
      table :: VEC{TABLE_COLUMN}@
      n :: VEC{REAL}(3)
      con :: VEC{BIN}@
      hab :: VEC{REAL}@
      dU :: MAT{REAL}(3,3)
      fac,test :: REAL
      dim1,dim2, a,b,i :: INT

      ! Unit conversion for ADP's: A^2!
      fac = ANGSTROM_PER_BOHR
      fac = fac*fac

      ! CIF ADP header
      stdout.flush
      stdout.text("# ==============")
      stdout.text("# Hirshfeld test")
      stdout.text("# ==============")
      stdout.flush
      stdout.text(". Values are printed out for all atom pairs")
      stdout.flush
      stdout.text(". Units are in Angstrom^2")
      stdout.flush
      stdout.text(". The test prints:")
      stdout.flush
      stdout.text("     h_AB = n^T_AB (U^A - U^B) n_AB")
      stdout.text("     where n = r_A - r_B/|r_A - r_B|")
      stdout.flush
      stdout.text("  is the unit vector from B to A")
      stdout.flush

      ! Make the Hirshfeld test matrix (lower triangle only)
      dim1 = .dim
      dim2 = dim1*(dim1-1)/2

      tab.create(dim1,dim1)
      tab = ZERO

      IDa.create(dim2)
      IDb.create(dim2)
      hab.create(dim2)
      con.create(dim2)

      i = 0
      do a = 2,.dim
      do b = 1,a-1

         ! Unit vector
         n = self(a).position - self(b).position
         n.normalise

         ! Difference in ADPs
         dU = self(a).ADP_tensor - self(b).ADP_tensor

         ! H test value
         test = dot_product(n,matmul(dU,n)) * fac

         ! Store labels & H test value
         i = i + 1
         IDa(i) = self(a).tag
         IDb(i) = self(b).tag
         con(i) = .bonded(a,b)
         hab(i) = test
         tab(a,b) = test

      end
      end

      ! Table
      table.create(4)

      ! Headings
      table(1).set_heading("Atom")
      table(1).set_subhead("A")
      table(2).set_heading("Atom")
      table(2).set_subhead("B")
      table(3).set_heading("Bonded?")
      table(4).set_heading("H. Test")
      table(4).set_subhead("  /A^2")

      ! Set data
      table(1).set_values(IDa)
      table(2).set_values(IDb)
      table(3).set_values(con)
      table(4).set_values(hab)

      ! Put tables
      table.put

      ! Clean
      table.destroy
      hab.destroy
      con.destroy
      IDb.destroy
      IDa.destroy

      ! Full triangle
      stdout.flush
      stdout.text("Full triangle of Hirshfeld test values:")
      stdout.flush
      stdout.put(tab)

      ! Clean
      tab.destroy

   end

   put_bonds_and_Hirshfeld_test(cov_R,cov_pADP)
   ! Output the Hirshfeld test table with errors, given the
   ! "cov_R" position covariance matrix and the  "cov_pADP" pADP
   ! covariance matrix. Set "paretheses" FALSE if you want errors
   ! without them.
      self :: IN
      cov_R,cov_pADP :: MAT{REAL}, IN

   DIE_IF(self(1).pos_axis_system/="cartesian","axis system must be cartesian")
   DIE_IF(any(self(:).ADP_axis_system/="cartesian"),"ADP axis system must be cartesian")
   DIE_IF(self(1).has_zero_ADP_tensor,"An ADP tensor is zero!")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{EVEC{INT}}@
      no_of_bonds, n_kind,k1,k2,n_bonds :: INT
      symbols,labels :: MAT{STR}@
      dash,dsh1 :: VEC{STR}@
      dist,derr,test,terr :: VEC{REAL}@
      pair :: MAT{INT}@
      has_unique_labels :: BIN

      ! Anything to do?
      if (.dim<2) return

      no_of_bonds = .no_of_bonds
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("=============================")
      stdout.text("Bond lengths & Hirshfeld test")
      stdout.text("=============================")
      stdout.flush
      stdout.text(". The bond-detection criteria is the same as used")
      stdout.text("  by the Cambridge Structural Database (CSD).")
      if (NOT has_unique_labels) then
      stdout.flush
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number tags are used.")
      end
      stdout.flush
      stdout.text(". Hirshfeld test values are defined by:")
      stdout.flush
      stdout.text("     h_AB = n^T_AB (U^A - U^B) n_AB")
      stdout.flush
      stdout.text("  for bonded atom pairs A--B, where n = (r_A-r_B)/|r_A-r_B|")
      stdout.text("  is the unit vector from B to A. The units are Angstrom^2.")
      stdout.flush
      stdout.show("No. of bonds =",no_of_bonds)

      if (no_of_bonds>VEC_ATOM_MAX_BONDS_IN_TABLE) then
      stdout.flush
      stdout.text("There are too many bonds to display in a table.")
      return
      end
      stdout.flush

      ! Get Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(8)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self.chemical_symbols)

      table(2).set_column_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_heading("B")
      table(3).set_width(table(1).width)
      table(3).set_left_justify(TRUE)

      table(4).set_heading("A")
      table(4).set_width_from(self.tag)

      table(5).set_column_spacing(0)
      table(5).set_heading("--")
      table(5).set_width(2)

      table(6).set_heading("B")
      table(6).set_width(table(4).width)
      table(6).set_left_justify(TRUE)

      table(7).set_heading("Bond distance")
      table(7).set_subhead("R(A--B) /A")
      table(7).set_width_from(ONE)

      table(8).set_heading("Hirshfeld Test")
      table(8).set_subhead("/A^2")

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_Hirshfeld_test(pair,dist,derr,test,terr,Z_list,k1,k2,cov_R,cov_pADP,angstrom=TRUE)

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            terr.destroy
            test.destroy
            derr.destroy
            dist.destroy
            pair.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_bonds,2)
         symbols = " "
         symbols(1,1) = self(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = self(Z_list(k2)[1]).chemical_symbol

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = self(pair(:,1)).tag
         labels(:,2) = self(pair(:,2)).tag

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table(1).set_values(symbols(:,1))
         table(2).set_values(dsh1)
         table(3).set_values(symbols(:,2))
         table(4).set_values(labels(:,1))
         table(5).set_values(dash)
         table(6).set_values(labels(:,2))
         table(7).set_real_precision(stdout.real_precision) ! Must do, for every block
         table(7).set_values_and_errors(dist,derr)
         table(8).set_values_and_errors(test,terr)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         test.destroy
         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      Z_list.destroy

   end

   get_bonded_Hirshfeld_test(pair,dist,test,Z_list,k1,k2,angstrom,range_factor)
   ! Get the Nx2 bonded-atom "pair"s, and the distances "dist" between
   ! them. The pair have "Z_list" groups "k1" and "k2", respectively.
      self :: IN
      pair :: MAT{INT}@, OUT
      dist,test :: VEC{REAL}@, OUT
      Z_list :: VEC{EVEC{INT}}, IN
      k1,k2 :: INT, IN
      angstrom :: BIN, optional, IN
      range_factor :: REAL, optional, IN

   ENSURE(k1<=k2,"k2 is smaller than k1")

      i1,i2,a1,a2, n :: INT

      ! How many pairs, n, are there?
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (k1==k2 AND a2<=a1) cycle
            if (NOT .bonded(a1,a2,range_factor)) cycle

            ! Count
            n = n + 1

         end
      end

      ! Allocate
      pair.create(n,2)
      dist.create(n)
      test.create(n)

      ! Make the list
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (k1==k2 AND a2<=a1) cycle
            if (NOT .bonded(a1,a2,range_factor)) cycle

            ! Add the data
            n = n + 1
            pair(n,1) = a1
            pair(n,2) = a2
            dist(n)   =  .bond_distance(a1,a2,angstrom)
            test(n)   = .Hirshfeld_test(a1,a2,angstrom)

         end
      end

   end

   get_bonded_Hirshfeld_test(pair,dist,derr,test,terr,Z_list,k1,k2,cov_R,cov_pADP,angstrom,range_factor)
   ! Get the Nx2 bonded-atom "pair"s, and the distances "dist" between
   ! them. The pair have "Z_list" groups "k1" and "k2", respectively.
   ! The position and pADP covariances are "cov_R", "cov_pADP".
      self :: IN
      pair :: MAT{INT}@, OUT
      dist,derr,test,terr :: VEC{REAL}@, OUT
      Z_list :: VEC{EVEC{INT}}, IN
      k1,k2 :: INT, IN
      cov_R,cov_pADP :: MAT{REAL}, IN
      angstrom :: BIN, optional, IN
      range_factor :: REAL, optional, IN

   ENSURE(k1<=k2,"k2 is smaller than k1")

      i1,i2,a1,a2, n :: INT
      d,t :: VEC{REAL}(2)

      ! How many pairs, n, are there?
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (k1==k2 AND a2<=a1) cycle
            if (NOT .bonded(a1,a2,range_factor)) cycle

            ! Count
            n = n + 1

         end
      end

      ! Allocate
      pair.create(n,2)
      dist.create(n)
      derr.create(n)
      test.create(n)
      terr.create(n)

      ! Make the list
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (k1==k2 AND a2<=a1) cycle
            if (NOT .bonded(a1,a2,range_factor)) cycle

            ! Get values
            d =  .bond_distance(a1,a2,cov_R,angstrom)
            t = .Hirshfeld_test(a1,a2,cov_pADP,angstrom)

            ! Add the data
            n = n + 1
            pair(n,1) = a1
            pair(n,2) = a2
            dist(n) = d(1)
            derr(n) = d(2)
            test(n) = t(1)
            terr(n) = t(2)

         end
      end

   end

!  ===========
!  Bond angles
!  ===========

   put_bond_angle_table
   ! Output the bond angle table.
      self :: IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{EVEC{INT}}@
      symbols,labels :: MAT{STR}@
      dash,dsh1 :: VEC{STR}@
      triple :: MAT{INT}@
      angle :: VEC{REAL}@
      val :: STR
      no_of_angles, n_kind,k1,k2,k3,n_angles,w :: INT
      has_unique_labels :: BIN

      if (.dim<3) return

      no_of_angles = .no_of_angles
      if (no_of_angles<1) return

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("===========")
      stdout.text("Bond Angles")
      stdout.text("===========")
      stdout.flush
      stdout.text(". Atom B of Angle(A--B--C) is the middle atom.")
      stdout.flush
      if (NOT has_unique_labels) then
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number ID tags are used.")
      end
      stdout.flush
      stdout.show("No. of bond angles =",no_of_angles)

      if (no_of_angles>VEC_ATOM_MAX_ANGLES_IN_TABLE) then
      stdout.flush
      stdout.text("There are too many angles to display in a table.")
      return
      end
      stdout.flush

      ! Get Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(11)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.chemical_symbols)

      table(2).set_column_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_column_spacing(0)
      table(3).set_heading("B")
      table(3).set_width_from(.chemical_symbols)

      table(4).set_column_spacing(0)
      table(4).set_heading("--")
      table(4).set_width(2)

      table(5).set_column_spacing(0)
      table(5).set_heading("C")
      table(5).set_width(table(2).width)
      table(5).set_left_justify(TRUE)

      table(6).set_heading("A")
      table(6).set_width_from(self(.angle_outer_atoms).tag)

      table(7).set_column_spacing(0)
      table(7).set_heading("--")
      table(7).set_width(2)

      table(8).set_column_spacing(0)
      table(8).set_heading("B")
      table(8).set_width_from(self(.angle_center_atoms).tag)
      w = table(8).width
      val = "B"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(8).set_heading(val(1:w))

      table(9).set_column_spacing(0)
      table(9).set_heading("--")
      table(9).set_width(2)

      table(10).set_column_spacing(0)
      table(10).set_heading("C")
      table(10).set_width_from(self(.angle_outer_atoms).tag)
      table(10).set_left_justify(TRUE)

      table(11).set_heading("Angle(A--B--C)")
      table(11).set_subheading("/degree")
      table(11).set_width_from(-180d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_angles(triple,angle,Z_list,k1,k2,k3)
         angle = angle*DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            angle.destroy
            triple.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,3)
         symbols = " "
         symbols(1,1) = self(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = self(Z_list(k2)[1]).chemical_symbol
         symbols(1,3) = self(Z_list(k3)[1]).chemical_symbol

         ! Labels
         labels.create(n_angles,3)
         labels(:,1) = self(triple(:,1)).tag
         labels(:,2) = self(triple(:,2)).tag
         labels(:,3) = self(triple(:,3)).tag

         labels(:,2).pad_with("-",width=w,prepad=TRUE)

         ! Dashes
         dash.create(n_angles)
         dsh1.create(n_angles)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(dsh1)
         table( 5).set_values(symbols(:,3))
         table( 6).set_values(labels(:,1))
         table( 7).set_values(dash)
         table( 8).set_values(labels(:,2))
         table( 9).set_values(dash)
         table(10).set_values(labels(:,3))
         table(11).set_values(angle)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         angle.destroy
         triple.destroy

      end
      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      Z_list.destroy

   end

   put_bond_angle_table(covariance,parentheses)
   ! Output the bond angle table with errors given the "covariance"
   ! matrix between all atomic positions. Set "parentheses" FALSE if
   ! you don't want them for errors.
      self :: IN
      covariance :: MAT{REAL}, IN
      parentheses :: BIN, optional, IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{EVEC{INT}}@
      symbols,labels :: MAT{STR}@
      dash,dsh1 :: VEC{STR}@
      angle,esds :: VEC{REAL}@
      triple :: MAT{INT}@
      val :: STR
      no_of_angles, n_kind,k1,k2,k3,n_angles,w :: INT
      use_brackets,has_unique_labels :: BIN

      if (.dim<3) return

      no_of_angles = .no_of_angles
      if (no_of_angles<1) return

      ! Parentheses
      use_brackets = TRUE
      if (present(parentheses)) use_brackets = parentheses

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("===========")
      stdout.text("Bond Angles")
      stdout.text("===========")
      stdout.flush
      stdout.text("Atom B of Angle(A--B--C) is the middle atom.")
      stdout.flush
      if (NOT has_unique_labels) then
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number ID tags are used.")
      end
      stdout.flush
      stdout.show("No. of bond angles =",.no_of_angles)
      if (no_of_angles>VEC_ATOM_MAX_ANGLES_IN_TABLE) then
      stdout.flush
      stdout.text("There are too many angles to display in a table.")
      return
      end
      stdout.flush

      ! Get Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      if (use_brackets) then; table.create(11)
      else;                   table.create(12)
      end

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self(:).chemical_symbols)

      table(2).set_column_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_column_spacing(0)
      table(3).set_heading("B")
      table(3).set_width_from(self(:).chemical_symbols)

      table(4).set_column_spacing(0)
      table(4).set_heading("--")
      table(4).set_width(2)

      table(5).set_column_spacing(0)
      table(5).set_heading("C")
      table(5).set_width(table(2).width)
      table(5).set_left_justify(TRUE)

      table(6).set_heading("A")
      table(6).set_width_from(self(self(:).angle_outer_atoms).tag)

      table(7).set_column_spacing(0)
      table(7).set_heading("--")
      table(7).set_width(2)

      table(8).set_column_spacing(0)
      table(8).set_heading("B")
      table(8).set_width_from(self(self(:).angle_center_atoms).tag)
      w = table(8).width
      val = "B"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(8).set_heading(val(1:w))

      table(9).set_column_spacing(0)
      table(9).set_heading("--")
      table(9).set_width(2)

      table(10).set_column_spacing(0)
      table(10).set_heading("C")
      table(10).set_width_from(self(self(:).angle_outer_atoms).tag)
      table(10).set_left_justify(TRUE)

      table(11).set_heading("Angle(A--B--C)")
      table(11).set_subheading("/degree")
      table(11).set_width_from(ONE)

      if (NOT use_brackets) then
      table(12).set_heading("Error")
      table(12).set_width_from(ONE)
      end

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_angles(triple,angle,esds,Z_list,k1,k2,k3,covariance)
         angle = angle*DEGREE_PER_RADIAN
         esds  = esds *DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            esds.destroy
            angle.destroy
            triple.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,3)
         symbols = " "
         symbols(1,1) = self(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = self(Z_list(k2)[1]).chemical_symbol
         symbols(1,3) = self(Z_list(k3)[1]).chemical_symbol

         ! Labels
         labels.create(n_angles,3)
         labels(:,1) = self(triple(:,1)).tag
         labels(:,2) = self(triple(:,2)).tag
         labels(:,3) = self(triple(:,3)).tag

         labels(:,2).pad_with("-",width=w,prepad=TRUE)

         ! Dashes
         dash.create(n_angles)
         dsh1.create(n_angles)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(dsh1)
         table( 5).set_values(symbols(:,3))
         table( 6).set_values(labels(:,1))
         table( 7).set_values(dash)
         table( 8).set_values(labels(:,2))
         table( 9).set_values(dash)
         table(10).set_values(labels(:,3))
         if (use_brackets) then
         table(11).set_real_precision(stdout.real_precision) ! Must do, for every block
         table(11).set_values_and_errors(angle,esds)
         else
         table(11).set_values(angle)
         table(12).set_values(esds)
         end

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         esds.destroy
         angle.destroy
         triple.destroy

      end
      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      Z_list.destroy

   end

   get_bonded_angles(triple,angle,Z_list,k1,k2,k3) ::: leaky, private
   ! Get the Nx3 bonded-atom "triple"s, and the "angles" between them.
   ! The triple has "Z_list" groups of "k1", "k2", and "k3", resp.
      self :: IN
      triple :: MAT{INT}@, OUT
      angle :: VEC{REAL}@, OUT
      Z_list :: VEC{EVEC{INT}}, IN
      k1,k2,k3 :: INT, IN

   ENSURE(k1<=k3,"k3 is smaller than k1")

      i1,i2,i3,a1,a2,a3, n :: INT

      ! How many triples, n, are there?
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,Z_list(k3).element.dim
               a3 = Z_list(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle
               if (k1==k3 AND a3<a1) cycle

               ! Count
               n = n + 1

            end
         end
      end

      ! Allocate
      triple.create(n,3)
      angle.create(n)

      ! Make the list
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,Z_list(k3).element.dim
               a3 = Z_list(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle
               if (k1==k3 AND a3<a1) cycle

               ! Add data
               n = n + 1
               triple(n,1) = a1
               triple(n,2) = a2
               triple(n,3) = a3
               angle(n) = .bond_angle(a1,a2,a3)

            end
         end
      end

   end

   get_bonded_angles(triple,angle,esds,Z_list,k1,k2,k3,covariance) ::: leaky, private
   ! Get the bonded-atom "triple"s, and the "angles" between them, and
   ! the associated "esds". The triple has "Z_list" groups of "k1",
   ! "k2", and "k3", respectively. The "covariance" matrix is between
   ! *all* atom coordinates.
      self :: IN
      triple :: MAT{INT}@, OUT
      angle,esds :: VEC{REAL}@, OUT
      Z_list :: VEC{EVEC{INT}}, IN
      k1,k2,k3 :: INT, IN
      covariance :: MAT{REAL}, IN

   ENSURE(k1<=k3,"k3 is smaller than k1")
   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      i1,i2,i3,a1,a2,a3, n :: INT
      err :: REAL
      der :: VEC{REAL}(9)
      cov :: MAT{REAL}(9,9)

      ! How many triples, n, are there?
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,Z_list(k3).element.dim
               a3 = Z_list(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle
               if (k1==k3 AND a3<a1) cycle

               ! Count
               n = n + 1

            end
         end
      end

      ! Allocate
      triple.create(n,3)
      angle.create(n)
      esds.create(n)

      ! Make the list
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,Z_list(k3).element.dim
               a3 = Z_list(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle
               if (k1==k3 AND a3<a1) cycle

               ! Extract covariances for atoms a, b, c
               covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2,a3])

               ! Make error
               .bond_angle_deriv(a1,a2,a3,der)
               err = cov.dot(der,der)
               if (err<ZERO) then
                  err = ZERO
               end
               err = sqrt(err)

               ! Add data
               n = n + 1
               triple(n,1) = a1
               triple(n,2) = a2
               triple(n,3) = a3
               angle(n)    = .bond_angle(a1,a2,a3)
               esds(n)     = err

            end
         end
      end

   end

   put_bond_angle_with_error(a1,a2,a3,covariance) ::: leaky
   ! Put the bond angle between atoms "a1" ... "a3" with error.  The
   ! "covariance" matrix is for *all* atom coordinates.
      self :: IN
      a1,a2,a3 :: INT, IN
      covariance :: MAT{REAL}, IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")
   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      err,ang :: REAL
      der :: VEC{REAL}(9)
      cov :: MAT{REAL}(9,9)

      ! Extract covariances for atom a, b, c positions
      covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2,a3])

      ! Make error
      .bond_angle_deriv(a1,a2,a3,der)
      err = cov.dot(der,der)
      err = sqrt(err)
      err.convert_to("degree")

      ! Add the data
      ang   = .bond_angle(a1,a2,a3)
      ang.convert_to("degree")

      ! Output
      stdout.flush
      stdout.text("=====================")
      stdout.text("Bond angle with error")
      stdout.text("=====================")
      stdout.show("Atom 1        =",self(a1).tag)
      stdout.show("Atom 2        =",self(a2).tag)
      stdout.show("Atom 3        =",self(a3).tag)
      stdout.show("Bond angle    =",ang)
      stdout.show("Error         =",err)

   end

!  ================
!  Torsions angles
!  ================

   put_torsion_angle_table
   ! Output the torsion angle table.
      self :: IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{EVEC{INT}}@
      symbols,labels :: MAT{STR}@
      dash,dsh1 :: VEC{STR}@
      quad :: MAT{INT}@
      angle :: VEC{REAL}@
      val :: STR
      no_of_torsions, n_kind,k1,k2,k3,k4,n_angles,w :: INT
      has_unique_labels :: BIN

      if (.dim<4) return

      no_of_torsions = .no_of_torsion_angles
      if (no_of_torsions<1) return

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("==============")
      stdout.text("Torsion angles")
      stdout.text("==============")
      stdout.flush
      stdout.text(". The angle shown is the one that looking down B->C")
      stdout.text("  i.e. it's the one between r(A)-r(B) and r(D)-r(C)")
      stdout.flush
      stdout.text(". The angle is +ve if r(D)-r(C) is clockwise of r(A)-r(B)")
      stdout.flush
      if (NOT has_unique_labels) then
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number ID tags are used.")
      end
      stdout.flush
      stdout.show("No. of torsion angles =",no_of_torsions)

      if (no_of_torsions>VEC_ATOM_MAX_TORSIONS_IN_TABLE) then
      stdout.flush
      stdout.text("There are too many angles to display in a table.")
      return
      end
      stdout.flush

      ! Get atom Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(15)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self(:).chemical_symbols)

      table(2).set_column_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_column_spacing(0)
      table(3).set_heading("B")
      table(3).set_width_from(self(:).chemical_symbols)

      table(4).set_column_spacing(0)
      table(4).set_heading("--")
      table(4).set_width(2)

      table(5).set_column_spacing(0)
      table(5).set_heading("C")
      table(5).set_width_from(self(:).chemical_symbols)

      table(6).set_column_spacing(0)
      table(6).set_heading("--")
      table(6).set_width(2)

      table(7).set_column_spacing(0)
      table(7).set_heading("D")
      table(7).set_width(table(2).width)
      table(7).set_left_justify(TRUE)

      table(8).set_heading("A")
      table(8).set_width_from(self(self(:).torsion_angle_1st_atoms).tag)

      table(9).set_column_spacing(0)
      table(9).set_heading("--")
      table(9).set_width(2)

      table(10).set_column_spacing(0)
      table(10).set_heading("B")
      table(10).set_width_from(self(self(:).torsion_angle_2nd_atoms).tag)
      w = table(10).width
      val = "B"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(10).set_heading(val(1:w))

      table(11).set_column_spacing(0)
      table(11).set_heading("--")
      table(11).set_width(2)

      table(12).set_column_spacing(0)
      table(12).set_heading("C")
      table(12).set_width_from(self(self(:).torsion_angle_3rd_atoms).tag)
      w = table(12).width
      val = "C"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(12).set_heading(val(1:w))

      table(13).set_column_spacing(0)
      table(13).set_heading("--")
      table(13).set_width(2)

      table(14).set_column_spacing(0)
      table(14).set_heading("D")
      table(14).set_width_from(self(self(:).torsion_angle_4th_atoms).tag)
      table(14).set_left_justify(TRUE)

      table(15).set_heading("Angle(A--B--C--D)")
      table(15).set_subheading("/degree")
      table(15).set_width_from(-180d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = 1,n_kind
      do k4 = 1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_torsions(quad,angle,Z_list,k1,k2,k3,k4)
         angle = angle*DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            angle.destroy
            quad.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,4)
         symbols = " "
         symbols(1,1) = self(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = self(Z_list(k2)[1]).chemical_symbol
         symbols(1,3) = self(Z_list(k3)[1]).chemical_symbol
         symbols(1,4) = self(Z_list(k4)[1]).chemical_symbol

         ! Labels
         labels.create(n_angles,4)
         labels(:,1) = self(quad(:,1)).tag
         labels(:,2) = self(quad(:,2)).tag
         labels(:,3) = self(quad(:,3)).tag
         labels(:,4) = self(quad(:,4)).tag

         labels(:,2).pad_with("-",width=w,prepad=TRUE)
         labels(:,3).pad_with("-",width=w,prepad=TRUE)

         ! Dashes
         dash.create(n_angles)
         dsh1.create(n_angles)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(dsh1)
         table( 5).set_values(symbols(:,3))
         table( 6).set_values(dsh1)
         table( 7).set_values(symbols(:,4))

         table( 8).set_values(labels(:,1))
         table( 9).set_values(dash)
         table(10).set_values(labels(:,2))
         table(11).set_values(dash)
         table(12).set_values(labels(:,3))
         table(13).set_values(dash)
         table(14).set_values(labels(:,4))

         table(15).set_values(angle)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         angle.destroy
         quad.destroy

      end
      end
      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      Z_list.destroy

   end

   put_torsion_angle_table(covariance,parentheses)
   ! Output the torsion angle table with errors given the "covariance"
   ! matrix between all atomic positions. Set "parentheses" FALSE if
   ! ypou don't want them for errors.
      self :: IN
      covariance :: MAT{REAL}, IN
      parentheses :: BIN, optional, IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{EVEC{INT}}@
      symbols,labels :: MAT{STR}@
      dash,dsh1 :: VEC{STR}@
      angle,esds :: VEC{REAL}@
      quad :: MAT{INT}@
      no_of_torsions, n_kind,k1,k2,k3,k4,n_angles,w :: INT
      use_brackets,has_unique_labels :: BIN
      val :: STR

      if (.dim<4) return

      no_of_torsions = .no_of_torsion_angles
      if (no_of_torsions<1) return

      ! Parentheses
      use_brackets = TRUE
      if (present(parentheses)) use_brackets = parentheses

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("==============")
      stdout.text("Torsion angles")
      stdout.text("==============")
      stdout.flush
      stdout.text("The angle shown is the one that looking down B->C")
      stdout.text("i.e. it's the one between r(A)-r(B) and r(D)-r(C).")
      stdout.flush
      stdout.text("The angle is +ve if r(D)-r(C) is clockwise of r(A)-r(B).")
      stdout.flush
      if (NOT has_unique_labels) then
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number ID tags are used.")
      end
      stdout.flush
      stdout.show("No. of torsion angles =",no_of_torsions)
      if (no_of_torsions>VEC_ATOM_MAX_TORSIONS_IN_TABLE) then
      stdout.flush
      stdout.text("There are too many angles to display in a table.")
      return
      end
      stdout.flush

      ! Get Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      if (use_brackets) then; table.create(15)
      else;                   table.create(16)
      end

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self(:).chemical_symbols)

      table(2).set_column_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_column_spacing(0)
      table(3).set_heading("B")
      table(3).set_width_from(self(:).chemical_symbols)

      table(4).set_column_spacing(0)
      table(4).set_heading("--")
      table(4).set_width(2)

      table(5).set_column_spacing(0)
      table(5).set_heading("C")
      table(5).set_width_from(self(:).chemical_symbols)

      table(6).set_column_spacing(0)
      table(6).set_heading("--")
      table(6).set_width(2)

      table(7).set_column_spacing(0)
      table(7).set_heading("D")
      table(7).set_width(table(2).width)
      table(7).set_left_justify(TRUE)

      table(8).set_heading("A")
      table(8).set_width_from(self(self(:).torsion_angle_1st_atoms).tag)

      table(9).set_column_spacing(0)
      table(9).set_heading("--")
      table(9).set_width(2)

      table(10).set_column_spacing(0)
      table(10).set_heading("B")
      table(10).set_width_from(self(self(:).torsion_angle_2nd_atoms).tag)
      w = table(10).width
      val = "B"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(10).set_heading(val(1:w))

      table(11).set_column_spacing(0)
      table(11).set_heading("--")
      table(11).set_width(2)

      table(12).set_column_spacing(0)
      table(12).set_heading("C")
      table(12).set_width_from(self(self(:).torsion_angle_3rd_atoms).tag)
      w = table(12).width
      val = "C"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(12).set_heading(val(1:w))

      table(13).set_column_spacing(0)
      table(13).set_heading("--")
      table(13).set_width(2)

      table(14).set_column_spacing(0)
      table(14).set_heading("D")
      table(14).set_width_from(self(self(:).torsion_angle_4th_atoms).tag)
      table(14).set_left_justify(TRUE)

      table(15).set_heading("Angle(A--B--C--D)")
      table(15).set_subheading("/degree")
      table(15).set_width_from(ONE)

      if (NOT use_brackets) then
      table(16).set_heading("Error")
      table(16).set_width_from(ONE)
      end

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = 1,n_kind
      do k4 = 1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_torsions(quad,angle,esds,Z_list,k1,k2,k3,k4,covariance)
         angle = angle*DEGREE_PER_RADIAN
         esds  =  esds*DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            esds.destroy
            angle.destroy
            quad.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,4)
         symbols = " "
         symbols(1,1) = self(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = self(Z_list(k2)[1]).chemical_symbol
         symbols(1,3) = self(Z_list(k3)[1]).chemical_symbol
         symbols(1,4) = self(Z_list(k4)[1]).chemical_symbol

         ! Labels
         labels.create(n_angles,4)
         labels(:,1) = self(quad(:,1)).tag
         labels(:,2) = self(quad(:,2)).tag
         labels(:,3) = self(quad(:,3)).tag
         labels(:,4) = self(quad(:,4)).tag

         labels(:,2).pad_with("-",width=w,prepad=TRUE)
         labels(:,3).pad_with("-",width=w,prepad=TRUE)

         ! Dashes
         dash.create(n_angles)
         dsh1.create(n_angles)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(dsh1)
         table( 5).set_values(symbols(:,3))
         table( 6).set_values(dsh1)
         table( 7).set_values(symbols(:,4))

         table( 8).set_values(labels(:,1))
         table( 9).set_values(dash)
         table(10).set_values(labels(:,2))
         table(11).set_values(dash)
         table(12).set_values(labels(:,3))
         table(13).set_values(dash)
         table(14).set_values(labels(:,4))

         if (use_brackets) then
         table(15).set_real_precision(stdout.real_precision) ! Must do, for every block
         table(15).set_values_and_errors(angle,esds)
         else
         table(15).set_values(angle)
         table(16).set_values(esds)
         end

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Put spacer if not last block
         if (NOT (k1==n_kind AND k2==n_kind AND k3==n_kind AND k4==n_kind)) stdout.flush

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         esds.destroy
         angle.destroy
         quad.destroy

      end
      end
      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      Z_list.destroy

   end

   get_bonded_torsions(quad,angle,Z_list,k1,k2,k3,k4) ::: leaky, private
   ! Get the bonded-atom "quad"ruples, and the "angles" between them.
   ! The quadruple has "Z_list" groups of "k1" ... "k4", respectively.
      self :: IN
      quad :: MAT{INT}@, OUT
      angle :: VEC{REAL}@, OUT
      Z_list :: VEC{EVEC{INT}}, IN
      k1,k2,k3,k4 :: INT, IN

      i1,i2,i3,i4,a1,a2,a3,a4, n :: INT

      ! How many quadruples, n, are there?
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,Z_list(k3).element.dim
               a3 = Z_list(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle

               do i4 = 1,Z_list(k4).element.dim
                  a4 = Z_list(k4)[i4]

                  if (a4==a1 OR a4==a2 OR a4==a3) cycle
                  if (NOT .bonded(a3,a4)) cycle
                  if (a4<a1) cycle

                  ! Count
                  n = n + 1

               end
            end
         end
      end

      ! Allocate
      quad.create(n,4)
      angle.create(n)

      ! Make the list
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,Z_list(k3).element.dim
               a3 = Z_list(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle

               do i4 = 1,Z_list(k4).element.dim
                  a4 = Z_list(k4)[i4]

                  if (a4==a1 OR a4==a2 OR a4==a3) cycle
                  if (NOT .bonded(a3,a4)) cycle
                  if (a4<a1) cycle

                  ! Add data
                  n = n + 1
                  quad(n,1) = a1
                  quad(n,2) = a2
                  quad(n,3) = a3
                  quad(n,4) = a4
                  angle(n)  = .torsion_angle(a1,a2,a3,a4)

               end
            end
         end
      end

   end

   get_bonded_torsions(quad,angle,esds,Z_list,k1,k2,k3,k4,covariance) ::: leaky, private
   ! Get the bonded-atom "quad"ruples, and the "angles" between them.
   ! The quadruple has "Z_list" groups of "k1" ... "k4", respectively.
      self :: IN
      quad :: MAT{INT}@, OUT
      angle,esds :: VEC{REAL}@, OUT
      Z_list :: VEC{EVEC{INT}}, IN
      k1,k2,k3,k4 :: INT, IN
      covariance :: MAT{REAL}, IN

   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      i1,i2,i3,i4,a1,a2,a3,a4, n :: INT
      err :: REAL
      der :: VEC{REAL}(12)
      cov :: MAT{REAL}(12,12)

      ! How many quadruples, n, are there?
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,Z_list(k3).element.dim
               a3 = Z_list(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle

               do i4 = 1,Z_list(k4).element.dim
                  a4 = Z_list(k4)[i4]

                  if (a4==a1 OR a4==a2 OR a4==a3) cycle
                  if (NOT .bonded(a3,a4)) cycle
                  if (a4<a1) cycle

                  ! Count
                  n = n + 1

               end
            end
         end
      end

      ! Allocate
      quad.create(n,4)
      angle.create(n)
      esds.create(n)

      ! Make the list
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,Z_list(k3).element.dim
               a3 = Z_list(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle

               do i4 = 1,Z_list(k4).element.dim
                  a4 = Z_list(k4)[i4]

                  if (a4==a1 OR a4==a2 OR a4==a3) cycle
                  if (NOT .bonded(a3,a4)) cycle
                  if (a4<a1) cycle

                  ! Extract covariances for atoms a, b, c
                  covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2,a3,a4])

                  ! Make error
                  .torsion_angle_deriv(a1,a2,a3,a4,der)
                  err = cov.dot(der,der)
                  if (err<ZERO) then
                     err = ZERO
                  end
                  err = sqrt(err)

                  ! Add data
                  n = n + 1
                  quad(n,1) = a1
                  quad(n,2) = a2
                  quad(n,3) = a3
                  quad(n,4) = a4
                  angle(n)  = .torsion_angle(a1,a2,a3,a4)
                  esds(n)   = err

               end
            end
         end
      end

   end

   put_torsion_angle_with_error(a1,a2,a3,a4,covariance) ::: leaky
   ! Get the bonded-atom "pair"s, and the distances "dist" between
   ! them, and the associated "esds". The pair has "atom_kind" of "k1"
   ! and "k2", respectively. The "covariance" matrix for *all* atom
   ! coordinates is also given.
      self :: IN
      a1,a2,a3,a4 :: INT, IN
      covariance :: MAT{REAL}, IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")
   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      err,tor :: REAL
      der :: VEC{REAL}(12)
      cov :: MAT{REAL}(12,12)

      ! Extract covariances for atom a, b positions
      covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2,a3,a4])

      ! Make error
      .torsion_angle_deriv(a1,a2,a3,a4,der)
      err = cov.dot(der,der)
      err = sqrt(err)
      err.convert_to("degree")

      ! Add the data
      tor   = .torsion_angle(a1,a2,a3,a4)
      tor.convert_to("degree")

      ! Output
      stdout.flush
      stdout.text("========================")
      stdout.text("Torsion angle with error")
      stdout.text("========================")
      stdout.show("Atom 1        =",self(a1).tag)
      stdout.show("Atom 2        =",self(a2).tag)
      stdout.show("Atom 3        =",self(a3).tag)
      stdout.show("Atom 4        =",self(a4).tag)
      stdout.show("Torsion angle =",tor)
      stdout.show("Error         =",err)

   end

!  ==============
!  Principal axes
!  ==============

   put_principal_axes
   ! Put out the principal axis information
      self :: IN

      pm,pn :: VEC{REAL}(3)
      pa :: MAT{REAL}(3,3)
      reorder :: BIN

      .make_principal_moments(pm,pa,reorder)

      pn = pm/maxval(pm) ! normalised moments

      stdout.flush
      stdout.text("Principal moments and axes:")
      stdout.flush
      stdout.show("Center of mass    =",.center_of_mass)
      stdout.show("Principal moments =",pm)
      stdout.show("Spherical top?    =",.is_spherical_top(pn))
      stdout.show("Symmetric top?    =",.is_symmetric_top(pn))
      stdout.show("Prolate top?      =",.is_prolate_top(pn))
      stdout.show("Oblate top?       =",.is_oblate_top(pn))
      stdout.flush
      stdout.text("Principal axes:")
      stdout.put(pa)

   end

!  ==
!  MM
!  ==

!   put_mm_info ::: private
!   ! Output a table of the residue names, sequence numbers, charges, but
!   ! no basis sets. This is in PDB input format.
!      i :: INT
!      stdout.flush
!      stdout.text("Residue information:")
!      stdout.flush
!      stdout.dash(width=42)
!      stdout.put(" ",width=4)
!      stdout.put("#",width=7)
!      stdout.put("Name",width=4)
!      stdout.put("Residue",width=5)
!      stdout.put("Sequence",width=6)
!      stdout.put("x",width=3)
!      stdout.put("y",width=3)
!      stdout.put("z",width=3)
!      stdout.put("Charge",width=3)
!      stdout.put("Element",width=4)
!      stdout.flush
!      stdout.dash(width=42)
!      stdout.dash(int_fields=6,real_fields=5)
!      do i = 1,size(self)
!         stdout.put("ATOM",width=4)
!         stdout.put(i,width=7)
!         stdout.put(self(i).residue_atom_code,width=4)
!         stdout.put(self(i).residue_code,width=5)
!         stdout.put(self(i).residue_sequence_number,width=6)
!         stdout.put(self(i).position(1),width=8,precision=3)
!         stdout.put(self(i).position(2),width=8,precision=3)
!         stdout.put(self(i).position(3),width=8,precision=3)
!         stdout.put(self(i).mm_charge,width=7,precision=3)
!         stdout.put(self(i).label,width=4)
!         stdout.flush
!      end
!      stdout.dash(width=42)
!   end

!   put_restraint_atoms ::: private
!   ! Output a table of the atom names, residue names and restraint atom
!   ! information
!      i :: INT
!      stdout.text("Restraint atoms:")
!      stdout.save
!      stdout.set_int_width(9)
!      stdout.set_real_width(9)
!      stdout.set_real_precision(3)
!      stdout.dash(int_fields=5,real_fields=3)
!      stdout.put(" ",int_width=TRUE)
!      stdout.put("Atom",int_width=TRUE)
!      stdout.put("Residue",int_width=TRUE)
!      stdout.put("Sequence")
!      stdout.put("x")
!      stdout.put("y")
!      stdout.put("z")
!      stdout.put("Force",int_width=TRUE)
!      stdout.flush
!      stdout.dash(int_fields=5,real_fields=3)
!      do i = 1,size(self)
!         if (self(i).restraining_force_constant.is_zero) cycle
!         stdout.put(" ",int_width=TRUE)
!         stdout.put(self(i).residue_atom_code,int_width=TRUE)
!         stdout.put(self(i).residue_code,int_width=TRUE)
!         stdout.put(self(i).residue_sequence_number)
!         stdout.put(self(i).restraining_position(1))
!         stdout.put(self(i).restraining_position(2))
!         stdout.put(self(i).restraining_position(3))
!         stdout.put(self(i).restraining_force_constant)
!         stdout.flush
!      end
!      stdout.dash(int_fields=5,real_fields=3)
!      stdout.unsave
!   end

!  ====
!  VRML
!  ====

   put_vrml(out)
   ! Put vrml version of the atomvec to the file in object "out".
      self :: IN
      out :: TEXTFILE, INOUT

      out.set_real_precision(5)
      out.set_real_width(12)

      stdout.text("Generating VRML atoms...")
      VEC{ATOM}::put_vrml_header(out)
      .put_vrml_atoms(out)
      .put_vrml_bonds(out)
      stdout.text("done VRML atoms")
      stdout.flush

   end

   put_vrml_header(out) ::: selfless, private
   ! Put vrml header, and prototype bond and spheres, to the file.
      self :: IN
      out :: TEXTFILE, INOUT

      out.text("PROTO Atom " // achar(91))
      out.text("   field SFColor col 1 0 0")
      out.text("   field SFFloat rad 1")
      out.text("   field SFVec3f pos 0 0 0")
      out.text(achar(93))
      out.text("{")
      out.text("   Transform {")
      out.text("      translation IS pos")
      out.text("      children " // achar(91))
      out.text("         Shape {")
      out.text("            appearance Appearance {")
      out.text("               material Material {")
      out.text("                  diffuseColor IS col")
      out.text("               }")
      out.text("            }")
      out.text("            geometry Sphere {")
      out.text("              radius IS rad")
      out.text("            }")
      out.text("         }")
      out.text("      " // achar(93))
      out.text("   }")
      out.text("}")

      out.flush

      out.text("PROTO Bond " // achar(91))
      out.text("   field SFColor col 1 0 0")
      out.text("   field SFFloat hgt 1")
      out.text("   field SFVec3f pos 0 0 0")
      out.text("   field SFRotation rot 1 0 0 0")
      out.text(achar(93))
      out.text("{")
      out.text("   Transform {")
      out.text("      translation IS pos")
      out.text("      rotation IS rot")
      out.text("      children " // achar(91))
      out.text("         Shape {")
      out.text("            appearance Appearance {")
      out.text("               material Material {")
      out.text("                 diffuseColor IS col")
      out.text("               }")
      out.text("            }")
      out.text("            geometry Cylinder {")
      out.text("               radius 0.304245979")
      out.text("               height IS hgt")
      out.text("               top    FALSE")
      out.text("               bottom FALSE")
      out.text("            }")
      out.text("         }")
      out.text("      " // achar(93))
      out.text("   }")
      out.text("}")

      out.flush

   end

   put_vrml_atoms(out) ::: private
   ! Put spheres for the atoms to view as vrml.
      self :: IN
      out :: TEXTFILE, INOUT

      colour :: VEC{REAL}(3)
      label  :: STR(len=2)
      radius :: REAL
      n,Z :: INT

      do n = 1,.dim

         Z = self(n).atomic_number
         label = self(n).chemical_symbol

         select case (label)
         case ("H ","D ","T ");           colour = (/191,196,192/)
         case ("He","Rn");                colour = (/88,196,160/)
         case ("Li","Be","Na","Mg");      colour = (/144,149,145/)
         case ("B ");                     colour = (/187,4,187/)
         case ("C ");                     colour = (/160,80,17/)
         case ("N ","Al");                colour = (/126,169,176/)
         case ("Si");                     colour = (/192,172,137/)
         case ("S ");                     colour = (/192,165,0/)
         case ("Cl");                     colour = (/0,165,0/)
         case ("O ","Ca","Ge","As");      colour = (/192,12,8/)
         case ("Se","Br","Sr","I ");      colour = (/192,12,8/)
         case default;                    colour = (/192,148,25/)
         end

         select case (Z)
         case (1:54);     radius = self(n).bragg_slater_radius
         case default;    radius = 1.30d0
         end

         colour = colour / 256
         out.text("Atom {")
         out.text(" col " // trim(colour.to_concatenated_str("f15.8",separator=", ")))
         out.text(" pos " // trim(self(n).position.to_concatenated_str("f15.8",separator=", ")))
         out.text(" rad " // trim(radius.to_str("f15.8")))
         out.text("}")

      end

   end

   put_vrml_bonds(out) ::: private
   ! Put bonds for the atoms to view as vrml.
      self :: IN
      out :: TEXTFILE, INOUT

      col_a,col_b,posa,posb,pos1,pos2,AB,center :: VEC{REAL}(3)
      rot :: VEC{REAL}(4)
      hgta,hgtb,rada,radb :: REAL
      a,b :: INT

      do a = 1,.dim
      do b = 1,a-1

         if (.bonded(a,b)) then

            posa = self(a).position
            posb = self(b).position
            AB = posb-posa
            AB.normalise

            rada = self(a).bragg_slater_radius
            radb = self(b).bragg_slater_radius
            center = HALF*(posa+rada*AB + posb-radb*AB)

            hgta = (center - posa).norm
            hgtb = (posb - center).norm

            pos1 = HALF*(center + posa)
            pos2 = HALF*(center + posb)

            rot(4) = PI
            rot(1:3) = AB + [ZERO,ONE,ZERO]
            rot(1:3).normalise

            select case (self(a).chemical_symbol)
               case ("H ","D ","T ");           col_a = (/191,196,192/)
               case ("He","Rn");                col_a = (/88,196,160/)
               case ("Li","Be","Na","Mg");      col_a = (/144,149,145/)
               case ("B ");                     col_a = (/187,4,187/)
               case ("C ");                     col_a = (/160,80,17/)
               case ("N ","Al");                col_a = (/126,169,176/)
               case ("Si");                     col_a = (/192,172,137/)
               case ("S ");                     col_a = (/192,165,0/)
               case ("Cl");                     col_a = (/0,165,0/)
               case ("O ","Ca","Ge","As");      col_a = (/192,12,8/)
               case ("Se","Br","Sr","I ");      col_a = (/192,12,8/)
               case default;                    col_a = (/192,148,25/)
            end

            select case (self(b).chemical_symbol)
               case ("H ");                     col_b = (/191,196,192/)
               case ("He","Rn");                col_b = (/88,196,160/)
               case ("Li","Be","Na","Mg");      col_b = (/144,149,145/)
               case ("B ");                     col_b = (/187,4,187/)
               case ("C ");                     col_b = (/160,80,17/)
               case ("N ","Al");                col_b = (/126,169,176/)
               case ("Si");                     col_b = (/192,172,137/)
               case ("S ");                     col_b = (/192,165,0/)
               case ("Cl");                     col_b = (/0,165,0/)
               case ("O ","Ca","Ge","As");      col_b = (/192,12,8/)
               case ("Se","Br","Sr","I ");      col_b = (/192,12,8/)
               case default;                    col_b = (/192,148,25/)
            end

            col_a = col_a / 256
            col_b = col_b / 256
            out.text("Bond {")
            out.text(" col " //  trim(col_a.to_concatenated_str("f15.8",separator=", ")))
            out.text(" pos " //  trim(pos1.to_concatenated_str("f15.8",separator=", ")))
            out.text(" rot " //  trim(rot.to_concatenated_str("f15.8",separator=", ")))
            out.text(" hgt " //  trim(hgta.to_str("f15.8")))
            out.text("}")
            out.text("Bond {")
            out.text(" col " //  trim(col_b.to_concatenated_str("f15.8",separator=", ")))
            out.text(" pos " //  trim(pos2.to_concatenated_str("f15.8",separator=", ")))
            out.text(" rot " //  trim(rot.to_concatenated_str("f15.8",separator=", ")))
            out.text(" hgt " //  trim(hgtb.to_str("f15.8")))
            out.text("}")

         end

      end
      end

   end

   put_atom_groups
   ! Put out the atom group information
      self :: IN

   ENSURE(.has_groups,"no atom group information")

      n,i :: INT
      list :: VEC{EVEC{INT}}@

      .make_atom_group_list(list)

      stdout.save
      stdout.set_int_width(3)
      stdout.set_no_of_fields_per_line(25)
      stdout.set_using_array_labels(FALSE)

      stdout.flush
      stdout.text("Atom group information")
      stdout.flush
      stdout.show("n_groups =",list.dim)

      do n = 1,list.dim
         stdout.put("group "// trim(n.to_str) //"  =")
         do i = 1,list(n).element.dim
            stdout.put(list(n).element(i))
         end
         stdout.flush
      end

      stdout.unsave
      list.destroy

   end

   put_CX(label,angstrom)
   ! Outputs some information for the Crystal Explorer program
      label :: STR
      angstrom :: BIN, optional

      a :: INT
      pos :: VEC{REAL}(3)
      angst :: BIN

      angst = FALSE
      if (present(angstrom)) angst = angstrom

      ! Print atom_coords
      stdout.flush
      stdout.text("begin atom_coords " // label.trim)

      do a = 1,.dim

         stdout.put(self(a).label)
         stdout.put(self(a).chemical_symbol)

         pos = self(a).position
         if (angst) pos = ANGSTROM_PER_BOHR*pos
         stdout.put(pos(1))
         stdout.put(pos(2))
         stdout.put(pos(3))

         stdout.put(" IN")

         stdout.put(self(a).site_disorder_group)
         stdout.put(self(a).site_occupancy)

         stdout.flush

      end

      stdout.text("end atom_coords")

   end

!  ================
!  Put CIF routines
!  ================

   put_CIF_coords(refine_H_U_iso)
   ! Output the atoms and ADP's in CIF format to "stdout" in an
   ! axis system, with (optionally) errors "esd" provided externally.
      self :: IN
      refine_H_U_iso :: BIN, IN

      is_cartn :: BIN

      is_cartn = self(1).pos_axis_system=="cartesian"

      if (is_cartn) then; .put_CIF_coords_cartn(refine_H_U_iso)
      else;               .put_CIF_coords_cryst(refine_H_U_iso)
      end

   end

   put_CIF_coords(refine_H_U_iso,esd)
   ! Output the atoms and ADP's in CIF format to "stdout" in an
   ! axis system, with errors "esd" provided externally.
      self :: IN
      refine_H_U_iso :: BIN, IN
      esd :: VEC{REAL}, IN

      is_cartn :: BIN

      is_cartn = self(1).pos_axis_system=="cartesian"

      if (is_cartn) then; .put_CIF_coords_cartn(refine_H_U_iso,esd)
      else;               .put_CIF_coords_cryst(refine_H_U_iso,esd)
      end

   end

   put_CIF_coords_cartn(refine_H_U_iso) ::: private
   ! Output the atoms and ADP's in CIF format to "stdout" in the
   ! cartesian axis system. This version does override existing esd's.
      self :: IN
      refine_H_U_iso :: BIN, IN

   ENSURE(self(1).pos_axis_system=="cartesian","not cartesian axis system!")

      blnk,ADP_type :: VEC{STR}@
      Uiso,Uerr :: VEC{REAL}@
      xyz,err :: MAT{REAL}@
      fac,fac2 :: REAL
      tabl1,tabl2 :: VEC{TABLE_COLUMN}@

      ! Unit conversion
      fac  = ANGSTROM_PER_BOHR
      fac2 = fac*fac

      ! CIF coordinate header
      stdout.flush
      stdout.text("# =====================")
      stdout.text("# Cartesian coordinates")
      stdout.text("# =====================")
      stdout.flush
      stdout.text("# . These precise data use non-standard CIF tags")
      stdout.text("# . Please keep for a better refinement restart")
      stdout.text("# . Units are in Angstrom")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_Cartn_label")
      stdout.text("_atom_site_Cartn_x")
      stdout.text("_atom_site_Cartn_y")
      stdout.text("_atom_site_Cartn_z")
      stdout.text("_atom_site_Cartn_U_iso_or_equiv")
      stdout.text("_atom_site_Cartn_adp_type")
      stdout.text("_atom_site_Cartn_occupancy")
      stdout.text("_atom_site_Cartn_disorder_group")
      stdout.text("_atom_site_Cartn_x_esu")
      stdout.text("_atom_site_Cartn_y_esu")
      stdout.text("_atom_site_Cartn_z_esu")
      stdout.text("_atom_site_Cartn_U_iso_or_equiv_esu")

      ! Table column data
      blnk.create(.dim)
      xyz.create(.dim,3)
      err.create(.dim,3)
      Uiso.create(.dim)
      Uerr.create(.dim)
      ADP_type.create(.dim)

      ! Get table column data
      blnk     = " "
      .put_pos_vector_to(xyz,fac)
      .put_pos_errors_to(err,fac)
      Uiso     = self.U_iso      *fac2
      Uerr     = self.U_iso_error*fac2
      ADP_type = .ADP_type(refine_H_U_iso)

      ! Table 1
      tabl1.create(8)
      tabl1(1).set_values(self(:).tag)
      tabl1(2).set_values(xyz(:,1))
      tabl1(3).set_values(xyz(:,2))
      tabl1(4).set_values(xyz(:,3))
      tabl1(5).set_values(Uiso)
      tabl1(6).set_values(ADP_type)
      tabl1(7).set_values(self(:).site_occupancy)
      tabl1(8).set_values(self(:).site_disorder_group)

      ! Table 2
      tabl2.create(5)
      tabl2(1).set_values(blnk)
      tabl2(2).set_values(err(:,1))
      tabl2(3).set_values(err(:,2))
      tabl2(4).set_values(err(:,3))
      tabl2(5).set_values(Uerr)

      tabl2(1).set_width(tabl1(1).width)
      tabl2(2).set_width(tabl1(2).width)
      tabl2(3).set_width(tabl1(3).width)
      tabl2(4).set_width(tabl1(4).width)
      tabl2(5).set_width(tabl1(5).width)

      ! Put tables
      tabl1.put_body(tabl2)

      ! Clean
      tabl2.destroy
      tabl1.destroy

   end

   put_CIF_coords_cartn(refine_H_U_iso,esd) ::: private
   ! Output the atoms and ADP's in CIF format to "stdout" in an
   ! axis system, with errors "esd" provided externally.
      self :: IN
      refine_H_U_iso :: BIN, IN
      esd :: VEC{REAL}, IN

   ENSURE(esd.dim==.no_of_pADPS,"wrong size, esd")
   ENSURE(self(1).pos_axis_system=="cartesian","not cartesian axis system!")

      blnk,ADP_type :: VEC{STR}@
      Uiso,Uerr :: VEC{REAL}@
      xyz,err :: MAT{REAL}@
      tabl1,tabl2 :: VEC{TABLE_COLUMN}@
      fac,fac2 :: REAL

      ! Unit conversion
      fac  = ANGSTROM_PER_BOHR
      fac2 = fac*fac

      ! CIF coordinate header
      stdout.flush
      stdout.text("# =====================")
      stdout.text("# Cartesian coordinates")
      stdout.text("# =====================")
      stdout.flush
      stdout.text("# . These precise data use non-standard CIF tags")
      stdout.text("# . Please keep for a better refinement restart")
      stdout.text("# . Units are in Angstrom")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_Cartn_label")
      stdout.text("_atom_site_Cartn_x")
      stdout.text("_atom_site_Cartn_y")
      stdout.text("_atom_site_Cartn_z")
      stdout.text("_atom_site_Cartn_U_iso_or_equiv")
      stdout.text("_atom_site_Cartn_adp_type")
      stdout.text("_atom_site_Cartn_occupancy")
      stdout.text("_atom_site_Cartn_disorder_group")
      stdout.text("_atom_site_Cartn_x_esu")
      stdout.text("_atom_site_Cartn_y_esu")
      stdout.text("_atom_site_Cartn_z_esu")
      stdout.text("_atom_site_Cartn_U_iso_or_equiv_esu")

      ! Table column data
      blnk.create(.dim)
      xyz.create(.dim,3)
      err.create(.dim,3)
      Uiso.create(.dim)
      Uerr.create(.dim)
      ADP_type.create(.dim)

      ! Get table column data
      blnk     = " "
      .put_pos_vector_to(xyz,fac)
      .put_pos_errors_to(err,esd,fac)     ! Note esd
      Uiso     = self.U_iso      *fac2
      Uerr     = self.U_iso_error*fac2
      ADP_type = .ADP_type(refine_H_U_iso)

      ! Table 1
      tabl1.create(8)
      tabl1(1).set_values(self(:).tag)
      tabl1(2).set_values(xyz(:,1))
      tabl1(3).set_values(xyz(:,2))
      tabl1(4).set_values(xyz(:,3))
      tabl1(5).set_values(Uiso)
      tabl1(6).set_values(ADP_type)
      tabl1(7).set_values(self(:).site_occupancy)
      tabl1(8).set_values(self(:).site_disorder_group)

      ! Table 2
      tabl2.create(5)
      tabl2(1).set_values(blnk)
      tabl2(2).set_values(err(:,1))
      tabl2(3).set_values(err(:,2))
      tabl2(4).set_values(err(:,3))
      tabl2(5).set_values(Uerr)

      tabl2(1).set_width(tabl1(1).width)
      tabl2(2).set_width(tabl1(2).width)
      tabl2(3).set_width(tabl1(3).width)
      tabl2(4).set_width(tabl1(4).width)
      tabl2(5).set_width(tabl1(5).width)

      ! Put tables
      tabl1.put_body(tabl2)

      ! Clean
      tabl2.destroy
      tabl1.destroy

   end


   put_CIF_coords_cryst(refine_H_U_iso) ::: private
   ! Output the atoms and ADP's in CIF format to "stdout" in the
   ! crystal/fractional axis system. This version does not override
   ! existing esd's.
      self :: IN
      refine_H_U_iso :: BIN, IN

      ADP_type,symbols :: VEC{STR}@
      Uiso :: VEC{REAL}@
      xyz :: MAT{REAL}@
      err :: MAT{REAL}@
      table :: VEC{TABLE_COLUMN}@
      fac,fac2 :: REAL

      ! Table column data
      xyz.create(.dim,3)
      err.create(.dim,3)
      Uiso.create(.dim)
      ADP_type.create(.dim)
      symbols.create(.dim)

      ! Unit conversion
      fac  = ANGSTROM_PER_BOHR
      fac2 = fac*fac

      ! Get table column data
      Uiso     = self.U_iso*fac2
      ADP_type = .ADP_type(refine_H_U_iso)
      symbols  = ATOM:chemical_symbol(self(:))

      ! CIF coordinate header
      stdout.flush
      stdout.text("# ======================")
      stdout.text("# Fractional coordinates")
      stdout.text("# ======================")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_label")
      stdout.text("_atom_site_type_symbol")
      stdout.text("_atom_site_fract_x")
      stdout.text("_atom_site_fract_y")
      stdout.text("_atom_site_fract_z")
      stdout.text("_atom_site_U_iso_or_equiv")
      stdout.text("_atom_site_adp_type")
      stdout.text("_atom_site_occupancy")
      stdout.text("_atom_site_disorder_group")

      ! Get table column data
      .put_pos_vector_to(xyz)
      .put_pos_errors_to(err)

      ! Table 1
      table.create(9)
      table(1).set_values(self(:).tag)
      table(2).set_values(symbols)
      table(3).set_values_and_errors(xyz(:,1),err(:,1))
      table(4).set_values_and_errors(xyz(:,2),err(:,2))
      table(5).set_values_and_errors(xyz(:,3),err(:,3))
      table(6).set_values(Uiso)
      table(7).set_values(ADP_type)
      table(8).set_values(self(:).site_occupancy)
      table(9).set_values(self(:).site_disorder_group)

      ! Put tables
      table.put_body

      ! Clean
      table.destroy
      symbols.destroy
      ADP_type.destroy
      Uiso.destroy
      err.destroy
      xyz.destroy

   end

   put_CIF_coords_cryst(refine_H_U_iso,esd) ::: private
   ! Output the atoms and ADP's in CIF format to "stdout" in an
   ! axis system, with errors "esd" provided externally.
      self :: IN
      refine_H_U_iso :: BIN, IN
      esd :: VEC{REAL}, IN

   ENSURE(esd.dim==.no_of_pADPS,"wrong size, esd")
   ENSURE(self(1).pos_axis_system=="crystal","not crystal axis system!")

      blnk,ADP_type :: VEC{STR}@
      Uiso,Uerr :: VEC{REAL}@
      xyz,err :: MAT{REAL}@
      tabl1,tabl2 :: VEC{TABLE_COLUMN}@
      fac,fac2 :: REAL

      ! Unit conversion
      fac  = ANGSTROM_PER_BOHR
      fac2 = fac*fac

      ! CIF coordinate header
      stdout.flush
      stdout.text("# =====================================")
      stdout.text("# Precise fractional system coordinates")
      stdout.text("# =====================================")
      stdout.flush
      stdout.text("# . These precise data use non-standard CIF tags")
      stdout.text("# . Non-standard tags shadow standard tags to avoid duplication")
      stdout.text("# . Please keep for a better refinement restart")
      stdout.text("# . Better yet, use the refined cartesian parameters")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_Cryst_label")
      stdout.text("_atom_site_Cryst_x")
      stdout.text("_atom_site_Cryst_y")
      stdout.text("_atom_site_Cryst_z")
      stdout.text("_atom_site_Cryst_U_iso_or_equiv")
      stdout.text("_atom_site_Cryst_adp_type")
      stdout.text("_atom_site_Cryst_occupancy")
      stdout.text("_atom_site_Cryst_disorder_group")
      stdout.text("_atom_site_Cryst_x_esu")
      stdout.text("_atom_site_Cryst_y_esu")
      stdout.text("_atom_site_Cryst_z_esu")
      stdout.text("_atom_site_Cryst_U_iso_or_equiv_esu")

      ! Table column data
      blnk.create(.dim)
      xyz.create(.dim,3)
      err.create(.dim,3)
      Uiso.create(.dim)
      Uerr.create(.dim)
      ADP_type.create(.dim)

      ! Get table column data
      blnk     = " "
      .put_pos_vector_to(xyz)
      .put_pos_errors_to(err,esd)         ! Note esd
      Uiso     = self.U_iso      *fac2
      Uerr     = self.U_iso_error*fac2
      ADP_type = .ADP_type(refine_H_U_iso)

      ! Table 1
      tabl1.create(8)
      tabl1(1).set_values(self(:).tag)
      tabl1(2).set_values(xyz(:,1))
      tabl1(3).set_values(xyz(:,2))
      tabl1(4).set_values(xyz(:,3))
      tabl1(5).set_values(Uiso)
      tabl1(6).set_values(ADP_type)
      tabl1(7).set_values(self(:).site_occupancy)
      tabl1(8).set_values(self(:).site_disorder_group)

      ! Table 2
      tabl2.create(5)
      tabl2(1).set_values(blnk)
      tabl2(2).set_values(err(:,1))
      tabl2(3).set_values(err(:,2))
      tabl2(4).set_values(err(:,3))
      tabl2(5).set_values(Uerr)

      tabl2(1).set_width(tabl1(1).width)
      tabl2(2).set_width(tabl1(2).width)
      tabl2(3).set_width(tabl1(3).width)
      tabl2(4).set_width(tabl1(4).width)
      tabl2(5).set_width(tabl1(5).width)

      ! Put tables
      tabl1.put_body(tabl2)

      ! Clean
      tabl2.destroy
      tabl1.destroy

      ! CIF coordinate header
      stdout.flush
      stdout.text("# ======================")
      stdout.text("# Fractional coordinates")
      stdout.text("# ======================")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_label")
      stdout.text("_atom_site_fract_x")
      stdout.text("_atom_site_fract_y")
      stdout.text("_atom_site_fract_z")
      stdout.text("_atom_site_U_iso_or_equiv")
      stdout.text("_atom_site_adp_type")
      stdout.text("_atom_site_occupancy")
      stdout.text("_atom_site_disorder_group")

      ! Set table column data
      tabl1.create(8)
      tabl1(1).set_values(self(:).tag)
      tabl1(2).set_values_and_errors(xyz(:,1),err(:,1))
      tabl1(3).set_values_and_errors(xyz(:,2),err(:,2))
      tabl1(4).set_values_and_errors(xyz(:,3),err(:,3))
      tabl1(5).set_values_and_errors(Uiso,Uerr)
      tabl1(6).set_values(ADP_type)
      tabl1(7).set_values(self(:).site_occupancy)
      tabl1(8).set_values(self(:).site_disorder_group)

      ! Put table
      tabl1.put_body

      ! Clean
      tabl1.destroy

   end


   put_CIF_ADP2(refine_H_U_iso,esd)
   ! Output the ADP2's in CIF format to "stdout" in an axis system.
   ! This version uses inputted refinement "esd" errors.
      self :: IN
      refine_H_U_iso :: BIN, optional, IN
      esd :: VEC{REAL}, optional, IN

      is_cartn :: BIN

      is_cartn = self(1).ADP_axis_system=="cartesian"

      if (is_cartn) then; .put_CIF_ADP2_cartn(refine_H_U_iso,esd)
      else;               .put_CIF_ADP2_cryst(refine_H_U_iso,esd)
      end

   end

   put_CIF_ADP2_cartn(refine_H_U_iso,esd) ::: private
   ! Output the ADP2's in CIF format to "stdout" in cartesian axis system.
   ! If present and TRUE "refine_H_U_iso" removed H ADP printing.
   ! If present and TRUE "esd" array for whole atom list overrides ! errors.
      self :: IN
      refine_H_U_iso :: BIN, optional, IN
      esd :: VEC{REAL}, optional, IN

   ENSURE(all(self(:).ADP_axis_system=="cartesian"),"ADP axis system must be cartesian")

      list :: VEC{INT}@
      ID,blnk :: VEC{STR}@
      ADPv,ADPe :: MAT{REAL}@
      tabl1,tabl2 :: VEC{TABLE_COLUMN}@
      lab :: STR
      fac :: REAL
      i,dim :: INT
      H_U_iso :: BIN

      H_U_iso = FALSE
      if (present(refine_H_U_iso)) H_U_iso = refine_H_U_iso

      ! Unit conversion for ADP's
      fac = ANGSTROM_PER_BOHR

      ! CIF ADP header
      stdout.flush
      stdout.text("# ==============")
      stdout.text("# Cartesian ADPs")
      stdout.text("# ==============")
      stdout.flush
      stdout.text("# . These precise data use non-standard CIF tags")
      stdout.text("# . Please keep for a better refinement restart")
      stdout.text("# . Units are in Angstrom^2")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_Cartn_ADP2_U_label")
      do i = 1,6
      lab = ATOM:ADP2_index_label(i,form="123-repeated")
      stdout.text("_atom_site_Cartn_ADP2_U_"//trim(lab))
      end
      do i = 1,6
      lab = ATOM:ADP2_index_label(i,form="123-repeated")
      stdout.text("_atom_site_Cartn_ADP2_U_"//trim(lab)//"_esu")
      end

      ! Size of table
      dim = .dim
      if (H_U_iso) dim = .no_of_non_H_atoms

      ! Allocate column data
        ID.create(dim)
      blnk.create(dim)
      ADPv.create(dim,6)
      ADPe.create(dim,6)

      ! Get column data
      if (NOT H_U_iso) then
         ID =  self.tag
         blnk = " "
         self.put_ADP2_vector_to(ADPv,fac)
         if (NOT present(esd)) then; self.put_ADP2_errors_to(ADPe,fac)
         else;                       self.put_ADP2_errors_to(ADPe,fac,esd)
         end
      else
         list = .list_of_non_H_atoms
         ID =  self(list).tag
         blnk = " "
         self(list).put_ADP2_vector_to(ADPv,fac)
         if (NOT present(esd)) then; self(list).put_ADP2_errors_to(ADPe,fac)
         else;                             self.put_ADP2_errors_to(ADPe,list,fac,esd)
         end
      end

      ! Table 1
      tabl1.create(7)
      tabl1(1).set_values(ID)
      tabl1(2).set_values(ADPv(:,1))
      tabl1(3).set_values(ADPv(:,2))
      tabl1(4).set_values(ADPv(:,3))
      tabl1(5).set_values(ADPv(:,4))
      tabl1(6).set_values(ADPv(:,5))
      tabl1(7).set_values(ADPv(:,6))

      ! Table 2
      tabl2.create(7)
      tabl2(1).set_values(blnk)
      tabl2(2).set_values(ADPe(:,1))
      tabl2(3).set_values(ADPe(:,2))
      tabl2(4).set_values(ADPe(:,3))
      tabl2(5).set_values(ADPe(:,4))
      tabl2(6).set_values(ADPe(:,5))
      tabl2(7).set_values(ADPe(:,6))

      tabl2(1).set_width(tabl1(1).width)
      tabl2(2).set_width(tabl1(2).width)
      tabl2(3).set_width(tabl1(3).width)
      tabl2(4).set_width(tabl1(4).width)
      tabl2(5).set_width(tabl1(5).width)
      tabl2(6).set_width(tabl1(6).width)
      tabl2(7).set_width(tabl1(7).width)

      ! Put tables
      tabl1.put_body(tabl2)

      ! Clean
      tabl2.destroy
      tabl1.destroy

   end

   put_CIF_ADP2_cryst(refine_H_U_iso,esd) ::: private
   ! Output the ADP2's in CIF format to "stdout" in crystal system.
   ! If present and TRUE "refine_H_U_iso" removed H ADP printing.
   ! If present and TRUE "esd" array for whole atom list overrides ! errors.
      self :: IN
      refine_H_U_iso :: BIN, optional, IN
      esd :: VEC{REAL}, optional, IN

   ENSURE(all(self(:).ADP_axis_system=="crystal"),"ADP axis system must be crystal")

      list :: VEC{INT}@
      ID,blnk :: VEC{STR}@
      ADPv,ADPe :: MAT{REAL}@
      tabl1,tabl2 :: VEC{TABLE_COLUMN}@
      lab :: STR
      fac :: REAL
      i,dim :: INT
      H_U_iso :: BIN

      H_U_iso = FALSE
      if (present(refine_H_U_iso)) H_U_iso = refine_H_U_iso

      ! Unit conversion for ADP's
      fac = ANGSTROM_PER_BOHR

      ! CIF ADP header
      stdout.flush
      stdout.text("# ==================================")
      stdout.text("# Precise cartesian axis system ADPs")
      stdout.text("# ==================================")
      stdout.flush
      stdout.text("# . These precise data use non-standard CIF tags")
      stdout.text("# . Non-standard tags shadow standard tags to avoid duplication")
      stdout.text("# . Keep these for a refinement restart")
      stdout.text("# . Better yet, use the refined cartesian parameters")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_Cryst_ADP2_U_label")
      do i = 1,6
      lab = ATOM:ADP2_index_label(i,form="123-repeated")
      stdout.text("_atom_site_Cryst_ADP2_U_"//trim(lab))
      end
      do i = 1,6
      lab = ATOM:ADP2_index_label(i,form="123-repeated")
      stdout.text("_atom_site_Cryst_ADP2_U_"//trim(lab)//"_esu")
      end

      ! Size of table
      dim = .dim
      if (H_U_iso) dim = .no_of_non_H_atoms

      ! Allocate column data
        ID.create(dim)
      blnk.create(dim)
      ADPv.create(dim,6)
      ADPe.create(dim,6)

      ! Get column data
      if (NOT H_U_iso) then
         ID =  self.tag
         blnk = " "
         self.put_ADP2_vector_to(ADPv,fac)
         if (NOT present(esd)) then; self.put_ADP2_errors_to(ADPe,fac)
         else;                       self.put_ADP2_errors_to(ADPe,fac,esd)
         end
      else
         list = .list_of_non_H_atoms
         ID =  self(list).tag
         blnk = " "
         self(list).put_ADP2_vector_to(ADPv,fac)
         if (NOT present(esd)) then; self(list).put_ADP2_errors_to(ADPe,fac)
         else;                             self.put_ADP2_errors_to(ADPe,list,fac,esd)
         end
      end

      ! Table 1
      tabl1.create(7)
      tabl1(1).set_values(ID)
      tabl1(2).set_values(ADPv(:,1))
      tabl1(3).set_values(ADPv(:,2))
      tabl1(4).set_values(ADPv(:,3))
      tabl1(5).set_values(ADPv(:,4))
      tabl1(6).set_values(ADPv(:,5))
      tabl1(7).set_values(ADPv(:,6))

      ! Table 2
      tabl2.create(7)
      tabl2(1).set_values(blnk)
      tabl2(2).set_values(ADPe(:,1))
      tabl2(3).set_values(ADPe(:,2))
      tabl2(4).set_values(ADPe(:,3))
      tabl2(5).set_values(ADPe(:,4))
      tabl2(6).set_values(ADPe(:,5))
      tabl2(7).set_values(ADPe(:,6))

      tabl2(1).set_width(tabl1(1).width)
      tabl2(2).set_width(tabl1(2).width)
      tabl2(3).set_width(tabl1(3).width)
      tabl2(4).set_width(tabl1(4).width)
      tabl2(5).set_width(tabl1(5).width)
      tabl2(6).set_width(tabl1(6).width)
      tabl2(7).set_width(tabl1(7).width)

      ! Put tables
      tabl1.put_body(tabl2)

      ! Clean
      tabl2.destroy
      tabl1.destroy

      ! CIF ADP header
      stdout.flush
      stdout.text("# ====")
      stdout.text("# ADPs")
      stdout.text("# ====")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_aniso_label")
      do i = 1,6
      lab = ATOM:ADP_label(i,form="underscore-123-repeated")
      stdout.text("_atom_site_aniso_"//trim(lab))
      end

      ! Table
      tabl1.create(7)
      tabl1(1).set_values(ID)
      tabl1(2).set_values_and_errors(ADPv(:,1),ADPe(:,1))
      tabl1(3).set_values_and_errors(ADPv(:,2),ADPe(:,2))
      tabl1(4).set_values_and_errors(ADPv(:,3),ADPe(:,3))
      tabl1(5).set_values_and_errors(ADPv(:,4),ADPe(:,4))
      tabl1(6).set_values_and_errors(ADPv(:,5),ADPe(:,5))
      tabl1(7).set_values_and_errors(ADPv(:,6),ADPe(:,6))

      ! Put tables
      tabl1.put_body

      ! Clean
      tabl1.destroy

   end


   put_CIF_ADPn(cif,esd)
   ! Output anharmonic ADPs in CIF format to "stdout".  optionally
   ! with errors, stored in "esd". Can handle any .ADP_axis_system.
      self :: IN
      cif :: CIF, IN
      esd :: VEC{REAL}, optional, IN

      is_cartn :: BIN

      is_cartn = self(1).ADP_axis_system=="cartesian"

      if (NOT present(esd)) then
         if (is_cartn) then; .put_CIF_ADPn_cartn(cif)
         else;               .put_CIF_ADPn_cryst(cif)
         end
      else
         if (is_cartn) then; .put_CIF_ADPn_cartn(cif,esd)
         else;               .put_CIF_ADPn_cryst(cif,esd)
         end
      end

   end

   put_CIF_ADPn_cartn(cif) ::: private
   ! Output cartesian anharmonic ADPs in CIF format to "stdout".
   ! This version does not produce errors. See below.
      self :: IN
      cif :: CIF, IN

      i :: INT
      lab,ADPn_label :: STR
      ADP3v :: VEC{REAL}(10)
      ADP4v :: VEC{REAL}(15)
      fac1,fac2 :: REAL
      fac3,fac4 :: REAL

      ! Unit conversion for ADP's
      fac1 = ANGSTROM_PER_BOHR
      fac2 = fac1*fac1
      fac3 = fac2*fac1
      fac4 = fac2*fac2

      ! ==========
      ! Put ADP3's
      ! ==========
      if (.has_any_ADP3s_and_errors) then

         ADPn_label = "_atom_site_Cartn_ADP3_U_"

         stdout.flush
         stdout.text("# ===============")
         stdout.text("# Cartesian ADP3s")
         stdout.text("# ===============")
         stdout.flush
         stdout.text("# . These precise data use non-standard CIF tags")
         stdout.text("# . Please keep for a better refinement restart")
         stdout.text("# . Units are in Angstrom^3 but are scaled")

         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC3_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,10
         lab = ATOM:ADP3_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
       
         do i = 1,.dim
       
            if (NOT self(i).has_ADP3s_and_errors) cycle
       
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
       
            ! Get values
            self(i).put_ADP3_vector_to(ADP3v)

            ! Units !!!!!!!!!!!!
            ADP3v = fac3 * ADP3v

            ! Scale factor
            ADP3v = cif.GC3_scale_factor*ADP3v
       
            ! Print ADP3
            stdout.put(ADP3v( 1))
            stdout.put(ADP3v( 2))
            stdout.put(ADP3v( 3))
            stdout.flush

            stdout.put(ADP3v( 4))
            stdout.put(ADP3v( 5))
            stdout.flush

            stdout.put(ADP3v( 6))
            stdout.put(ADP3v( 7))
            stdout.flush

            stdout.put(ADP3v( 8))
            stdout.put(ADP3v( 9))
            stdout.flush

            stdout.put(ADP3v(10))
            stdout.flush
       
         end

      end

      ! ==========
      ! Put ADP4's
      ! ==========
      if (.has_any_ADP4s_and_errors) then

         ADPn_label = "_atom_site_Cartn_ADP4_U_"

         stdout.flush
         stdout.text("# ===============")
         stdout.text("# Cartesian ADP4s")
         stdout.text("# ===============")
         stdout.flush
         stdout.text("# . These precise data use non-standard CIF tags")
         stdout.text("# . Please keep for a better refinement restart")
         stdout.text("# . Units are in Angstrom^4 but may be scaled")

         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC4_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,15
         lab = ATOM:ADP4_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
        
         do i = 1,.dim
        
            if (NOT self(i).has_ADP4s_and_errors) cycle
        
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
        
            ! Get values
            self(i).put_ADP4_vector_to(ADP4v)

            ! Units !!!!!!!!!!
            ADP4v = fac4*ADP4v

            ! Scale factor
            ADP4v = cif.GC4_scale_factor*ADP4v
        
            ! Print ADP4
            stdout.put(ADP4v( 1))
            stdout.put(ADP4v( 2))
            stdout.put(ADP4v( 3))
            stdout.flush

            stdout.put(ADP4v( 4))
            stdout.put(ADP4v( 5))
            stdout.flush

            stdout.put(ADP4v( 6))
            stdout.put(ADP4v( 7))
            stdout.flush

            stdout.put(ADP4v( 8))
            stdout.put(ADP4v( 9))
            stdout.flush

            stdout.put(ADP4v(10))
            stdout.put(ADP4v(11))
            stdout.put(ADP4v(12))
            stdout.flush

            stdout.put(ADP4v(13))
            stdout.put(ADP4v(14))
            stdout.put(ADP4v(15))
            stdout.flush
        
         end

      end

   end

   put_CIF_ADPn_cartn(cif,esd) ::: private
   ! Output cartesian anharmonic ADPs in CIF format to "stdout".
   ! This version produces errors, stored in "esd".
      self :: IN
      cif :: CIF, IN
      esd :: VEC{REAL}, IN

   ENSURE(esd.dim==.no_of_pADPS,"wrong sizem esd")

      ADP :: VEC{REAL}(15)
      err :: VEC{REAL}(15)
      lab,ADPn_label :: STR
      i,k :: INT
      fac1,fac2 :: REAL
      fac3,fac4 :: REAL

      ! Unit conversion for ADP's
      fac1 = ANGSTROM_PER_BOHR
      fac2 = fac1*fac1
      fac3 = fac2*fac1
      fac4 = fac2*fac2

      ! ==========
      ! Put ADP3's 
      ! ==========
      if (.has_any_ADP3s_and_errors) then

         ADPn_label = "_atom_site_Cartn_ADP3_U_"

         stdout.flush
         stdout.text("# ===============")
         stdout.text("# Cartesian ADP3s")
         stdout.text("# ===============")
         stdout.flush
         stdout.text("# . These precise data use non-standard CIF tags")
         stdout.text("# . Please keep for a better refinement restart")
         stdout.text("# . Units are in Angstrom^3 but may be scaled")
        
         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC3_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,3
         lab = ATOM:ADP3_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 1,3
         lab = ATOM:ADP3_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         do i = 4,5
         lab = ATOM:ADP3_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 4,5
         lab = ATOM:ADP3_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         do i = 6,7
         lab = ATOM:ADP3_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 6,7
         lab = ATOM:ADP3_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         do i = 8,9
         lab = ATOM:ADP3_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 8,9
         lab = ATOM:ADP3_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         do i = 10,10
         lab = ATOM:ADP3_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end
        
         k = 0
         do i = 1,.dim
        
            if (NOT self(i).has_ADP3s_and_errors) cycle
        
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
        
            ! Get values and errors
            self(i).put_ADP3_vector_to(ADP(1:10))
            err(1:10) = esd(k+10:k+19)

            ! Units !!!!!!!!!!!!!!!!!!
            ADP(1:10) = ADP(1:10)*fac3
            err(1:10) = err(1:10)*fac3

            ! Scale by scale factor
            ADP(1:10) = ADP(1:10)*cif.GC3_scale_factor
            err(1:10) = err(1:10)*cif.GC3_scale_factor
        
            ! Put quantity q with full error.
            stdout.put(ADP( 1))
            stdout.put(ADP( 2))
            stdout.put(ADP( 3))
            stdout.flush
            stdout.put(err( 1))
            stdout.put(err( 2))
            stdout.put(err( 3))
            stdout.flush

            stdout.put(ADP( 4))
            stdout.put(ADP( 5))
            stdout.flush
            stdout.put(err( 4))
            stdout.put(err( 5))
            stdout.flush

            stdout.put(ADP( 6))
            stdout.put(ADP( 7))
            stdout.flush
            stdout.put(err( 6))
            stdout.put(err( 7))
            stdout.flush

            stdout.put(ADP( 8))
            stdout.put(ADP( 9))
            stdout.flush
            stdout.put(err( 8))
            stdout.put(err( 9))
            stdout.flush

            stdout.put(ADP(10))
            stdout.flush
            stdout.put(err(10))
            stdout.flush
        
            k = k + self(i).no_of_pADPs
        
         end

      end

      ! ==========
      ! Put ADP4's
      ! ==========
      if (.has_any_ADP4s_and_errors) then

         ADPn_label = "_atom_site_Cartn_ADP4_U_"

         stdout.flush
         stdout.text("# ===============")
         stdout.text("# Cartesian ADP4s")
         stdout.text("# ===============")
         stdout.flush
         stdout.text("# . These precise data use non-standard CIF tags")
         stdout.text("# . Please keep for a better refinement restart")
         stdout.text("# . Units are in Angstrom^4")
        
         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC4_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,3
         lab = ATOM:ADP4_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 1,3
         lab = ATOM:ADP4_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         do i = 4,5
         lab = ATOM:ADP4_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 4,5
         lab = ATOM:ADP4_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         do i = 6,7
         lab = ATOM:ADP4_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 6,7
         lab = ATOM:ADP4_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         do i = 8,9
         lab = ATOM:ADP4_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 8,9
         lab = ATOM:ADP4_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         do i = 10,12
         lab = ATOM:ADP4_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 10,12
         lab = ATOM:ADP4_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         do i = 13,15
         lab = ATOM:ADP4_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 13,15
         lab = ATOM:ADP4_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end
        
         k = 0
         do i = 1,.dim
        
            if (NOT self(i).has_ADP4s_and_errors) cycle
        
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
        
            ! Get values and errors (dimensionless)
            self(i).put_ADP4_vector_to(ADP(1:15))
            err(1:15) = esd(k+20:k+34)

            ! Units !!!!!!!!!!!!!!!!!!
            ADP(1:15) = ADP(1:15)*fac4
            err(1:15) = err(1:15)*fac4

            ! Scale by scale factor
            ADP(1:15) = ADP(1:15)*cif.GC4_scale_factor
            err(1:15) = err(1:15)*cif.GC4_scale_factor
        
            ! Put quantity q with full error.
            stdout.put(ADP( 1))
            stdout.put(ADP( 2))
            stdout.put(ADP( 3))
            stdout.flush
            stdout.put(err( 1))
            stdout.put(err( 2))
            stdout.put(err( 3))
            stdout.flush

            stdout.put(ADP( 4))
            stdout.put(ADP( 5))
            stdout.flush
            stdout.put(err( 4))
            stdout.put(err( 5))
            stdout.flush

            stdout.put(ADP( 6))
            stdout.put(ADP( 7))
            stdout.flush
            stdout.put(err( 6))
            stdout.put(err( 7))
            stdout.flush

            stdout.put(ADP( 8))
            stdout.put(ADP( 9))
            stdout.flush
            stdout.put(err( 8))
            stdout.put(err( 9))
            stdout.flush

            stdout.put(ADP(10))
            stdout.put(ADP(11))
            stdout.put(ADP(12))
            stdout.flush
            stdout.put(err(10))
            stdout.put(err(11))
            stdout.put(err(12))
            stdout.flush

            stdout.put(ADP(13))
            stdout.put(ADP(14))
            stdout.put(ADP(15))
            stdout.flush
            stdout.put(err(13))
            stdout.put(err(14))
            stdout.put(err(15))
            stdout.flush
        
            k = k + self(i).no_of_pADPs
        
         end

      end ! =========

   end



   put_CIF_ADPn_cryst(cif) ::: private
   ! Output anharmonic ADPs in CIF format to "stdout".
   ! This version does not produce errors. See below.
   ! Can handle any .ADP_axis_system.
      self :: IN
      cif :: CIF, IN

      i :: INT
      lab,ADPn_label :: STR
      ADP3v :: VEC{REAL}(10)
      ADP4v :: VEC{REAL}(15)

      ! ==========
      ! Put ADP3's
      ! ==========
      if (.has_any_ADP3s_and_errors) then

         ADPn_label = "_atom_site_anharm_GC_C_"

         stdout.flush
         stdout.text("# ======================================")
         stdout.text("# Third order Gram-Charlier coefficients")
         stdout.text("# ======================================")
         stdout.flush
         stdout.text("# . These data are in standard presentation")
         stdout.text("# . They are dimensionless but are scaled")

         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC3_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,10
         lab = ATOM:ADP3_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
       
         do i = 1,.dim
       
            if (NOT self(i).has_ADP3s_and_errors) cycle
       
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
       
            ! Get values
            self(i).put_ADP3_vector_to(ADP3v)

            ! Scale factor
            ADP3v = cif.GC3_scale_factor*ADP3v
       
            ! Print ADP3
            stdout.put(ADP3v( 1))
            stdout.put(ADP3v( 2))
            stdout.put(ADP3v( 3))
            stdout.flush

            stdout.put(ADP3v( 4))
            stdout.put(ADP3v( 5))
            stdout.flush

            stdout.put(ADP3v( 6))
            stdout.put(ADP3v( 7))
            stdout.flush

            stdout.put(ADP3v( 8))
            stdout.put(ADP3v( 9))
            stdout.flush

            stdout.put(ADP3v(10))
            stdout.flush
       
         end

      end

      ! ==========
      ! Put ADP4's
      ! ==========
      if (.has_any_ADP4s_and_errors) then

         ADPn_label = "_atom_site_anharm_GC_D_"

         stdout.flush
         stdout.text("# =======================================")
         stdout.text("# Fourth order Gram-Charlier coefficients")
         stdout.text("# =======================================")
         stdout.flush
         stdout.text("# . These data are in standard presentation")
         stdout.text("# . They are dimensionless but may be scaled")

         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC4_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,15
         lab = ATOM:ADP4_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
        
         do i = 1,.dim
        
            if (NOT self(i).has_ADP4s_and_errors) cycle
        
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
        
            ! Get values
            self(i).put_ADP4_vector_to(ADP4v)

            ! Scale factor
            ADP4v = cif.GC4_scale_factor*ADP4v
        
            ! Print ADP4
            stdout.put(ADP4v( 1))
            stdout.put(ADP4v( 2))
            stdout.put(ADP4v( 3))
            stdout.flush

            stdout.put(ADP4v( 4))
            stdout.put(ADP4v( 5))
            stdout.flush

            stdout.put(ADP4v( 6))
            stdout.put(ADP4v( 7))
            stdout.flush

            stdout.put(ADP4v( 8))
            stdout.put(ADP4v( 9))
            stdout.flush

            stdout.put(ADP4v(10))
            stdout.put(ADP4v(11))
            stdout.put(ADP4v(12))
            stdout.flush

            stdout.put(ADP4v(13))
            stdout.put(ADP4v(14))
            stdout.put(ADP4v(15))
            stdout.flush
        
         end

      end

   end

   put_CIF_ADPn_cryst(cif,esd) ::: private
   ! Output fractional/GC anharmonic ADPs in CIF format to "stdout".
   ! This version produces errors, stored in "esd".
      self :: IN
      cif :: CIF, IN
      esd :: VEC{REAL}, IN

   ENSURE(esd.dim==.no_of_pADPS,"wrong sizem esd")

      ADP :: VEC{REAL}(15)
      err :: VEC{REAL}(15)
      lab,ADPn_label :: STR
      i,k :: INT

      ! ==========
      ! Put ADP3's 
      ! ==========
      if (.has_any_ADP3s_and_errors) then

         ADPn_label = "_atom_site_anharm_GC_C_"

         stdout.flush
         stdout.text("# ============================================")
         stdout.text("# Precise 3rd order Gram-Charlier coefficients")
         stdout.text("# ============================================")
         stdout.flush
         stdout.text("# . These are precise parameters and ESDs")
         stdout.text("# . Keep these for a refinement restart")
         stdout.text("# . Better yet, use the refined cartesian parameters")
        
         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC3_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,10
         lab = ATOM:ADP3_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end
        
         k = 0
         do i = 1,.dim
        
            if (NOT self(i).has_ADP3s_and_errors) cycle
        
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
        
            ! Get values and errors (dimensionless)
            self(i).put_ADP3_vector_to(ADP(1:10))
            err(1:10) = esd(k+10:k+19)

            ! Scale by scale_factor
            ADP(1:10) = ADP(1:10)*cif.GC3_scale_factor
            err(1:10) = err(1:10)*cif.GC3_scale_factor
        
            ! Put quantity q with full error.
            stdout.put(ADP( 1)); stdout.flush
            stdout.put(err( 1)); stdout.flush
            stdout.put(ADP( 2)); stdout.flush
            stdout.put(err( 2)); stdout.flush
            stdout.put(ADP( 3)); stdout.flush
            stdout.put(err( 3)); stdout.flush
            stdout.put(ADP( 4)); stdout.flush
            stdout.put(err( 4)); stdout.flush
            stdout.put(ADP( 5)); stdout.flush
            stdout.put(err( 5)); stdout.flush
            stdout.put(ADP( 6)); stdout.flush
            stdout.put(err( 6)); stdout.flush
            stdout.put(ADP( 7)); stdout.flush
            stdout.put(err( 7)); stdout.flush
            stdout.put(ADP( 8)); stdout.flush
            stdout.put(err( 8)); stdout.flush
            stdout.put(ADP( 9)); stdout.flush
            stdout.put(err( 9)); stdout.flush
            stdout.put(ADP(10)); stdout.flush
            stdout.put(err(10)); stdout.flush
        
            k = k + self(i).no_of_pADPs
        
         end

         ! Reset precision for errors
         stdout.save
         stdout.set_real_width(stdout.saved.real_width+3)
         stdout.set_real_precision(stdout.saved.real_precision+3)
         
         ! CIF ADP header
         stdout.flush
         stdout.text("# ======================================")
         stdout.text("# Third order Gram-Charlier coefficients")
         stdout.text("# ======================================")
         stdout.flush
         stdout.text("# . These data are in standard presentation")

         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC3_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")
         do i = 1,10
         lab = ATOM:ADP3_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         
         ! Put ADP's
         k = 0
         do i = 1,.dim
        
            if (NOT self(i).has_ADP3s_and_errors) cycle
         
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
        
            ! Get values and errors
            self(i).put_ADP3_vector_to(ADP(1:10))
            err(1:10) = esd(k+10:k+19)

            ! Scale by scale_factor
            ADP(1:10) = ADP(1:10)*cif.GC3_scale_factor
            err(1:10) = err(1:10)*cif.GC3_scale_factor
         
            ! Put quantity q with error e in format q(e)
            stdout.put(ADP( 1),err( 1))
            stdout.put(ADP( 2),err( 2))
            stdout.put(ADP( 3),err( 3))
            stdout.flush

            stdout.put(ADP( 4),err( 4))
            stdout.put(ADP( 5),err( 5))
            stdout.flush

            stdout.put(ADP( 6),err( 6))
            stdout.put(ADP( 7),err( 7))
            stdout.flush

            stdout.put(ADP( 8),err( 8))
            stdout.put(ADP( 9),err( 9))
            stdout.flush

            stdout.put(ADP(10),err(10))
            stdout.flush
         
            k = k + self(i).no_of_pADPs
         
         end
         
         ! Revert
         stdout.unsave
   
      end

      ! ==========
      ! Put ADP4's
      ! ==========
      if (.has_any_ADP4s_and_errors) then

         ADPn_label = "_atom_site_anharm_GC_D_"

         stdout.flush
         stdout.text("# ============================================")
         stdout.text("# Precise 4th order Gram-Charlier coefficients")
         stdout.text("# ============================================")
         stdout.flush
         stdout.text("# . These are precise parameters and ESDs")
         stdout.text("# . Keep these for a refinement restart")
         stdout.text("# . Better yet, use the refined cartesian parameters")
        
         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC4_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")
         do i = 1,15
         lab = ATOM:ADP4_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end
        
         k = 0
         do i = 1,.dim
        
            if (NOT self(i).has_ADP4s_and_errors) cycle
        
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
        
            ! Get values and errors (dimensionless)
            self(i).put_ADP4_vector_to(ADP(1:15))
            err(1:15) = esd(k+20:k+34)

            ! Scale by scale factor
            ADP(1:15) = ADP(1:15)*cif.GC4_scale_factor
            err(1:15) = err(1:15)*cif.GC4_scale_factor
        
            ! Put quantity q with full error.
            stdout.put(ADP( 1)); stdout.flush
            stdout.put(err( 1)); stdout.flush
            stdout.put(ADP( 2)); stdout.flush
            stdout.put(err( 2)); stdout.flush
            stdout.put(ADP( 3)); stdout.flush
            stdout.put(err( 3)); stdout.flush
            stdout.put(ADP( 4)); stdout.flush
            stdout.put(err( 4)); stdout.flush
            stdout.put(ADP( 5)); stdout.flush
            stdout.put(err( 5)); stdout.flush
            stdout.put(ADP( 6)); stdout.flush
            stdout.put(err( 6)); stdout.flush
            stdout.put(ADP( 7)); stdout.flush
            stdout.put(err( 7)); stdout.flush
            stdout.put(ADP( 8)); stdout.flush
            stdout.put(err( 8)); stdout.flush
            stdout.put(ADP( 9)); stdout.flush
            stdout.put(err( 9)); stdout.flush
            stdout.put(ADP(10)); stdout.flush
            stdout.put(err(10)); stdout.flush
            stdout.put(ADP(11)); stdout.flush
            stdout.put(err(11)); stdout.flush
            stdout.put(ADP(12)); stdout.flush
            stdout.put(err(12)); stdout.flush
            stdout.put(ADP(13)); stdout.flush
            stdout.put(err(13)); stdout.flush
            stdout.put(ADP(14)); stdout.flush
            stdout.put(err(14)); stdout.flush
            stdout.put(ADP(15)); stdout.flush
            stdout.put(err(15)); stdout.flush
        
            k = k + self(i).no_of_pADPs
        
         end

         ! Reset precision for errors
         stdout.save
         stdout.set_real_width(stdout.saved.real_width+3)
         stdout.set_real_precision(stdout.saved.real_precision+3)
         
         ! CIF ADP header
         stdout.flush
         stdout.text("# =======================================")
         stdout.text("# Fourth order Gram-Charlier coefficients")
         stdout.text("# =======================================")
         stdout.flush
         stdout.text("# . These data are in standard presentation")

         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC4_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")
         do i = 1,15
         lab = ATOM:ADP4_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         
         ! Put ADP's
         k = 0
         do i = 1,.dim
        
            if (NOT self(i).has_ADP4s_and_errors) cycle
         
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
        
            ! Get values and errors
            self(i).put_ADP4_vector_to(ADP(1:15))
            err(1:15) = esd(k+20:k+34)

            ! Scale by scale_factor
            ADP(1:15) = ADP(1:15)*cif.GC4_scale_factor
            err(1:15) = err(1:15)*cif.GC4_scale_factor
         
            ! Put quantity q with error e in format q(e)
            stdout.put(ADP( 1),err( 1))
            stdout.put(ADP( 2),err( 2))
            stdout.put(ADP( 3),err( 3))
            stdout.flush

            stdout.put(ADP( 4),err( 4))
            stdout.put(ADP( 5),err( 5))
            stdout.flush

            stdout.put(ADP( 6),err( 6))
            stdout.put(ADP( 7),err( 7))
            stdout.flush

            stdout.put(ADP( 8),err( 8))
            stdout.put(ADP( 9),err( 9))
            stdout.flush

            stdout.put(ADP(10),err(10))
            stdout.put(ADP(11),err(11))
            stdout.put(ADP(12),err(12))
            stdout.flush

            stdout.put(ADP(13),err(13))
            stdout.put(ADP(14),err(14))
            stdout.put(ADP(15),err(15))
            stdout.flush
         
            k = k + self(i).no_of_pADPs
         
         end
         
         ! Revert
         stdout.unsave
   
      end ! =========

   end



   put_CIF_bond_length_table(covariance)
   ! Output the CIF bond length table with errors, given the "covariance"
   ! matrix between all atomic positions. 
      self :: IN
      covariance :: MAT{REAL}, IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{EVEC{INT}}@
      n_kind,k1,k2,n_bonds :: INT
      labels :: MAT{STR}@
      dash,dsh1 :: VEC{STR}@
      dist,esds :: VEC{REAL}@
      pair :: MAT{INT}@

      ! Header
      stdout.flush
      stdout.text("# ============")
      stdout.text("# Bond lengths")
      stdout.text("# ============")

      ! Loop 
      stdout.flush
      stdout.text("loop_")
      stdout.text(" _geom_bond_atom_site_label_1")
      stdout.text(" _geom_bond_site_symmetry_1")
      stdout.text(" _geom_bond_atom_site_label_2")
      stdout.text(" _geom_bond_site_symmetry_2")
      stdout.text(" _geom_bond_distance")
      stdout.text(" _geom_bond_publ_flag")

      ! Get Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(6)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self.tag)
      table(2).set_heading(".")
      table(2).set_width(1)
      table(3).set_heading("B")
      table(3).set_width(table(1).width)
      table(4).set_heading(".")
      table(4).set_width(1)
      table(5).set_heading("R(A--B)")
      table(5).set_width_from(ONE)
      table(6).set_heading("yes")
      table(6).set_width(3)


      ! Loop over atom Z classes, Z(k1) >= Z(k2)
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_atoms(pair,dist,esds,Z_list,k1,k2,covariance) ! leaky
         dist = dist*ANGSTROM_PER_BOHR
         esds = esds*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            esds.destroy
            dist.destroy
            pair.destroy
            cycle
         end

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = self(pair(:,1)).tag
         labels(:,2) = self(pair(:,2)).tag

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "."
         dsh1    = "yes"

         ! Set table data
         table(1).set_values(labels(:,1))
         table(2).set_values(dash)
         table(3).set_values(labels(:,2))
         table(4).set_values(dash)
         table(5).set_values_and_errors(dist,esds)
         table(6).set_values(dsh1)

         ! Put body
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         esds.destroy
         dist.destroy
         pair.destroy

      end
      end


      ! Clean
      table.destroy
      Z_list.destroy

   end

   put_CIF_bond_Hirshfeld_table(cov_R,cov_pADP)
   ! Output the CIF bond length table with errors, given the "covariance"
   ! matrix between all atomic positions. 
      self :: IN
      cov_R,cov_pADP :: MAT{REAL}, IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{EVEC{INT}}@
      n_kind,k1,k2,n_bonds :: INT
      labels :: MAT{STR}@
      dash :: VEC{STR}@
      dist,derr,test,terr :: VEC{REAL}@
      pair :: MAT{INT}@

      ! Header
      stdout.flush
      stdout.text("# ==============================")
      stdout.text("# Bond lengths & Hirshfeld tests")
      stdout.text("# ==============================")

      ! Loop 
      stdout.flush
      stdout.text("loop_")
      stdout.text(" _geom_bond_atom_site_label_1")
      stdout.text(" _geom_bond_site_symmetry_1")
      stdout.text(" _geom_bond_atom_site_label_2")
      stdout.text(" _geom_bond_site_symmetry_2")
      stdout.text(" _geom_bond_distance")
      stdout.text(" _geom_bond_distance_esu")
      stdout.text(" _geom_bond_Hirshfeld_test")
      stdout.text(" _geom_bond_Hirshfeld_test_esu")

      ! Get Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(8)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self.tag)
      table(2).set_heading(".")
      table(2).set_width(1)
      table(3).set_heading("B")
      table(3).set_width(table(1).width)
      table(4).set_heading(".")
      table(4).set_width(1)
      table(5).set_heading("R(A--B)")
      table(5).set_width_from(ONE)
      table(6).set_heading("R(A--B) esu")
      table(6).set_width_from(ONE)
      table(7).set_heading("Hirshfeld test")
      table(7).set_width_from(ONE)
      table(8).set_heading("Hirshfeld test esu")
      table(8).set_width_from(ONE)


      ! Loop over atom Z classes, Z(k1) >= Z(k2)
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_Hirshfeld_test(pair,dist,derr,test,terr,Z_list,k1,k2,cov_R,cov_pADP,angstrom=TRUE)

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            terr.destroy
            test.destroy
            derr.destroy
            dist.destroy
            pair.destroy
            cycle
         end

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = self(pair(:,1)).tag
         labels(:,2) = self(pair(:,2)).tag

         ! Dashes
         dash.create(n_bonds)
         dash    = "."

         ! Set table data
         table(1).set_values(labels(:,1))
         table(2).set_values(dash)
         table(3).set_values(labels(:,2))
         table(4).set_values(dash)
         table(5).set_values(dist)
         table(6).set_values(derr)
         table(7).set_values(test)
         table(8).set_values(terr)

         ! Put body
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dash.destroy
         labels.destroy
         terr.destroy
         test.destroy
         derr.destroy
         dist.destroy
         pair.destroy

      end
      end


      ! Clean
      table.destroy
      Z_list.destroy

   end

   put_CIF_bond_angle_table(covariance)
   ! Output the CIF bond angle table with errors given the "covariance"
   ! matrix between all atomic positions. 
      self :: IN
      covariance :: MAT{REAL}, IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{EVEC{INT}}@
      n_kind,k1,k2,k3,n_angles :: INT
      symbols   :: MAT{STR}@
      dash,dsh1 :: VEC{STR}@
      angle,esds :: VEC{REAL}@
      triple :: MAT{INT}@

      ! Title
      stdout.flush
      stdout.text("# ===========")
      stdout.text("# Bond Angles")
      stdout.text("# ===========")

      ! Loop 
      stdout.flush
      stdout.text("loop_")
      stdout.text(" _geom_angle_atom_site_label_1")
      stdout.text(" _geom_angle_site_symmetry_1")
      stdout.text(" _geom_angle_atom_site_label_2")
      stdout.text(" _geom_angle_site_symmetry_2")
      stdout.text(" _geom_angle_atom_site_label_3")
      stdout.text(" _geom_angle_site_symmetry_3")
      stdout.text(" _geom_angle")
      stdout.text(" _geom_angle_publ_flag")

      ! Get Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(8)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self(.angle_outer_atoms).tag)
      table(2).set_heading(".")
      table(2).set_width(1)
      table(3).set_heading("B")
      table(3).set_width_from(self(.angle_center_atoms).tag)
      table(4).set_heading(".")
      table(4).set_width(1)
      table(5).set_heading("C")
      table(5).set_width_from(self(.angle_outer_atoms).tag)
      table(6).set_heading(".")
      table(6).set_width(1)
      table(7).set_heading("Angle(A--B--C)")
      table(7).set_width_from(ONE)
      table(8).set_heading("yes")
      table(8).set_width(3)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_angles(triple,angle,esds,Z_list,k1,k2,k3,covariance)
         angle = angle*DEGREE_PER_RADIAN
         esds  = esds *DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            esds.destroy
            angle.destroy
            triple.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,3)
         symbols = " "
         symbols(:,1) = self(triple(:,1)).tag
         symbols(:,2) = self(triple(:,2)).tag
         symbols(:,3) = self(triple(:,3)).tag

         ! Dashes
         dash.create(n_angles)
         dsh1.create(n_angles)
         dash    = "."
         dsh1    = "yes"

         ! Set table data
         table(1).set_values(symbols(:,1))
         table(2).set_values(dash)
         table(3).set_values(symbols(:,2))
         table(4).set_values(dash)
         table(5).set_values(symbols(:,3))
         table(6).set_values(dash)
         table(7).set_values_and_errors(angle,esds)
         table(8).set_values(dsh1)

         ! Put body
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         symbols.destroy
         esds.destroy
         angle.destroy
         triple.destroy

      end
      end
      end

      ! Clean
      table.destroy
      Z_list.destroy

   end

   put_CIF_bond_torsion_angle_table(covariance,parentheses)
   ! Output the CIF bond angle table with errors given the "covariance"
   ! matrix between all atomic positions. 
      self :: IN
      covariance :: MAT{REAL}, IN
      parentheses :: BIN, optional, IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{EVEC{INT}}@
      symbols,labels :: MAT{STR}@
      dash :: VEC{STR}@
      angle,esds :: VEC{REAL}@
      quad :: MAT{INT}@
      no_of_torsions, n_kind,k1,k2,k3,k4,n_angles :: INT
      use_brackets :: BIN

      if (.dim<4) return

      no_of_torsions = .no_of_torsion_angles
      if (no_of_torsions<1) return

      ! Title
      stdout.flush
      stdout.text("# ==============")
      stdout.text("# Torsion angles")
      stdout.text("# ==============")

      ! Parentheses
      use_brackets = TRUE
      if (present(parentheses)) use_brackets = parentheses

      ! Loop 
      stdout.flush
      stdout.text("loop_")
      stdout.text(" _geom_torsion_atom_site_label_1")
      stdout.text(" _geom_torsion_site_symmetry_1")
      stdout.text(" _geom_torsion_atom_site_label_2")
      stdout.text(" _geom_torsion_site_symmetry_2")
      stdout.text(" _geom_torsion_atom_site_label_3")
      stdout.text(" _geom_torsion_site_symmetry_3")
      stdout.text(" _geom_torsion_atom_site_label_4")
      stdout.text(" _geom_torsion_site_symmetry_4")
      stdout.text(" _geom_torsion")
      if (NOT use_brackets) then
         stdout.text(" _geom_torsion_esu")
      end

      ! Get Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      if (use_brackets) then; table.create(9)
      else;                   table.create(10)
      end

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self(.torsion_angle_1st_atoms).tag)
      table(2).set_heading(".")
      table(2).set_width(1)
      table(3).set_heading("B")
      table(3).set_width_from(self(.torsion_angle_2nd_atoms).tag)
      table(4).set_heading(".")
      table(4).set_width(1)
      table(5).set_heading("C")
      table(5).set_width_from(self(.torsion_angle_3rd_atoms).tag)
      table(6).set_heading(".")
      table(6).set_width(1)
      table(7).set_heading("D")
      table(7).set_width_from(self(.torsion_angle_4th_atoms).tag)
      table(8).set_heading(".")
      table(8).set_width(1)
      table(9).set_heading("Torsion(A--B--C--D)")
      table(9).set_width_from(ONE)
      if (NOT use_brackets) then
         table(10).set_heading("Torsion(A--B--C--D) esu")
         table(10).set_width_from(ONE)
      end

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = 1,n_kind
      do k4 = 1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_torsions(quad,angle,esds,Z_list,k1,k2,k3,k4,covariance)
         angle = angle*DEGREE_PER_RADIAN
         esds  =  esds*DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            esds.destroy
            angle.destroy
            quad.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,4)
         symbols = " "
         symbols(1,1) = self(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = self(Z_list(k2)[1]).chemical_symbol
         symbols(1,3) = self(Z_list(k3)[1]).chemical_symbol
         symbols(1,4) = self(Z_list(k4)[1]).chemical_symbol

         ! Labels
         labels.create(n_angles,4)
         labels(:,1) = self(quad(:,1)).tag
         labels(:,2) = self(quad(:,2)).tag
         labels(:,3) = self(quad(:,3)).tag
         labels(:,4) = self(quad(:,4)).tag

         ! Dashes
         dash.create(n_angles)
         dash    = "."

         ! Set table data
         table( 1).set_values(labels(:,1))
         table( 2).set_values(dash)
         table( 3).set_values(labels(:,2))
         table( 4).set_values(dash)
         table( 5).set_values(labels(:,3))
         table( 6).set_values(dash)
         table( 7).set_values(labels(:,4))
         table( 8).set_values(dash)
         if (use_brackets) then
         table( 9).set_real_precision(stdout.real_precision) ! Must do, for every block
         table( 9).set_values_and_errors(angle,esds)
         else
         table( 9).set_values(angle)
         table(10).set_values(esds)
         end

         ! Put body
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dash.destroy
         symbols.destroy
         esds.destroy
         angle.destroy
         quad.destroy

      end
      end
      end
      end

      ! Clean
      table.destroy
      Z_list.destroy

   end


   put_CIF_coords_cartn_HBB(refine_H_U_iso,esd)
   ! Output the atoms and ADP's in CIF format to "stdout" in an
   ! axis system, with errors "esd" provided externally.
      self :: IN
      refine_H_U_iso :: BIN, IN
      esd :: VEC{REAL}, IN

   ENSURE(esd.dim==.no_of_pADPS,"wrong size, esd")
   ENSURE(self(1).pos_axis_system=="cartesian","not cartesian axis system!")

      blnk,ADP_type :: VEC{STR}@
      Uiso,Uerr :: VEC{REAL}@
      xyz,err :: MAT{REAL}@
      tabl1,tabl2,tabl3,tabl4 :: VEC{TABLE_COLUMN}@
      fac,fac2 :: REAL

      ! Unit conversion
      fac  = ANGSTROM_PER_BOHR
      fac2 = fac*fac

      ! CIF coordinate header
      stdout.flush
      stdout.text("# =====================")
      stdout.text("# Cartesian coordinates")
      stdout.text("# =====================")
      stdout.flush
      stdout.text("# . These precise data use non-standard CIF tags")
      stdout.text("# . Please keep for a better refinement restart")
      stdout.text("# . Units are in Angstrom")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_Cartn_label")
      stdout.text("_atom_site_Cartn_x")
      stdout.text("_atom_site_Cartn_x_esu")
      stdout.text("_atom_site_Cartn_y")
      stdout.text("_atom_site_Cartn_y_esu")
      stdout.text("_atom_site_Cartn_z")
      stdout.text("_atom_site_Cartn_z_esu")

      ! Table column data
      blnk.create(.dim)
      xyz.create(.dim,3)
      err.create(.dim,3)
      Uiso.create(.dim)
      Uerr.create(.dim)
      ADP_type.create(.dim)

      ! Get table column data
      blnk     = " "
      .put_pos_vector_to(xyz,fac)
      .put_pos_errors_to(err,esd,fac)     ! Note esd
      Uiso     = self.U_iso      *fac2
      Uerr     = self.U_iso_error*fac2
      ADP_type = .ADP_type(refine_H_U_iso)

      ! Table 1
      tabl1.create(3)
      tabl1(1).set_values(self(:).tag)
      tabl1(2).set_values(xyz(:,1))
      tabl1(3).set_values(err(:,1))

      ! Table 2
      tabl2.create(3)
      tabl2(1).set_values(blnk)
      tabl2(2).set_values(xyz(:,2))
      tabl2(3).set_values(err(:,2))

      tabl2(1).set_width(tabl1(1).width)
      tabl2(2).set_width(tabl1(2).width)
      tabl2(3).set_width(tabl1(3).width)

      ! Table 3
      tabl3.create(3)
      tabl3(1).set_values(blnk)
      tabl3(2).set_values(xyz(:,3))
      tabl3(3).set_values(err(:,3))

      tabl3(1).set_width(tabl1(1).width)
      tabl3(2).set_width(tabl1(2).width)
      tabl3(3).set_width(tabl1(3).width)

      ! Put tables
      tabl1.put_body(tabl1,tabl2,tabl3)

      ! CIF Ueq or Uiso header
      stdout.flush
      stdout.text("# =====================")
      stdout.text("# Ueq or Uiso          ")
      stdout.text("# =====================")
      stdout.flush
      stdout.text("# . These precise data use non-standard CIF tags")
      stdout.text("# . Please keep for a better refinement restart")
      stdout.text("# . Units are in Angstrom^2")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_Cartn_U_iso_or_equiv")
      stdout.text("_atom_site_Cartn_U_iso_or_equiv_esu")

      ! Table 4
      tabl4.create(3)
      tabl4(1).set_values(self(:).tag)
      tabl4(2).set_values(Uiso)
      tabl4(3).set_values(Uerr)

      ! Put tables
      tabl4.put_body

      ! Clean
      tabl4.destroy
      tabl3.destroy
      tabl2.destroy
      tabl1.destroy

   end

   put_CIF_ADP2_cartn_HBB(refine_H_U_iso,esd)
   ! Output the ADP2's in CIF format to "stdout" in cartesian axis system.
   ! If present and TRUE "refine_H_U_iso" removed H ADP printing.
   ! If present and TRUE "esd" array for whole atom list overrides errors.
      self :: IN
      refine_H_U_iso :: BIN, optional, IN
      esd :: VEC{REAL}, optional, IN

   ENSURE(all(self(:).ADP_axis_system=="cartesian"),"ADP axis system must be cartesian")

      list :: VEC{INT}@
      ID,blnk :: VEC{STR}@
      ADPv,ADPe :: MAT{REAL}@
      tabl1,tabl2,tabl3,tabl4,tabl5,tabl6 :: VEC{TABLE_COLUMN}@
      lab :: STR
      fac :: REAL
      i,dim :: INT
      H_U_iso :: BIN

      H_U_iso = FALSE
      if (present(refine_H_U_iso)) H_U_iso = refine_H_U_iso

      ! Unit conversion for ADP's
      fac = ANGSTROM_PER_BOHR

      ! CIF ADP header
      stdout.flush
      stdout.text("# ==============")
      stdout.text("# Cartesian ADPs")
      stdout.text("# ==============")
      stdout.flush
      stdout.text("# . These precise data use non-standard CIF tags")
      stdout.text("# . Please keep for a better refinement restart")
      stdout.text("# . Units are in Angstrom^2")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_Cartn_ADP2_U_label")
      do i = 1,6
      lab = ATOM:ADP2_index_label(i,form="123-repeated")
      stdout.text("_atom_site_Cartn_ADP2_U_"//trim(lab))
      lab = ATOM:ADP2_index_label(i,form="123-repeated")
      stdout.text("_atom_site_Cartn_ADP2_U_"//trim(lab)//"_esu")
      end

      ! Size of table
      dim = .dim
      if (H_U_iso) dim = .no_of_non_H_atoms

      ! Allocate column data
        ID.create(dim)
      blnk.create(dim)
      ADPv.create(dim,6)
      ADPe.create(dim,6)

      ! Get column data
      if (NOT H_U_iso) then
         ID =  self.tag
         blnk = " "
         self.put_ADP2_vector_to(ADPv,fac)
         if (NOT present(esd)) then; self.put_ADP2_errors_to(ADPe,fac)
         else;                       self.put_ADP2_errors_to(ADPe,fac,esd)
         end
      else
         list = .list_of_non_H_atoms
         ID =  self(list).tag
         blnk = " "
         self(list).put_ADP2_vector_to(ADPv,fac)
         if (NOT present(esd)) then; self(list).put_ADP2_errors_to(ADPe,fac)
         else;                             self.put_ADP2_errors_to(ADPe,list,fac,esd)
         end
      end

      ! Table 1
      tabl1.create(3)
      tabl1(1).set_values(ID)
      tabl1(2).set_values(ADPv(:,1))
      tabl1(3).set_values(ADPe(:,1))

      ! Table 2
      tabl2.create(3)
      tabl2(1).set_values(blnk)
      tabl2(2).set_values(ADPv(:,2))
      tabl2(3).set_values(ADPe(:,2))

      tabl2(1).set_width(tabl1(1).width)
      tabl2(2).set_width(tabl1(2).width)
      tabl2(3).set_width(tabl1(3).width)

      ! Table 3
      tabl3.create(3)
      tabl3(1).set_values(blnk)
      tabl3(2).set_values(ADPv(:,3))
      tabl3(3).set_values(ADPe(:,3))

      tabl3(1).set_width(tabl1(1).width)
      tabl3(2).set_width(tabl1(2).width)
      tabl3(3).set_width(tabl1(3).width)

      ! Table 4
      tabl4.create(3)
      tabl4(1).set_values(blnk)
      tabl4(2).set_values(ADPv(:,4))
      tabl4(3).set_values(ADPe(:,4))

      tabl4(1).set_width(tabl1(1).width)
      tabl4(2).set_width(tabl1(2).width)
      tabl4(3).set_width(tabl1(3).width)

      ! Table 5
      tabl5.create(3)
      tabl5(1).set_values(blnk)
      tabl5(2).set_values(ADPv(:,5))
      tabl5(3).set_values(ADPe(:,5))

      tabl5(1).set_width(tabl1(1).width)
      tabl5(2).set_width(tabl1(2).width)
      tabl5(3).set_width(tabl1(3).width)

      ! Table 6
      tabl6.create(3)
      tabl6(1).set_values(blnk)
      tabl6(2).set_values(ADPv(:,6))
      tabl6(3).set_values(ADPe(:,6))

      tabl6(1).set_width(tabl1(1).width)
      tabl6(2).set_width(tabl1(2).width)
      tabl6(3).set_width(tabl1(3).width)

      ! Put tables
      tabl1.put_body(tabl1,tabl2,tabl3,tabl4,tabl5,tabl6)

      ! Clean
      tabl6.destroy
      tabl5.destroy
      tabl4.destroy
      tabl3.destroy
      tabl2.destroy
      tabl1.destroy

   end

   put_CIF_ADP2_in_inertial_axes_cartn_HBB(cov,refine_H_U_iso)
   ! Output cartesian ADP2s in the inertial axis frame, 
   ! in CIF format to "stdout".
      self :: IN
      cov :: MAT{REAL}, IN
      refine_H_U_iso :: BIN, optional, IN

   ENSURE(cov.is_square,"covariance matrix is not square!")
   ENSURE(cov.dim1==.no_of_pADPs,"wrong size, covariance matrix!")

      lab,ADP2_label :: STR
      ADP2v,ADP2s :: VEC{REAL}(6)
      fac1,fac2 :: REAL
      U,dU :: MAT{REAL}@
      axes :: MAT{REAL}(3,3)
      i,dim :: INT
      H_U_iso :: BIN

      H_U_iso = FALSE
      if (present(refine_H_U_iso)) H_U_iso = refine_H_U_iso

      ! Unit conversion for ADP's
      fac1 = ANGSTROM_PER_BOHR
      fac2 = fac1*fac1

      ! Get the quntities
      .make_inertial_axes(axes)
      .get_ADP2s_in_new_axes_in(U,dU,axes,cov) 

      ! Put the ADP2's
      ADP2_label = "_atom_site_ADP2_in_inertial_U_"

      stdout.flush
      stdout.text("# ===================================")
      stdout.text("# Cartesian ADP2s inertial axis frame")
      stdout.text("# ===================================")
      stdout.flush
      stdout.text("# . These precise data use non-standard CIF tags")
      stdout.text("# . Units are in Angstrom^2")

      stdout.flush
      stdout.text("loop_")
      stdout.text(trim(ADP2_label)//"label")

      do i = 1,6
         lab = ATOM:ADP2_index_label(i,form="123-repeated")
         stdout.put(trim(trim(ADP2_label)//trim(lab)),left=TRUE)
         stdout.put(trim(trim(ADP2_label)//trim(lab)//trim("_esu")),left=TRUE)
         stdout.flush
      end
      
      ! Size of table
      dim = .dim
      if (H_U_iso) dim = .no_of_non_H_atoms

!     ! Get column data
!     if (NOT H_U_iso) then
      
         do i = 1,dim
         
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
         
            ! Units !!!!!!!!!!!!
            ADP2v = fac2 *  U(i,1:6)
            ADP2s = fac2 * dU(i,1:6)
 
            ! Print ADP2
            stdout.put(ADP2v(1))
            stdout.put(ADP2s(1))
            stdout.flush
            stdout.put(ADP2v(2))
            stdout.put(ADP2s(2))
            stdout.flush
            stdout.put(ADP2v(3))
            stdout.put(ADP2s(3))
            stdout.flush
            stdout.put(ADP2v(4))
            stdout.put(ADP2s(4))
            stdout.flush
            stdout.put(ADP2v(5))
            stdout.put(ADP2s(5))
            stdout.flush
            stdout.put(ADP2v(6))
            stdout.put(ADP2s(6))
            stdout.flush
         
         end

!     end

      ! Clean
      dU.destroy
       U.destroy

   end

   put_CIF_ADP2_in_ADP2_principal_axes_cartn_HBB(cov,refine_H_U_iso)
   ! Output cartesian ADP2s in the ADP2 principal axis frame (for
   ! checking) in CIF format to "stdout".
      self :: IN
      cov :: MAT{REAL}, IN
      refine_H_U_iso :: BIN, optional, IN

   ENSURE(cov.is_square,"covariance matrix is not square!")
   ENSURE(cov.dim1==.no_of_pADPs,"wrong size, covariance matrix!")

      lab,ADPn_label :: STR
      ADP2v,ADP2s :: VEC{REAL}(6)
      fac1,fac2 :: REAL
      U,dU :: MAT{REAL}@
      i,n,dim :: INT
      H_U_iso :: BIN

      H_U_iso = FALSE
      if (present(refine_H_U_iso)) H_U_iso = refine_H_U_iso

      ! Unit conversion for ADP's
      fac1 = ANGSTROM_PER_BOHR
      fac2 = fac1*fac1

      ! Get the quntities
      .get_ADP2s_in_ADP2_principal_axes_in(U,dU,cov)

      ! Put the ADP2's
!     if (.has_any_ADP2s_and_errors) then

         ADPn_label = "_atom_site_ADP2_in_principal_U_"

         stdout.flush
         stdout.text("# ============================================")
         stdout.text("# Cartesian ADP2s in ADP2 principal axis frame")
         stdout.text("# ============================================")
         stdout.flush
         stdout.text("# . These precise data use non-standard CIF tags")
         stdout.text("# . Please keep for a better refinement restart")
         stdout.text("# . Units are in Angstrom^2")

         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,6
            lab = ATOM:ADP2_index_label(i,form="123-repeated")
            stdout.put(trim(trim(ADPn_label)//trim(lab)),left=TRUE)
            stdout.put(trim(trim(ADPn_label)//trim(lab)//trim("_esu")),left=TRUE)
            stdout.flush
         end
       
         n = 0

         ! Size of table
         dim = .dim
         if (H_U_iso) dim = .no_of_non_H_atoms
   
!        ! Get column data
!        if (NOT H_U_iso) then
      
            do i = 1,dim
          
               ! ADP2 atom index
               n = n + 1
          
               stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
          
               ! Units !!!!!!!!!!!!
               ADP2v = fac2 *  U(n,1:6)
               ADP2s = fac2 * dU(n,1:6)
 
               ! Print ADP2
               stdout.put(ADP2v( 1))
               stdout.put(ADP2s( 1))
               stdout.flush
               stdout.put(ADP2v( 2))
               stdout.put(ADP2s( 2))
               stdout.flush
               stdout.put(ADP2v( 3))
               stdout.put(ADP2s( 3))
               stdout.flush
               stdout.put(ADP2v( 4))
               stdout.put(ADP2s( 4))
               stdout.flush
               stdout.put(ADP2v( 5))
               stdout.put(ADP2s( 5))
               stdout.flush
               stdout.put(ADP2v( 6))
               stdout.put(ADP2s( 6))
               stdout.flush
          
            end

!        end
!     end

      ! Clean
      dU.destroy
       U.destroy

   end

   put_CIF_ADP3_cartn_HBB(esd,GC3_scale_factor)
   ! Output cartesian anharmonic ADPs in CIF format to "stdout".
   ! This version produces errors, stored in "esd".
      self :: IN
      esd :: VEC{REAL}, IN
      GC3_scale_factor :: REAL, IN

   ENSURE(esd.dim==.no_of_pADPS,"wrong sizem esd")

      ADP :: VEC{REAL}(15)
      err :: VEC{REAL}(15)
      lab,ADPn_label :: STR
      i,k :: INT
      fac1,fac2,fac3 :: REAL

      ! Unit conversion for ADP's
      fac1 = ANGSTROM_PER_BOHR
      fac2 = fac1*fac1
      fac3 = fac2*fac1

      ! ==========
      ! Put ADP3's 
      ! ==========
      if (.has_any_ADP3s_and_errors) then

         ADPn_label = "_atom_site_Cartn_ADP3_U_"

         stdout.flush
         stdout.text("# ===============")
         stdout.text("# Cartesian ADP3s")
         stdout.text("# ===============")
         stdout.flush
         stdout.text("# . These precise data use non-standard CIF tags")
         stdout.text("# . Please keep for a better refinement restart")
         stdout.text("# . Units are in Angstrom^3 but may be scaled")
        
         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(GC3_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,10
         lab = ATOM:ADP3_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         k = 0
         do i = 1,.dim
        
            if (NOT self(i).has_ADP3s_and_errors) cycle
        
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
!            stdout.flush
        
            ! Get values and errors
            self(i).put_ADP3_vector_to(ADP(1:10))
            err(1:10) = esd(k+10:k+19)

            ! Units !!!!!!!!!!!!!!!!!!
            ADP(1:10) = ADP(1:10)*fac3
            err(1:10) = err(1:10)*fac3

            ! Scale by scale factor
            ADP(1:10) = ADP(1:10)*GC3_scale_factor
            err(1:10) = err(1:10)*GC3_scale_factor
        
            ! Put quantity q with full error.
            stdout.put(ADP( 1))
            stdout.put(err( 1))
            stdout.flush
            stdout.put(ADP( 2))
            stdout.put(err( 2))
            stdout.flush
            stdout.put(ADP( 3))
            stdout.put(err( 3))
            stdout.flush
            stdout.put(ADP( 4))
            stdout.put(err( 4))
            stdout.flush
            stdout.put(ADP( 5))
            stdout.put(err( 5))
            stdout.flush
            stdout.put(ADP( 6))
            stdout.put(err( 6))
            stdout.flush
            stdout.put(ADP( 7))
            stdout.put(err( 7))
            stdout.flush
            stdout.put(ADP( 8))
            stdout.put(err( 8))
            stdout.flush
            stdout.put(ADP( 9))
            stdout.put(err( 9))
            stdout.flush
            stdout.put(ADP(10))
            stdout.put(err(10))
            stdout.flush

            k = k + self(i).no_of_pADPs
        
         end

      end

   end

   put_CIF_ADP3_in_inertial_axes_cartn_HBB(cov,GC3_scale_factor)
   ! Output cartesian anharmonic ADPs in the ADP2 principal axis
   ! frame, in CIF format to "stdout".
      self :: IN
      cov :: MAT{REAL}, IN
      GC3_scale_factor :: REAL, IN

   ENSURE(cov.is_square,"covariance matrix is not square!")
   ENSURE(cov.dim1==.no_of_pADPs,"wrong size, covariance matrix!")

      lab,ADPn_label :: STR
      ADP3v,ADP3s :: VEC{REAL}(10)
      fac1,fac2,fac3 :: REAL
      U,dU :: MAT{REAL}@
      axes :: MAT{REAL}(3,3)
      i,n :: INT

      ! Unit conversion for ADP's
      fac1 = ANGSTROM_PER_BOHR
      fac2 = fac1*fac1
      fac3 = fac2*fac1

      ! Get the quntities
      .make_inertial_axes(axes)
      .get_ADP3s_in_new_axes_in(U,dU,axes,cov) 

      ! Put the ADP3's
      if (.has_any_ADP3s_and_errors) then

         ADPn_label = "_atom_site_ADP3_in_inertial_U_"

         stdout.flush
         stdout.text("# ===========================================")
         stdout.text("# Cartesian ADP3s in ADP2 inertial axis frame")
         stdout.text("# ===========================================")
         stdout.flush
         stdout.text("# . These precise data use non-standard CIF tags")
         stdout.text("# . Please keep for a better refinement restart")
         stdout.text("# . Units are in Angstrom^3 but are scaled")

         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(GC3_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,10
            lab = ATOM:ADP3_index_label(i,form="123-repeated")
            stdout.put(trim(trim(ADPn_label)//trim(lab)),left=TRUE)
            stdout.put(trim(trim(ADPn_label)//trim(lab)//trim("_esu")),left=TRUE)
            stdout.flush
         end
       
         n = 0

         do i = 1,.dim
       
            if (NOT self(i).has_ADP3s_and_errors) cycle

            ! ADP3 atom index
            n = n + 1
       
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
!           stdout.flush
       
            ! Units !!!!!!!!!!!!
            ADP3v = fac3 *  U(n,1:10)
            ADP3s = fac3 * dU(n,1:10)

            ! Scale factor
            ADP3v = GC3_scale_factor*ADP3v
            ADP3s = GC3_scale_factor*ADP3s
       
            ! Print ADP3
            stdout.put(ADP3v( 1))
            stdout.put(ADP3s( 1))
            stdout.flush
            stdout.put(ADP3v( 2))
            stdout.put(ADP3s( 2))
            stdout.flush
            stdout.put(ADP3v( 3))
            stdout.put(ADP3s( 3))
            stdout.flush
            stdout.put(ADP3v( 4))
            stdout.put(ADP3s( 4))
            stdout.flush
            stdout.put(ADP3v( 5))
            stdout.put(ADP3s( 5))
            stdout.flush
            stdout.put(ADP3v( 6))
            stdout.put(ADP3s( 6))
            stdout.flush
            stdout.put(ADP3v( 7))
            stdout.put(ADP3s( 7))
            stdout.flush
            stdout.put(ADP3v( 8))
            stdout.put(ADP3s( 8))
            stdout.flush
            stdout.put(ADP3v( 9))
            stdout.put(ADP3s( 9))
            stdout.flush
            stdout.put(ADP3v(10))
            stdout.put(ADP3s(10))
            stdout.flush
       
         end

      end

      ! Clean
      dU.destroy
       U.destroy

   end

   put_CIF_ADP3_in_ADP2_principal_axes_cartn_HBB(cov,GC3_scale_factor)
   ! Output cartesian anharmonic ADPs in the ADP2 principal axis
   ! frame, in CIF format to "stdout".
      self :: IN
      cov :: MAT{REAL}, IN
      GC3_scale_factor :: REAL, IN

   ENSURE(cov.is_square,"covariance matrix is not square!")
   ENSURE(cov.dim1==.no_of_pADPs,"wrong size, covariance matrix!")

      lab,ADPn_label :: STR
      ADP3v,ADP3s :: VEC{REAL}(10)
      fac1,fac2,fac3 :: REAL
      U,dU :: MAT{REAL}@
      i,n :: INT

      ! Unit conversion for ADP's
      fac1 = ANGSTROM_PER_BOHR
      fac2 = fac1*fac1
      fac3 = fac2*fac1

      ! Get the quntities
      .get_ADP3s_in_ADP2_principal_axes_in(U,dU,cov)

      ! Put the ADP3's
      if (.has_any_ADP3s_and_errors) then

         ADPn_label = "_atom_site_ADP3_in_principal_U_"

         stdout.flush
         stdout.text("# ============================================")
         stdout.text("# Cartesian ADP3s in ADP2 principal axis frame")
         stdout.text("# ============================================")
         stdout.flush
         stdout.text("# . These precise data use non-standard CIF tags")
         stdout.text("# . Please keep for a better refinement restart")
         stdout.text("# . Units are in Angstrom^3 but are scaled")

         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(GC3_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,10
            lab = ATOM:ADP3_index_label(i,form="123-repeated")
            stdout.put(trim(trim(ADPn_label)//trim(lab)),left=TRUE)
            stdout.put(trim(trim(ADPn_label)//trim(lab)//trim("_esu")),left=TRUE)
            stdout.flush
         end
       
         n = 0

         do i = 1,.dim
       
            if (NOT self(i).has_ADP3s_and_errors) cycle

            ! ADP3 atom index
            n = n + 1
       
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
!           stdout.flush
       
            ! Units !!!!!!!!!!!!
            ADP3v = fac3 *  U(n,1:10)
            ADP3s = fac3 * dU(n,1:10)

            ! Scale factor
            ADP3v = GC3_scale_factor*ADP3v
            ADP3s = GC3_scale_factor*ADP3s
       
            ! Print ADP3
            stdout.put(ADP3v( 1))
            stdout.put(ADP3s( 1))
            stdout.flush
            stdout.put(ADP3v( 2))
            stdout.put(ADP3s( 2))
            stdout.flush
            stdout.put(ADP3v( 3))
            stdout.put(ADP3s( 3))
            stdout.flush
            stdout.put(ADP3v( 4))
            stdout.put(ADP3s( 4))
            stdout.flush
            stdout.put(ADP3v( 5))
            stdout.put(ADP3s( 5))
            stdout.flush
            stdout.put(ADP3v( 6))
            stdout.put(ADP3s( 6))
            stdout.flush
            stdout.put(ADP3v( 7))
            stdout.put(ADP3s( 7))
            stdout.flush
            stdout.put(ADP3v( 8))
            stdout.put(ADP3s( 8))
            stdout.flush
            stdout.put(ADP3v( 9))
            stdout.put(ADP3s( 9))
            stdout.flush
            stdout.put(ADP3v(10))
            stdout.put(ADP3s(10))
            stdout.flush
       
         end

      end

      ! Clean
      dU.destroy
       U.destroy

   end

   put_CIF_ADP4_cartn_HBB(esd,GC4_scale_factor)
   ! Output cartesian anharmonic ADPs in CIF format to "stdout".
   ! This version produces errors, stored in "esd".
      self :: IN
      esd :: VEC{REAL}, IN
      GC4_scale_factor :: REAL, IN

   ENSURE(esd.dim==.no_of_pADPS,"wrong sizem esd")

      ADP :: VEC{REAL}(15)
      err :: VEC{REAL}(15)
      lab,ADPn_label :: STR
      i,k :: INT
      fac1,fac2 :: REAL
      fac3,fac4 :: REAL

      ! Unit conversion for ADP's
      fac1 = ANGSTROM_PER_BOHR
      fac2 = fac1*fac1
      fac3 = fac2*fac1
      fac4 = fac2*fac2

      ! ==========
      ! Put ADP4's
      ! ==========
      if (.has_any_ADP4s_and_errors) then

         ADPn_label = "_atom_site_Cartn_ADP4_U_"

         stdout.flush
         stdout.text("# ===============")
         stdout.text("# Cartesian ADP4s")
         stdout.text("# ===============")
         stdout.flush
         stdout.text("# . These precise data use non-standard CIF tags")
         stdout.text("# . Please keep for a better refinement restart")
         stdout.text("# . Units are in Angstrom^4")
        
         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(GC4_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,15
         lab = ATOM:ADP4_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         k = 0
         do i = 1,.dim
        
            if (NOT self(i).has_ADP4s_and_errors) cycle
        
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
!           stdout.flush
        
            ! Get values and errors (dimensionless)
            self(i).put_ADP4_vector_to(ADP(1:15))
            err(1:15) = esd(k+20:k+34)

            ! Units !!!!!!!!!!!!!!!!!!
            ADP(1:15) = ADP(1:15)*fac4
            err(1:15) = err(1:15)*fac4

            ! Scale by scale factor
            ADP(1:15) = ADP(1:15)*GC4_scale_factor
            err(1:15) = err(1:15)*GC4_scale_factor
        
            ! Put quantity q with full error.
            stdout.put(ADP( 1))
            stdout.put(err( 1))
            stdout.flush
            stdout.put(ADP( 2))
            stdout.put(err( 2))
            stdout.flush
            stdout.put(ADP( 3))
            stdout.put(err( 3))
            stdout.flush
            stdout.put(ADP( 4))
            stdout.put(err( 4))
            stdout.flush
            stdout.put(ADP( 5))
            stdout.put(err( 5))
            stdout.flush
            stdout.put(ADP( 6))
            stdout.put(err( 6))
            stdout.flush
            stdout.put(ADP( 7))
            stdout.put(err( 7))
            stdout.flush
            stdout.put(ADP( 8))
            stdout.put(err( 8))
            stdout.flush
            stdout.put(ADP( 9))
            stdout.put(err( 9))
            stdout.flush
            stdout.put(ADP(10))
            stdout.put(err(10))
            stdout.flush
            stdout.put(ADP(11))
            stdout.put(err(11))
            stdout.flush
            stdout.put(ADP(12))
            stdout.put(err(12))
            stdout.flush
            stdout.put(ADP(13))
            stdout.put(err(13))
            stdout.flush
            stdout.put(ADP(14))
            stdout.put(err(14))
            stdout.flush
            stdout.put(ADP(15))
            stdout.put(err(15))
            stdout.flush
        
            k = k + self(i).no_of_pADPs
        
         end

      end ! =========

   end

   put_CIF_ADP4_in_inertial_axes_cartn_HBB(cov,GC4_scale_factor)
   ! Output cartesian anharmonic ADPs in the ADP2 principal axis
   ! frame, in CIF format to "stdout".
      self :: IN
      cov :: MAT{REAL}, IN
      GC4_scale_factor :: REAL, IN

   ENSURE(cov.is_square,"covariance matrix is not square!")
   ENSURE(cov.dim1==.no_of_pADPs,"wrong size, covariance matrix!")

      lab,ADPn_label :: STR
      ADP4v,ADP4s :: VEC{REAL}(15)
      fac1,fac2 :: REAL
      fac3,fac4 :: REAL
      U,dU :: MAT{REAL}@
      axes :: MAT{REAL}(3,3)
      i,n :: INT

      ! Unit conversion for ADP's
      fac1 = ANGSTROM_PER_BOHR
      fac2 = fac1*fac1
      fac3 = fac2*fac1
      fac4 = fac2*fac2

      ! Get the quntities
      .make_inertial_axes(axes)
      .get_ADP4s_in_new_axes_in(U,dU,axes,cov) 

      ! Put the ADP4's
      if (.has_any_ADP4s_and_errors) then

         ADPn_label = "_atom_site_ADP4_in_inertial_U_"

         stdout.flush
         stdout.text("# ===========================================")
         stdout.text("# Cartesian ADP4s in ADP2 inertial axis frame")
         stdout.text("# ===========================================")
         stdout.flush
         stdout.text("# . These precise data use non-standard CIF tags")
         stdout.text("# . Please keep for a better refinement restart")
         stdout.text("# . Units are in Angstrom^4 but may be scaled")

         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(GC4_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,15
            lab = ATOM:ADP4_index_label(i,form="123-repeated")
            stdout.put(trim(trim(ADPn_label)//trim(lab)),left=TRUE)
            stdout.put(trim(trim(ADPn_label)//trim(lab)//trim("_esu")),left=TRUE)
            stdout.flush
         end

         n = 0
        
         do i = 1,.dim
        
            if (NOT self(i).has_ADP4s_and_errors) cycle

            ! ADP4 atom index
            n = n + 1
        
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
!           stdout.flush
        
            ! Get values
            self(i).put_ADP4_vector_to(ADP4v)

            ! Units !!!!!!!!!!
            ADP4v = fac4 *  U(n,1:15)
            ADP4s = fac4 * dU(n,1:15)

            ! Scale factor
            ADP4v = GC4_scale_factor*ADP4v
            ADP4s = GC4_scale_factor*ADP4s
        
            ! Print ADP4
            stdout.put(ADP4v( 1))
            stdout.put(ADP4s( 1))
            stdout.flush
            stdout.put(ADP4v( 2))
            stdout.put(ADP4s( 2))
            stdout.flush
            stdout.put(ADP4v( 3))
            stdout.put(ADP4s( 3))
            stdout.flush
            stdout.put(ADP4v( 4))
            stdout.put(ADP4s( 4))
            stdout.flush
            stdout.put(ADP4v( 5))
            stdout.put(ADP4s( 5))
            stdout.flush
            stdout.put(ADP4v( 6))
            stdout.put(ADP4s( 6))
            stdout.flush
            stdout.put(ADP4v( 7))
            stdout.put(ADP4s( 7))
            stdout.flush
            stdout.put(ADP4v( 8))
            stdout.put(ADP4s( 8))
            stdout.flush
            stdout.put(ADP4v( 9))
            stdout.put(ADP4s( 9))
            stdout.flush
            stdout.put(ADP4v(10))
            stdout.put(ADP4s(10))
            stdout.flush
            stdout.put(ADP4v(11))
            stdout.put(ADP4s(11))
            stdout.flush
            stdout.put(ADP4v(12))
            stdout.put(ADP4s(12))
            stdout.flush
            stdout.put(ADP4v(13))
            stdout.put(ADP4s(13))
            stdout.flush
            stdout.put(ADP4v(14))
            stdout.put(ADP4s(14))
            stdout.flush
            stdout.put(ADP4v(15))
            stdout.put(ADP4s(15))
            stdout.flush
        
         end

      end

      ! Clean
      dU.destroy
       U.destroy

   end

   put_CIF_ADP4_in_ADP2_principal_axes_cartn_HBB(cov,GC4_scale_factor)
   ! Output cartesian anharmonic ADPs in the ADP2 principal axis
   ! frame, in CIF format to "stdout".
      self :: IN
      cov :: MAT{REAL}, IN
      GC4_scale_factor :: REAL, IN

   ENSURE(cov.is_square,"covariance matrix is not square!")
   ENSURE(cov.dim1==.no_of_pADPs,"wrong size, covariance matrix!")

      lab,ADPn_label :: STR
      ADP4v,ADP4s :: VEC{REAL}(15)
      fac1,fac2 :: REAL
      fac3,fac4 :: REAL
      U,dU :: MAT{REAL}@
      i,n :: INT

      ! Unit conversion for ADP's
      fac1 = ANGSTROM_PER_BOHR
      fac2 = fac1*fac1
      fac3 = fac2*fac1
      fac4 = fac2*fac2

      ! Get the quntities
      .get_ADP4s_in_ADP2_principal_axes_in(U,dU,cov)

      ! Put the ADP4's
      if (.has_any_ADP4s_and_errors) then

         ADPn_label = "_atom_site_ADP4_in_principal_U_"

         stdout.flush
         stdout.text("# ============================================")
         stdout.text("# Cartesian ADP4s in ADP2 principal axis frame")
         stdout.text("# ============================================")
         stdout.flush
         stdout.text("# . These precise data use non-standard CIF tags")
         stdout.text("# . Please keep for a better refinement restart")
         stdout.text("# . Units are in Angstrom^4 but may be scaled")

         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(GC4_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,15
            lab = ATOM:ADP4_index_label(i,form="123-repeated")
            stdout.put(trim(trim(ADPn_label)//trim(lab)),left=TRUE)
            stdout.put(trim(trim(ADPn_label)//trim(lab)//trim("_esu")),left=TRUE)
            stdout.flush
         end

         n = 0
        
         do i = 1,.dim
        
            if (NOT self(i).has_ADP4s_and_errors) cycle

            ! ADP4 atom index
            n = n + 1
        
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
!           stdout.flush
        
            ! Get values
            self(i).put_ADP4_vector_to(ADP4v)

            ! Units !!!!!!!!!!
            ADP4v = fac4 *  U(n,1:15)
            ADP4s = fac4 * dU(n,1:15)

            ! Scale factor
            ADP4v = GC4_scale_factor*ADP4v
            ADP4s = GC4_scale_factor*ADP4s
        
            ! Print ADP4
            stdout.put(ADP4v( 1))
            stdout.put(ADP4s( 1))
            stdout.flush
            stdout.put(ADP4v( 2))
            stdout.put(ADP4s( 2))
            stdout.flush
            stdout.put(ADP4v( 3))
            stdout.put(ADP4s( 3))
            stdout.flush
            stdout.put(ADP4v( 4))
            stdout.put(ADP4s( 4))
            stdout.flush
            stdout.put(ADP4v( 5))
            stdout.put(ADP4s( 5))
            stdout.flush
            stdout.put(ADP4v( 6))
            stdout.put(ADP4s( 6))
            stdout.flush
            stdout.put(ADP4v( 7))
            stdout.put(ADP4s( 7))
            stdout.flush
            stdout.put(ADP4v( 8))
            stdout.put(ADP4s( 8))
            stdout.flush
            stdout.put(ADP4v( 9))
            stdout.put(ADP4s( 9))
            stdout.flush
            stdout.put(ADP4v(10))
            stdout.put(ADP4s(10))
            stdout.flush
            stdout.put(ADP4v(11))
            stdout.put(ADP4s(11))
            stdout.flush
            stdout.put(ADP4v(12))
            stdout.put(ADP4s(12))
            stdout.flush
            stdout.put(ADP4v(13))
            stdout.put(ADP4s(13))
            stdout.flush
            stdout.put(ADP4v(14))
            stdout.put(ADP4s(14))
            stdout.flush
            stdout.put(ADP4v(15))
            stdout.put(ADP4s(15))
            stdout.flush
        
         end

      end

      ! Clean
      dU.destroy
       U.destroy

   end

   put_CIF_bond_angle_table_HBB(covariance)
   ! Output the CIF bond angle table with errors given the "covariance"
   ! matrix between all atomic positions. 
      self :: IN
      covariance :: MAT{REAL}, IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{EVEC{INT}}@
      n_kind,k1,k2,k3,n_angles :: INT
      symbols   :: MAT{STR}@
      dash :: VEC{STR}@
      angle,esds :: VEC{REAL}@
      triple :: MAT{INT}@

      ! Title
      stdout.flush
      stdout.text("# ===========")
      stdout.text("# Bond Angles")
      stdout.text("# ===========")

      ! Loop 
      stdout.flush
      stdout.text("loop_")
      stdout.text(" _geom_angle_atom_site_label_1")
      stdout.text(" _geom_angle_site_symmetry_1")
      stdout.text(" _geom_angle_atom_site_label_2")
      stdout.text(" _geom_angle_site_symmetry_2")
      stdout.text(" _geom_angle_atom_site_label_3")
      stdout.text(" _geom_angle_site_symmetry_3")
      stdout.text(" _geom_angle")
      stdout.text(" _geom_angle_esu")

      ! Get Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(8)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self(.angle_outer_atoms).tag)
      table(2).set_heading(".")
      table(2).set_width(1)
      table(3).set_heading("B")
      table(3).set_width_from(self(.angle_center_atoms).tag)
      table(4).set_heading(".")
      table(4).set_width(1)
      table(5).set_heading("C")
      table(5).set_width_from(self(.angle_outer_atoms).tag)
      table(6).set_heading(".")
      table(6).set_width(1)
      table(7).set_heading("Angle(A--B--C)")
      table(7).set_width_from(ONE)
      table(8).set_heading("Angle(A--B--C) esu")
      table(8).set_width_from(ONE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_angles(triple,angle,esds,Z_list,k1,k2,k3,covariance)
         angle = angle*DEGREE_PER_RADIAN
         esds  = esds *DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            esds.destroy
            angle.destroy
            triple.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,3)
         symbols = " "
         symbols(:,1) = self(triple(:,1)).tag
         symbols(:,2) = self(triple(:,2)).tag
         symbols(:,3) = self(triple(:,3)).tag

         ! Dashes
         dash.create(n_angles)
         dash    = "."

         ! Set table data
         table(1).set_values(symbols(:,1))
         table(2).set_values(dash)
         table(3).set_values(symbols(:,2))
         table(4).set_values(dash)
         table(5).set_values(symbols(:,3))
         table(6).set_values(dash)
         table(7).set_values(angle)
         table(8).set_values(esds)

         ! Put body
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dash.destroy
         symbols.destroy
         esds.destroy
         angle.destroy
         triple.destroy

      end
      end
      end

      ! Clean
      table.destroy
      Z_list.destroy

   end


   put_NKA_with_errors(T_sequence_no)
   ! Output the atom positions, ADP's, ADP sigmas in NKA file format
   ! to "stdout".
      self :: IN
      T_sequence_no :: INT, IN

      i,k :: INT
      fac :: REAL
      ADP :: MAT{REAL}(3,3)
      pos :: VEC{REAL}(3)
      err :: VEC{REAL}(6)

      ! Unit conversion for ADP's
      fac =  ANGSTROM_PER_BOHR*ANGSTROM_PER_BOHR

      ! Coordinates and ADP's in A^2
      stdout.flush
      do i = 1,.dim

         stdout.put(self(i).chemical_symbol,width=3)

         ! Coordinates in crystal or cartesian system
         pos = ANGSTROM_PER_BOHR * self(i).position
         stdout.put(pos(1))
         stdout.put(pos(2))
         stdout.put(pos(3))
         stdout.put(1,width=2)
         stdout.put(T_sequence_no,width=3)
         stdout.flush

         ! Get values and errors
         ADP =  fac * self(i).ADP_tensor

         ! ADP's always in cartesians and A^2
         stdout.put(ADP(1,1))
         stdout.put(ADP(2,2))
         stdout.put(ADP(3,3))
         stdout.put(ADP(1,2))
         stdout.put(ADP(1,3))
         stdout.put(ADP(2,3))

         stdout.flush

      end

      ! Now the ADP errors
      stdout.flush
      k = -9
      do i = 1,.dim

         k = k + 9

         stdout.put("SIG",width=3)
         stdout.put(self(i).chemical_symbol,width=3)
         stdout.put(T_sequence_no,width=3)

         ! Get values and errors
         err = fac * self(i).pADP_errors(4:9)

         ! Print ADPs
         stdout.put(err(1))
         stdout.put(err(2))
         stdout.put(err(3))
         stdout.put(err(4))
         stdout.put(err(5))
         stdout.put(err(6))

         stdout.flush

      end

   end

   put_excel_with_errors(esd,temperature)
   ! Output the atoms in Excel file format to "stdout"
   ! This should be in the crystal coordinate system.
      self :: IN
      esd :: VEC{REAL}, IN
      temperature :: REAL, IN

   ENSURE(self(1).pos_axis_system=="crystal","must be in crystal axis system")

      i,k :: INT
      fac :: REAL
      ADP :: MAT{REAL}(3,3)
      err :: VEC{REAL}(6)
      lab :: STR

      ! Unit conversion for ADP's
      fac =  ANGSTROM_PER_BOHR*ANGSTROM_PER_BOHR

      ! Coordinates in crystal axis system
      stdout.show("Coordinates refined at T =",temperature)
      stdout.flush
      k = 0
      do i = 1,.dim

         stdout.put("x")
         stdout.put(self(i).position(1))
         stdout.put(esd(k+1))
         stdout.put(self(i).tag)
         stdout.flush

         stdout.put("y")
         stdout.put(self(i).position(2))
         stdout.put(esd(k+2))
         stdout.put(self(i).tag)
         stdout.flush

         stdout.put("z")
         stdout.put(self(i).position(3))
         stdout.put(esd(k+3))
         stdout.put(self(i).tag)
         stdout.flush

         k = k + 9

      end

      ! ADP's in crystal (CIF) axis system, angstrom^2 units
      stdout.show("ADP's refined at T =",temperature)
      stdout.flush
      k = 0
      do i = 1,.dim

         ! Get values and errors
         ADP = fac * self(i).ADP_tensor
         err = fac * esd(k+4:k+9)
         lab = self(i).tag

         ! Print
         stdout.put("U11"); stdout.put(ADP(1,1)); stdout.put(err(1)); stdout.put(lab); stdout.flush
         stdout.put("U22"); stdout.put(ADP(2,2)); stdout.put(err(2)); stdout.put(lab); stdout.flush
         stdout.put("U33"); stdout.put(ADP(3,3)); stdout.put(err(3)); stdout.put(lab); stdout.flush
         stdout.put("U12"); stdout.put(ADP(1,2)); stdout.put(err(4)); stdout.put(lab); stdout.flush
         stdout.put("U13"); stdout.put(ADP(1,3)); stdout.put(err(5)); stdout.put(lab); stdout.flush
         stdout.put("U23"); stdout.put(ADP(2,3)); stdout.put(err(6)); stdout.put(lab); stdout.flush

         k = k + 9

      end

   end

!  ============
!  Put orbitals
!  ============

   put_orbitals(orb,pair)
   ! Output the orbitals "orb" in a table with basis function labels.
      self :: IN
      orb :: MAT{REAL}, IN
      pair :: BIN, optional, IN

   ENSURE(.has_all_gaussian_bases,"no gaussian bases")
   ENSURE(orb.dim2==.no_of_basis_functions,"wrong dim2, orb: "//trim(INT:to_str(orb.dim2)))

      table :: VEC{TABLE_COLUMN}@
      labels :: VEC{STR}@
      is_pair :: BIN
      c :: INT

      ! Bond/antibond pair?
      is_pair = FALSE
      if (present(pair)) then
      if (orb.dim2==2) then
         is_pair = pair
      end
      end

      ! Basis-fn tags
      labels.create(.no_of_basis_functions)
      labels = .tag_xyz_basis_fn_part

      ! Create table
      table.create(orb.dim2+1)

      ! Set table headings
      table(1).set_heading("Basis")
      table(1).set_subhead("func.")

      if (is_pair) then
         table(2).set_heading("Bond")
         table(2).set_subhead("Orb.")
         table(3).set_heading("Anti")
         table(3).set_subhead("bond")
      else
         do c = 1,orb.dim2
         table(c+1).set_heading("Orb")
         table(c+1).set_subhead(trim(c.to_str))
         end
      end

      ! Set data
      table(1).set_values(labels)
      do c = 1,orb.dim2
         table(c+1).set_values(orb(:,c))
      end


      ! Put
      table.put(label_rows=FALSE)

      ! Clean
      table.destroy
      labels.destroy

   end

end
