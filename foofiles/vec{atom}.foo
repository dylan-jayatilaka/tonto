!---------------------------------------------------------------------------
!
! VEC{ATOM}: ATOM vectors
!
! Copyright (C) Dylan Jayatilaka, 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: vec{atom}.foo 4409 2014-06-10 03:32:55Z durhammike $
!---------------------------------------------------------------------------

module VEC{ATOM}

   implicit none

 ! saved_self :: VEC{ATOM}*, private  DEFAULT_NULL

   ! Index information arrays; the strange "4" stands for "for" and
   ! prevents a name clash with a procedure of the same name.

!   index_info_created :: BIN, private DEFAULT(FALSE)
!   atom_4_shell :: VEC{INT}*, private DEFAULT_NULL
!   atom_shell_4_shell :: VEC{INT}*, private DEFAULT_NULL
!   first_shell_4_atom :: VEC{INT}*, private DEFAULT_NULL
!   first_basis_fn_4_shell :: VEC{INT}*, private DEFAULT_NULL
!   last_basis_fn_4_shell  :: VEC{INT}*, private DEFAULT_NULL
!   angular_moment_4_shell :: VEC{INT}*, private DEFAULT_NULL
!   first_basis_fn_4_atom  :: VEC{INT}*, private DEFAULT_NULL
!   last_basis_fn_4_atom   :: VEC{INT}*, private DEFAULT_NULL

   ! Atom connection table, to save work
   connections_for :: VEC{VEC_{INT}}*, private DEFAULT_NULL

contains

!  ==================
!  Allocation methods
!  ==================

   create(dim) ::: get_from(VEC{OBJECT}), leaky
   ! Create space for object
   end

   destroy ::: get_from(VEC{OBJECT}), leaky
   ! Destroy space for object
   end

   nullify_ptr_part ::: get_from(VEC{OBJECT})
   ! Nullify the pointer parts of self
   end

   nullify_bases
   ! Nullify all the bases
      .nullify_basis_part
      .nullify_slaterbasis_part
      .nullify_coppensbasis_part
   end

   nullify_basis_part
   ! Nullify the basis parts of self
      a :: INT
      do a = 1,.dim
         nullify(self(a).basis)
      end
   end

   nullify_slaterbasis_part
   ! Nullify the slaterbasis parts of self
      a :: INT
      do a = 1,.dim
         nullify(self(a).slaterbasis)
      end
   end

   nullify_coppensbasis_part
   ! Nullify the coppensbasis parts of self
      a :: INT
      do a = 1,.dim
         nullify(self(a).coppensbasis)
      end
   end

   destroy_ptr_part
   ! Destroy the pointer parts of self

      a :: INT

      ! Bases are never destroyed, they are always resolved externally
      ! to this module. (You just have to know that).
      .nullify_bases

      ! Destroy unique ptr parts (made outside of this module)
      if (.has_all_ANOs_made)           .destroy_ANOs
      if (.has_all_ANO_interpolators)   .destroy_ANO_interpolators
      if (.has_all_shell_info)          .destroy_shell_info

      ! Destroy non-unique ptr parts (made outside of this module)
      ! Each atom has a non-aliased object
      if (.has_all_spherical_atom_data) .destroy_spherical_atom_data
      if (.has_all_interpolators)       .destroy_interpolators

      ! Now safe to destroy ...
      do a = 1,.dim
         self(a).destroy_ptr_part
      end

   end

   destroy_ANOs ::: leaky
   ! Destroy the (unique-atom) ANOs
      a :: INT
      do a = 1,.dim
         self(a).destroy_ANOs
      end
   end

   destroy_ANO_interpolators ::: leaky
   ! Destroy the (unique-atom) ANO interpolators
      a :: INT
      do a = 1,.dim
         self(a).destroy_ANO_interpolators
      end
   end

   destroy_shell_info ::: leaky
   ! Destroy the (unique-atom) shell info
      a :: INT
      do a = 1,.dim
         self(a).destroy_shell_info
      end
   end

   destroy_spherical_atom_data ::: leaky
   ! Destroy the (non-unique) ANO data
      a :: INT
      do a = 1,.dim
         self(a).destroy_spherical_atom_data
      end
   end

   destroy_interpolators ::: leakys
   ! Destroy (non-unique) interpolator parts
      a :: INT
      do a = 1,.dim
         self(a).interpolator.destroy
      end
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
   end

!  ====
!  Copy
!  ====

   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky
   ! Create a replica copy of "vec".
   end

   create_copy(vec,list) ::: get_from(VEC{OBJECT}), leaky
   ! Create a copy of "vec" for the elements in "list".
   end

   copy(vec) ::: leaky
   ! Copy "vec".
      vec :: VEC{ATOM}

   ENSURE(.dim==vec.dim,"vec size does not match")

      a :: INT

      ! Copy
      do a = 1,vec.dim
         self(a).copy(vec(a))
      end

      ! Update unique atoms
      .update

   end

   copy(vec,list) ::: leaky
   ! Copy "vec" for the elements in "list".
      vec  :: VEC{ATOM}, IN
      list :: VEC{INT}, IN

   ENSURE(.dim==list.dim,"wrong size, list")

      a,b :: INT

      ! Copy
      do a = 1,list.dim
         b = list(a)
         self(a).copy(vec(b))
      end

      ! Update unique atoms
      .update

   end

!  ======================
!  Shrink, expand, append
!  ======================

   shrink(dim)
   ! Shrink the atomvec to dimension "dim", retaining contents.
      self :: PTR
      dim :: INT, IN
      ENSURE(.created,"no self array")
      ENSURE(dim<=.dim,"dim too large")
      old :: VEC{ATOM}*
      n :: INT
      if (dim==.dim) return
      old => self
      nullify(self)
      self.create(dim)
      do n=1,dim
       self(n).copy(old(n))
      end
      old.nullify_basis_part
      old.destroy
   end

   expand(dim) ::: get_from(VEC{OBJECT}), leaky
   ! Expand the vector "self" to "dim". New slots are left undefined.
   end

   append(v) ::: get_from(VEC{OBJECT}), leaky
   ! Expands self and appends the contents of vector "v".
   end

   append(value) ::: get_from(VEC{OBJECT}), leaky
   ! Expands self by 1, and appends the single scalar "value" onto the end.
   end

   prune_element(k) ::: get_from(VEC{OBJECT}), leaky
   ! Removes the single element at position "k" from the vector.
   ! The order of the elements is unchanged.
   end

!  ===
!  Set
!  ===

   set_defaults ::: get_from(VEC{OBJECT}), leaky
   ! Set default values
   end

!  ==========
!  Set labels
!  ==========

   set_atom_data_from_labels(labels)
   ! Set "labels" for the atoms and also their atomic numbers.
      labels :: VEC{STR}

   ENSURE(labels.dim==.dim,"wrong length for labels")

      a :: INT

      do a = 1,.dim
         self(a).set_atom_data_from_label(labels(a))
      end

   end

   set_labels(labels)
   ! Set the "labels" ONLY for the atoms; use the above routine to set the
   ! atomic numbers as well.
      labels :: VEC{STR}

   ENSURE(labels.dim==.dim,"wrong length for labels")

      self%label = labels

   end

   set_recognised_labels(list) ::: leaky
   ! Set "list" to be the list of recognised labels. If all labels are
   ! recognised then "list" is not created.
      list :: VEC{INT}*
      n :: INT
      nullify(list)
      do n = 1,.dim
         if (NOT self(n).has_recognised_label) cycle
         list.append(n)
      end
      if (list.dim==.dim) list.destroy
   end

   set_use_interpolators(use_interp)
   ! Read whether to use interpolators for spherical atom densities
      use_interp :: BIN, IN
      a :: INT

      self%use_interpolator = use_interp

      if (.has_all_slater_bases)  then
         do a = 1,.dim
            self(a).slaterbasis.use_interpolator = use_interp
         end
      end

      if (.has_all_coppens_bases) then
         do a = 1,.dim
            self(a).coppensbasis.use_interpolator = use_interp
         end
      end

   end

   set_unique_tags
   ! Set the unique tags.

      atom_kind :: VEC{VEC_{INT}}*
      a,k,n,nk :: INT

      ! Get the atom kinds
      .make_atom_kind_list(atom_kind)

      ! Label atoms consecutively by kind and number
      do k = 1,atom_kind.dim

         nk = atom_kind(k).element.dim

         do n = 1,nk

            ! Atom index
            a = atom_kind(k)[n]

            ! Skip dummy
            if (self(a).is_a_dummy_atom) cycle

            ! Set tag
            if (nk==1) then; self(a)%tag = trim(self(a).chemical_symbol)
            else;            self(a)%tag = trim(self(a).chemical_symbol) // trim(n.to_str)
            end

         end

      end

      ! Clean
      atom_kind.destroy

   end

   set_basis_suffix(suffix)
   ! Set the "basis_label" to be a library-style label using "suffix"
      suffix :: STR, IN

      val :: STR
      a :: INT

      do a = 1,.dim
         val = self(a).library_basis_label(suffix)
         self(a).set_basis_label(val)
      end

   end

!  =========
!  Set kinds
!  =========

   set_kinds(n_kind)
   ! Set the kinds and whether the atoms are basis-unique.
   ! . They are the same kind if they have the same kind of basis
   !   and same atomic number.
   ! . This is used for ANO or other QM type calculations.
      n_kind :: INT, optional

      k,a,b :: INT

      ! Initially all different kind
      do a = 1,.dim
         self(a).set_kind(a)
      end

      ! Kind index
      k = 0

      ! Loop on atoms "a"
      do a = 1,.dim

         ! Already found this kind?
         if (self(a).kind<=k) cycle

         ! New kind
         k = k + 1
         self(a).set_kind(k)
         self(a).set_is_unique_kind(TRUE)

         ! Set non-unique kinds
         do b = a+1,.dim

            if (self(b).kind<=k) cycle
            if (NOT .same_kind_of_atoms(a,b)) cycle

            self(b).set_kind(k)
            self(b).set_is_unique_kind(FALSE)

         end

      end

      if (present (n_kind)) n_kind = k

   end

   set_is_unique_kind(val)
   ! Generic set
      val :: BIN, IN

      a :: INT

      do a = 1,.dim
         self(a).set_is_unique_kind(val)
      end

   end

   set_basis_kind(val)
   ! Generic set
      self :: INOUT
      val :: STR, IN

      a :: INT

      do a = 1,.dim
         self(a).set_basis_kind(val)
      end

   end

!  ===========================
!  Set whether data/info made
!  ===========================

   set_ANOs_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>self%ANOs_made)
   ! Generic set
   end

   set_spherical_atom_data_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>self%spherical_atom_data_made)
   ! Generic set
   end

   set_ANO_interpolators_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>self%ANO_interpolators_made)
   ! Generic set
   end

   set_interpolators_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>self%interpolators_made)
   ! Generic set
   end

   set_shell_info_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>self%shell_info_made)
   ! Generic set
   end

!  =============
!  Set positions
!  =============

   set_positions_from_vector(v)
   ! Set the positions from "v", a flat vector, where the xyz
   ! positions increment fastest
      v :: VEC{REAL}

   ENSURE(v.dim==3*.dim,"wrong size, v")

      k,i :: INT

      k = 0

      do i = 1,.dim
         self(i).position(1) = v(k+1)
         self(i).position(2) = v(k+2)
         self(i).position(3) = v(k+3)
         k = k + 3
      end

   end

   set_positions_to(mx)
   ! Set the positions from matrix "mx". The shape, (3xN) or (Nx3),
   ! determines how the coordinates are extracted.
      mx :: MAT{REAL}, IN

      a :: INT

      if      (mx.dim1==3 AND mx.dim2==.dim) then

         do a = 1,.dim
            self(a).set_position(mx(:,a))
         end

      else if (mx.dim1==.dim AND mx.dim2==3) then

         do a = 1,.dim
            self(a).set_position(mx(a,:))
         end

      else

         DIE("incorrectly sized geometry array")

      end

   end

   set_positions_and_errors_to(mx,me)
   ! Set the positions and errors from matrix "mx" and "me".
   ! The shape, (3xN) or (Nx3), determines how the coordinates
   ! are extracted.
      mx,me :: MAT{REAL}, IN

   ENSURE(mx.is_same_shape_as(me),"matrices are not the same shape")

      a :: INT

      if      (mx.dim1==3 AND mx.dim2==.dim) then

         do a = 1,.dim
            self(a).set_position_and_error(mx(:,a),me(:,a))
         end

      else if (mx.dim1==.dim AND mx.dim2==3) then

         do a = 1,.dim
            self(a).set_position_and_error(mx(a,:),me(a,:))
         end

      else

         DIE("incorrectly sized geometry array")

      end

   end

   set_coordinates_to(mx)
   ! Set the positions from matrix "mx". The shape, (3xN) or (Nx3),
   ! determines how the coordinates are extracted.
      mx :: MAT{REAL}, IN
      .set_positions_to(mx)
   end

!  ====================
!  Set site occupancies
!  ====================

   set_site_occupancies(val)
   ! Generic set
      val :: VEC{REAL}, IN

   ENSURE(val.dim==.dim,"wrong size for occupancies")

      a :: INT

      do a = 1,.dim
         self(a).set_site_occupancy(val(a))
      end

   end

!  ===============
!  Set axis system
!  ===============

   set_axis_system(val)
   ! Generic set
      val :: STR

      a :: INT

      do a = 1,.dim
         self(a).set_axis_system(val)
      end

   end

   set_ADP_axis_system(val)
   ! Generic set
      val :: STR

      a :: INT

      do a = 1,.dim
         self(a).set_ADP_axis_system(val)
      end

   end

!  ============
!  pADP/ADP set
!  ============

   set_ADP_tensor(val)
   ! Generic set
      val :: REAL

      a :: INT

      do a = 1,.dim
         self(a).set_ADP_tensor(val)
      end

   end

! Set U_iso

   set_isotropic_H_ADP
   ! Set the isotropuc hydrogen ADPs

      a :: INT

      do a = 1,.dim
         if (self(a).atomic_number==1) then
            self(a).set_isotropic_ADP
         end
      end

   end

   set_U_iso(val)
   ! Generic set
      val :: REAL, IN

      a :: INT

      do a = 1,.dim
         self(a).set_U_iso(val)
      end

   end

   set_U_iso(val)
   ! Generic set
      val :: VEC{REAL}, IN

   ENSURE(val.dim==.dim,"wrong size for occupancies")

      a :: INT

      do a = 1,.dim
         self(a).set_U_iso(val(a))
      end

   end

! Reset pADPs

   reset_pADPs_and_errors(dim) ::: leaky
   ! Allocate the positional-ADP parameters to a set size "dim".
   ! NOTE: assigning 4th order tags implies 3rd order.
      dim :: INT, IN

      n,a :: INT

      ! Make sure at least 9 long.
      n = max(dim,9)

      ! Reset each pADP
      do a = 1,.dim
         self(a).reset_pADPs_and_errors(n)
      end

   end

   reset_pADPs_and_errors(anharm3_tags,anharm4_tags) ::: leaky
   ! Allocate the positional-ADP parameters based on the given tags.
   ! NOTE: assigning 4th order tags implies 3rd order.
      self :: PTR
      anharm3_tags,anharm4_tags :: VEC{STR}*

      t,a :: INT
      tag :: STR

      ! Find the 4th-order tags, resize pADP_vector, and set to 0
      ! If the atoms are already fourth order do nothing.
      if (anharm4_tags.created) then

         do t = 1,anharm4_tags.dim
            tag = anharm4_tags(t)
            a   = self(:).tag.index_of(tag)
            DIE_IF(a==0,"no atom for 4th-order tag: "//trim(tag))
            self(a).reset_pADPs_and_errors(34)
         end

      end

      ! Find the 3rd-order tags, resize pADP_vector, and set to 0
      ! If they were already 3rd or 4th order, do nothing
      if (anharm3_tags.created) then

         do t = 1,anharm3_tags.dim
            tag = anharm3_tags(t)
            a   = self(:).tag.index_of(tag)
            DIE_IF(a==0,"no atom for 3rd-order tag: "//trim(tag))
            self(a).reset_pADPs_and_errors(19)
         end

      end

      ! Make sure at least 9 long.
      do a = 1,.dim
         self(a).reset_pADPs_and_errors(9)
      end

   end

! Set pADPs

   set_pADP_vector_to(X) ::: leaky
   ! Set the pADP vector from vector "X".
   ! NOTE: positions and ADP_tensors are set!
      X :: VEC{REAL}, IN

   DIE_IF(X.dim/=.no_of_pADPs,"wrong size, X")

      a,f,l :: INT

      l = 0
      do a = 1,.dim

         ! Limits
         f = l + 1
         l = l + self(a).no_of_pADPs

         ! Leaky
         self(a).set_pADP_vector_to(X(f:l))

      end

   end

   set_pADP_errors_to(dX)
   ! Set the pADP errors from vector "dX".
      dX :: VEC{REAL}, IN

   DIE_IF(dX.dim/=.no_of_pADPs,"wrong size, dX")

      a,f,l :: INT

      l = 0
      do a = 1,.dim

         ! Limits
         f = l + 1
         l = l + self(a).no_of_pADPs

         ! Not leaky
         self(a).set_pADP_errors_to(dX(f:l))

      end

   end

!  ============
!  pADP/ADP put
!  ============

   put_pADP_vector_to(X,fac)
   ! Put the whole pADP vector into vector "X".
   ! If present, include length-conversion factor "fac".
      self :: IN
      X :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(X.dim/=.no_of_pADPs,"wrong size, X")

      a,f,l :: INT

      l = 0
      do a = 1,.dim

         ! Limits
         f = l + 1
         l = l + self(a).no_of_pADPs

         ! Set
         self(a).put_pADP_vector_to(X(f:l),fac)

      end

   end

   put_pos_vector_to(X,fac)
   ! Put the position vector into matrix "X".
   ! If present, include length-conversion factor "fac".
      self :: IN
      X :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(X.dim1/=.dim,"wrong size, X")
   DIE_IF(X.dim2/=3   ,"wrong size, X")

      a :: INT

      do a = 1,.dim
         self(a).put_pos_vector_to(X(a,:),fac)
      end

   end

   put_pADP2_vector_to(X,fac)
   ! Put the second-order pADP vector into matrix "X".
   ! If present, include length-conversion factor "fac".
      self :: IN
      X :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(X.dim1/=.dim,"wrong size, X")
   DIE_IF(X.dim2/=9   ,"wrong size, X")

      a :: INT

      do a = 1,.dim
         self(a).put_pADP2_vector_to(X(a,:),fac)
      end

   end

   put_ADP2_vector_to(U,fac)
   ! Put the second-order ADP parameters into vector "U".
   ! If present, include length conversion factor "fac".
      self :: IN
      U :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(U.dim/=6*.dim,"wrong size, U")

      a,f,l :: INT

      l = 0
      do a = 1,.dim
         f = l + 1
         l = l + 6
         self(a).put_ADP2_vector_to(U(f:l),fac)
      end

   end

   put_ADP2_vector_to(U,fac)
   ! Put the second-order ADP vector into matrix "U".
   ! If present, include length-conversion factor "fac".
      self :: IN
      U :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(U.dim1/=.dim,"wrong size, U")
   DIE_IF(U.dim2/=6   ,"wrong size, U")

      a :: INT

      do a = 1,.dim
         self(a).put_ADP2_vector_to(U(a,:),fac)
      end

   end

   put_ADP3_vector_to(U,fac)
   ! Put the ADP3 parameters into vector "U".
   ! If present, include length conversion factor "fac".
      self :: IN
      U :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(U.dim/=.no_of_ADP3s,"wrong size, X")

      a,f,l :: INT

      l = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP3s_and_errors) cycle

         ! Set ADP3's
         f = l + 1
         l = l + 10
         self(a).put_ADP3_vector_to(U(f:l),fac)

      end

   end

   put_ADP3_vector_to(U,fac)
   ! Put the ADP3 parameters into matrix "U".
   ! If present, include length conversion factor "fac".
      self :: IN
      U :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(U.dim1/=.no_of_ADP3_atoms,"wrong size, U")
   DIE_IF(U.dim2/=10               ,"wrong size, U")

      a,i :: INT

      i = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP3s_and_errors) cycle

         ! Set ADP3's
         i = i + 1
         self(a).put_ADP3_vector_to(U(i,:),fac)

      end

   end

   put_ADP4_vector_to(U,fac)
   ! Put the ADP4 parameters into vector "U".
   ! If present, include length conversion factor "fac".
      self :: IN
      U :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(U.dim/=.no_of_ADP4s,"wrong size, X")

      a,f,l :: INT

      l = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP4s_and_errors) cycle

         ! Set ADP4's
         f = l + 1
         l = l + 15
         self(a).put_ADP4_vector_to(U(f:l),fac)

      end

   end

   put_ADP4_vector_to(U,fac)
   ! Put the ADP4 parameters into matrix "U".
   ! If present, include length conversion factor "fac".
      self :: IN
      U :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(U.dim1/=.no_of_ADP4_atoms,"wrong size, U")
   DIE_IF(U.dim2/=15               ,"wrong size, U")

      a,i :: INT

      i = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP4s_and_errors) cycle

         ! Set ADP4's
         i = i + 1
         self(a).put_ADP4_vector_to(U(i,:),fac)

      end

   end

! Put pADPx atom list

   put_ADP3_atom_list_to(list)
   ! Put the ADP3 atom list to "list".
      self :: IN
      list :: VEC{INT}, OUT

   DIE_IF(list.dim/=.no_of_ADP3_atoms,"wrong size, list")

      a,i :: INT

      i = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP3s_and_errors) cycle

         ! List of atoms
         i = i + 1
         list(i) = a

      end

   end

   put_ADP4_atom_list_to(list)
   ! Put the ADP4 atom list to "list".
      self :: IN
      list :: VEC{INT}, OUT

   DIE_IF(list.dim/=.no_of_ADP4_atoms,"wrong size, list")

      a,i :: INT

      i = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP4s_and_errors) cycle

         ! List of atoms
         i = i + 1
         list(i) = a

      end

   end

! Put pADP errors

   put_pADP_errors_to(dX,fac)
   ! Put all the pADP errors into vector "dX".
   ! If present, include length-conversion factor "fac".
      self :: IN
      dX :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(dX.dim/=.no_of_pADPs,"wrong size, dX")

      a,f,l :: INT

      l = 0
      do a = 1,.dim
         f = l + 1
         l = l + self(a).no_of_pADPs
         self(a).put_pADP_errors_to(dX(f:l),fac)
      end

   end

   put_pos_errors_to(dX,fac)
   ! Put the position errors into matrix "dX".
   ! If present, include length conversion factor "fac".
      self :: IN
      dX :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(dX.dim1/=.dim,"wrong size, dX")
   DIE_IF(dX.dim2/=3   ,"wrong size, dX")

      a :: INT

      do a = 1,.dim
         self(a).put_pos_errors_to(dX(a,:),fac)
      end

   end

   put_pADP2_errors_to(dX,fac)
   ! Put the pADP errors into matrix "dX".
   ! If present, include length conversion factor "fac".
      self :: IN
      dX :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(dX.dim1/=.dim,"wrong size, dX")
   DIE_IF(dX.dim2/=9   ,"wrong size, dX")

      a :: INT

      do a = 1,.dim
         self(a).put_pADP2_errors_to(dX(a,:),fac)
      end

   end

   put_ADP2_errors_to(dU,fac)
   ! Put the ADP2 errors into vector "dU".
   ! If present, include length-conversion factor "fac".
      self :: IN
      dU :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(dU.dim/=6*.dim,"wrong size, dU")

      a,f,l :: INT

      l = 0
      do a = 1,.dim
         f = l + 1
         l = l + 6
         self(a).put_ADP2_errors_to(dU(f:l),fac)
      end

   end

   put_ADP2_errors_to(dU,fac)
   ! Put the ADP2 errors into matrix "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU  :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(dU.dim1/=.dim,"wrong size, dU")
   DIE_IF(dU.dim2/=6   ,"wrong size, dU")

      a :: INT

      do a = 1,.dim
         self(a).put_ADP2_errors_to(dU(a,:),fac)
      end

   end

   put_ADP3_errors_to(dU,fac)
   ! Put the ADP3 errors into vector "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(dU.dim/=.no_of_ADP3s,"wrong size, dU")

      a,f,l :: INT

      l = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP3s_and_errors) cycle

         ! Set ADP3's
         f = l + 1
         l = l + 10
         self(a).put_ADP3_errors_to(dU(f:l),fac)

      end

   end

   put_ADP3_errors_to(dU,fac)
   ! Put the ADP3 errors into matrix "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(dU.dim1/=.no_of_ADP3_atoms,"wrong size, dU")
   DIE_IF(dU.dim2/=10               ,"wrong size, U")

      a,i :: INT

      i = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP3s_and_errors) cycle

         ! Set ADP3's
         i = i + 1
         self(a).put_ADP3_errors_to(dU(i,:),fac)

      end

   end

   put_ADP4_errors_to(dU,fac)
   ! Put the ADP4 errors into vector "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(dU.dim/=.no_of_ADP4s,"wrong size, dU")

      a,f,l :: INT

      l = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP4s_and_errors) cycle

         ! Set ADP4's
         f = l + 1
         l = l + 10
         self(a).put_ADP4_errors_to(dU(f:l),fac)

      end

   end

   put_ADP4_errors_to(dU,fac)
   ! Put the ADP4 errors into matrix "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(dU.dim1/=.no_of_ADP4_atoms,"wrong size, dU")
   DIE_IF(dU.dim2/=15               ,"wrong size, dU")

      a,i :: INT

      i = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP4s_and_errors) cycle

         ! Set ADP4's
         i = i + 1
         self(a).put_ADP4_errors_to(dU(i,:),fac)

      end

   end

! Put pADP labels

   put_position_labels_to(Xc)
   ! Put only the position labels into matrix "Xc".
      self :: IN
      Xc :: VEC{STR}(3), OUT

      i :: INT

      do i = 1,3
         Xc(i) = self(1).pADP_label(i)
      end

   end

   put_pADP2_labels_to(Xc)
   ! Put only the positions and ADP2 labels into matrix "Xc".
      self :: IN
      Xc :: VEC{STR}(9), OUT

      i :: INT

      do i = 1,9
         Xc(i) = self(1).pADP_label(i)
      end

   end

   put_ADP2_labels_to(Uc)
   ! Put the (second order) ADP labels into matrix "Uc".
      self :: IN
      Uc :: VEC{STR}(6), OUT

      i :: INT

      do i = 1,6
         Uc(i) = self(1).ADP_label(i)
      end

   end

   put_ADP3_labels_to(Uc)
   ! Put the ADP3 labels into matrix "Uc".
      self :: IN
      Uc :: VEC{STR}(10), OUT

      i :: INT

      do i = 1,10
         Uc(i) = self(1).ADP3_label(i)
      end

   end

   put_ADP4_labels_to(Uc)
   ! Put the ADP4 labels into matrix "Uc".
      self :: IN
      Uc :: VEC{STR}(15), OUT

      i :: INT

      do i = 1,15
         Uc(i) = self(1).ADP4_label(i)
      end

   end

!  ===============
!  Coordinate info
!  ===============

   coordinates_ptr(skip_dummies) result (res) ::: leaky
   ! Create the 3 x .dim coordinate matrix pointer
      self :: IN
      skip_dummies :: BIN, IN, optional
      res :: MAT{REAL}*

      n_atom :: INT
      skip :: BIN

      skip = FALSE
      if (present(skip_dummies)) skip = skip_dummies

      if (skip) then
         n_atom = .no_of_nondummy_atoms
         res.create(3,n_atom)
         .put_coordinates_to(res,positions_as_rows=FALSE,skip_dummies=TRUE)
      else
         res.create(3,.dim)
         .put_coordinates_to(res,positions_as_rows=FALSE)
      end

   end

   put_coordinates_to(mx,positions_as_rows,skip_dummies) ::: PURE
   ! Put the atom coordinates in a matrix "mx".
   ! If put_coordinates_as_rows=TRUE  then "mx" is dim x 3
   ! If put_coordinates_as_rows=FALSE then "mx" is 3 x dim
   ! If skip_dummies=FALSE then dim = .dim1 (default)
   ! If skip_dummies=TRUE  then dim = .no_of_nondummy_atoms
      self :: IN
      mx :: MAT{REAL}, OUT
      positions_as_rows :: BIN, IN
      skip_dummies :: BIN, optional, IN

      i,a :: INT
      skip :: BIN

      skip = FALSE
      if (present(skip_dummies)) skip = skip_dummies

      ! Put all atoms
      if (NOT skip) then

         if (positions_as_rows) then

            ENSURE(mx.dim1==.dim AND mx.dim2==3,"wrong shape, mx")

            do a = 1,.dim
               mx(a,:) = self(a).position
            end

         else

            ENSURE(mx.dim2==.dim AND mx.dim1==3,"wrong shape, mx")

            do a = 1,.dim
               mx(:,a) = self(a).position
            end

         end

      ! Put non-dummy atoms
      else

         if (positions_as_rows) then

            ENSURE(mx.dim1==.no_of_nondummy_atoms AND mx.dim2==3,"wrong shape, mx")

            i = 0
            do a = 1,.dim
               if (self(a).is_a_dummy_atom) cycle
               i = i + 1
               mx(i,:) = self(a).position
            end

         else

            ENSURE(mx.dim2==.no_of_nondummy_atoms AND mx.dim1==3,"wrong shape, mx")

            i = 0
            do a = 1,.dim
               if (self(a).is_a_dummy_atom) cycle
               i = i + 1
               mx(:,i) = self(a).position
            end

         end

      end

   end

   coordinate_vector result (res)
   ! Return the coordinates as a flat vector "res" where the xyz
   ! positions increment fastest, useful for optimisations
      self :: IN
      res :: VEC{REAL}(3*.dim)
      .put_coordinate_vector_to(res)
   end

   put_coordinate_vector_to(v)
   ! Put the coordinates as a flat vector in "v" where the xyz
   ! positions increment fastest, useful for optimisations
      self :: IN
      v :: VEC{REAL}, OUT

   ENSURE(v.dim==3*.dim,"wrong size, v")

      k,i :: INT

      k = 0
      do i = 1,.dim

        v(k+1) = self(i).position(1)
        v(k+2) = self(i).position(2)
        v(k+3) = self(i).position(3)
        k = k + 3
      end

   end

!  ========
!  Finalize
!  ========

   update
   ! Update/finalize, as far as possible.

      ! Update the labels?
      .update_labels

      ! Make atom kinds/unique atoms
      ! Should we always set the kinds?
      .set_kinds

      ! Set groups
      ! Probs here? --dylan 5/14
      if (any(self(:).group==0)) .set_connected_groups

   end

   update_labels ::: private
   ! Update the labels and/or tags.
   ! NOTE: Only update the labels if the label data are not
   ! unique, so as to preserve previous unique labels (and
   ! hopefully kinds) which can happen if a subset of a
   ! processed atom list is being updated.
   ! NOTE: It is assumed that is you set a different label
   ! you really mean that the atom is a different kind.

      unique_labels,unique_tags :: BIN

      ! Unique labels?
      unique_labels = .has_unique_labels
      unique_tags   = .has_unique_tags

      ! Set unique labels/tags
      if (unique_labels) then

         ! Set unique tags from labels
         if (NOT unique_tags) self(:)%tag = self(:)%label

      else ! not unique labels

         ! Set unique tags if needed
         if (NOT unique_tags) .set_unique_tags

         ! Set labels from tags
         self(:)%label = self(:)%tag

      end

   end

!  =======================
!  List-based I/O Routines
!  =======================

   read_list_keywords ::: get_from(VEC{OBJECT}), recursive, leaky
   ! Read in and process list-based keywords from "stdin". List-based keywords
   ! are those that are intended to apply to each individual element of the list
   ! through a list of "keys" stored in the associated list-element type module.
   ! NOTE: this routine will create the list, if required.
   end

   process_list_keyword(keyword) ::: get_from(VEC{OBJECT}), leaky
   ! Process a list-type "keyword", common to all list-type objects.
   end

   read_data ::: get_from(VEC{OBJECT}), leaky
   ! Repeatedly process the "keys" to read in the data list.
   ! Opening and closing braces are needed.
   end

   read_data_sans_braces ::: get_from(VEC{OBJECT}), leaky
   ! Repeatedly process the "keys" to read in the data list.
   ! Opening and closing braces are not needed.
   end

   data_length result (length) ::: get_from(VEC{OBJECT})
   ! Read ahead in stdin to get the "length" of the data list, i.e. the number
   ! of data items in the list. The data must begin with the first data item,
   ! *not* a "{" symbol.  The order of data items comprising the list is given
   ! by keys defined in the associated list-element type module. The data list
   ! must be terminated by a "}" symbol.
   end

   read_altered_data ::: get_from(VEC{OBJECT}), leaky
   ! Read in a sublist of the complete list, and alter the data for that
   ! sublist.  The order of the data items in the sublist is given by the "keys"
   ! defined in the associated list-element type module.
   end

   read_append_data ::: get_from(VEC{OBJECT}), leaky
   ! Read in a set of data to append to an existing set.
   end

   process_keys ::: get_from(VEC{OBJECT}), leaky
   ! Process the "keys" on each element of the list.
   end

   process_keys_once ::: get_from(VEC{OBJECT})
   ! Process the "keys" just once on an anonymous object. This is useful if the
   ! "keys" set global variables in the list module (e.g. the default order of
   ! lists *within* the list data) as opposed to being keys pertaining to each
   ! element of the list.
   end

   keys_created result (res) ::: get_from(VEC{OBJECT})
   ! Return TRUE if the list-element keys are created.
   end

   set_keys(the_keys) ::: get_from(VEC{OBJECT})
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(VEC{OBJECT}), leaky
   ! This is for destroying the "keys" externally.
   end

   read_keys ::: get_from(VEC{OBJECT}), leaky
   ! Read a new set of keys
   end

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input
   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file
   end

!  ===========================
!  Non-list based I/O routines
!  ===========================

   read_keywords ::: get_from(VEC{OBJECT}), recursive, leaky
   ! Read in and process normal (non list-type) keywords from "stdin".
   end

   process_keyword(keyword) ::: leaky
   ! Process a normal (non list-type) "keyword".
      self :: PTR
      keyword :: STR

      atom :: ATOM
      word :: STR

      word = keyword
      word.to_lower_case
      select case (word)
       case("}") ! do nothing.
       case("dump                          "); .dump("atoms")
       case("find_n_terminal_atoms         "); .find_N_terminal_atoms
       case("find_protein_backbone         "); .find_protein_backbone
       case("put                           "); .put
       case("put_bond_angle_table          "); .put_bond_angle_table
       case("put_bond_length_table         "); .put_bond_length_table
       case("put_coordinates               "); .put_coordinates
       case("put_coordinates_and_charges   "); .put_coordinates_and_charges
       case("put_invariom_labels           "); .put_invariom_labels
       case("put_smiles_invariom_labels    "); .put_smiles_invariom_labels
       case("put_mm_info                   "); .put_mm_info
       case("put_torsion_angle_table       "); .put_torsion_angle_table
       case("put_protein_sequence          "); .put_protein_sequence
       case("put_restraint_atoms           "); .put_restraint_atoms
       case("read_cif                      "); .read_CIF
       case("redirect                      "); .redirect
       case("revert                        "); .revert
       case("set_covalent_radii_ccdc       "); atom.set_covalent_radii_ccdc
       case("use_interpolators=            "); .read_use_interpolators
       case default;               UNKNOWN(word)
      end

   end

   read_CIF ::: leaky
   ! Read information from a Crystallographic Information File whose
   ! name is read from "stdin".
      self :: PTR
      cif :: CIF*
      found :: BIN
      name :: STR

      ! Read name frxd_geo_220K.cifom stdin
      stdin.read(name)

      ! Create CIF and find data
      cif.create(name)
      cif.open
      cif.find_crystal_data_block(found)
      ENSURE(found,"no crystal data block found")

      ! Read
      .read_CIF_atoms(cif)
      .read_CIF_ADPs(cif)

      ! Clean
      cif.destroy

   end

   read_CIF(name) ::: leaky
   ! Read information from a Crystallographic Information File "name"
      self :: PTR
      name :: STR, IN

      cif :: CIF*
      found :: BIN

      ! Create the CIF and find data
      cif.create(name)
      cif.open
      cif.find_crystal_data_block(found)
      ENSURE(found,"no crystal data block found")

      ! Read
      .read_CIF_atoms(cif)
      .read_CIF_ADPs(cif)

      ! Clean
      cif.destroy

   end

   read_CIF(cif) ::: leaky
   ! Read information from a Crystallographic Information File "name"
      self :: PTR
      cif :: CIF

      ! Read
      .read_CIF_atoms(cif)
      .read_CIF_ADPs(cif)

   end

   read_CIF_atoms(cif) ::: leaky
   ! Read information from a Crystallographic Information File, "cif".
   ! It is an error if there are no atom coordinates in the file.
   ! It is NOT an error if the ADP (thermal) tensors are missing.
   ! NOTE: self is destroyed and created from this file!
      self :: PTR
      cif :: CIF

      fs,fc,fd,fo,fl :: BIN
      IDs,labels,symbols :: VEC{STR}*
      disorder_group :: MAT{STR}*
      pos,err :: MAT{REAL}*
      dg :: STR
      i :: INT

      ! Read the site labels FIRST because these seem to correlate with
      ! the anisotropic U's.
      nullify(symbols)
      nullify(labels)
      cif.read_looped_item("_atom_site_type_symbol",symbols,fs)
      cif.read_looped_item("_atom_site_label",labels,fl)

      DIE_IF(NOT(fs OR fl),"no atom site label information in CIF file")

      ! Destroy the old atom list (if there)
      .destroy

      ! Create the new atom list
      if (symbols.created) then
         .create(symbols.dim)
         .set_atom_data_from_labels(symbols)     ! For Z's
         if (labels.created) .set_labels(labels) ! For U's
      else if (labels.created) then
         .create(labels.dim)
         .set_atom_data_from_labels(labels)      ! This may not work
      end
      labels.destroy
      symbols.destroy

      ! Read the site coordinates, and possibly occupancies
      cif.find_looped_item("_atom_site_occupancy",fo)
      if (fo) then
         IDs.create(4)
         IDs = ["_atom_site_fract_x  ", &
                "_atom_site_fract_y  ", &
                "_atom_site_fract_z  ", &
                "_atom_site_occupancy"]
         cif.read_looped_items(IDs,pos,err,found=fc)
      else
         IDs.create(3)
         IDs = ["_atom_site_fract_x  ", &
                "_atom_site_fract_y  ", &
                "_atom_site_fract_z  "]
         cif.read_looped_items(IDs,pos,err,found=fc)
      end
      IDs.destroy

      DIE_IF(NOT fc,"no atom coordinate information in CIF file")

      ! Assign the positions and errors -- including pADP_vector.
      .set_axis_system("crystal")
      .reset_pADPs_and_errors(9)
      .set_positions_and_errors_to(pos(1:3,:),err(1:3,:))
      if (fo) .set_site_occupancies(pos(4,:))
      err.destroy
      pos.destroy

      ! Read the disorder, group if there
      cif.find_looped_item("_atom_site_disorder_group",fd)
      if (fd) then
         IDs.create(1)
         IDs = ["_atom_site_disorder_group"]
         cif.read_looped_items(IDs,disorder_group)
         ENSURE(disorder_group.dim2==.dim,"inconsistent # of _atom_site_disorder_groups")
         do i = 1,disorder_group.dim2
            dg = disorder_group(1,i)
            if      (dg==".")   then; self(i).set_site_disorder_group(0)
            else if (dg.is_int) then; self(i).set_site_disorder_group(dg.to_int)
            end
         end
         disorder_group.destroy
         IDs.destroy
      end

      ! Clean
      if (fl) labels.destroy
      IDs.destroy

      ! Update?
      .update

   end

   read_CIF_ADPs(cif) ::: leaky
   ! Read ADP information from the Crystallographic Information File, "cif".
   ! It is an error if there are no atom coordinates in the file.
   ! It is NOT an error if the ADP (thermal) tensors are missing.
   ! NOTE: self is destroyed and created from this file!
      self :: PTR
      cif :: CIF

   DIE_IF(self(:).label.no_of_unique_elements/=.dim,"for the ADP's, every site symbol must be distinct!")

      f3,f4,fi,fu,fl :: BIN
      IDs,labels :: VEC{STR}*
      i,ind :: INT
      U,dU :: MAT{REAL}*
      U_iso :: VEC{REAL}*
      fac :: REAL
      lab :: STR

      .detect_CIF_AADPs(cif,f3,f4)

      if (f4) then

         ! Read the U4's
         .detect_CIF_ADP4(cif,f4,IDs,labels)
         cif.read_looped_item(trim(cif.GC4_label)//"label",labels,fl)
         cif.read_looped_items(IDs,U,dU)

         ! Change U units & scale
         if (cif.GC_format=="u") then
            U.convert_from("angstrom^4") ! into bohr^n
            dU.convert_from("angstrom^4")
         end
         U  =  U/cif.GC4_scale_factor
         dU = dU/cif.GC4_scale_factor

         ! Match the labels and assign the ADP4 tensors
         do i = 1,labels.dim

            ! Find matching index "ind"
            ind = self(:).label.index_of(labels(i))
            DIE_IF(ind==0,"unmatching atom_site_anharm_GC_D_label, "//trim(labels(i)))

            ! Assign ADP and form
            self(ind).reset_pADPs_and_errors(34)
            self(ind).set_ADP4_vector_to(U(:,i))
            self(ind).set_ADP4_errors_to(dU(:,i))
            self(ind).set_ADPn_form(cif.GC_format)

         end

         ! Clean up
         U.destroy
         dU.destroy
         labels.destroy
         IDs.destroy

      end

      if (f3) then

         ! Read the U3's
         .detect_CIF_ADP3(cif,f3,IDs,labels)
         cif.read_looped_item(trim(cif.GC3_label)//"label",labels,fl)
         cif.read_looped_items(IDs,U,dU,found=fu)

         ! Change U units?
         if (cif.GC_format=="u") then
            U.convert_from("angstrom^3")
            dU.convert_from("angstrom^3")
         end
         U  =  U/cif.GC3_scale_factor
         dU = dU/cif.GC3_scale_factor

         ! Match the labels and assign the U3 tensors
         do i = 1,labels.dim

            ! Find matching index "ind"
            ind = self(:).label.index_of(labels(i))
            DIE_IF(ind==0,"unmatching atom_site_anharm_GC_C_label, "//trim(labels(i)))

            ! Assign ADP and form
            self(ind).reset_pADPs_and_errors(19)
            self(ind).set_ADP3_vector_to(U(:,i))
            self(ind).set_ADP3_errors_to(dU(:,i))
            self(ind).set_ADPn_form(cif.GC_format)

         end

         ! Clean up
         U.destroy
         dU.destroy
         labels.destroy
         IDs.destroy

      end

      ! Read the U_iso values if there =======
      cif.read_looped_item("_atom_site_U_iso_or_equiv",U_iso,found=fi)
      if (fi) then
         ! Change units if required
         if (cif.U_iso_is_B_iso) then
            fac = ONE/(EIGHT*PI*PI)
            U_iso = fac*U_iso
         end
         U_iso.convert_from("angstrom^2")
         .reset_pADPs_and_errors(9)
         .set_U_iso(U_iso)
         U_iso.destroy
      end

      ! Try to read U tensor if there =======
      IDs.create(6)
      do i = 1,6
         lab = self(1).ADP_label(i,form="underscore-123-repeated")
         IDs(i) = "_atom_site_aniso_"//trim(lab)
      end
      cif.read_looped_item("_atom_site_aniso_label",labels,fl)
      cif.read_looped_items(IDs,U,dU,found=fu)

      ! Read the ADP2s
      if (fl AND fu) then

         ! Change units if required
         if (cif.U_is_B) then
            fac = ONE/(EIGHT*PI*PI)
            U = fac*U
         else if (cif.U_is_beta) then
            DIE("U_is_beta option no longer supported")
         end

         ! Change U units to au^2
         U.convert_from("angstrom^2")
         dU.convert_from("angstrom^2")

         ! Match the anisotropic U labels and assign the U tensors
         do i = 1,labels.dim

            ! Find matching index "ind"
            ind = self(:).label.index_of(labels(i))
            DIE_IF(ind==0,"unmatching atom_site_aniso_label, "//trim(labels(i)))

            ! Assign ADP
            self(ind).reset_pADPs_and_errors(9)
            self(ind).set_ADP_tensor(U(:,i))
            self(ind).set_ADP2_errors_to(dU(:,i))

         end

      end

      ! Clean up
      if (fu) then
         U.destroy
         dU.destroy
      end
      if (fl) labels.destroy
      IDs.destroy

      ! Set the crystal axis system. For anharmonic ADPs (if any)
      ! the form "g" or "u" was already detected and set.
      .set_ADP_axis_system("crystal")

   end

   detect_CIF_AADPs(cif,f3,f4) ::: private
   ! Detect if the file has anharmonic ADPs (AADPs),
   ! either dimensionless "g" or cartesian dimensioned "u"
   ! Gram-Charlier coefficients. The cif.GC_format will be
   ! set to this value, accordingly.
      self :: IN
      cif :: CIF, INOUT
      f3,f4 :: BIN, OUT

      GC_format :: VEC{STR}(2) = ["g", "u"]
      fmt :: INT

      do fmt = 1,GC_format.dim

         ! Detect fmt
         cif.set_GC_format(GC_format(fmt))
         .detect_CIF_ADP4(cif,f4)
         .detect_CIF_ADP3(cif,f3)

         ! If fmt found exit
         if (f3 OR f4) exit

      end

   end

   detect_CIF_ADP3(cif,f3,IDs0,labels0) ::: private, leaky
   ! Detect if the file has ADP3s, using the current setting for
   ! the cif.GC_format, either dimensionless "g" or cartesian
   ! dimensioned "u". Optionally return the IDs and labels.
      self :: IN
      cif :: CIF, INOUT
      f3 :: BIN, OUT
      IDs0,labels0 :: VEC{STR}*, optional

      fu,fl :: BIN
      IDs,labels :: VEC{STR}*
      U,dU :: MAT{REAL}*
      lab :: STR
      i :: INT

      IDs.create(10)
      do i = 1,10
         lab = self(1).ADP3_index_label(i,form="underscore-123-repeated")
         IDs(i) = trim(cif.GC3_label)//trim(lab)
      end
      cif.read_looped_item(trim(cif.GC3_label)//"label",labels,fl)
      cif.read_looped_items(IDs,U,dU,found=fu)

      f3 = fu AND fl

      ! Save the tags? Or clean?
      if (present(IDs0) AND present(labels0)) then
         if (fl) labels0 => labels
         IDs0 => IDs
      else
         if (fl) labels.destroy
         IDs.destroy
      end

   end

   detect_CIF_ADP4(cif,f4,IDs0,labels0) ::: private, leaky
   ! Detect if the file has ADP4s, using the current setting for
   ! the cif.GC_format, either dimensionless "g" or cartesian
   ! dimensioned "u". Optionally return the IDs and labels.
      self :: IN
      cif :: CIF, INOUT
      f4 :: BIN, OUT
      IDs0,labels0 :: VEC{STR}*, optional

      fu,fl :: BIN
      IDs,labels :: VEC{STR}*
      U,dU :: MAT{REAL}*
      lab :: STR
      i :: INT

      IDs.create(15)
      do i = 1,15
         lab = self(1).ADP4_index_label(i,form="underscore-123-repeated")
         IDs(i) = trim(cif.GC4_label)//trim(lab)
      end
      cif.read_looped_item(trim(cif.GC4_label)//"label",labels,fl)
      cif.read_looped_items(IDs,U,dU,found=fu)

      f4 = fu AND fl

      ! Save the tags? Or clean?
      if (present(IDs0) AND present(labels0)) then
         if (fl) labels0 => labels
         IDs0 => IDs
      else
         if (fl) labels.destroy
         IDs.destroy
      end

   end

   read_use_interpolators
   ! Read whether to use interpolators for spherical atom densities
      self :: PTR
      use_interp :: BIN

      stdin.read(use_interp)

      if (.destroyed) return

      .set_use_interpolators(use_interp)

   end

!  =============
!  Resolve bases
!  =============

   resolve_bases(basis,suffix) ::: template
   ! Resolve the basis sets for each atom -- by pointer assigning its basis to
   ! the element in "basis" which matches either the atoms .basis_label, or else
   ! matches a label constructed in a standard way, by joining the atom chemical
   ! symbol with the ":suffix" string.
      basis :: VEC{BASIS?}*
      suffix :: STR, optional

      a :: INT

      do a = 1,.dim
         self(a).resolve_basis(basis,suffix)
      end

   end

   resolve_bases(basis,suffix) ::: get_from(VEC{ATOM}, BASIS?=>BASIS)
   ! Resolve the basis sets for each atom -- by pointer assigning its basis to
   ! the element in "basis" which matches either the atoms .basis_label, or else
   ! matches a label constructed in a standard way, by joining the atom chemical
   ! symbol with the ":suffix" string.
   end

   resolve_bases(basis,suffix) ::: get_from(VEC{ATOM}, BASIS?=>SLATERBASIS)
   ! Resolve the basis sets for each atom -- by pointer assigning its basis to
   ! the element in "basis" which matches either the atoms .basis_label, or else
   ! matches a label constructed in a standard way, by joining the atom chemical
   ! symbol with the ":suffix" string.
   end

   resolve_bases(basis,suffix) ::: get_from(VEC{ATOM}, BASIS?=>COPPENSBASIS)
   ! Resolve the basis sets for each atom -- by pointer assigning its basis to
   ! the element in "basis" which matches either the atoms .basis_label, or else
   ! matches a label constructed in a standard way, by joining the atom chemical
   ! symbol with the ":suffix" string.
   end

!  ===================
!  Axis system changes
!  ===================

   change_axis_system_to(axis_system,cell)
   ! Change the atom axis systems to the desired "axis_system".
   ! NOTE: Errors are *not* transformed since that needs covariances.
   !       The errors must be transformed outside this routine.
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN

      a :: INT

      do a = 1,.dim
         self(a).change_axis_system_to(axis_system,cell)
      end

   end

!  ===============
!  Change geometry
!  ===============

   extend_bond_lengths(z1,z2,factor)
   ! Uniformly extend the bond lengths between all BONDED atoms with atomic
   ! number "z1" and "z2" by a "factor". Only the coordinates of the atoms with
   ! atomic number "z2" are altered.
      z1,z2 :: INT, IN
      factor :: REAL, IN

      atom_kind :: VEC{INT}*
      n_kind,z1_pos,z2_pos,z1_kind,z2_kind,a1,a2 :: INT
      r :: VEC{REAL}(3)

      if (all(self(:).atomic_number/=z1) OR all(self(:).atomic_number/=z2)) return

      z1_pos = self(:).atomic_number.index_of_value(z1)
      z2_pos = self(:).atomic_number.index_of_value(z2)

      atom_kind.create(.dim)
      .make_atom_kind_list(atom_kind,n_kind)

      z1_kind = atom_kind(z1_pos)
      z2_kind = atom_kind(z2_pos)

      do a1 = z1_pos,.dim

         if (atom_kind(a1)/=z1_kind) cycle

         do a2 = z2_pos,.dim

            if (atom_kind(a2)/=z2_kind) cycle
            if (NOT .bonded(a1,a2)) cycle

            r = self(a2).position &
              - self(a1).position

            self(a2).set_position(self(a1).position + factor*r)

         end

      end

      atom_kind.destroy

   end

   set_bond_lengths(z1,z2,length)
   ! Uniformly set the bond lengths between all BONDED atoms with atomic number
   ! "z1" and "z2" to be "length". Only the coordinates of the atoms with atomic
   ! number "z2" are altered.
      z1,z2 :: INT, IN
      length :: REAL, IN

      atom_kind :: VEC{INT}*
      n_kind,z1_pos,z2_pos,z1_kind,z2_kind,a1,a2 :: INT
      r :: VEC{REAL}(3)

      if (all(self(:).atomic_number/=z1) OR all(self(:).atomic_number/=z2)) return

      z1_pos = self(:).atomic_number.index_of_value(z1)
      z2_pos = self(:).atomic_number.index_of_value(z2)

      atom_kind.create(.dim)
      .make_atom_kind_list(atom_kind,n_kind)

      z1_kind = atom_kind(z1_pos)
      z2_kind = atom_kind(z2_pos)

      do a1 = z1_pos,.dim

         if (atom_kind(a1)/=z1_kind) cycle

         do a2 = z2_pos,.dim

            if (atom_kind(a2)/=z2_kind) cycle
            if (NOT .bonded(a1,a2)) cycle

            r = self(a2).position &
              - self(a1).position
            r.normalise

            self(a2).set_position(self(a1).position + length*r)

         end

      end

      atom_kind.destroy

   end

!  ===================
!  Information methods
!  ===================

   no_of_dummy_atoms result (res) ::: pure
   ! Return the number of dummy atoms
      self :: IN
      res :: INT
      if (.dim==0) then
         res = 0
      else
         res = count(ATOM:is_a_dummy_atom(self))
      end
   end

   dummy_atoms result (ind) ::: pure
   ! Return the list of dummy atoms
      self :: IN
      ind :: VEC{INT}(.no_of_dummy_atoms)
      i :: INT

      if (.no_of_dummy_atoms==0) return

      i = 0
      ind = pack([(i, i=1,.dim)],mask=ATOM:is_a_dummy_atom(self))

   end

   no_of_nondummy_atoms result (res) ::: pure
   ! Return the number of non-dummy atoms
      self :: IN
      res :: INT
      if (.dim==0) then
         res = 0
      else
         res = count(ATOM:is_a_nondummy_atom(self))
      end
   end

   nondummy_atoms result (ind) ::: leaky
   ! Return TRUE if all atoms have unique labels
      self :: IN
      ind :: VEC{INT}(.no_of_nondummy_atoms)
      i :: INT

      if (.no_of_nondummy_atoms==0) return

      i = 0
      ind = pack([(i, i=1,.dim)],mask=ATOM:is_a_nondummy_atom(self))

   end

   no_of_atoms_with_bases result (res) ::: pure
   ! Return the number of atoms with bases
      self :: IN
      res :: INT
      res = count(ATOM:has_basis(self))
   end

   atoms_with_bases result (ind) ::: pure
   ! Return TRUE if all atoms have unique labels
      self :: IN
      ind :: VEC{INT}(.no_of_atoms_with_bases)
      i :: INT
      i = 0
      ind = pack([(i, i=1,.dim)],mask=ATOM:has_basis(self))
   end

   chemical_formula(with_spaces) result (res)
   ! Return the chemical formula for the molecule, as a string, in
   ! alphabetical order of elements
      with_spaces :: BIN, optional
      res :: STR

      a,na :: INT
      spaces :: BIN
      symbol :: VEC{STR}*

      ! Do we want spaces between the elements?
      spaces = FALSE
      if (present(with_spaces)) spaces = with_spaces

      ! Get alphabetical list of chemical symbols
      symbol.create(.dim)
      do a = 1,.dim
         symbol(a) = self(a).chemical_symbol
      end
      symbol.quick_sort

      ! Make the chemical symbol
      res = " "
      a = 1
      do
         na = count(symbol==symbol(a))
         if (spaces AND res/=" ") then; res = trim(res) // " " // trim(symbol(a))
         else;                          res = trim(res) //        trim(symbol(a))
         end
         if (na>1) &
         res = trim(res) // trim(na.to_str)
         a = a + na
         if (a>.dim) exit
      end

      ! Clean up
      symbol.destroy

   end

   molecular_weight result (res) ::: pure
   ! Return the molceular weight for this atomvec
      self :: IN
      res :: REAL

      a :: INT

      res = ZERO

      do a = 1,.dim
         res = res + self(a).mass
      end

   end

   get_mean_neutron_numbers(NN)
   ! Get the atom coordinates in a matrix object "coord"
      NN :: VEC{REAL}
       a :: INT
      do a = 1,.dim
         NN(a) = self(a).mean_neutron_number
      end
   end

   no_of_nonmetal_atoms result (res) ::: pure
   ! Return the number of non-dummy atoms
      self :: IN
      res :: INT
      res = count(ATOM:is_a_nonmetal(self))
   end

   no_of_metalloid_atoms result (res) ::: pure
   ! Return the number of non-dummy atoms
      self :: IN
      res :: INT
      res = count(ATOM:is_a_metalloid(self))
   end

   no_of_metal_atoms result (res) ::: pure
   ! Return the number of non-dummy atoms
      self :: IN
      res :: INT
      res = count(ATOM:is_a_metal(self))
   end

   list_of_metal_atoms result (res) ::: leaky
   ! Return the number of non-dummy atoms
      self :: IN
      res :: VEC{INT}*

      n,a,i :: INT

      n = .no_of_metal_atoms

      res.create(n)

      i = 0
      do a = 1,n
         if (NOT self(a).is_a_metal) cycle
         i = i + 1
         res(i) = a
      end

   end

!  =====================
!  Symbols, labels, tags
!  =====================

   unique_tags result (res) ::: leaky, PURE
   ! Return the unique tags
      self :: IN
      res :: VEC{STR}*

      res.create(.dim)
      res = self.tag

   end

   chemical_symbols result (res)
   ! Return an array of the chemical symbols for each atom
      res :: VEC{STR}(size(self))
      res = ATOM:chemical_symbol(self)
   end

   has_dummy_labels result (res)
   ! Return TRUE if any atom has a dummy charge labels
      self :: IN
      res :: BIN
      res = any(ATOM:has_a_dummy_label(self))
   end

! pADP's

   no_of_NPD_ADPs result (res)
   ! Return the number of non-positive definite ADPs
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         if (self(a).has_NPD_ADP) res = res + 1
      end

   end

   no_of_flat_ADPs result (res)
   ! Return the number of flat ADPs
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         if (self(a).has_flat_ADP) res = res + 1
      end

   end

   no_of_pADPs result (res) ::: pure
   ! Return the number of positional and ADP parameters.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).no_of_pADPs
      end

   end

   no_of_pADPs_up_to_atom(a) result (res)
   ! Return the no. of the pADPs up to but *not* including atom "a".
      a :: INT, IN
      res :: INT

   ENSURE(a>0,"a must be +ve")
   ENSURE(a<=.dim,"a too large")

      b,n :: INT

      res = 0
      do b = 1,a-1
         n = self(b).no_of_pADPs
         res = res + n
      end

   end

   max_no_of_pADPs_per_atom result (res) ::: pure
   ! Return the *maximum* number of pADP parameters per atom
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         res = max(res,self(a).no_of_pADPs)
      end

   end

   atom_for_pADP_index(par_index,last_index) result (res)
   ! Return the atom for the cumulative position-ADP index "par_index".
   ! Also treturn the cumulative index up to the previous atom.
      par_index :: INT, IN
      last_index :: INT, OUT, optional
      res :: INT

   ENSURE(par_index>0,"par_index must be +ve")
   ENSURE(par_index<=.no_of_pADPs,"par_index too large")

      a,n,l :: INT

      n = 0
      l = 0

      do a = 1,.dim

         n = self(a).no_of_pADPs
         l = l + n

         if (par_index>l) cycle

         exit

      end

      res = a
      if (present(last_index)) last_index = l - n

   end

   tag_pADP_label(par_index) result (res)
   ! Return the unique tag with the parameter (positional-ADP) label
   ! for the *cumulative* parameter index "par_index"
      par_index :: INT, IN
      res :: STR

      a,ind :: INT

      a   = .atom_for_pADP_index(par_index,ind)
      ind = par_index - ind

      res = self(a).tag_pADP_label(ind)

   end

   tag_pADP_labels result (res) ::: leaky
   ! Return *all* the tags and positional-ADP labels.
      res :: VEC{STR}*

      a,n,i,l,dim :: INT

      ! No. of parameters
      dim = .no_of_pADPs

      ! Leaky
      res.create(dim)

      l = 0

      ! Get the labels
      do a = 1,.dim

         n = self(a).no_of_pADPs

         do i = 1,n
            res(l+i) = self(a).tag_pADP_label(i)
         end

         l = l + n

      end

   end

   tag_pADP_labels(par_indices) result (res) ::: leaky
   ! Return the tag and positional-ADP parameter with  the indices
   ! "par_indices"
      par_indices :: VEC{INT}
      res :: VEC{STR}*

      i :: INT

      ! Create the label arrays (leaky)
      res.create(par_indices.dim)

      ! Get the labels
      do i = 1,par_indices.dim
         res(i) = .tag_pADP_label(par_indices(i))
      end

   end

! ADP's

   no_of_ADP3s result (res) ::: pure
   ! Return the number of ADP3 parameters.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         if (NOT self(a).has_ADP3s_and_errors) cycle
         res = res + 10
      end

   end

   no_of_ADP3_atoms result (res) ::: pure
   ! Return the number of atoms with ADP3 parameters.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         if (NOT self(a).has_ADP3s_and_errors) cycle
         res = res + 1
      end

   end

   no_of_ADP4s result (res) ::: pure
   ! Return the number of ADP4 parameters.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         if (NOT self(a).has_ADP4s_and_errors) cycle
         res = res + 15
      end

   end

   no_of_ADP4_atoms result (res) ::: pure
   ! Return the number of atoms with ADP4 parameters.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         if (NOT self(a).has_ADP4s_and_errors) cycle
         res = res + 1
      end

   end

!  ================
!  Nuclear energies
!  ================

   sum_of_nuclear_charges result (res)
   ! Return the sum of the nuclear_charges
   ! Note: dummy atoms may have non-zero nuclear charge
      res :: REAL
      res = VEC{REAL}:sum(self(:).nuclear_charge)
   end

   nuclear_repulsion_energy result (res)
   ! Return the nuclear repulsion energy.
      res :: REAL

      i,j :: INT
      qi,qj :: REAL
      r :: VEC{REAL}(3)


      res = ZERO
      do i = 1,.dim
         qi = self(i).nuclear_charge
         do j = 1,i-1
            qj = self(j).nuclear_charge
            r =  self(j).position - self(i).position
            res = res + qi*qj/sqrt(dot_product(r,r))
         end
      end

   end

   nuclear_repulsion_energy(atoms) result (res)
   ! Return the nuclear repulsion energy felt by the group of atoms "a" in
   ! the field of all the nuclei in "self"
      atoms :: VEC{INT}
      res :: REAL

      a,i,j :: INT
      qi,qj :: REAL
      r :: VEC{REAL}(3)

      res = ZERO

      do i = 1,atoms.dim
         a = atoms(i)
         qi = self(a).nuclear_charge
         do j = 1,.dim
            if (any(atoms==j)) cycle
            qj = self(j).nuclear_charge
            r =  self(j).position - self(a).position
            res = res + qi*qj/sqrt(dot_product(r,r))
         end
      end

      res = HALF*res ! only count half the interaction energy
      res = res + self(atoms).nuclear_repulsion_energy

   end

   nuclear_repulsion_energy(atoms,nuclei) result (res)
   ! Return the nuclear repulsion energy felt by the group of atoms "a" in
   ! the field of all the nuclei in "nuclei"
      atoms, nuclei :: VEC{INT}
      res :: REAL

      a, i,j,k, n_atoms, n_field :: INT
      qi,qj :: REAL
      r :: VEC{REAL}(3)


      res = ZERO
      n_atoms = size(atoms)
      n_field = size(nuclei)
      do i=1,n_atoms
         a = atoms(i)
         qi = self(a).nuclear_charge
         do k=1,n_field
            j = nuclei(k)
            if (any(atoms==j)) cycle
            qj = self(j).nuclear_charge
            r =  self(j).position - self(a).position
            res = res + qi*qj/sqrt(dot_product(r,r))
         end
      end
      res = res + self(atoms).nuclear_repulsion_energy

   end

!  ======================
!  Center of mass & shape
!  ======================

   center_of_mass result (res) ::: pure
   ! Return the center of mass
      self :: IN
      res :: VEC{REAL}(3)

      a :: INT
      mw :: REAL

      res = ZERO

      do a = 1,.dim
         res = res + self(a).position*self(a).mass
      end

      mw  = ONE/.molecular_weight
      res = res*mw

   end

   move_origin_to_center_of_mass
   ! Move the origin to the center of mass
      .translate_by(-.center_of_mass)
   end

   change_to_principal_axes
   ! Move the origin to the center of mass and change the coordinates to be with
   ! respect to the principal axes
      pm :: VEC{REAL}(3)
      pa :: MAT{REAL}(3,3)
      .translate_by(-.center_of_mass)
      .make_principal_moments(pm,pa)
      .change_coordinate_axes(pa)
   end

   change_to_principal_top_axes
   ! Move the origin to the center of mass and change the coordinates to be with
   ! respect to the principal top axes i.e. in the case of symmetric tops the
   ! last axis is the unique axes.
      self :: INOUT

      pm :: VEC{REAL}(3)
      pa :: MAT{REAL}(3,3)
      reorder :: BIN

      .translate_by(-.center_of_mass)
      .make_principal_moments(pm,pa,reorder)
      .change_coordinate_axes(pa)

   end

   change_coordinate_axes(axes)
   ! Change the coordinates of the atoms to be with respect to the columns of
   ! "axes", which must be an orthogonal matrix.
      axes :: MAT{REAL}(3,3)
      a :: INT
      do a = 1,.dim
         self(a).change_coordinate_axes(axes)
      end
   end

   displacement_mass_vector result (res) ::: pure
   ! Return the length 3*.dim mass vector used for weighting the
   ! cartesian force contant matrix
      self :: IN
      res :: VEC{REAL}(3*.dim)

      a,i,ia :: INT

      ia = 0
      do a = 1,.dim
      do i = 1,3
         ia = ia + 1
         res(ia) = self(a).mass
      end
      end

   end

   mass result (res) ::: pure
   ! Return the mass of the molecule
      self :: IN
      res :: REAL

      a :: INT

      res = ZERO

      do a = 1,.dim
         res = res + self(a).mass
      end

   end

   reduced_mass result(mu)
   ! Return the center of mass
      mu :: REAL
      a :: INT
      mu = ZERO
      do a = 1,.dim
         mu = mu + ONE / self(a).mass
      end
      mu = ONE/mu
   end

   make_inertia_tensor(it)
   ! Make the moment of inertia tensor wrt the center of mass
      it :: MAT{REAL}(3,3)
      m :: MAT{REAL}(3,3)
      com,r :: VEC{REAL}(3)
      trace :: REAL
      a :: INT
      com = .center_of_mass
      it = ZERO
      do a = 1,.dim
         r = self(a).position - com
         m = spread(r,dim=1,ncopies=3)*spread(r,dim=2,ncopies=3)
         m = self(a).mass * m
         trace = m.trace
         m = -m
         m.increment_diagonal_by(trace)
         it = it + m
      end
   end

   make_principal_moments(pm,pa,reorder)
   ! Make the principal moments "pm" and principal axes "pm" wrt the center of
   ! mass.  If "reorder" is present then the principal axes are made to be right
   ! handed. Also:
   ! - For sperical tops, the local x,y,z axes are the pricipal axes
   ! - For symmetric tops, the C axis is unique
   ! - For asymmetric tops, the pricipal axes are aligned close to the local
   !    x,y,z axes
      pm :: VEC{REAL}(3)
      pa :: MAT{REAL}(3,3)
      reorder :: BIN, optional

      pn :: VEC{REAL}(3)
      it :: MAT{REAL}(3,3)

      ! Make the inertia tensor and axes
      .make_inertia_tensor(it)
      it.solve_eigenproblem(pm,pa)

      ! Set small moments to zero
      if (NOT present(reorder)) return

      where (pm<TOL(6))
         pm = ZERO
      end

      ! Make principal axes close to x,y,z
      if (abs(pa(1,2)) > abs(pa(1,1))) then
         pa.swap_columns(1,2)
         pm.swap_elements(1,2)
      end
      if (abs(pa(1,3)) > abs(pa(1,1))) then
         pa.swap_columns(1,3)
         pm.swap_elements(1,3)
      end
      if (abs(pa(2,3)) > abs(pa(2,2))) then
         pa.swap_columns(2,3)
         pm.swap_elements(2,3)
      end

      ! Use normalised moments for now
      pn = pm/maxval(abs(pm))

      ! Spherical top? ... axes are x,y,z
      if (.is_spherical_top(pn)) then
            pa.to_unit_matrix
      ! Symmetric top? ... C axis is unique
      else if (.is_symmetric_top(pn)) then
         if (abs(pn(1)-pn(3)) < TOL(2)) then
            pa.swap_columns(2,3)
            pm.swap_elements(2,3)
         else if (abs(pn(2)-pn(3)) < TOL(2)) then
            pa.swap_columns(1,3)
            pm.swap_elements(1,3)
         end
      end

      ! Make positive diagonals
      if (pa(1,1)<ZERO AND pa(2,2)<ZERO) then
         pa(:,1) = -pa(:,1)
         pa(:,2) = -pa(:,2)
      end

      ! Ensure axes are right handed
      if (pa.determinant>ZERO) return

      ! Swap columns 1,2 if equal moments
      if (abs(pm(1)-pm(2)) < TOL(6)) then
         pm.swap_elements(1,2)
         pa.swap_columns(1,2)
      ! Swap columns 2,3 if equal moments
      else if (abs (pm(2)-pm(3)) < TOL(6)) then
         pm.swap_elements(2,3)
         pa.swap_columns(2,3)
      ! Reverse all C axis
      else
         pa(:,3) = -pa(:,3)
      end

   end

   make_shape_tensor(st)
   ! Make the shape tensor "st" wrt the center of atoms. This is the
   ! same as the moment of inertia tensor except that each atom is
   ! assumed to have unit mass.
      st :: MAT{REAL}(3,3)

      m :: MAT{REAL}(3,3)
      c,r :: VEC{REAL}(3)
      a :: INT

      c = .center_of_atoms
      st = ZERO
      do a = 1,.dim
         r = self(a).position - c
         m = spread(r,dim=1,ncopies=3)*spread(r,dim=2,ncopies=3)
         m.increment_diagonal_by(-m.trace)
         st = st - m
      end

   end

   make_shape_moments(sm,sa)
   ! Make the shape moments "sm" and principal shape axes "sa" wrt the
   ! center of atoms. The shape axes are the same as the principal
   ! moment of inertia axes except that each atom is assumed to have
   ! unit mass. The principal shape axes are made right handed.
      sm :: VEC{REAL}(3)
      sa :: MAT{REAL}(3,3)

      st :: MAT{REAL}(3,3)

      .make_shape_tensor(st)
      st.solve_eigenproblem(sm,sa)

      ! Make axes are close to x,y,z
      if (abs(sa(1,2)) > abs(sa(1,1))) then
         sa.swap_columns(1,2)
         sm.swap_elements(1,2)
      end
      if (abs(sa(1,3)) > abs(sa(1,1))) then
         sa.swap_columns(1,3)
         sm.swap_elements(1,3)
      end
      if (abs(sa(2,3)) > abs(sa(2,2))) then
         sa.swap_columns(2,3)
         sm.swap_elements(2,3)
      end

      ! Make axes +ve
      if (sa(1,1)<ZERO)        sa(:,1) = -sa(:,1)
      if (sa(2,2)<ZERO)        sa(:,2) = -sa(:,2)
      if (sa.determinant<ZERO) sa(:,3) = -sa(:,3)

   end

!  ===========
!  Shape tests
!  ===========

   is_linear(pm) result (res)
   ! Return TRUE if the geometry is linear.
   ! Needs principal moments of inertia "pm"
      res :: BIN
      pm :: VEC{REAL}(3), optional

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)

      if (present(pm)) then; mi = pm
      else;                  .make_principal_moments(mi,ma,reorder=TRUE)
      end

      res = any(mi==ZERO)

   end

   is_spherical_top(pm) result (res)
   ! Return TRUE if the geometry is a spherical top
   ! Needs principal moments of inertia "pm"
      res :: BIN
      pm :: VEC{REAL}(3), optional

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)

      if (present(pm)) then; mi = pm
      else;                  .make_principal_moments(mi,ma,reorder=TRUE)
      end

      res = .no_of_same_principal_moments(mi)==3

   end

   is_symmetric_top(pm) result (res)
   ! Return TRUE if the geometry is a symmetric top
   ! Needs principal moments of inertia "pm"
      res :: BIN
      pm :: VEC{REAL}(3), optional

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)

      if (present(pm)) then
         mi = pm
      else
         .make_principal_moments(mi,ma)
      end

      res = .no_of_same_principal_moments(mi)==1

   end

   is_prolate_top(pm) result (res)
   ! Return TRUE if the geometry is a prolate top
   ! Needs principal moments of inertia "pm" after alignment
      res :: BIN
      pm :: VEC{REAL}(3), optional

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)

      if (present(pm)) then; mi = pm
      else;                  .make_principal_moments(mi,ma,reorder=TRUE)
      end

      res = .is_symmetric_top(pm) AND (mi(3)<mi(1))

   end

   is_oblate_top(pm) result (res)
   ! Return TRUE if the geometry is a oblate top
   ! Needs principal moments of inertia "pm" after alignment
      res :: BIN
      pm :: VEC{REAL}(3), optional

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)

      if (present(pm)) then; mi = pm
      else;                  .make_principal_moments(mi,ma,reorder=TRUE)
      end

      res = .is_symmetric_top(pm) AND (mi(3)>mi(1))

   end

   is_asymmetric_top(pm) result (res)
   ! Return TRUE if the geometry is a asymmetric top
   ! Needs principal moments of inertia "pm"
      res :: BIN
      pm :: VEC{REAL}(3), optional

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)

      if (present(pm)) then; mi = pm
      else;                  .make_principal_moments(mi,ma,reorder=TRUE)
      end

      res = .no_of_same_principal_moments(mi)==0

   end

   no_of_same_principal_moments(pm) result(same)
   ! Return the number of "same" pairs of principal moments of inertia.
   ! Needs principal moments of inertia "pm"
      same :: INT
      pm :: VEC{REAL}(3), optional

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)
      i,j :: INT

      if (present(pm)) then; mi = pm
      else;                  .make_principal_moments(mi,ma,reorder=TRUE)
      end

      same = 0
      do i = 1,3
      do j = 1,i-1
         if (abs(mi(i)-mi(j))<=TOL(2)) then
            same = same + 1
         end
      end
      end

   end

!  =============
!  Box centering
!  =============

   center_of_atoms(axes) result(center)
   ! Return the centroid of the atom positions in "center". If "axes" is present
   ! then the "center" is expressed with respect to the new "axes", where the
   ! columns of "axes" are the coordinates of the new axes in terms of the old.
      center :: VEC{REAL}(3)
      axes :: MAT{REAL}(3,3), optional

      a :: INT
      c :: VEC{REAL}(3)

      center = ZERO
      do a = 1,.dim
         center = center + self(a).position
      end
      center = center/.dim

      if (present(axes)) then
         c = center
         center.to_product_of(axes,c,transpose_a=TRUE)
      end

   end

   move_origin_to_center_of_atoms
   ! Move the origin to the center of atoms
      .translate_by(-.center_of_atoms)
   end

   bounding_cube_width result(width)
   ! Return "width" which is a width of a side of a cube in which the molecule
   ! nicely sits.
   ! Suitable for generating plot widths.
      width :: REAL
      center,dist :: VEC{REAL}(3)
      length :: REAL
      a :: INT
      width = ZERO
      center = .center_of_atoms
      do a = 1,.dim
         dist = self(a).position - center
         length = dist.norm + self(a).bragg_slater_radius*BOHR_PER_ANGSTROM*TWO
         length = max(length, dist.norm*TWO)
         width = max(width,length)
      end
      width = TWO*width
   end

   bounding_box_widths(axes) result(box)
   ! Return "box" which are three widths of a side of a box in which
   ! the molecule nicely sits. If "axes" is present, the "box"
   ! coordinates are expressed in terms of the new "axes", where the
   ! columns of "axes" are the coordinates of the new axes in terms of
   ! the old. These "axes" may be (typically) the principal moment
   ! axes. This routine is suitable for generating plot widths.
      axes :: MAT{REAL}(3,3), optional
      box :: VEC{REAL}(3)

      center,v,dist :: VEC{REAL}(3)
      a :: INT

      box = ZERO
      center = .center_of_atoms

      do a = 1,.dim

         ! Position relative to center
         dist = self(a).position - center

         ! Position in new axis system
         if (present(axes)) then
            v = dist
            dist.to_product_of(axes,v,transpose_a=TRUE)
         end

         ! Flip to +ve quadrant and add boundary
         dist = abs(dist)
         dist = dist + self(a).bragg_slater_radius*BOHR_PER_ANGSTROM*TWO

         ! Get box width
         box  = max(box,dist)

      end

      box = FOUR*box

   end

!  ===========================================
!  Presence/absence of features and properties
!  ===========================================

   has_sequence_numbers result (res)
   ! Return TRUE if any atom in the list has a non zero sequence number
      res :: BIN
      res = any(self.residue_sequence_number > 1)
   end

   has_nonzero_position_errors result (res)
   ! Return TRUE if all atom have non-zero position errors
      res :: BIN
      i :: INT

      res = TRUE

      do i = 1,.dim
         if (REAL:is_zero(self(i).position_error.norm)) then
            res = FALSE
            exit
         end
      end

   end

   has_nonzero_ADP_tensors result (res)
   ! Return TRUE if any atom has a non-zero ADP tensor
      res :: BIN
      i :: INT

      res = FALSE

      do i = 1,.dim
         if (all(self(i).ADP_tensor==ZERO)) cycle
         res = TRUE
         exit
      end

   end

   has_nonzero_U_iso result (res)
   ! Return TRUE if any atom in the list has a non zero U_iso
      res :: BIN
      res = any(self.U_iso>ZERO)
   end

   has_nonzero_ADPs result (res)
   ! Return TRUE if any atom in the list has a non zero ADP tensor
   ! OR non zero isotropic thermal factor.
      res :: BIN
      res = .has_nonzero_ADP_tensors OR .has_nonzero_U_iso
   end

   has_nonzero_pos_errors result (res)
   ! Return TRUE if *any* atom has a non-zero position errors
      res :: BIN
      a :: INT

      res = FALSE
      do a = 1,.dim
         if (NOT self(a).has_pADPs_and_errors) cycle
         if (REAL:is_zero(self(a).pADP_errors(1:3).norm)) cycle
         res = TRUE
         exit
      end

   end

   has_nonzero_pADP2_errors result (res)
   ! Return TRUE if *any* atom has a non-zero pADP2 errors
      res :: BIN
      a :: INT

      res = FALSE
      do a = 1,.dim
         if (NOT self(a).has_pADPs_and_errors) cycle
         if (REAL:is_zero(self(a).pADP_errors(1:9).norm)) cycle
         res = TRUE
         exit
      end

   end

   has_nonzero_ADP3_errors result (res)
   ! Return TRUE if *any* atom has a non-zero pADP3 error
      res :: BIN
      a :: INT

      res = FALSE

      do a = 1,.dim
         if (NOT self(a).has_ADP3s_and_errors) cycle
         if (REAL:is_zero(self(a).pADP_errors(10:19).norm)) cycle
         res = TRUE
         exit
      end

   end

   has_nonzero_ADP4_errors result (res)
   ! Return TRUE if *any* atom has a non-zero ADP4 error
      res :: BIN
      a :: INT

      res = FALSE
      do a = 1,.dim
         if (NOT self(a).has_ADP4s_and_errors) cycle
         if (REAL:is_zero(self(a).pADP_errors(20:34).norm)) cycle
         res = TRUE
         exit
      end

   end

   has_any_ADP3s_and_errors result (res) ::: pure
   ! Return TRUE if there are *any* ADP3s
      self :: IN
      res :: BIN

      a :: INT

      res = FALSE

      do a = 1,.dim
         if (NOT self(a).has_ADP3s_and_errors) cycle
         res = TRUE
         exit
      end

   end

   has_any_ADP4s_and_errors result (res) ::: pure
   ! Return TRUE if there are *any* ADP4s
      self :: IN
      res :: BIN

      a :: INT

      res = FALSE

      do a = 1,.dim
         if (NOT self(a).has_ADP4s_and_errors) cycle
         res = TRUE
         exit
      end

   end

   has_residue_codes result (res)
   ! Return TRUE if any atom in the list has a residue names
      res :: BIN
      res = any(self(:).residue_code /= " " )
   end

   has_restraints result (res)
   ! Return TRUE if any atom in the list has a restrained position
   ! or restrained force constants
      res :: BIN
      res = any(self(:).restraining_force_constant/=ZERO)
   end

   has_dipoles result (has)
   ! Return TRUE if any of the atoms have dipoles
      self :: IN
      has :: BIN

      a :: INT

      has = FALSE

      do a = 1,.dim
         has = self(a).has_dipole
         if (has) exit
      end

   end

   has_polarisabilities result (has)
   ! Return TRUE if any of the atoms have polarisabilities
      self :: IN
      has :: BIN

      a :: INT

      has = FALSE

      do a = 1,.dim
         has = self(a).has_polarisability
         if (has) exit
      end

   end

!  ====================
!  ADP inquiry methods
!  ====================

   has_NPD_ADP result (res)
   ! Return TRUE if the ADP is non-zero and non-positive definite.
      self :: IN
      res :: VEC{BIN}(.dim)

      a :: INT

      do a = 1,.dim
         res(a) = self(a).has_NPD_ADP
      end

   end

   has_flat_ADP(ratio) result (res)
   ! Return TRUE if the ADP is flat i.e. the the max to
   ! the min eigenvalue is greater than "ratio" (or FOUR
   ! if not supplied).
      self :: IN
      ratio :: REAL, IN, optional
      res :: VEC{BIN}(.dim)

      a :: INT

      do a = 1,.dim
         res(a) = self(a).has_flat_ADP(ratio)
      end

   end

   ADP_principal_axis_ratio result (res)
   ! Return the actual max/min ADP principal axis ratio
   ! (or 1000 if the min eigenvalue is zero).
      self :: IN
      res :: VEC{REAL}(.dim)

      a :: INT

      do a = 1,.dim
         res(a) = self(a).ADP_principal_axis_ratio
      end

   end

!  ================
!  Bases and labels
!  ================

   has_unique_labels result (has)
   ! Return TRUE if all non-dummy atoms have unique labels.
   ! A dummy atom has zero charge, no basis and a dummy-type label.
      self :: IN
      has :: BIN


      unique_labels,unique_x_kind :: BIN
      dum :: VEC{INT}*
      n :: INT

      n = .no_of_nondummy_atoms

      if (n==0) then

         has = TRUE

      else

         dum.create(n)
         dum = .nondummy_atoms
         unique_labels = NOT self(dum).label.has_repetitions
         unique_x_kind =     self(dum).has_unique_xtal_kinds
         has = unique_labels AND unique_x_kind
         dum.destroy

      end

   end

   get_1st_repeated_labels(li,lj)
   ! Return the indices of the first repeated labels
   ! in "li" and "lj".
      self :: IN
      li,lj :: INT, OUT

      dum :: VEC{INT}*
      n :: INT

      n = .no_of_nondummy_atoms

      if (n==0) then

         li = 0
         lj = 0

      else

         dum.create(n)
         dum = .nondummy_atoms
         self(dum).label.get_1st_repetition(li,lj)
         dum.destroy

      end

   end

   has_unique_tags result (has)
   ! Return TRUE if all non-dummy atoms have unique tags.
   ! A dummy atom has zero charge, no basis and a dummy-type label.
      self :: IN
      has :: BIN

      dum :: VEC{INT}*
      n :: INT

      n = .no_of_nondummy_atoms

      if (.no_of_nondummy_atoms==0) then

         has = TRUE

      else

         dum.create(n)
         dum = .nondummy_atoms
         has = NOT self(dum).tag.has_repetitions AND NOT any(self(dum).tag==" ")
         dum.destroy

      end

   end

   has_unique_kinds result (has)
   ! Return TRUE if all atoms have unique kinds
      self :: IN
      has :: BIN
      has = NOT self(:).kind.has_repetitions
   end

   has_unique_xtal_kinds result (unq)
   ! Return TRUE if all atoms have unique *xtal* kinds
      self :: IN
      unq :: BIN

      a,b :: INT

      unq = TRUE

      do a = 2,.dim
      do b = 1,a-1

         if (NOT self(a).is_xtal_identical_to(self(b))) cycle

         unq = FALSE
         return

      end
      end

   end

   get_1st_repeated_xtal_kinds(ka,kb)
   ! Return the indices of the first repeated xtal kinds
   ! in "ka" and "kb".
      self :: IN
      ka,kb :: INT, OUT

      a,b :: INT

      ka = 0
      kb = 0

      do a = 2,.dim
      do b = 1,a-1

         if (NOT self(a).is_xtal_identical_to(self(b))) cycle

         ka = a
         kb = b
         return

      end
      end

   end

   has_all_bases result(has)
   ! Return TRUE if all atoms have a basis on one kind or another.
      self :: IN
      has :: BIN
      has = .has_all_gaussian_bases OR .has_all_slater_bases OR .has_all_coppens_bases
   end

   has_all_gaussian_bases result(has)
   ! Return TRUE if all atom gaussian basis data exists
      self :: IN
      has :: BIN
      a :: INT
      has = TRUE
      do a = 1,.dim
         has = self(a).basis.created
         if (NOT has) exit
      end
   end

   has_all_slater_bases result(has)
   ! Return TRUE if all atom slater basis data exists
      self :: IN
      has :: BIN
      a :: INT
      has = TRUE
      do a = 1,.dim
         has = self(a).slaterbasis.created
         if (NOT has) exit
      end
   end

   has_all_coppens_bases result(has)
   ! Return TRUE if all atom slater basis data exists
      self :: IN
      has :: BIN
      a :: INT
      has = TRUE
      do a = 1,.dim
         has = self(a).coppensbasis.created
         if (NOT has) exit
      end
   end

   has_all_density_data result(has)
   ! Return TRUE if all atoms have some kind of atom density data, either
   ! slaterbasis, coppensbasis or gausian ANO data. This routine does NOT check
   ! that they are all the same kind of data!
      self :: IN
      has :: BIN
      has = .has_all_slater_bases OR .has_all_coppens_bases OR .has_all_ANOs_made
   end

   basis_labels result (labels) ::: leaky
   ! Return a list of basis set "labels". Missing labels are returned blank.
      labels :: VEC{STR}*
      i :: INT
      labels.create(size(self))
      do i = 1,size(self)
         if (self(i).basis_label/=" ") then; labels(i) = self(i).basis_label
         else;                               labels(i) = " "
         end
      end
   end

   library_basis_labels(suffix) result (labels) ::: leaky
   ! Return a list of library basis set labels, the atoms element name with
   ! ":suffix" appended to it. Only a unique list of basis labels is returned.
      suffix :: STR
      labels :: VEC{STR}*
      i :: INT
      labels.create(.dim)
      do i = 1,.dim
         labels(i) = self(i).library_basis_label(suffix)
      end
      labels.remove_repetitions
   end

   library_basis_labels(Z_max,suffix) result (labels) ::: selfless, leaky
   ! Return a list of library basis set labels, for the atoms with
   ! atomic numbers up to "Z_max", with ":suffix" appended to it. Only
   ! a unique list of basis labels is returned.
      Z_max :: INT
      suffix :: STR
      labels :: VEC{STR}*
      Z :: INT
      labels.create(Z_max)
      do Z = 1,Z_max
         labels(Z) = ATOM:library_basis_label(Z,suffix)
      end
   end

!   library_basis_labels(suffix) result (labels) ::: leaky
!   ! Return a list of library basis set labels. The label is either the atoms
!   ! own .basis_label (if it contains the colon character, the indicator of a
!   ! library basis set), or else it is the atoms element name with ":suffix"
!   ! appended to it. Only a unique list of basis labels is returned.
!      suffix :: STR
!      labels :: VEC{STR}*
!      i :: INT
!      labels.create(size(self))
!      do i = 1,size(self)
!         if (self(i).basis_label.includes(":")) then
!            labels(i) = self(i).basis_label
!         else
!            labels(i) = self(i).library_basis_label(suffix)
!         end
!      end
!      labels.remove_repetitions
!   end

   minimum_basis_exponents result (res)
   ! Return the minimum exponent in the basis.
      res :: VEC{REAL}(.dim)
      i :: INT
      do i = 1,.dim
        res(i) = self(i).minimum_basis_exponent
      end
   end

   has_all_shell_info result (res)
   ! Return TRUE if all shell info is there for every atom.
      res :: BIN
      res = all(self(:).shell_info_made)
   end

!  ======================
!  ANOs and interpolators
!  ======================

   has_all_ANOs_made result (res)
   ! Return TRUE if the ANO data is made for every atom.
      res :: BIN
      res = all(self(:).ANOs_made)
   end

   has_all_ANO_matrices result (res)
   ! Return TRUE if the ANO data is made for every atom.
      res :: BIN

      a :: INT

      res = TRUE
      do a = 1,.dim
         res = self(a).has_ANO_matrices
         if (NOT res) exit
      end

   end

   has_all_spherical_atom_data result (res)
   ! Return TRUE if the per-atom interpolators are made for every atom.
      res :: BIN
      res = all(self(:).spherical_atom_data_made)
   end

!  =============
!  Interpolators
!  =============

   has_all_ANO_interpolators result (res)
   ! Return TRUE if the ANO interpolators are made for every atom.
      res :: BIN
      res = all(self(:).ANO_interpolators_made)
   end

   has_all_slater_interpolators result(has)
   ! Return TRUE if all atoms have slaterbases which have interpolators.
      self :: IN
      has :: BIN
      a :: INT
      has = TRUE
      do a = 1,.dim
         has = self(a).slaterbasis.created
         if (NOT has) exit
         has = self(a).slaterbasis.interpolator.created
         if (NOT has) exit
      end
   end

   has_all_coppens_interpolators result(has)
   ! Return TRUE if all atoms have coppensbases which have interpolators.
      self :: IN
      has :: BIN
      a :: INT
      has = TRUE
      do a = 1,.dim
         has = self(a).coppensbasis.created
         if (NOT has) exit
         has = self(a).coppensbasis.interpolator.created
         if (NOT has) exit
      end
   end

   has_all_interpolators result (res)
   ! Return TRUE if the per-atom interpolators are made for every atom.
      res :: BIN
      res = all(self(:).interpolators_made)
   end

   has_interpolators_any_kind result(has)
   ! Return TRUE if all atoms have slaterbases which have interpolators, or all
   ! atoms have coppensbases with interpolators.
      self :: IN
      has :: BIN
      has = .has_all_atom_interpolators OR .has_all_slater_interpolators OR .has_all_coppens_interpolators
   end

   has_all_atom_interpolators result(has)
   ! Return TRUE if all atoms have interpolators.
      self :: IN
      has :: BIN
      a :: INT
      has = TRUE
      do a = 1,.dim
         has = self(a).interpolator.created
         if (NOT has) exit
      end
   end

   max_interpolator_table_length(tol) result (res)
   ! Returns the maximum interpolator table length for a given table cutoff
   ! tolerance "tol".  This table length is used for setting the cluster radius,
   ! for calculations where the cluster size must be determined so that the
   ! Hirshfeld surface is accurate.
      tol,res :: REAL
      last :: REAL
      i :: INT
      res = ZERO
      select case (self(1).basis_kind)
         case ("slater")
            ENSURE(.has_all_slater_bases,"missing slater bases")
            do i = 1,.dim
               last = self(i).slaterbasis.interpolator_table_length(tol)
               res = max(res,last)
            end
         case ("coppens")
            ENSURE(.has_all_coppens_bases,"missing coppens bases")
            do i = 1,.dim
               last = self(i).coppensbasis.interpolator_table_length(tol)
               res = max(res,last)
            end
         case ("gaussian")
            ENSURE(.has_all_ANOs_made,"missing atom ANOs")
            do i = 1,.dim
               last = self(i).interpolator_table_length(tol)
               res = max(res,last)
            end
         case default
            UNKNOWN(self(1).basis_kind)
      end
   end

!  =================
!  Axes and disorder
!  =================

   has_cartesian_axes result (res)
   ! Return TRUE if all atom pisitions *and* ADP (thermal) tensors are
   ! in the cartesian axis system.
      self :: IN
      res :: BIN

      pos,ADP :: BIN
      a :: INT

      res = TRUE

      do a = 1,.dim

         pos = self(a).pos_axis_system=="cartesian"
         ADP = self(a).ADP_axis_system=="cartesian"
         res = pos AND ADP

         if (self(a).has_ADP3s) res = res AND self(a).ADP3_axis_system=="cartesian"
         if (self(a).has_ADP4s) res = res AND self(a).ADP4_axis_system=="cartesian"

         if (NOT res) exit

      end

   end

   has_cartesian_ADP_axes result (res)
   ! Return TRUE if all atom ADP (thermal) tensors are in the
   ! cartesian axis system.
      self :: IN
      res :: BIN

      a :: INT

      res = TRUE
      do a = 1,.dim
         res = self(a).ADP_axis_system=="cartesian"
         if (NOT res) exit
      end
   end

   has_crystal_ADP_axes result(has)
   ! Return TRUE if all atom ADP (thermal) tensors are in the crystal axis system.
      self :: IN
      has :: BIN
      a :: INT
      has = TRUE
      do a = 1,.dim
         has = self(a).ADP_axis_system=="crystal"
         if (NOT has) exit
      end
   end

   has_disorder result (has)
   ! Return TRUE if any atom has disorder i.e. an occupancy which is not one.
      self :: IN
      has :: BIN
      has = NOT self(:).site_occupancy.has_all_equal_to(ONE)
   end

   atom_index_from_position(pos) result (res)
   ! Return the index of atom from its position "pos"
      pos :: VEC{REAL}(3)
      res :: INT
      a :: INT
      found :: BIN
      found = FALSE
      do a = 1,.dim
         found = pos.same_as(self(a).position)
         if (found) exit
      end
      res = a
      ENSURE(found,"no atom for this position")
   end

!  =====
!  Radii
!  =====

   covalent_radii_ccdc result (res)
   ! Returns the CCDC covalent radius for this atom
      res :: VEC{REAL}(.dim)
      a :: INT
      do a = 1,.dim
         res(a) = self(a).covalent_radius_ccdc
      end
   end

   vdw_radii_ccdc result (res)
   ! Returns the CCDC vdw radius for this atom
      res :: VEC{REAL}(.dim)
      a :: INT
      do a = 1,.dim
         res(a) = self(a).vdw_radius_ccdc
      end
   end

   get_covalent_radii_ccdc(radii)
   ! Returns the CCDC covalent radius for this atom
      radii :: VEC{REAL}(.dim)
      a :: INT
      do a = 1,.dim
         radii(a) = self(a).covalent_radius_ccdc
      end
   end

   get_vdw_radii_ccdc(radii) ::: pure
   ! Returns the CCDC vdw radius for this atom
      self :: IN
      radii :: VEC{REAL}(.dim), OUT

      a :: INT

      do a = 1,.dim
         radii(a) = self(a).vdw_radius_ccdc
      end

   end

!  =======================
!  Spackman's coefficients
!  =======================

   get_Spackman86_a_coeffs_in(coeff) ::: pure
   ! Returns the GKR a-coefficients
      self :: IN
      coeff :: VEC{REAL}, OUT

      i :: INT

      do i = 1,.dim
         coeff(i) = self(i).Spackman86_a_6_dispersion_coeff
      end

   end

   get_Spackman86_b_coeffs_in(coeff) ::: pure
   ! Returns the GKR a-coefficients
      self :: IN
      coeff :: VEC{REAL}, OUT

      i :: INT

      do i = 1,.dim
         coeff(i) = self(i).Spackman86_b_repulsion_coeff
      end

   end

   get_Spackman86_c_coeffs_in(coeff) ::: pure
   ! Returns the GKR a-coefficients
      self :: IN
      coeff :: VEC{REAL}, OUT

      i :: INT

      do i = 1,.dim
         coeff(i) = self(i).Spackman86_c_repulsion_coeff
      end

   end

!  =======================
!  Grimme's coefficients
!  =======================

   get_Grimme06_a_coeffs_in(coeff) ::: pure
   ! Returns the Grimme a-coefficients
      self :: IN
      coeff :: VEC{REAL}, OUT

      i :: INT

      do i = 1,.dim
         coeff(i) = self(i).Grimme06_a_6_dispersion_coeff
      end

   end

   get_Grimme06_r_coeffs_in(coeff) ::: pure
   ! Returns the Grimme a-coefficients
      self :: IN
      coeff :: VEC{REAL}, OUT

      i :: INT

      do i = 1,.dim
         coeff(i) = self(i).Grimme06_r_0_dispersion_coeff
      end

   end


!  ================================
!  Moments, fields, field gradients
!  ================================

   nuclear_dipole_moment result (res)
   ! Return the dipole moment obtained from the atomic numbers.
   ! Dummy nuclear charges are not included
      res :: VEC{REAL}(3)
      a :: INT
      res = ZERO
      do a = 1,.dim
         res = res + self(a).atomic_number*self(a).position
      end
   end

   nuclear_quadrupole_moment result (res)
   ! Return the quadrupole moment obtained from the nuclear charges
   ! as a vector, in the order: xx, yy, zz, xy, xz, yz
   ! Dummy nuclear charges are not included
      res :: VEC{REAL}(6)
       Z :: REAL
       a :: INT
      res = ZERO
      do a = 1,.dim
         Z = self(a).atomic_number
         res(1) = res(1) + Z * self(a).position(1) * self(a).position(1)
         res(2) = res(2) + Z * self(a).position(2) * self(a).position(2)
         res(3) = res(3) + Z * self(a).position(3) * self(a).position(3)
         res(4) = res(4) + Z * self(a).position(1) * self(a).position(2)
         res(5) = res(5) + Z * self(a).position(1) * self(a).position(3)
         res(6) = res(6) + Z * self(a).position(2) * self(a).position(3)
      end
   end

   nuclear_octupole_moment result (res)
   ! Return the octupole moment obtained from the nuclear charges as a vector,
   ! in the order: xxx, yyy, zzz, xxy, xxz, yyx, yyz, zzx, zzy, xyz
   ! Dummy nuclear charges are not included
      res :: VEC{REAL}(10)
      Z :: REAL
      a :: INT
      res = ZERO
      do a = 1,.dim
         Z = self(a).atomic_number
         res(1)  = res(1)  + Z * self(a).position(1) * self(a).position(1) * self(a).position(1)
         res(2)  = res(2)  + Z * self(a).position(2) * self(a).position(2) * self(a).position(2)
         res(3)  = res(3)  + Z * self(a).position(3) * self(a).position(3) * self(a).position(3)
         res(4)  = res(4)  + Z * self(a).position(1) * self(a).position(1) * self(a).position(2)
         res(5)  = res(5)  + Z * self(a).position(1) * self(a).position(1) * self(a).position(3)
         res(6)  = res(6)  + Z * self(a).position(2) * self(a).position(2) * self(a).position(1)
         res(7)  = res(7)  + Z * self(a).position(2) * self(a).position(2) * self(a).position(3)
         res(8)  = res(8)  + Z * self(a).position(3) * self(a).position(3) * self(a).position(1)
         res(9)  = res(9)  + Z * self(a).position(3) * self(a).position(3) * self(a).position(2)
         res(10) = res(10) + Z * self(a).position(1) * self(a).position(2) * self(a).position(3)
      end
   end

   nuclear_E_field_at_positions(pos) result (res)
   ! Return the nuclear contribution to the electric fields
   ! at the nuclei as a (3 x .dim) array
      pos :: MAT{REAL}, IN
      res :: MAT{REAL}(3,pos.dim2)
      Z,r :: REAL
      a,b :: INT
      ab :: VEC{REAL}(3)
      res = ZERO

      do a = 1,pos.dim2
         do b = 1,.dim
            Z  = self(b).nuclear_charge
            ab = pos(:,a) - self(b).position
            r  = ab.norm
            res(:,a) = res(:,a) + Z*ab/(r*r*r)
         end
      end
   end

   nuclear_E_field_at_nuclei result (res)
   ! Return the nuclear contribution to the electric fields
   ! at the nuclei as a (3 x .dim) array
      res :: MAT{REAL}(3,size(self))
      Z,r :: REAL
      a,b :: INT
      ab :: VEC{REAL}(3)
      res = ZERO
      do a = 1,.dim
         do b = 1,.dim
            if (b==a) cycle
            Z  = self(b).nuclear_charge
            ab = self(a).position - self(b).position
            r  = ab.norm
            res(:,a) = res(:,a) + Z*ab/(r*r*r)
         end
      end
   end

   nuclear_EFG_at_nuclei result (res)
   ! Return the nuclear contribution to the electric fields gradient
   ! (EFG) at the nuclei as a (6 x .dim) array
      res :: MAT{REAL}(6,size(self))
      Z,r,r3,r5 :: REAL
      a,b :: INT
      ab :: VEC{REAL}(3)
      res = ZERO
      do a = 1,.dim
         do b = 1,.dim
            if (b==a) cycle
            Z  = self(b).nuclear_charge
            ab = self(a).position - self(b).position
            r  = ab.norm
            r3 = r*r*r
            r5 = r3*r*r
            res(1,a) = res(1,a) - Z * (THREE*ab(1)*ab(1)/r5 - ONE/r3)
            res(2,a) = res(2,a) - Z * (THREE*ab(2)*ab(2)/r5 - ONE/r3)
            res(3,a) = res(3,a) - Z * (THREE*ab(3)*ab(3)/r5 - ONE/r3)
            res(4,a) = res(4,a) - Z * (THREE*ab(1)*ab(2)/r5)
            res(5,a) = res(5,a) - Z * (THREE*ab(1)*ab(3)/r5)
            res(6,a) = res(6,a) - Z * (THREE*ab(2)*ab(3)/r5)
         end
      end
   end

!  ========================
!  Atom kinds, unique atoms
!  ========================

   same_kind_of_atoms(a,b) result (res)
   ! Return true if atoms "a" and "b" are the same kind
   ! . They are the same kind if they have the same kind of basis
   !   and same atomic number.
   ! . This is used for ANO or other QM type calculations.
      a,b :: INT
      res :: BIN
      res = self(a).is_same_kind_as(self(b))
   end

   make_atom_kind_count(cnt,n_kind) ::: leaky
   ! Return an array "cnt" in which each element represents an atom,
   ! and the value of that array element is a count of the number of
   ! atoms of that kind.  Later atoms (i.e. array elements) which are
   ! of the same kind as earlier atoms have a count equal to the minus
   ! of the index of the earlier atom they are equivalent to. The
   ! number of different kinds is returned in "n_kind".
      cnt :: VEC{INT}*
      n_kind :: INT

      n,l,n_atom :: INT

      n_atom = .dim

      cnt.create(n_atom)
      cnt = 1

      do n = 1,n_atom
         if (cnt(n)<0) cycle
         do l = n+1,n_atom
            if (cnt(l)<0) cycle
            if (NOT .same_kind_of_atoms(l,n)) cycle
            cnt(n) = cnt(n)+1
            cnt(l) = -n
         end
      end

      n_kind = count(cnt>0)

   end

   make_atom_kind_list(atom_kind) ::: leaky
   ! Make the atom kind list ... atom_kind(k).element(c) is the c-th
   ! atom of the same kind as atom k, which is a unique kind.
      atom_kind :: VEC{VEC_{INT}}*

      cnt :: VEC{INT}*
      n,l,k,c,n_atom :: INT

      .make_atom_kind_count(cnt,n)

      nullify(atom_kind)
      atom_kind.create(n)

      n_atom = .dim

      k = 0
      do n = 1,n_atom
         if (cnt(n)<0) cycle
         k = k + 1
         c = 1
         atom_kind(k).element.create(cnt(n))
         atom_kind(k).element(c) = n
         do l = n+1,n_atom
            if (cnt(l)/=-n) cycle
            c = c+1
            atom_kind(k).element(c) = l
         end
      end

      cnt.destroy

      ! Now sort into descending atomic number
    ! indices.create(atom_kind.dim)
    ! self(atom_kind.element(1)).atomic_number.quick_sort(indices,decreasing_order=TRUE)
    ! atom_kind = atom_kind(indices)
    ! indices.destroy

   end

   make_atom_kind_list(atom_kind,n_kind)
   ! Make a different atom kind list ... atom_kind(k) is the kind
   ! index of the k-th atom. (Same effect as the make_atom_kind_map
   ! routine).
      atom_kind :: VEC{INT}
      n_kind :: INT

   ENSURE(atom_kind.dim==.dim,"atom_kind is incorrectly dimensioned")

      n_atom,n,k,l :: INT

      n_atom = .dim
      atom_kind = [ (n, n=1,n_atom) ]

      k = 0
      do n = 1,n_atom

         ! Found kind for atom n?
         if (atom_kind(n)<=k) cycle

         ! Set kind
         k = k + 1
         atom_kind(n) = k

         ! Set non-unique kinds
         do l = n+1,n_atom

            if (atom_kind(l)<=k) cycle
            if (NOT .same_kind_of_atoms(l,n)) cycle

            atom_kind(l) = k

         end

      end

      n_kind = k

   end

   make_unique_atom_list(unique_atom)
   ! "unique_atom(k)" is the index of the first atom which represents
   ! all the the atoms which are of the same kind, k. This requires
   ! "atom_kind" to have been made via "make_atom_kind_list" above.
      unique_atom :: VEC{INT}

      n_kind,k,n :: INT

      n_kind = maxval(self(:).kind)

      ! Check size
      DIE_IF(unique_atom.dim/=n_kind,"unique atom incorrectly dimensioned")

      ! Make the list
      k = 0
      do n = 1,.dim
         if (NOT self(n).is_unique_kind) cycle
         k = k + 1
         unique_atom(k) = n
      end

   end

   are_distinct(a,b) result (res)
   ! Return true if atoms "a" and "b" are crystallographically
   ! distinct based on occupancy and atomic number
      a,b :: INT
      res :: BIN
      res = self(a).atomic_number      /=self(b).atomic_number       &
        OR  self(a).site_disorder_group/=self(b).site_disorder_group &
        OR NOT self(a).site_occupancy.equals(self(b).site_occupancy)
   end

!  ===========
!  Atom groups
!  ===========

   has_site_groups result (res) ::: pure
   ! Return TRUE if any crstal site dirder groups have been defined
      self :: IN
      res :: BIN

      if (any(self(:).site_disorder_group>0)) then; res = TRUE
      else;                                         res = FALSE
      end

   end

   has_groups result (res) ::: pure
   ! Return TRUE if any atom groups have been defined
   ! This only counts if there is more than one group!
      self :: IN
      res :: BIN

      if (any(self(:).group>1)) then; res = TRUE
      else;                           res = FALSE
      end

   end

   no_of_groups result (res) ::: pure
   ! Return the number of groups
      self :: IN
      res :: INT

      res = maxval(self(:).group)

   end

   set_connected_groups
   ! Search through the list of atoms as assigns each atom the same
   ! group number if the atom is a part of the same connected
   ! molecule.
      self :: INOUT

      atoms_bonded_to_atom :: VEC{VEC_{INT}}*
      group_for :: VEC{INT}*
      a,b,c,n, ga,gb :: INT

      ! Can only proceed in cartesian axes
      if (NOT all(ATOM:is_in_cartesian_system(self))) return

      ! Make the bond list
      .make_connection_table(atoms_bonded_to_atom)

      ! List of groups
      group_for.create(.dim)
      group_for = 0

      ! Loop over atoms
      do a = 1,.dim

         ! Get group for a
         ga = group_for(a)
         if (ga==0) then ! next group
            ga = maxval(group_for) + 1
            group_for(a) = ga
         end

         ! Loop over bonded atoms
         n = atoms_bonded_to_atom(a).element.dim
         do c = 1,n

            b  = atoms_bonded_to_atom(a)[c]
            gb = group_for(b)

            if (gb==0) then
               group_for(b) = ga
            else if (gb>ga) then
               where (group_for==gb) group_for = ga
            else if (gb<ga) then
               where (group_for==ga) group_for = gb
               ga = gb ! NOTE
            end

         end

      end

      ! Assign
      self(:).group = group_for

      ! Clean
      group_for.destroy
      atoms_bonded_to_atom.destroy

   end

   make_atom_group_list(atom_group) ::: leaky
   ! This routine finds all the atoms in the same group and makes
   ! their indices as a atom_group of integers. The result is a
   ! "atom_group" of atom_group of integers. NOTE that "atom_group" is
   ! created.
      atom_group :: VEC{VEC_{INT}}*

      n_group,g,n,i :: INT
      group_indices :: VEC{INT}*

      ! Extract the group indices
      group_indices.create(.dim)
      group_indices = self.group
      n_group = group_indices.no_of_unique_elements

      ! Create the atom_group list of indices
      atom_group.create(n_group)

      ! All atoms in one group, size .dim
      if (n_group==1) then
         atom_group(1).element.create(.dim)
         atom_group(1).element = [ (i, i=1,.dim) ]
      ! Atoms in different groups, size n_group
      else
        do g = 1,n_group
           n = count(group_indices==g)
           DIE_IF(n==0,"group indices are not sequential!")
           atom_group(g).element.create(n)
           atom_group(g).element = pack( [ (i, i=1,.dim) ], group_indices==g)
        end
      end

      ! Clean
      group_indices.destroy

   end

   set_group_to(g)
   ! Set the atom "group" index to "g".
      self :: INOUT
      g :: INT, IN

      a :: INT

      do a = 1,.dim
         self(a).group = g
      end

   end

!  =========================
!  Shell information methods
!  =========================

   make_shell_limits(first,last,momentum) ::: leaky
   ! Get the shell function limit vectors "first" and "last" for
   ! corresponding to the concatenated vector of atomvec shells. Also
   ! get the angular "momentum" for the shell.
      first,last,momentum :: VEC{INT}*

      a,as,n,ss,f,l :: INT

      nullify(first);    first.create(.n_shell)
      nullify(last);     last.create(.n_shell)
      nullify(momentum); momentum.create(.n_shell)

      ss = 0; l = 0
      do a = 1,.dim
         n = self(a).basis.n_shell
         do as = 1,n
            ss = ss + 1
            f = l + 1
            l = f + self(a).basis.shell(as).n_bf - 1
            first(ss) = f
            last(ss)  = l
            momentum(ss) = self(a).basis.shell(as).l
         end
      end
   end

   make_atom_basis_fn_limits(first,last) ::: leaky
   ! Get the first and last basis functions for the atoms
      first,last :: VEC{INT}*

      a,as,n,l :: INT

      nullify(first); first.create(.dim)
      nullify(last);  last.create(.dim)

      l = 0
      do a = 1,.dim
         n = self(a).basis.n_shell
         first(a) = l + 1
         do as = 1,n
            l = l + self(a).basis.shell(as).n_bf
         end
         last(a) = l
      end

   end

   make_primitive_limits(frst,last,atom,lmom,expo) ::: leaky
   ! Get the primitive function limit vectors "frst" and "last" and
   ! other data pertaining to the primitive function corresponding to
   ! the concatenated bases of all the atoms.
      frst,last,atom,lmom :: VEC{INT}*
      expo :: VEC{REAL}*
      basis :: BASIS*
      shell :: SHELL*
      nps,a,as,ap,p,f,l :: INT
      nps = .no_of_primitive_shells
      frst.create(nps)
      last.create(nps)
      atom.create(nps)
      lmom.create(nps)
      expo.create(nps)
      p = 0; l = 0
      do a = 1,.dim
         basis => self(a).basis
         do as = 1,basis.n_shell
            shell => basis.shell(as)
            do ap = 1,shell.n_cc
               p = p + 1
               f = l + 1
               l = l + shell.n_bf
               frst(p) = f
               last(p) = l
               atom(p) = a
               lmom(p) = shell.l
               expo(p) = shell.exponent(ap)
            end
         end
      end
   end

!  ==============================
!  Atom-shell information methods
!  ==============================

   atom_for_shell(s) result(a)
   ! Return the *atom* number "a" corresponding to the
   ! *atomvec* shell number "s"
      a,s :: INT
      ss,n :: INT
      ss = 0
      do a = 1,.dim
         n = self(a).basis.n_shell
         ss = ss + n
         if (s<=ss) exit
      end
   end

   atom_for_shell result (res) ::: leaky
   ! Return a vector of *atom* numbers corresponding to the
   ! vector of *atomvec* shell numbers
      res :: VEC{INT}*
      a,ss,n :: INT
      nullify(res); res.create(.n_shell)
      ss = 0
      do a = 1,.dim
         n = self(a).basis.n_shell
         res(ss+1:ss+n) = a
         ss = ss + n
      end
   end

   atom_shell_for_shell(s) result(as)
   ! Return the *atom* shell number "as" corresponding to the
   ! *atomvec* shell number "s"
      s :: INT
      as :: INT

   ENSURE(.dim>0,"no atoms")

      a,ss,n :: INT

      n = 0
      ss = 0
      do a = 1,.dim
         ENSURE(self(a).basis.created,"no basis for atom "//trim(a.to_str))
         n = self(a).basis.n_shell
         ss = ss + n
         if (s<=ss) exit
      end

      as = s - ss + n

   end

   atom_shell_for_shell result (res) ::: leaky
   ! Return a vector of *atom* shell numbers corresponding to the
   ! *atomvec* shell number vector
      res :: VEC{INT}*
      a,ss,n,as :: INT
      nullify(res); res.create(.n_shell)
      ss = 0
      do a = 1,.dim
         n = self(a).basis.n_shell
         do as = 1,n
            res(ss+as) = as
         end
         ss = ss + n
      end
   end

   first_shell_for_atom(a) result (res)
   ! Return the index of the first shell for atom "a" in the atomvec
      a,res :: INT
      at,n :: INT
      res = 1
      do at = 1,(a-1)
         n = self(a).basis.n_shell
         res = res + n
      end
   end

   make_shell_for_atom_limits(first,last)
   ! Return the indices of the first and last shell for each atom in the atomvec
      first,last :: VEC{INT}
      ss,a,n :: INT
      ss = 0
      do a = 1,.dim
         first(a) = ss + 1
         n = self(a).basis.n_shell
         ss = ss + n
         last(a) = ss
      end
   end

   first_shell_for_atom result (res) ::: leaky
   ! Return the indices of the first shell for an atom in the atomvec
      res :: VEC{INT}*
      ss,a,n :: INT
      nullify(res); res.create(size(self))
      ss = 0
      do a = 1,.dim
         n = self(a).basis.n_shell
         res(a) = ss + 1
         ss = ss + n
      end
   end

!  ===============
!  Invariom labels
!  ===============

   neighbours_of(a,range_factor) result (res) ::: leaky
   ! Return the list of atoms bonded to atom "a".
      a :: INT
      range_factor :: REAL, optional
      res :: VEC{INT}*
      b :: INT
      nullify(res)
      do b = 1,.dim
         if (b==a) cycle
         if (NOT .bonded(a,b,range_factor)) cycle
         res.append(b)
      end
   end

   is_next_neighbour_chiral(a) result (res) ::: leaky
   ! Return TRUE if there are four next nearest neighbours for the
   ! atom "a", and if they are all different.
      a :: INT
      res :: BIN
      neighbour :: VEC{INT}*
      Z :: VEC{INT}(4)
      neighbour => .neighbours_of(a)
      if (neighbour.destroyed) then
         res = FALSE
      else if (neighbour.dim==4) then
         Z = self(neighbour).atomic_number
         res = NOT Z.has_repetitions
      else
         res = FALSE
      end
      neighbour.destroy
   end

   next_neighbour_handedness_of(a) result (res) ::: leaky
   ! Return the handedness of the atom "a" based only on the four
   ! connecting atoms around it.
      a :: INT
      res :: STR
      n :: INT
      p2,p3,p4,pc :: VEC{REAL}(3)
      Z,order :: VEC{INT}(4)
      neighbour :: VEC{INT}*

      neighbour => .neighbours_of(a)
      DIE_IF(neighbour.destroyed,"there are no neighbours")
      n = neighbour.dim
      DIE_IF(neighbour.dim/=4,"must have four neighbours, n = "//trim(n.to_str))
    ! stdout.show("neighbours =",neighbour)

      Z = self(neighbour).atomic_number
      Z.quick_sort(order)
      neighbour = neighbour(order)
    ! stdout.show("sorted neighbours =",neighbour)

      p2 = self(neighbour(2)).position - self(a).position
      p3 = self(neighbour(3)).position - self(a).position
      p4 = self(neighbour(4)).position - self(a).position
      pc = p4.cross(p3)
      if (p2.dot(pc)>ZERO) then; res = "R"
      else;                      res = "S"
      end

      neighbour.destroy

   end


   invariom_labels result (res) ::: leaky
   ! Return the invariom label for the atom "a"
      res :: VEC{STR}*
      a :: INT
      res.create(.dim)
      do a = 1,.dim
         res(a) = .invariom_label_of(a)
      end
   end

   invariom_label_of(a) result (res)
   ! Return the invariom label for the atom "a"
      a :: INT
      res :: STR

      special_Z :: VEC{INT}(3) = [1,15,16]
      i,j,n,m,f2,l2,p :: INT
      Z,bond,order,neighbour,Z2,bond2,order2,neighbour2 :: VEC{INT}*
      bonds,bonds2,mesomer,ZZ :: VEC{STR}*
      special,do_2nd_neighbour :: BIN
      symbol :: STR

      ! Start with the R or S symbol, if the atom is chiral
      if (.is_next_neighbour_chiral(a)) then; res = trim(.next_neighbour_handedness_of(a))//"-"
      else;                                   res = " "
      end

      ! Start with "a" atoms chemical symbol
      res = trim(res)//self(a).chemical_symbol

      ! Get indices of the nearest neighbours; return if no neighbours
      neighbour => .neighbours_of(a)
      if (neighbour.destroyed) return
      neighbour.prune(a)
      if (neighbour.dim==0) return

      ! Create arrays to store the bond order (times 10) and string
      ! form of bond order
      n = neighbour.dim
      bond.create(n)
      bonds.create(n)

      ! Get the atomic numbers Z of neighbors and order them in
      ! decreasing bond-order/atomic number
      Z.create(n)
      order.create(n)
      Z = self(neighbour).atomic_number
      .allred_rochow_bond_orders(a,neighbour,bond,bonds)
      Z = 1000*bond + Z
      Z.quick_sort(order,decreasing_order=TRUE)
      neighbour = neighbour(order)
      bond  = bond(order)
      bonds = bonds(order)
      order.destroy; Z.destroy

      ! If special Z atoms switch on next nearest neighbour
      f2 = 0
      special = FALSE

      if (any(special_Z==self(a).atomic_number)) then
         f2 = 1
         l2 = bond.dim
         special = TRUE

      ! Find out how many mesomeric bonds there are
      else
         f2 = bond.index_of_value(15)
         l2 = 0
         if (f2>0) then
            if      (f2==bond.dim) then;       l2 = f2
            else if (bond(bond.dim)==15) then; l2 = bond.dim
            else;                              l2 = bond(f2+1:).index_of_value_ne_to(15)
                                               l2 = f2 + l2 - 1
            end
         end
      end

      do_2nd_neighbour = f2>0 AND l2>=f2

      nullify(mesomer)

      ! If we should do second nearest neighbours ...
      if (do_2nd_neighbour) then

         mesomer.create(f2,l2); mesomer = " "
         ZZ.create(f2,l2);      ZZ = "0"

         ! Loop over second nearest neighbour atoms or mesomeric atoms
         do i = f2,l2

            ! Get indices of the 2nd nearest neighbours; return if no neighbours
            neighbour2 => .neighbours_of(neighbour(i))
            DIE_IF(neighbour2.destroyed,"mesomeric atom has no neighbours")

            ! We don't want the original first neighbour
            neighbour2.prune(a)
            if (neighbour2.dim==0) then
               neighbour2.destroy
               cycle
            end

            ! Order the 2nd nearest neighbours in decreasing bond-order/atomic number
            m = neighbour2.dim
            bond2.create(m)
            bonds2.create(m)
            Z2.create(m)
            order2.create(m)
            Z2 = self(neighbour2).atomic_number
            .allred_rochow_bond_orders(neighbour(i),neighbour2,bond2,bonds2)
            Z2 = 1000*bond2 + Z2
            Z2.quick_sort(order2,decreasing_order=TRUE)
            neighbour2 = neighbour2(order2)
            Z2 = Z2(order2)
            bond2 = bond2(order2)
            bonds2 = bonds2(order2)

           ! Make and store the unsorted mesomer 2nd nearest neighbour invariom names
            mesomer(i) = achar(91)
            do j = 1,m
               symbol = self(neighbour2(j)).chemical_symbol
               mesomer(i) = trim(mesomer(i))// &
                            trim(bonds2(j))// &
                            trim(symbol.lower_cased)
            end
            mesomer(i) = trim(mesomer(i))//achar(93)

            ! Make the 2nd nearest neighbour ordering string ZZ
            p = 1
            do j = 1,m
               ZZ(i)(p:p+3) = trim(Z2(j).to_str)
               p = p + 4
            end

            order2.destroy
            Z2.destroy
            bonds2.destroy
            bond2.destroy
            neighbour2.destroy
         end

         ! Now reorder the mesomer strings according to ZZ
         if (l2>f2) then
            order.create(f2,l2)
            ZZ.quick_sort(order,decreasing_order=TRUE)
            order = order + f2 - 1
            neighbour(f2:l2) = neighbour(order)
            mesomer(f2:l2) = mesomer(order)
            order.destroy
         end

         ZZ.destroy

      end

      ! Now everything is sorted; just make the invariom label
      res = res.trim_blanks_from_start
      do i = 1,n
         symbol = self(neighbour(i)).chemical_symbol
         res = trim(res)//trim(bonds(i))//trim(symbol.lower_cased)
         if (bond(i)==15 OR special) then
            res = trim(res)//trim(mesomer(i))
         end
      end

      mesomer.destroy; bonds.destroy; bond.destroy; neighbour.destroy
   end

   put_invariom_labels
   ! Print out the invariom labels
      a :: INT
      do a = 1,.dim
         stdout.show("label for atom "//trim(a.to_str)//" = ",.invariom_label_of(a))
      end
   end

   allred_rochow_bond_orders(a,neighbours,bond,bonds)
   ! Given at atom "a" and its "neighbours" return the allred-rochow
   ! bond distinguishing parameters "bond" (times 10) and the
   ! cooresponding string form.
      a :: INT, IN
      neighbours :: VEC{INT}, IN
      bond :: VEC{INT}, OUT
      bonds :: VEC{STR}, OUT

   ENSURE(0<a AND a <=.dim,"index a out of range")
   ENSURE(bond.dim==neighbours.dim,"bond array, wrong size")
   ENSURE(bonds.dim==neighbours.dim,"bond array, wrong size")

      i,b :: INT
      br :: REAL

      do i = 1,neighbours.dim
         b = .bond_distinguisher(a,neighbours(i))
         bond(i) = b
         if (b==15) then
            br = b/TEN
            bonds(i) = br.to_str("f3.1")
         else
            b = b/10
            bonds(i) = b.to_str
         end
      end
   end

   bond_distinguisher(a,b) result (res)
   ! Return true if "self" is bonded to "b".  If present, "range_factor" is used
   ! to determine the distance range in which the atoms are regarded as bonded.
   ! This uses the CCDC method, as documented on their web page.
      a,b :: INT, IN
      res :: INT

      d,chi,cra,crb,ena,enb :: REAL

      d = .bond_distance(a,b)*ANGSTROM_PER_BOHR

      cra = self(a).invariom_covalent_radius
      crb = self(b).invariom_covalent_radius

      ena = self(a).allred_rochow_en
      enb = self(b).allred_rochow_en

      chi = cra + crb - 0.08 * abs(ena-enb) - d

      res = 0
           if (chi <= 0.0847 ) then; res = 10
      else if (chi <= 0.184 )  then; res = 15
      else if (chi <= 0.27 )   then; res = 20
      else if (chi >  0.27 )   then; res = 30
      end

   end


   smiles_invariom_labels result (res) ::: leaky
   ! Return the invariom label for the atom "a"
      res :: VEC{STR}*
      a :: INT
      res.create(.dim)
      do a = 1,.dim
         res(a) = .smiles_invariom_label_of(a)
      end
   end

   smiles_invariom_label_of(a) result (res)
   ! Return the invariom label for the atom "a"
      a :: INT
      res :: STR

      special_Z :: VEC{INT}(3) = [1,15,16]
      i,j,n,m,f2,l2,p :: INT
      Z,bond,order,neighbour,Z2,bond2,order2,neighbour2 :: VEC{INT}*
      bonds,bonds2,mesomer,ZZ :: VEC{STR}*
      special,do_2nd_neighbour :: BIN
      symbol :: STR

      ! Start with the R or S symbol, if the atom is chiral
      if (.is_next_neighbour_chiral(a)) then; res = trim(.next_neighbour_handedness_of(a))//"-"
      else;                                   res = " "
      end

      ! Start with "a" atoms chemical symbol
      res = trim(res)//self(a).chemical_symbol

      ! Get indices of the nearest neighbours; return if no neighbours
      neighbour => .neighbours_of(a)
      if (neighbour.destroyed) return
      neighbour.prune(a)
      if (neighbour.dim==0) return

      ! Create arrays to store the bond order (times 10) and string
      ! form of bond order
      n = neighbour.dim
      bond.create(n)
      bonds.create(n)

      ! Get the atomic numbers Z of neighbors and order them in
      ! decreasing bond-order/atomic number
      Z.create(n)
      order.create(n)
      Z = self(neighbour).atomic_number
      .smiles_bond_orders(a,neighbour,bond,bonds)
      Z = 1000*bond + Z
      Z.quick_sort(order,decreasing_order=TRUE)
      neighbour = neighbour(order)
      bond  = bond(order)
      bonds = bonds(order)
      order.destroy; Z.destroy

      ! If special Z atoms switch on next nearest neighbour
      f2 = 0
      special = FALSE

      if (any(special_Z==self(a).atomic_number)) then
         f2 = 1
         l2 = bond.dim
         special = TRUE

      ! Find out how many mesomeric bonds there are
      else
         f2 = bond.index_of_value(15)
         l2 = 0
         if (f2>0) then
            if      (f2==bond.dim) then;       l2 = f2
            else if (bond(bond.dim)==15) then; l2 = bond.dim
            else;                              l2 = bond(f2+1:).index_of_value_ne_to(15)
                                               l2 = f2 + l2 - 1
            end
         end
      end

      do_2nd_neighbour = f2>0 AND l2>=f2

      nullify(mesomer)

      ! If we should do second nearest neighbours ...
      if (do_2nd_neighbour) then

         mesomer.create(f2,l2); mesomer = " "
         ZZ.create(f2,l2);      ZZ = "0"

         ! Loop over second nearest neighbour atoms or mesomeric atoms
         do i = f2,l2

            ! Get indices of the 2nd nearest neighbours; return if no neighbours
            neighbour2 => .neighbours_of(neighbour(i))
            DIE_IF(neighbour2.destroyed,"mesomeric atom has no neighbours")

            ! We don't want the original first neighbour
            neighbour2.prune(a)
            if (neighbour2.dim==0) then
               neighbour2.destroy
               cycle
            end

            ! Order the 2nd nearest neighbours in decreasing bond-order/atomic number
            m = neighbour2.dim
            bond2.create(m)
            bonds2.create(m)
            Z2.create(m)
            order2.create(m)
            Z2 = self(neighbour2).atomic_number
            .smiles_bond_orders(neighbour(i),neighbour2,bond2,bonds2)
            Z2 = 1000*bond2 + Z2
            Z2.quick_sort(order2,decreasing_order=TRUE)
            neighbour2 = neighbour2(order2)
            Z2 = Z2(order2)
            bond2 = bond2(order2)
            bonds2 = bonds2(order2)

           ! Make and store the unsorted mesomer 2nd nearest neighbour invariom names
            mesomer(i) = "("
            do j = 1,m
               symbol = self(neighbour2(j)).chemical_symbol
               mesomer(i) = trim(mesomer(i))// &
                            trim(bonds2(j))// &
                            trim(symbol.lower_cased)
            end
            mesomer(i) = trim(mesomer(i))//")"

            ! Make the 2nd nearest neighbour ordering string ZZ
            p = 1
            do j = 1,m
               ZZ(i)(p:p+3) = trim(Z2(j).to_str)
               p = p + 4
            end

            order2.destroy
            Z2.destroy
            bonds2.destroy
            bond2.destroy
            neighbour2.destroy
         end

         ! Now reorder the mesomer strings according to ZZ
         if (l2>f2) then
            order.create(f2,l2)
            ZZ.quick_sort(order,decreasing_order=TRUE)
            order = order + f2 - 1
            neighbour(f2:l2) = neighbour(order)
            mesomer(f2:l2) = mesomer(order)
            order.destroy
         end

         ZZ.destroy

      end

      ! Now everything is sorted; just make the invariom label
      res = res.trim_blanks_from_start
      res = trim(res)//"("
      do i = 1,n
         symbol = self(neighbour(i)).chemical_symbol
         res = trim(res)//trim(bonds(i))//trim(symbol.lower_cased)
         if (bond(i)==15 OR special) then
            res = trim(res)//trim(mesomer(i))
         end
      end
      res = trim(res)//")"

      mesomer.destroy; bonds.destroy; bond.destroy; neighbour.destroy

   end

   put_smiles_invariom_labels
   ! Print out the invariom labels
      a :: INT
      do a = 1,.dim
         stdout.show("label for atom "//trim(a.to_str)//" = ",.smiles_invariom_label_of(a))
      end
   end

   smiles_bond_orders(a,neighbours,bond,bonds)
   ! Given at atom "a" and its "neighbours" return the allred-rochow
   ! bond distinguishing parameters "bond" (times 10) and the
   ! cooresponding string form.
      a :: INT, IN
      neighbours :: VEC{INT}, IN
      bond :: VEC{INT}, OUT
      bonds :: VEC{STR}, OUT

   ENSURE(0<a AND a <=.dim,"index a out of range")
   ENSURE(bond.dim==neighbours.dim,"bond array, wrong size")
   ENSURE(bonds.dim==neighbours.dim,"bond array, wrong size")

      i,b :: INT

      do i = 1,neighbours.dim
         b = .bond_distinguisher(a,neighbours(i))
         bond(i) = b
         select case (b)
         case (10);    bonds(i) = "-"
         case (15);    bonds(i) = ":"
         case (20);    bonds(i) = "="
         case (25);    bonds(i) = "%"
         case (30);    bonds(i) = "#"
         case default; bonds(i) = "?"
         end
      end
   end


!  =================
!  Protein detection
!  =================

   find_N_terminal_atoms
   ! Print the indices of the N terminal atoms.
      list :: VEC{INT}*

      .make_connection_table(skip_hydrogen=TRUE)
      .find_N_terminal_atoms(list)

      stdout.text("List of N terminal atoms:")
      stdout.put(list)

      list.destroy
      connections_for.destroy

   end

   find_N_terminal_atoms(list) ::: leaky
   ! Print the indices of the protein backbone atoms.
      list :: VEC{INT}*

   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      N,Cp0,Ca,Cb,Cp,N1,Ot,Ct :: INT
      N_terminal :: BIN

      list.create(0)

      do N = 1,.dim
        if (self(N).atomic_number/=7) cycle
        Cp0 = 0
        if (NOT .is_protein_backbone_N(N,Cp0,Ca,Cb,Cp,N1,Ot,Ct,N_terminal,try=TRUE)) cycle
        if (NOT N_terminal) cycle
        list.append(N)
      end

   end


   find_protein_backbone
   ! Return the of indices of the N terminal atoms.
      backbone :: VEC{VEC_{INT}}*

      .make_connection_table(skip_hydrogen=TRUE)
      .find_protein_backbone(backbone)

      backbone.destroy
      connections_for.destroy

   end

   find_protein_backbone(backbone) ::: leaky
   ! Return the "backbone" of atom indices in each protein backbone.
      backbone :: VEC{VEC_{INT}}*

   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      terminal :: VEC{INT}*
      N_terminal :: BIN
      i, N,Cp0,Ca,Cb,Cp,N1,Ot,Ct :: INT

      .find_N_terminal_atoms(terminal)

      backbone.create(terminal.dim,1)

      do i = 1,terminal.dim

        N = terminal(i)
        backbone(i)[1] = N
        Cp0 = 0

        do
           if (NOT .is_protein_backbone_N(N,Cp0,Ca,Cb,Cp,N1,Ot,Ct,N_terminal,try=TRUE)) exit
           if      (Ot/=0) then
              backbone(i).element.append([Ca,Cp,Ot])
              exit
           else if (Ct/=0) then
              backbone(i).element.append([Ca,Cp,Ct])
              exit
           else
              backbone(i).element.append([Ca,Cp,N1])
              N = N1
              Cp0 = Cp
           end
        end

        stdout.show("Backbone for protein strand =",i)
        stdout.put(backbone(i)[:])
      end

      terminal.destroy

   end

!   find_protein_backbone_from_N(N,C,found,Ca,Cc,N1,Ot)
!   ! Given the index "N" of a nitrogen atom and possibly the index "C"
!   ! of a connected carbon atom, return "found" as TRUE if that
!   ! nitrogen atom is part of a protein backbone. Also return the
!   ! index "Ca" of the C-alpha carbon, the index "Cc" of the C-carboxy
!   ! carbon, and either "N1" the next nitrogen in the backbone, or
!   ! "Ot" the terminal oxygen in the backbone. This assumes a
!   ! connection table has been made.
!     N,C :: INT, IN
!     found :: BIN, OUT
!     Ca,Cc,N1,Ot :: INT, OUT
!
!   ENSURE(connections_for.created,"no connection table")
!   ENSURE(connections_for.dim==.dim,"wrong size connection table")
!   ENSURE(N>0 AND N<=.dim,"N index out of range")
!   ENSURE(self(N).atomic_number==7,"N is not the index of a nitrogen atom")
!   ENSURE(C>=0 AND C<=.dim,"C index out of range")
!
!     nn,na,ia,nc,ic,O2,X :: INT
!
!     ! Set defaults
!     found = FALSE
!     Ca = 0; Cc = 0; N1 = 0; Ot = 0
!
!     ! Check if C is bonded to N
!     if (C>0) then
!        DIE_IF(NOT self(N).is_bonded_to(self(C)),"N is not bonded to C")
!     end
!
!     ! # of connections for N
!     nn = connections_for(N).element.dim
!
!     ! A backbone N must have 1 connection and can't have
!     ! more than 2 connections
!     if (nn<=0) return
!     if (nn >2) return
!
!     ! Get the index of C-alpha atom
!     Ca = connections_for(N)[1]
!     if (Ca==C) then
!        DIE_IF(nn<2,"not enough connections to N = "//trim(N.to_str))
!        Ca = connections_for(N)[2]
!     end
!
!     ! C-alpha must be a carbon
!     if (self(Ca).atomic_number/=6) return
!
!     ! # of  connections for C-alpha
!     na = connections_for(Ca).element.dim
!
!     ! C-alpha must have 2 connections (GLY) or 3 connections
!     if (na/=3 AND na/=2) return
!
!     ! Now find C-carboxy carbon
!     do ia = 1,na
!        Cc = connections_for(Ca)[ia]          ! Index of C-carboxy
!        if (Cc==N) cycle                      ! Cc can't be the first N
!        if (self(Cc).atomic_number/=6) cycle  ! Cc must be a carbon
!        nc = connections_for(Cc).element.dim
!        if (nc/=3) cycle                      ! C-carboxy must have 3 connections
!        O2 = 0                                ! It must have a =O
!        N1 = 0                                ! It must have a -N, or
!        Ot = 0                                ! It must have a terminal -OH
!        do ic = 1,nc
!           X = connections_for(Cc)[ic]
!           if (X==Ca) cycle
!           if (self(X).atomic_number==7) N1 = X
!           if (self(X).atomic_number==8) then
!              if (Ot==0) then; O2 = X
!              else;            Ot = X
!              end
!           end
!        end
!        found = O2/=0 AND (N1/=0 OR Ot/=0)
!        if (found) exit
!     end
!   end


   is_protein_backbone_N(N,Cp0,Ca,Cb,Cp,N1,Ot,Ct,N_terminal,try) result (res)
   ! Return TRUE if "N" is the index of a nitrogen atom in the
   ! backbone of a protein, Cp0-N-Ca-Cp-(N1,Ot,Ct), given also
   ! (possibly) the index "Cp0" of a connected C prime carbon atom.
   ! Return the index "Ca" of the C-alpha carbon, the index of the
   ! beta carbon "Cb" (if it exists), the index "Cp" of the next C
   ! prime carboxy carbon, and either "N1" the next nitrogen in the
   ! backbone, or "Ot" the terminal oxygen in the backbone. If "N" is
   ! an N-terminal atom, return "N_terminal" as TRUE. This assumes a
   ! connection table has been made.
      N,Cp0 :: INT, IN
      Ca,Cb,Cp,N1,Ot,Ct :: INT, OUT
      N_terminal :: BIN, OUT
      try :: BIN, optional
      res :: BIN

   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(N>0 AND N<=.dim,"N index out of range")
   ENSURE(self(N).atomic_number==7,"N is not the index of a nitrogen atom")
   ENSURE(Cp0>=0 AND Cp0<=.dim,"Cp0 index out of range")

      C1,C2,C3,O1, O11,Ca1,N11 :: INT

      res = FALSE
      N_terminal = FALSE

      ! One connection to N: Terminal N-Ca connection
      if (.has_1_connection(N,6,Ca)) then
        res = .is_protein_C_alpha(Ca,N,Cb,Cp,O1,N1,Ot,Ct)
        N_terminal = TRUE

      ! Two connections to N: Backbone or terminal PRO C1-N-C2 connection
      else if (.has_2_connections(N,6,6,C1,C2)) then

        Ca = 0
        if      (C1==Cp0) then; Ca = C2
        else if (C2==Cp0) then; Ca = C1
        end

        ! We found Cp0, so we know Ca
        if (Ca/=0) then
           res = .is_protein_C_alpha(Ca,N,Cb,Cp,O1,N1,Ot,Ct)

        ! Find which of C1 and C2 is Ca. If requested, determine which
        ! of C1 and C2 is NOT a Cp, which implies N_terminal. Also
        ! check for a terminal proline.
        else
           if      (.is_protein_C_alpha(C1,N,Cb,Cp,O1,N1,Ot,Ct)) then
              res = TRUE
              Ca = C1
              if (.has_ring(N,C2,[6,6,6])) N_terminal = TRUE
              if (NOT N_terminal AND present(try)) &
                 N_terminal = NOT .is_protein_C_prime_carbon(C2,N,O11,Ca1,N11)
           else if (.is_protein_C_alpha(C2,N,Cb,Cp,O1,N1,Ot,Ct)) then
              res = TRUE
              Ca = C2
              if (.has_ring(N,C1,[6,6,6])) N_terminal = TRUE
              if (NOT N_terminal AND present(try)) &
                 N_terminal = NOT .is_protein_C_prime_carbon(C1,N,O11,Ca1,N11)
           end

        end

      ! Three connections to N: Backbone PRO N-C1C2C3 connection
      ! NOTE: this only works if Cp0 is given
      else if (.has_3_connections(N,6,6,6,C1,C2,C3)) then
        if      (C1==Cp0) then; C1 = C2; C2 = C3; C3 = 0
        else if (C2==Cp0) then; C2 = C3; C3 = 0
        else if (C3==Cp0) then; C3 = 0
        end
        if (C3==0) then
           if      (.is_protein_C_alpha(C1,N,Cb,Cp,O1,N1,Ot,Ct)) then
              if (.has_ring(N,C2,[6,6,6])) then
                 Ca = C1
                 res = TRUE
              end
           else if (.is_protein_C_alpha(C2,N,Cb,Cp,O1,N1,Ot,Ct)) then
              if (.has_ring(N,C1,[6,6,6])) then
                 Ca = C2
                 res = TRUE
              end
           end
        end
      end

   end

   is_protein_C_alpha(Ca,N,Cb,Cp,O1,N1,Ot,Ct) result (res)
   ! Return TRUE if "Ca" is the index of a C-alpha atom in the
   ! backbone of a protein. You must supply the connected nitrogen
   ! atom "N". Returned are the index of the beta carbon "Cb", the
   ! index of the next C prime carboxy carbon "Cp", the connected
   ! oxygen atom "O1", and either the next nitrogen in the
   ! backbone "N1", or "Ot" the terminal oxygen in the backbone.
   ! NOTE: this is useful for travelling from N terminal to C terminal
   ! Diagram: N-CaCb-Cp=O1-(N1,Ot,Ct)
      Ca,N :: INT, IN
      Cb,Cp,O1,N1,Ot,Ct :: INT, OUT
      res :: BIN

   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(N>0 AND N<=.dim,"N index out of range")
   ENSURE(Ca>=0 AND Ca<=.dim,"Ca index out of range")

      C1,C2,C3 :: INT

      res = FALSE

      ! GLY N-Ca-Cp connection
      if (.has_2_connections(Ca,N,6,Cp)) then
        if      (.is_CCOO_carbon(Cp,Ca,Ot,O1)) then ! two terminal oxygens
           N1 = 0
           Ct = 0
           Cb = 0
           res = TRUE
        else if (.is_CCON_carbon(Cp,Ca,O1,N1)) then ! Cp has =O and next nitrogen
           Ot = 0
           Ct = 0
           Cb = 0
           res = TRUE
        else if (.is_CCOC_carbon(Cp,Ca,O1,Ct)) then ! terminal methyl
           N1 = 0
           Ot = 0
           Cb = 0
           res = TRUE
        else if (.has_2_connections(Cp,Ca,7,N1)) then ! Cp has no oxygen
           Ot = 0
           Ct = 0
           Cb = 0
           res = TRUE
        end

      ! Any other residue, which of C1 and C2 is Cp?
      else if (.has_3_connections(Ca,N,6,6,C1,C2)) then
        if      (.is_CCOO_carbon(C1,Ca,Ot,O1)) then ! two terminal oxygens
           Cp = C1
           Cb = C2
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C1,Ca,O1,N1)) then ! Cp=C1 has =O and next nitrogen
           Cp = C1
           Cb = C2
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C1,Ca,O1,Ct)) then ! terminal methyl
           Cp = C1
           Cb = C2
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.is_CCOO_carbon(C2,Ca,Ot,O1)) then
           Cp = C2
           Cb = C1
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C2,Ca,O1,N1)) then
           Cp = C2
           Cb = C1
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C2,Ca,O1,Ct)) then ! terminal methyl
           Cp = C2
           Cb = C1
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.has_2_connections(C1,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C1
           Cb = C2
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.has_2_connections(C2,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C2
           Cb = C1
           Ot = 0
           Ct = 0
           res = TRUE
        end

      ! For non-standard branched residues, which of C1, C2, C3 is Cp?
      else if (.has_4_connections(Ca,N,6,C1,C2,C3)) then
        if      (.is_CCOO_carbon(C1,Ca,Ot,O1)) then
           Cp = C1
           Cb = 0
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C1,Ca,O1,N1)) then
           Cp = C1
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C1,Ca,O1,Ct)) then ! terminal methyl
           Cp = C1
           Cb = 0
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.is_CCOO_carbon(C2,Ca,Ot,O1)) then
           Cp = C2
           Cb = 0
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C2,Ca,O1,N1)) then
           Cp = C2
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C2,Ca,O1,Ct)) then ! terminal methyl
           Cp = C2
           Cb = 0
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.is_CCOO_carbon(C3,Ca,Ot,O1)) then
           Cp = C3
           Cb = 0
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C3,Ca,O1,N1)) then
           Cp = C3
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C3,Ca,O1,Ct)) then ! terminal methyl
           Cp = C3
           Cb = 0
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.has_2_connections(C1,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C1
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.has_2_connections(C2,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C2
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.has_2_connections(C3,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C3
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        end
      end
   end

   is_protein_C_prime_carbon(Cp,N,O,Ca,N1) result (res)
   ! Return TRUE if "Cp" is the index of a N-Cp-Ca-N1 carbon, where
   ! "N" is the index of a nitrogen bonded to "Cp". If TRUE, "O",
   ! "Ca" and "N1" are returned as the index of the bonded oxygen,
   ! alpha Carbon and previous nitrogen respectively.
      Cp,N :: INT, IN
      O,Ca,N1 :: INT, OUT
      res :: BIN

   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"Cp index out of range")
   ENSURE( N>=0 AND  N<=.dim," N index out of range")

      Cb,Cb1,s,x,i :: INT
      list :: VEC{INT}*

      x = 6
      s = 7
      O  = 0
      Ca = 0
      N1 = 0
      res = FALSE

      if (.has_3_connections(Cp,N,8,6,O,Ca)) then      ! Cp=ON connection

        res =  .has_1_connection(O,Cp) &
          AND (.has_2_connections(Ca,Cp,7,N1) &
          OR   .has_3_connections(Ca,Cp,7,6,N1,Cb) &
          OR   .has_4_connections(Ca,Cp,s,x,x,N1,Cb,Cb1))

      else if (.has_a_connection(Cp,N)) then           ! Cp has no O connection

       if (.has_Z_connections(Cp,6,list)) then
          do i = 1,list.dim
             Ca = list(i)
             res = .has_2_connections(Ca,Cp,7,N1) &
              OR   .has_3_connections(Ca,Cp,7,6,N1,Cb) &
              OR   .has_4_connections(Ca,Cp,s,x,x,N1,Cb,Cb1)
              if (res) exit
          end
          list.destroy
       end

      end

   end

   is_NCOC_carbon(Cp,N,O,Ca,N1) result (res)
   ! Return TRUE if "Cp" is the index of a N-Cp=O-Ca-N1 carbon, where
   ! "N" is the index of a nitrogen bonded to "Cp". If TRUE, "O",
   ! "Ca" and "N1" are returned as the index of the bonded oxygen,
   ! alpha Carbon and next nitrogen respectively.
      Cp,N :: INT, IN
      O,Ca,N1 :: INT, OUT
      res :: BIN

   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"Cp index out of range")
   ENSURE( N>=0 AND  N<=.dim," N index out of range")

      Cb,Cb1,s,x :: INT

      x = 6
      s = 7
      N1 = 0

      if (.has_3_connections(Cp,N,8,6,O,Ca)) then      ! Cp=ON connection

        res =  .has_1_connection(O,Cp) &
          AND (.has_2_connections(Ca,Cp,7,N1) &
          OR   .has_3_connections(Ca,Cp,7,6,N1,Cb) &
          OR   .has_4_connections(Ca,Cp,s,x,x,N1,Cb,Cb1))

      else

        res = FALSE

      end

   end

   is_CCOO_carbon(Cp,Ca,O1,O2) result (res)
   ! Return TRUE if "Cp" is the index of a Ca-Cp=OO carbon, where "Ca"
   ! is the index of an (alpha) carbon bonded to "Cp". If TRUE, "O1" and
   ! "O2" are returned as the indices of the bonded oxygens.
      Cp,Ca :: INT, IN
      O1,O2 :: INT, OUT
      res :: BIN

   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"Cp index out of range")
   ENSURE(Ca>=0 AND Ca<=.dim,"Ca index out of range")

      if (.has_3_connections(Cp,Ca,8,8,O1,O2)) then      ! Cp=O1O2 connection
        res = .has_1_connection(O1,Cp) AND .has_1_connection(O2,Cp)
      else
        res = FALSE
      end

   end

   is_CCOC_carbon(Cp,Ca,O1,C) result (res)
   ! Return TRUE if "Cp" is the index of a Ca-Cp=OC carbon, where "Ca"
   ! is the index of an (alpha) carbon bonded to "Cp". If TRUE, "O1" and
   ! "C" are returned as the indices of the bonded oxygen and terminal
   ! methyl.
      Cp,Ca :: INT, IN
      O1,C :: INT, OUT
      res :: BIN

   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"Cp index out of range")
   ENSURE(Ca>=0 AND Ca<=.dim,"Ca index out of range")

      if (.has_3_connections(Cp,Ca,8,6,O1,C)) then      ! Cp=O1C connection
        res = .has_1_connection(O1,Cp) AND .has_1_connection(C,Cp)
      else
        res = FALSE
      end

   end

   is_CCON_carbon(Cp,Ca,O1,N1) result (res)
   ! Return TRUE if "Cp" is the index of a Ca-Cp=ON carbon, where "Ca"
   ! is the index of an (alpha) carbon bonded to "Cp". If TRUE, "O1" and
   ! "N1" are returned as the indices of the bonded oxygen and
   ! nitrogen atom.
      Cp,Ca :: INT, IN
      O1,N1 :: INT, OUT
      res :: BIN

   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"C index out of range")

      res = .has_3_connections(Cp,Ca,8,7,O1,N1)

   end

!  =================
!  Connection tables
!  =================

   make_connection_table(skip_hydrogen) ::: leaky
   ! Make the atom connection table "connections_for".  If
   ! "skip_hydrogen" is present and TRUE, connections are not made to
   ! any hydrogen atom.
      skip_hydrogen :: BIN, optional

      r :: REAL

      if (connections_for.created) return

      r = 0.5d0
      r.convert_from("angstrom")
      ATOM:set_atom_bonded_range_factor(r)
      .make_connection_table(connections_for,skip_hydrogen)

   end

   make_connection_table(connections_for,skip_hydrogen) ::: leaky, PURE
   ! Make the atom connection table "connections_for".  If
   ! "skip_hydrogen" is present and TRUE, connections are not made to
   ! any hydrogen atom.
      self :: IN
      connections_for :: VEC{VEC_{INT}}*
      skip_hydrogen :: BIN, optional, IN

      i,j :: INT
      skip_H :: BIN

      skip_H = FALSE
      if (present(skip_hydrogen)) skip_H = skip_hydrogen

      connections_for.create(.dim,0)

      do i = 1,.dim

        if (skip_H) then
           if (self(i).atomic_number==1) cycle
        end

        do j = i+1,.dim
           if (skip_H) then
              if (self(j).atomic_number==1) cycle
           end
           if (NOT self(i).is_bonded_to(self(j))) cycle
           connections_for(i).element.append(j)
           connections_for(j).element.append(i)
        end

      end

   end

!  =====================
!  Atom connection tests
!  =====================

   has_a_connection(X,W) result (res)
   ! Returns TRUE if the atom with index "X" is connected to the atom
   ! with index "W".
      X,W :: INT, IN
      res :: BIN

   DIE_IF(X<1 OR X>.dim,"X index out of range")
   ENSURE(W>0 AND W<=.dim,"W index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      res = any(connections_for(X)[:]==W)

   end

   has_Z_connection(X,Z) result (res)
   ! Returns TRUE if the atom with index "X" is connected to an atom
   ! with atomic number "Z".
      X,Z :: INT, IN
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      res = any(self(connections_for(X)[:]).atomic_number==Z)

   end

   has_Z_connections(X,Z,list) result (res) ::: leaky
   ! Return "TRUE" if atom "X" has connections to atoms with atomic
   ! number "Z", and if so, return a "list" of the atom indices.
      X,Z :: INT, IN
      list :: VEC{INT}*
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      nx,i,Y :: INT

      res = FALSE
      nx = connections_for(X).element.dim

      if (nx==0) return

      list.create(0)
      do i = 1,nx
        Y = connections_for(X)[i]            ! Index of atom connected to X
        if (self(Y).atomic_number/=Z) cycle  ! Y must have atomic number Z
        list.append(Y)
      end

      res = list.created

   end

   has_0_connections(X) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" no connection
      X :: INT, IN
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")

      if (connections_for.destroyed) .make_connection_table
      res = connections_for(X).element.dim == 0

   end

   has_1_connection(X) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" only has one connection
      X :: INT, IN
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")

      if (connections_for.destroyed) .make_connection_table
      res = connections_for(X).element.dim == 1

   end

   has_1_connection(X,Y) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" only has one connection
   ! to an atom with index "Y".
      X,Y :: INT, IN
      res :: BIN

   DIE_IF(X<1 OR X>.dim,"X index out of range")
   ENSURE(Y>0 AND Y<=.dim,"Y index out of range")

      if (connections_for.destroyed) .make_connection_table

      res = connections_for(X).element.dim == 1
      if (NOT res) return

      res = connections_for(X)[1] == Y

   end

   has_1_connection(X,Z,Y) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" only has one connection
   ! to an atom with atomic number "Z".If there is a connection, return
   ! the index of the connected atom in "Y".
      X,Z :: INT, IN
      Y   :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")

      nx :: INT

      if (connections_for.destroyed) .make_connection_table

      res = FALSE
      nx = connections_for(X).element.dim
      if (nx/=1) return

      Y = connections_for(X)[1]
      if (self(Y).atomic_number/=Z) then
        Y = 0
      else
        res = TRUE
      end

   end

   has_2_connections(X) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has two connections
      X :: INT, IN
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")

      if (connections_for.destroyed) .make_connection_table
      res = connections_for(X).element.dim == 2

   end

   has_2_connections(X,Y1,Y2) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has two connections:
   ! one to the atom with index "Y1", the other to the atom with
   ! index "Y2".
      X,Y1,Y2 :: INT, IN
      res :: BIN

   DIE_IF(X<1 OR X>.dim,"X index out of range")

      if (connections_for.destroyed) .make_connection_table

      res = connections_for(X).element.dim == 2
      if (NOT res) return
      res = (connections_for(X)[1]==Y1 AND connections_for(X)[2]==Y2) &
         OR (connections_for(X)[2]==Y1 AND connections_for(X)[1]==Y2)
   end

   has_2_connections(X,Z1,Z2,Y1,Y2) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has two connections:
   ! one to an atom with atomic number "Z1", the other to an atom with
   ! atomic number "Z2". If there are connectons, return the indices
   ! of these atoms as "Y1" and "Y2" respectively.
      X,Z1,Z2 :: INT, IN
      Y1,Y2 :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")

      A1,A2 :: INT

      if (connections_for.destroyed) .make_connection_table

      Y1 = 0
      Y2 = 0
      res = FALSE
      if (connections_for(X).element.dim/=2) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]
      if      (self(A1).atomic_number==Z1 AND self(A2).atomic_number==Z2) then
        Y1 = A1
        Y2 = A2
        res = TRUE
      else if (self(A2).atomic_number==Z1 AND self(A1).atomic_number==Z2) then
        Y1 = A2
        Y2 = A1
        res = TRUE
      end
   end

   has_2_connections(X,W,Z,Y) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has two connections:
   ! one to the atom with index "W", the other to an atom with atomic
   ! number "Z".If there is a latter connection, return the index of
   ! atom with atomic number "Z" in "Y".
      X,W,Z :: INT, IN
      Y :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(W>0 AND W<=.dim,"W index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      nx,Y1,Y2 :: INT

      if (connections_for.destroyed) .make_connection_table

      Y = 0
      res = FALSE
      nx = connections_for(X).element.dim
      if (nx/=2) return

      Y1 = connections_for(X)[1]
      Y2 = connections_for(X)[2]
      if      (Y1==W AND self(Y2).atomic_number==Z) then
        Y = Y2
        res = TRUE
      else if (Y2==W AND self(Y1).atomic_number==Z) then
        Y = Y1
        res = TRUE
      end
   end

   has_3_connections(X) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has three connections
      X :: INT, IN
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")

      if (connections_for.destroyed) .make_connection_table
      res = connections_for(X).element.dim==3

   end

   has_3_connections(X,Z1,Z2,Z3,Y1,Y2,Y3) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has three connections:
   ! to atoms with atomic numbers "Z1", "Z2" and "Z3" with the atom
   ! indices returned in "Y1", "Y2" and "Y3".
      X,Z1,Z2,Z3 :: INT, IN
      Y1,Y2,Y3 :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")

      A1,A2,A3,N1,N2,N3 :: INT

      if (connections_for.destroyed) .make_connection_table

      Y1 = 0
      Y2 = 0
      Y3 = 0
      res = FALSE

      if (connections_for(X).element.dim/=3) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]
      A3 = connections_for(X)[3]

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number

      if      (Z1==N1 AND Z2==N2 AND Z3==N3) then; Y1=A1; Y2=A2; Y3=A3; res = TRUE
      else if (Z1==N1 AND Z2==N3 AND Z3==N2) then; Y1=A1; Y2=A3; Y3=A2; res = TRUE
      else if (Z1==N2 AND Z2==N1 AND Z3==N3) then; Y1=A2; Y2=A1; Y3=A3; res = TRUE
      else if (Z1==N2 AND Z2==N3 AND Z3==N1) then; Y1=A2; Y2=A3; Y3=A1; res = TRUE
      else if (Z1==N3 AND Z2==N1 AND Z3==N2) then; Y1=A3; Y2=A1; Y3=A2; res = TRUE
      else if (Z1==N3 AND Z2==N2 AND Z3==N1) then; Y1=A3; Y2=A2; Y3=A1; res = TRUE
      end

   end

   has_3_connections(X,W,Z1,Z2,Y1,Y2) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has three connections:
   ! one to the atom with index "W", the other two to atoms with atomic
   ! numbers "Z1" and "Z2".If there are these latter connections,
   ! return the indices of atoms with atomic numbers "Z1" and "Z2"
   ! in "Y1" and "Y2".
      X,W,Z1,Z2 :: INT, IN
      Y1,Y2 :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(W>0 AND W<=.dim,"W index out of range")

      A1,A2,A3,N1,N2,N3 :: INT

      if (connections_for.destroyed) .make_connection_table

      Y1 = 0
      Y2 = 0
      res = FALSE

      if (connections_for(X).element.dim/=3) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]
      A3 = connections_for(X)[3]

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number

      if      (A1==W AND Z1==N2 AND Z2==N3) then; Y1=A2; Y2=A3; res = TRUE
      else if (A1==W AND Z1==N3 AND Z2==N2) then; Y1=A3; Y2=A2; res = TRUE
      else if (A2==W AND Z1==N1 AND Z2==N3) then; Y1=A1; Y2=A3; res = TRUE
      else if (A2==W AND Z1==N3 AND Z2==N1) then; Y1=A3; Y2=A1; res = TRUE
      else if (A3==W AND Z1==N1 AND Z2==N2) then; Y1=A1; Y2=A2; res = TRUE
      else if (A3==W AND Z1==N2 AND Z2==N1) then; Y1=A2; Y2=A1; res = TRUE
      end

   end

   has_3_connections(X,V,W,Z,Y) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has three connections:
   ! two to atoms "V" and "W", and one to an atom with atomic
   ! numbers "Z".If there is this latter connection, return the
   ! index of this atom in "Y".
      X,V,W,Z :: INT, IN
      Y :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(V>0 AND V<=.dim,"V index out of range")
   ENSURE(W>0 AND W<=.dim,"W index out of range")

      A1,A2,A3,N1,N2,N3 :: INT

      if (connections_for.destroyed) .make_connection_table

      Y = 0
      res = FALSE

      if (connections_for(X).element.dim/=3) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]
      A3 = connections_for(X)[3]

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number

      if      (A1==V AND A2==W  AND Z==N1) then; Y=A1; res = TRUE
      else if (A1==W AND A2==V  AND Z==N1) then; Y=A1; res = TRUE
      else if (A1==V AND A2==W  AND Z==N2) then; Y=A2; res = TRUE
      else if (A1==W AND A2==V  AND Z==N2) then; Y=A2; res = TRUE
      else if (A1==V AND A2==W  AND Z==N3) then; Y=A3; res = TRUE
      else if (A1==W AND A2==V  AND Z==N3) then; Y=A3; res = TRUE
      end

   end

   has_4_connections(X) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has four connections
      X :: INT, IN
      res :: BIN

   DIE_IF(X<1 OR X>.dim,"X index out of range")

      if (connections_for.destroyed) .make_connection_table
      res = connections_for(X).element.dim==4

   end

   has_4_connections(X,W,Z1,Z2,Z3,Y1,Y2,Y3) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has four connections: one
   ! to the atom with index "W", the other three to atoms with atomic
   ! numbers "Z1", "Z2" and "Z3".If there are these latter
   ! connections, return the indices of atoms with thse atomic numbers
   ! in "Y1", "Y2" and "Y3" respectively.
      X,W,Z1,Z2,Z3 :: INT, IN
      Y1,Y2,Y3 :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(W>0 AND W<=.dim,"W index out of range")

      A1,A2,A3,A4,N1,N2,N3,N4 :: INT

      if (connections_for.destroyed) .make_connection_table

      Y1 = 0
      Y2 = 0
      Y3 = 0
      res = FALSE

      if (connections_for(X).element.dim/=4) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]
      A3 = connections_for(X)[3]
      A4 = connections_for(X)[4]

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number
      N4 = self(A4).atomic_number

      if      (A1==W AND Z1==N2 AND Z2==N3 AND Z3==N4) then; Y1=A2; Y2=A3; Y3=A4; res = TRUE
      else if (A1==W AND Z1==N2 AND Z2==N4 AND Z3==N3) then; Y1=A2; Y2=A4; Y3=A3; res = TRUE
      else if (A1==W AND Z1==N3 AND Z2==N2 AND Z3==N4) then; Y1=A3; Y2=A2; Y3=A4; res = TRUE
      else if (A1==W AND Z1==N3 AND Z2==N4 AND Z3==N2) then; Y1=A3; Y2=A4; Y3=A2; res = TRUE
      else if (A1==W AND Z1==N4 AND Z2==N2 AND Z3==N3) then; Y1=A4; Y2=A2; Y3=A3; res = TRUE
      else if (A1==W AND Z1==N4 AND Z2==N3 AND Z3==N2) then; Y1=A4; Y2=A3; Y3=A2; res = TRUE
      else if (A2==W AND Z1==N1 AND Z2==N3 AND Z3==N4) then; Y1=A1; Y2=A3; Y3=A4; res = TRUE
      else if (A2==W AND Z1==N1 AND Z2==N4 AND Z3==N3) then; Y1=A1; Y2=A4; Y3=A3; res = TRUE
      else if (A2==W AND Z1==N3 AND Z2==N1 AND Z3==N4) then; Y1=A3; Y2=A1; Y3=A4; res = TRUE
      else if (A2==W AND Z1==N3 AND Z2==N4 AND Z3==N1) then; Y1=A3; Y2=A4; Y3=A1; res = TRUE
      else if (A2==W AND Z1==N4 AND Z2==N1 AND Z3==N3) then; Y1=A4; Y2=A1; Y3=A3; res = TRUE
      else if (A2==W AND Z1==N4 AND Z2==N3 AND Z3==N1) then; Y1=A4; Y2=A3; Y3=A1; res = TRUE
      else if (A3==W AND Z1==N2 AND Z2==N1 AND Z3==N4) then; Y1=A2; Y2=A1; Y3=A4; res = TRUE
      else if (A3==W AND Z1==N2 AND Z2==N4 AND Z3==N1) then; Y1=A2; Y2=A4; Y3=A1; res = TRUE
      else if (A3==W AND Z1==N1 AND Z2==N2 AND Z3==N4) then; Y1=A1; Y2=A2; Y3=A4; res = TRUE
      else if (A3==W AND Z1==N1 AND Z2==N4 AND Z3==N2) then; Y1=A1; Y2=A4; Y3=A2; res = TRUE
      else if (A3==W AND Z1==N4 AND Z2==N2 AND Z3==N1) then; Y1=A4; Y2=A2; Y3=A1; res = TRUE
      else if (A3==W AND Z1==N4 AND Z2==N1 AND Z3==N2) then; Y1=A4; Y2=A1; Y3=A2; res = TRUE
      else if (A4==W AND Z1==N2 AND Z2==N3 AND Z3==N1) then; Y1=A2; Y2=A3; Y3=A1; res = TRUE
      else if (A4==W AND Z1==N2 AND Z2==N1 AND Z3==N3) then; Y1=A2; Y2=A1; Y3=A3; res = TRUE
      else if (A4==W AND Z1==N3 AND Z2==N2 AND Z3==N1) then; Y1=A3; Y2=A2; Y3=A1; res = TRUE
      else if (A4==W AND Z1==N3 AND Z2==N1 AND Z3==N2) then; Y1=A3; Y2=A1; Y3=A2; res = TRUE
      else if (A4==W AND Z1==N1 AND Z2==N2 AND Z3==N3) then; Y1=A1; Y2=A2; Y3=A3; res = TRUE
      else if (A4==W AND Z1==N1 AND Z2==N3 AND Z3==N2) then; Y1=A1; Y2=A3; Y3=A2; res = TRUE
      end

   end

   has_4_connections(X,W,Z,Y1,Y2,Y3) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has four connections: one
   ! to the atom with index "W", the other three to atoms with atomic
   ! number "Z".If there are these latter connections, return the
   ! indices of atoms with this atomic number in "Y1", "Y2" and "Y3"
   ! respectively.
      X,W,Z :: INT, IN
      Y1,Y2,Y3 :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(W>0 AND W<=.dim,"W index out of range")

      A1,A2,A3,A4,N1,N2,N3,N4 :: INT

      if (connections_for.destroyed) .make_connection_table

      Y1 = 0
      Y2 = 0
      Y3 = 0
      res = FALSE

      if (connections_for(X).element.dim/=4) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]
      A3 = connections_for(X)[3]
      A4 = connections_for(X)[4]

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number
      N4 = self(A4).atomic_number

      if      (A1==W AND Z==N2 AND Z==N3 AND Z==N4) then; Y1=A2; Y2=A3; Y3=A4; res = TRUE
      else if (A2==W AND Z==N1 AND Z==N3 AND Z==N4) then; Y1=A1; Y2=A3; Y3=A4; res = TRUE
      else if (A3==W AND Z==N2 AND Z==N1 AND Z==N4) then; Y1=A2; Y2=A1; Y3=A4; res = TRUE
      else if (A4==W AND Z==N2 AND Z==N3 AND Z==N1) then; Y1=A2; Y2=A3; Y3=A1; res = TRUE
      end

   end

   has_ring(A,B,Z,R) result (res) ::: leaky
   ! Return TRUE if the atoms with indices "A" and "B" form part of a
   ! single connection ring of atoms whose atomic numbers after atom
   ! "B" are given in "Z". NOTE: "A" need not be single connected.
      A,B :: INT, IN
      Z :: VEC{INT}, IN
      R :: VEC{INT}, OUT, optional
      res :: BIN

   ENSURE(A>=0 AND A<=.dim,"A index out of range")
   ENSURE(B>=0 AND B<=.dim,"A index out of range")
   ENSURE(Z.dim>0,"Z array too small")

      i,W,X,Y :: INT

      if (connections_for.destroyed) .make_connection_table

      W = A
      X = B
      do i = 1,Z.dim
        res = .has_2_connections(X,W,Z(i),Y)
        if (NOT res) return
        if (present(R)) R(i) = Y
        W = X
        X = Y
      end
      res = .has_a_connection(X,A)

   end

   has_chain(A,B,Z,C) result (res) ::: leaky
   ! Return TRUE if the atoms with indices "A" and "B" form part of a
   ! single connection chain of atoms whose atomic numbers after atom
   ! "B" are given in "Z".
      A,B :: INT, IN
      Z :: VEC{INT}, IN
      C :: VEC{INT}, OUT, optional
      res :: BIN

   ENSURE(A>=0 AND A<=.dim,"A index out of range")
   ENSURE(B>=0 AND B<=.dim,"A index out of range")
   ENSURE(Z.dim>0,"Z array too small")

      i,W,X,Y :: INT

      if (connections_for.destroyed) .make_connection_table

      res = FALSE

      W = A
      X = B
      do i = 1,Z.dim
        res = .has_2_connections(X,W,Z(i),Y)
        if (NOT res) return
        if (present(C)) C(i) = Y
        W = X
        X = Y
      end

   end

!  ====================
!  Amino acid detectors
!  ====================

   put_protein_sequence ::: leaky
   ! Return the "backbone" of atom indices in each protein backbone.

      backbone :: VEC{VEC_{INT}}*
      terminal :: VEC{INT}*
      N_terminal :: BIN
      i, N,Cp0,Ca,Cb,Cp,N1,Ot,Ct :: INT

      .make_connection_table(skip_hydrogen=TRUE)

      .find_N_terminal_atoms(terminal)

      backbone.create(terminal.dim,1)

      do i = 1,terminal.dim

        N = terminal(i)
        backbone(i)[1] = N
        Cp0 = 0

        stdout.show("Sequence for protein strand =",i)

        do

           if (NOT .is_protein_backbone_N(N,Cp0,Ca,Cb,Cp,N1,Ot,Ct,N_terminal,try=TRUE)) exit

           if      (Ot/=0) then
              backbone(i).element.append([Ca,Cp,Ot])
              exit
           else if (Ct/=0) then
              backbone(i).element.append([Ca,Cp,Ct])
              exit
           else
              backbone(i).element.append([Ca,Cp,N1])
              N = N1
              Cp0 = Cp
           end

           if (Cb==0) then; stdout.text("GLY")
           else;            stdout.text(.protein_side_chain_3_code(Ca,Cb))
           end

        end

      end

      terminal.destroy
      backbone.destroy
      connections_for.destroy

   end

!   find_protein_backbone_from_N(N,C,found,Ca,Cc,N1,Ot)
!   ! Given the index "N" of a nitrogen atom and possibly the index "C"
!   ! of a connected carbon atom, return "found" as TRUE if that
!   ! nitrogen atom is part of a protein backbone. Also return the
!   ! index "Ca" of the C-alpha carbon, the index "Cc" of the C-carboxy
!   ! carbon, and either "N1" the next nitrogen in the backbone, or
!   ! "Ot" the terminal oxygen in the backbone. This assumes a
!   ! connection table has been made.
!     N,C :: INT, IN
!     found :: BIN, OUT
!     Ca,Cc,N1,Ot :: INT, OUT
!
!   ENSURE(connections_for.created,"no connection table")
!   ENSURE(connections_for.dim==.dim,"wrong size connection table")
!   ENSURE(N>0 AND N<=.dim,"N index out of range")
!   ENSURE(self(N).atomic_number==7,"N is not the index of a nitrogen atom")
!   ENSURE(C>=0 AND C<=.dim,"C index out of range")
!
!     nn,na,ia,nc,ic,O2,X :: INT
!
!     ! Set defaults
!     found = FALSE
!     Ca = 0; Cc = 0; N1 = 0; Ot = 0
!
!     ! Check if C is bonded to N
!     if (C>0) then
!        DIE_IF(NOT self(N).is_bonded_to(self(C)),"N is not bonded to C")
!     end
!
!     ! # of connections for N
!     nn = connections_for(N).element.dim
!
!     ! A backbone N must have 1 connection and can't have
!     ! more than 2 connections
!     if (nn<=0) return
!     if (nn >2) return
!
!     ! Get the index of C-alpha atom
!     Ca = connections_for(N)[1]
!     if (Ca==C) then
!        DIE_IF(nn<2,"not enough connections to N = "//trim(N.to_str))
!        Ca = connections_for(N)[2]
!     end
!
!     ! C-alpha must be a carbon
!     if (self(Ca).atomic_number/=6) return
!
!     ! # of  connections for C-alpha
!     na = connections_for(Ca).element.dim
!
!     ! C-alpha must have 2 connections (GLY) or 3 connections
!     if (na/=3 AND na/=2) return
!
!     ! Now find C-carboxy carbon
!     do ia = 1,na
!        Cc = connections_for(Ca)[ia]          ! Index of C-carboxy
!        if (Cc==N) cycle                      ! Cc can't be the first N
!        if (self(Cc).atomic_number/=6) cycle  ! Cc must be a carbon
!        nc = connections_for(Cc).element.dim
!        if (nc/=3) cycle                      ! C-carboxy must have 3 connections
!        O2 = 0                                ! It must have a =O
!        N1 = 0                                ! It must have a -N, or
!        Ot = 0                                ! It must have a terminal -OH
!        do ic = 1,nc
!           X = connections_for(Cc)[ic]
!           if (X==Ca) cycle
!           if (self(X).atomic_number==7) N1 = X
!           if (self(X).atomic_number==8) then
!              if (Ot==0) then; O2 = X
!              else;            Ot = X
!              end
!           end
!        end
!        found = O2/=0 AND (N1/=0 OR Ot/=0)
!        if (found) exit
!     end
!   end

   protein_side_chain_3_code(Ca,Cb) result (res)
   ! Returns the 3 letter code for a side chain connected at carbon
   ! atoms "Ca" and "Cb".
      Ca,Cb :: INT, IN
      res :: STR
   ENSURE(Ca>=0 AND Ca<=.dim,"Ca index out of range")
   ENSURE(Cb>=0 AND Cb<=.dim,"Cb index out of range")
   ENSURE(self(Ca).atomic_number==6,"must suppy index of alpha carbon atom")
   ENSURE(self(Cb).atomic_number==6,"must suppy index of beta carbon atom")
      if      (.has_ALA(Ca,Cb)) then; res = "ALA"
      else if (.has_ARG(Ca,Cb)) then; res = "ARG"
      else if (.has_ASN(Ca,Cb)) then; res = "ASN"
      else if (.has_ASP(Ca,Cb)) then; res = "ASP"
      else if (.has_CYS(Ca,Cb)) then; res = "CYS"
      else if (.has_GLN(Ca,Cb)) then; res = "GLN"
      else if (.has_GLU(Ca,Cb)) then; res = "GLU"
      else if (.has_HIS(Ca,Cb)) then; res = "HIS"
      else if (.has_ILE(Ca,Cb)) then; res = "ILE"
      else if (.has_LEU(Ca,Cb)) then; res = "LEU"
      else if (.has_LYS(Ca,Cb)) then; res = "LYS"
      else if (.has_MET(Ca,Cb)) then; res = "MET"
      else if (.has_PHE(Ca,Cb)) then; res = "PHE"
      else if (.has_SER(Ca,Cb)) then; res = "SER"
      else if (.has_THR(Ca,Cb)) then; res = "THR"
      else if (.has_TRP(Ca,Cb)) then; res = "TRP"
      else if (.has_TYR(Ca,Cb)) then; res = "TYR"
      else if (.has_VAL(Ca,Cb)) then; res = "VAL"
      else;                           res = "UNK"
      end
   end

   has_ALA(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ALA
      Ca,Cb :: INT, IN
      res :: BIN
      res = .has_1_connection(Cb,Ca)
   end

   has_ARG(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ARG
      Ca,Cb :: INT, IN
      res :: BIN
      C :: VEC{INT}(4)
      Nz1,Nz2 :: INT
      res = .has_chain(Ca,Cb,[6,6,7,6],C)
      if (NOT res) return
      res = .has_3_connections(C(4),C(3),7,7,Nz1,Nz2)
      if (NOT res) return
      res = .has_1_connection(Nz1,C(4))
      if (NOT res) return
      res = .has_1_connection(Nz2,C(4))
   end

   has_ASN(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ASN
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Og,Ng :: INT
      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,6,7,Og,Ng)
      if (NOT res) return
      res = .has_1_connection(Og,Cg)
      if (NOT res) return
      res = .has_1_connection(Ng,Cg)
   end

   has_ASP(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ASP
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Og1,Og2 :: INT
      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,6,7,Og1,Og2)
      if (NOT res) return
      res = .has_1_connection(Og1,Cg)
      if (NOT res) return
      res = .has_1_connection(Og2,Cg)
   end

   has_CYS(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes CYS
      Ca,Cb :: INT, IN
      res :: BIN
      Sg :: INT
      res = .has_2_connections(Cb,Ca,16,Sg)
      if (NOT res) return
      res = .has_1_connection(Sg,Cb)
   end

   has_GLN(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes GLN
      Ca,Cb :: INT, IN
      res :: BIN
      C :: VEC{INT}(2)
      Ne,Oe :: INT
      res = .has_chain(Ca,Cb,[6,6],C)
      if (NOT res) return
      res = .has_3_connections(C(2),C(1),8,7,Oe,Ne)
      if (NOT res) return
      res = .has_1_connection(Ne,C(2))
      if (NOT res) return
      res = .has_1_connection(Oe,C(2))
   end

   has_GLU(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes GLU
      Ca,Cb :: INT, IN
      res :: BIN
      C :: VEC{INT}(2)
      Oe1,Oe2 :: INT
      res = .has_chain(Ca,Cb,[6,6],C)
      if (NOT res) return
      res = .has_3_connections(C(2),C(1),8,8,Oe1,Oe2)
      if (NOT res) return
      res = .has_1_connection(Oe1,C(2))
      if (NOT res) return
      res = .has_1_connection(Oe2,C(2))
   end

   has_HIS(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes HIS
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Nd,Cd :: INT
      res = .has_2_connections(Cb,Ca,16,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,7,6,Nd,Cd)
      if (NOT res) return
      res = .has_ring(Cg,Nd,[6,7,6])
   end

   has_ILE(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ILE
      Ca,Cb :: INT, IN
      res :: BIN
      Cg1,Cg2,Cd :: INT
      res = .has_3_connections(Cb,Ca,6,6,Cg1,Cg2)
      if (NOT res) return
      if      (.has_1_connection(Cg1,Cb)) then
        res = .has_2_connections(Cg2,Cb,6,Cd)
        if (NOT res) return
        res = .has_1_connection(Cd,Cg2)
      else if (.has_1_connection(Cg2,Cb)) then
        res = .has_2_connections(Cg1,Cb,6,Cd)
        if (NOT res) return
        res = .has_1_connection(Cd,Cg1)
      else
        res = FALSE
      end
   end

   has_LEU(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes LEU
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Cd1,Cd2 :: INT
      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,6,7,Cd1,Cd2)
      if (NOT res) return
      res = .has_1_connection(Cd1,Cg)
      if (NOT res) return
      res = .has_1_connection(Cd2,Cg)
   end

   has_LYS(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes LYS
      Ca,Cb :: INT, IN
      res :: BIN
      C :: VEC{INT}(4)
      res = .has_chain(Ca,Cb,[6,6,6,7],C)
      if (NOT res) return
      res = .has_1_connection(C(4),C(3))
   end

   has_MET(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes MET
      Ca,Cb :: INT, IN
      res :: BIN
      C :: VEC{INT}(3)
      res = .has_chain(Ca,Cb,[6,16,6],C)
      if (NOT res) return
      res = .has_1_connection(C(3),C(2))
   end

   has_PHE(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes PHE
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Cd1,Cd2 :: INT
      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,6,6,Cd1,Cd2)
      if (NOT res) return
      res = .has_ring(Cg,Cd1,[6,6,6,6])
   end

   has_SER(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes SER
      Ca,Cb :: INT, IN
      res :: BIN
      Og :: INT
      res = .has_2_connections(Cb,Ca,8,Og)
      if (NOT res) return
      res = .has_1_connection(Og,Cb)
   end

   has_THR(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes THR
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Og :: INT
      res = .has_3_connections(Cb,Ca,6,8,Cg,Og)
      if (NOT res) return
      res = .has_1_connection(Cg,Cb)
      if (NOT res) return
      res = .has_1_connection(Og,Cb)
   end

   has_TRP(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes TRP
      Ca,Cb :: INT, IN
      res :: BIN
      C :: VEC{INT}(4)
      Cg,Cd1,Cd2,Ne,Ce1,Cf1 :: INT
      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,6,6,Cd1,Cd2)
      if (NOT res) return
      if      (.has_2_connections(Cd1,Cg,7,Ne)) then
        res = .has_2_connections(Ne,Cd1,6,Ce1)
        if (NOT res) return
        res = .has_3_connections(Ce1,Ne,Cd2,6,Cf1)
        if (NOT res) return
        res = .has_chain(Ce1,Cf1,[6,6,6,6],C)
        if (NOT res) return
        res = C(4)==Cd2
      else if (.has_2_connections(Cd2,Cg,7,Ne)) then
        res = .has_2_connections(Ne,Cd2,6,Ce1)
        if (NOT res) return
        res = .has_3_connections(Ce1,Ne,Cd1,6,Cf1)
        if (NOT res) return
        res = .has_chain(Ce1,Cf1,[6,6,6,6],C)
        if (NOT res) return
        res = C(4)==Cd1
      else
        res = FALSE
      end
   end

   has_TYR(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes TYR
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Cd1,Cd2,Ce1,Ce2,Cz,Oz :: INT
      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,6,6,Cd1,Cd2)
      if (NOT res) return
      res = .has_2_connections(Cd1,Cg,6,Ce1)
      if (NOT res) return
      res = .has_2_connections(Cd2,Cg,6,Ce2)
      if (NOT res) return
      res = .has_2_connections(Ce1,Cg,6,Cz)
      if (NOT res) return
      res = .has_2_connections(Ce2,Cg,6,Cz)
      if (NOT res) return
      res = .has_3_connections(Cz,Ce1,Ce2,8,Oz)
      if (NOT res) return
      res = .has_1_connection(Oz,Cz)
   end

   has_VAL(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes THR
      Ca,Cb :: INT, IN
      res :: BIN
      Cg1,Cg2 :: INT
      res = .has_3_connections(Cb,Ca,6,6,Cg1,Cg2)
      if (NOT res) return
      res = .has_1_connection(Cg1,Cb)
      if (NOT res) return
      res = .has_1_connection(Cg2,Cb)
   end

!  ========================
!  Bonds, distances, angles
!  ========================

   nearest_atom_to(pos) result (res) ::: pure
   ! Return the index of the nearest atom to point "pos".
      self :: IN
      pos :: VEC{REAL}(3), IN
      res :: INT

      a :: INT
      dpos :: VEC{REAL}(3)
      dmin,dist :: REAL

      res = 1

      dmin = huge(ONE)
      do a = 1,.dim

         dpos = pos - self(a).position
         dist = dpos.norm

         if (dist<dmin) then
            dmin = dist
            res  = a
         end

      end

   end

   bonded(a,b,range_factor,H_bonded) result (res) ::: pure
   ! Return true if "self" is bonded to "b".  If present, "range_factor" is used
   ! to determine the distance range in which the atoms are regarded as bonded.
   ! This uses the CCDC method, as documented on their web page.
      self :: IN
      a,b :: INT, IN
      range_factor :: REAL, IN, optional
      H_bonded :: BIN, IN, optional
      res :: BIN

      res = self(a).is_bonded_to(self(b),range_factor)

      ! Check if H-bobds are to be considered
      if (present(H_bonded)) then
      if (H_bonded) then
      if (NOT res) then
      if (self(a).atomic_number==1 OR self(b).atomic_number==1) then
         res = self(a).is_vdw_bonded_to(self(b),range_factor)
      end
      end
      end
      end

   end

   vdw_bonded(a,b,range_factor,vdw_range_pc) result (res)
   ! Return true if "a" is vdw bonded to "b". Atoms which are
   ! covalently bonded are not vand-der-waals bonded.  If present,
   ! "range_factor" is used to determine the distance range in which
   ! the atoms are regarded as covalent bonded. If present
   ! "vdw_range_pc" is the percentage increase in the vdw radius to be
   ! tolerated while still regarding the atoms vdw bonded (default
   ! 10%). This uses the CCDC method, as documented on their web page.
      a,b :: INT, IN
      range_factor,vdw_range_pc :: REAL, optional, IN
      res :: BIN
      res = self(a).is_vdw_bonded_to(self(b),range_factor,vdw_range_pc)
   end

   is_vdw_bonded_to(list,range_factor,vdw_range_pc) result (res)
   ! Return true if "self" has any atom vdw bonded to "list".
      self :: IN
      list :: VEC{ATOM}, IN
      range_factor,vdw_range_pc :: REAL, optional, IN
      res :: BIN

      a,b :: INT

      res = FALSE
      do a = 1,.dim
      do b = 1,list.dim
         res = self(a).is_vdw_bonded_to(list(b),range_factor,vdw_range_pc)
         if (res) exit
      end
      end

   end

   are_nearby(a,b,dist) result (res) ::: pure
   ! Return whether atoms "a" and "b" are nearby, i.e. within length "dist".
      self :: IN
      a,b :: INT, IN
      dist :: REAL, IN
      res :: BIN

      tmp :: VEC{REAL}(3)
      r2 :: REAL

      tmp = self(a).position - self(b).position
      tmp = abs(tmp)
      if      (tmp(1)>dist) then; res = FALSE
      else if (tmp(2)>dist) then; res = FALSE
      else if (tmp(3)>dist) then; res = FALSE
      else
         r2 = dot_product(tmp,tmp)
         res = (r2 < dist*dist)
      end

   end

   connected(a,b,c,d) result (res)
   ! Return true if atoms "a" "b" "c" and "d" are connected together
      a,b,c,d :: INT, IN
      res :: BIN

      res = .bonded(a,b) OR .bonded(a,c) OR .bonded(a,d)
      res = res AND ( .bonded(b,a) OR .bonded(b,c) OR .bonded(b,d) )
      res = res AND ( .bonded(c,a) OR .bonded(c,b) OR .bonded(c,d) )
      res = res AND ( .bonded(d,a) OR .bonded(d,b) OR .bonded(d,c) )

   end


   no_of_bonds(H_bonded) result (res)
   ! Return the number of bonded atoms
      H_bonded :: BIN, IN, optional
      res :: INT

      a,b :: INT

      res = 0

      do a = 1,.dim
      do b = 1,a-1
         if (.bonded(a,b,H_bonded=H_bonded)) res = res + 1
      end
      end

   end

   bond_distance(a,b,angstrom) result (res)
   ! Return the bond distance between atoms "a" and "b"
      a,b :: INT, IN
      res :: REAL
      angstrom :: BIN, optional, IN

      rab :: VEC{REAL}(3)
      change :: BIN

      rab = self(b).position - self(a).position
      res = sqrt(rab(1)*rab(1) + rab(2)*rab(2) + rab(3)*rab(3))

      change = FALSE
      if (present (angstrom)) change = angstrom
      if (change) res = res * STR:conversion_factor("angstrom")

   end


   no_of_angles result (res) ::: pure
   ! Return the number of angles within bond contact distance
      self :: IN
      res :: INT

      n,a,b,c :: INT

      n = .dim

      res = 0

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle

            res = res + 1

         end

      end
      end

   end

   bond_angle(a,b,c,degrees) result (res)
   ! Return the bond angle between atoms "a" , "b" and "c".
   ! The central atom is "b". The angle is calculated as
   ! arccos(nba.nbc) . If "degrees" is present and TRUE,
   ! result is in degrees.
      a,b,c :: INT, IN
      degrees :: BIN, optional, IN

      res :: REAL
      rba,rbc :: VEC{REAL}(3)
      change :: BIN

      rba = self(a).position - self(b).position
      rbc = self(c).position - self(b).position
      rba.normalise
      rbc.normalise
      res = rba.dot(rbc)
      res = res.arccos

      change = FALSE
      if (present (degrees)) change = degrees
      if (change) res = res * STR:conversion_factor("degree")

   end

   no_of_angle_center_atoms result (res) ::: pure
   ! Return the number of list of atom indices B which belong to
   ! angles centers angle(ABC)
      self :: IN
      res :: INT

      n,a,b,c :: INT
      cnt :: VEC{BIN}*

      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle

            cnt(b) = TRUE

         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   angle_center_atoms result (res) ::: pure
   ! Return the list of atom indices B which belong to angles centers
   ! angle(ABC)
      self :: IN
      res :: VEC{INT}(.no_of_angle_center_atoms)

      n,a,b,c :: INT
      cnt :: VEC{BIN}*

      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle

            cnt(b) = TRUE

         end

      end
      end

      res = pack([( a, a=1,n)],mask=cnt)

      deallocate(cnt)

   end

   no_of_angle_outer_atoms result (res) ::: pure
   ! Return the number of list of atoms which are outer angle atoms
      self :: IN
      res :: INT

      n,a,b,c :: INT
      cnt :: VEC{BIN}*

      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle

            cnt(a) = TRUE
            cnt(c) = TRUE

         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   angle_outer_atoms result (res) ::: pure
   ! Return the list of atoms which are outer angle atoms
      self :: IN
      res :: VEC{INT}(.no_of_angle_outer_atoms)

      n,a,b,c :: INT
      cnt :: VEC{BIN}*

      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle

            cnt(a) = TRUE
            cnt(c) = TRUE

         end

      end
      end

      res = pack([( a, a=1,n)],mask=cnt)

      deallocate(cnt)

   end


   no_of_torsion_angles result (res) ::: pure
   ! Return the number of torsion angles within bond contact distance
      self :: IN
      res :: INT

      n,a,b,c,d :: INT

      n = .dim

      res = 0

      do a = 1,n
      do b = 1,n

         if (a==b) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (a==c OR b==c) cycle
            if (NOT .bonded(b,c)) cycle

            do d = 1,n

               if (a==d OR b==d OR c==d) cycle
               if (NOT .bonded(c,d)) cycle

               res = res + 1

            end
         end

      end
      end

      res = res/2

   end

   torsion_angle(a,b,c,d,abc_colinear,bcd_colinear,degrees) result (res)
   ! Return the torsion angle between atoms "a", "b", "c" and "d". The
   ! atoms are assumed connected like a--b--c--d and the angle
   ! returned is that between vectors (a-b) and (d-c) i.e. the torsion
   ! angle looking down the b--c bond.  torsion is positive if (a-b)
   ! is counterclockwise of (d-c). If "degrees" is present and
   ! TRUE, result is in degrees.  NOTE: If the result is -ONE, either
   ! a--b--c or b--c--d are colinear, and the variables
   ! "abc_colinear" and "bcd_colinear" are set.
   ! See Tuzun et al (2000) J. Comp. Chem 21 p. 553-561
      a,b,c,d :: INT, IN
      abc_colinear,bcd_colinear :: BIN, optional, OUT
      degrees :: BIN, optional, IN
      res :: REAL

      change :: BIN
      rba,rcb,rdc,tba,tdc :: VEC{REAL}(3)
      dot :: REAL

      if (present(abc_colinear)) abc_colinear = FALSE
      if (present(bcd_colinear)) bcd_colinear = FALSE

      ! Vectors point from d -> c -> b -> a
      rba = self(a).position - self(b).position
      rcb = self(b).position - self(c).position
      rdc = self(c).position - self(d).position
      rba.normalise
      rcb.normalise
      rdc.normalise

      tba.to_cross_product_of(rba,rcb)
      tdc.to_cross_product_of(rcb,rdc)

      ! Collinear test
      res = ZERO
      if (abs(tba.norm)<TOL(5)) then
         res = -ONE
         if (present(abc_colinear)) abc_colinear = TRUE
      end
      if (abs(tdc.norm)<TOL(5)) then
         res = -ONE
         if (present(bcd_colinear)) bcd_colinear = TRUE
      end
      if (res<ZERO) return

      tba.normalise
      tdc.normalise
      res = tba.dot(tdc)
      res = res.arccos

      ! Sign of angle: see Tozun et al eq. (11)
      ! And also Figure 1
      dot = -rdc.dot(tba)
      if (dot<ZERO) res = -res

      change = FALSE
      if (present (degrees)) change = degrees
      if (change) res = res * STR:conversion_factor("degree")

   end

   no_of_torsion_angle_1st_atoms result (res) ::: pure
   ! Return the number of list of indices of 1st atoms in a torsion angle
      self :: IN
      res :: INT

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a1) = TRUE

            end
         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   torsion_angle_1st_atoms result (res) ::: pure
   ! Return the list of indices of 1st atoms in a torsion angle
      self :: IN
      res :: VEC{INT}(.no_of_torsion_angle_1st_atoms)

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a1) = TRUE

            end
         end

      end
      end

      res = pack([ (a1, a1=1,n) ],mask=cnt)

      deallocate(cnt)

   end

   no_of_torsion_angle_2nd_atoms result (res) ::: pure
   ! Return the number of list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: INT

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a2) = TRUE

            end
         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   torsion_angle_2nd_atoms result (res) ::: pure
   ! Return the list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: VEC{INT}(.no_of_torsion_angle_2nd_atoms)

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a2) = TRUE

            end
         end

      end
      end

      res = pack([ (a1, a1=1,n) ],mask=cnt)

      deallocate(cnt)

   end

   no_of_torsion_angle_3rd_atoms result (res) ::: pure
   ! Return the number of list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: INT

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a3) = TRUE

            end
         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   torsion_angle_3rd_atoms result (res) ::: pure
   ! Return the list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: VEC{INT}(.no_of_torsion_angle_3rd_atoms)

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a3) = TRUE

            end
         end

      end
      end

      res = pack([ (a1, a1=1,n) ],mask=cnt)

      deallocate(cnt)

   end

   no_of_torsion_angle_4th_atoms result (res) ::: pure
   ! Return the umber list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: INT

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a4) = TRUE

            end
         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   torsion_angle_4th_atoms result (res) ::: pure
   ! Return the list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: VEC{INT}(.no_of_torsion_angle_4th_atoms)

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a4) = TRUE

            end
         end

      end
      end

      res = pack([ (a1, a1=1,n) ],mask=cnt)

      deallocate(cnt)

   end

   has_all_Hs_single_bonded(has_Hs) result (res)
   ! Return TRUE if "self" has all H atom single bonded. If there are
   ! no H's then the result is TRUE but "has_Hs" is set FALSE..
      res :: BIN
      has_Hs :: BIN, OUT

      a,b,n :: INT

      res = TRUE
      has_Hs = FALSE

      do a = 1,.dim

         if (self(a).atomic_number/=1) cycle

         has_Hs = TRUE

         n = 0
         do b = 1,.dim
            if (self(b).atomic_number<=1) cycle
            if (NOT self(a).is_bonded_to(self(b))) cycle
            n = n + 1
            if (n>1) exit
         end

         res = n==1
         if (NOT res) exit

      end

   end


   Spackman86_dispersion_energy(atom) result (res) ::: PURE
   ! Return Spackman's dispersion energy between "self" and "atom"s.
   ! See Spackman M. A. (1986) J. Chem. Phys. 85(11) p. 6579
      self :: IN
      atom :: VEC{ATOM}, IN
      res :: REAL

   ENSURE(self.has_all_Spackman86_a_coeffs,"self: not all Spackman a coefficients defined")
   ENSURE(atom.has_all_Spackman86_a_coeffs,"atom: not all Spackman a coefficients defined")

      i,j :: INT
      r, a_i,a_j :: REAL

      res = ZERO

      ! Loop over pairs
      do i = 1,.dim

         a_i =  self(i).Spackman86_a_6_dispersion_coeff

         do j = 1,atom.dim

            a_j =  atom(j).Spackman86_a_6_dispersion_coeff

            r = self(i).bond_distance_to(atom(j))

            res = res - a_i*a_j/r**6

         end

      end

   end

   Spackman86_repulsion_energy(atom) result (res) ::: PURE
   ! Return Spackman's repulsion energy between "self" and "atom"s.
   ! See Spackman M. A. (1986) J. Chem. Phys. 85(11) p. 6579
      self :: IN
      atom :: VEC{ATOM}, IN
      res :: REAL

   ENSURE(self.has_all_Spackman86_b_c_coeffs,"self: not all Spackman b & c coefficients defined")
   ENSURE(atom.has_all_Spackman86_b_c_coeffs,"atom: not all Spackman b & c coefficients defined")

      i,j, Z_i,Z_j :: INT
      r,r_offset, b_i,b_j, c_i,c_j :: REAL

      res = ZERO

      ! Loop over pairs
      do i = 1,.dim

         Z_i = self(i).atomic_number
         b_i = self(i).Spackman86_b_repulsion_coeff
         c_i = self(i).Spackman86_c_repulsion_coeff

         do j = 1,atom.dim

            Z_j = atom(j).atomic_number
            b_j = atom(j).Spackman86_b_repulsion_coeff
            c_j = atom(j).Spackman86_c_repulsion_coeff

            r = self(i).bond_distance_to(atom(j))

            ! Modify distance r only for repulsion term
            ! for H atoms ... just an approximate hack
            r_offset = ZERO
            if (Z_i==1  OR  Z_j==1) r_offset = HALF  * BOHR_PER_ANGSTROM ! X-H interactions
            if (Z_i== 1 AND Z_j==1) r_offset = TENTH * BOHR_PER_ANGSTROM ! H-H interactions
            r = r + r_offset

            res = res + b_i*b_j*exp(-r*(c_i+c_j))

         end

      end

   end

   Grimme06_dispersion_energy(atom) result (res) ::: pure
   ! Return Grimmes's dispersion energy between "self" and "atom"s.
   ! Based on C6 terms from Grimme (2006) J. Comp. Chem.  27(15) p. 1787
   ! E_disp = sum over atoms (C6 / r^6).
      self :: IN
      atom :: VEC{ATOM}, IN
      res :: REAL
      d :: REAL
      damping_factor :: REAL
      rr :: REAL

    ENSURE(self.has_all_Grimme06_a_coeffs,"self: not all Grimme a coefficients defined")
    ENSURE(atom.has_all_Grimme06_a_coeffs,"atom: not all Grimme a coefficients defined")


      i,j :: INT
      rij, a_i,a_j, r_i, r_j :: REAL

      res = ZERO
      d = 20.0d0

      ! Loop over pairs
      do i = 1,.dim

         a_i =  self(i).Grimme06_a_6_dispersion_coeff
         r_i = self(i).Grimme06_r_0_dispersion_coeff

         do j = 1,atom.dim

            a_j =  atom(j).Grimme06_a_6_dispersion_coeff
            r_j = atom(j).Grimme06_r_0_dispersion_coeff

            rr = (r_i + r_j)
            rij   = self(i).bond_distance_to(atom(j))
            damping_factor = (ONE / (ONE + exp(-d * (rij/(rr) - ONE))))
            res = res - (a_i*a_j/rij**6 * damping_factor)

         end

      end

   end

   polarization_energy(F_sq) result (res) ::: PURE
   ! Return simplified polarization energy
   ! Uses atomic polarizabilties from Thakkar and Lupinetti (2006)
      self :: IN
      F_sq :: VEC{REAL}, IN
      res :: REAL

   ENSURE(self.has_all_Thakkar_atomic_polarizabilities,"self: not all Grimme a coefficients defined")

      i :: INT
      polarizability :: REAL

      res = ZERO

      do i = 1,.dim
         polarizability = self(i).Thakkar_atomic_dipole_polarizability
         res = res + polarizability * F_sq(i)

      end

      res = -HALF * res


   end

   has_all_Spackman86_a_coeffs result (res) ::: pure
   ! Return TRUE if "self" has all dispersion coefficients.
      self :: IN
      res :: BIN

      res = all(ATOM::Spackman86_a_6_dispersion_coeff(self)/=ZERO)

   end

   has_all_Spackman86_b_c_coeffs result (res) ::: pure
   ! Return TRUE if "self" has all repulsion coefficients.
      self :: IN
      res :: BIN

      has_b,has_c :: BIN

      has_b = all(ATOM::Spackman86_b_repulsion_coeff(self)/=ZERO)
      has_c = all(ATOM::Spackman86_c_repulsion_coeff(self) /=ZERO)
      res = has_b AND has_c

   end

   has_all_Grimme06_a_coeffs result (res) ::: pure
   ! Return TRUE if "self" has all dispersion coefficients.
      self :: IN
      res :: BIN

      res = all(ATOM::Grimme06_a_6_dispersion_coeff(self)/=ZERO)

   end

   has_all_Thakkar_atomic_polarizabilities result (res) ::: pure
   ! Return TRUE if "self" has all atomic polarizabilities
      self :: IN
      res :: BIN

      res = all(ATOM::Thakkar_atomic_dipole_polarizability(self)/=ZERO)

   end

!  ================================================
!  Position derivatives of bonds, distances, angles
!  ================================================

   bond_distance_deriv(a,b,deriv)
   ! Return the bond distance derivatives "deriv" wrt cartesian
   ! positions between atoms "a" and "b". The bond vector is rb - ra
      a,b :: INT, IN
      deriv :: VEC{REAL}(6)

      rab :: VEC{REAL}(3)
      dab :: REAL

      ! Vector rab and (inverse) length
      rab = self(b).position - self(a).position
      dab = sqrt(rab(1)*rab(1) + rab(2)*rab(2) + rab(3)*rab(3))
      dab = ONE/dab

      ! Derivative
      deriv(1:3) = -rab*dab ! wrt a
      deriv(4:6) =  rab*dab ! wrt b

   end

   bond_angle_deriv(a,b,c,deriv,abc_colinear)
   ! Return the bond angle derivatives "deriv" between atoms "a" , "b"
   ! and "c".  The central atom is "b". The angle is calculated as
   ! arccos(nba.nbc). See Tuzun et al (2000) J. Comp. Chem 21 p.
   ! 553-561 equation (6).
      a,b,c :: INT
      deriv :: VEC{REAL}(9)
      abc_colinear :: BIN, OUT, optional

      rba,rbc,rx,ry :: VEC{REAL}(3)
      dba,dbc,cs,sn :: REAL

      if (present(abc_colinear)) abc_colinear = FALSE

      ! Vectors
      rba = self(a).position - self(b).position
      rbc = self(c).position - self(b).position

      ! Get lengths and normalise
      dba = ONE/rba.norm; rba = rba*dba
      dbc = ONE/rbc.norm; rbc = rbc*dbc

      ! sin part
      cs = dot_product(rba,rbc)
      sn = sqrt((ONE-cs)*(ONE+cs))
      if (abs(sn)<TOL(5)) then
         deriv = ZERO
         if (present(abc_colinear)) abc_colinear = TRUE
         return
      else
         sn = ONE/sn
      end

      ! I checked the formula below myself

      ! Derivtive wrt c: see (6b)
      ! NOTE: this equation is actually -Nabla1
      rx.to_cross_product_of(rbc,rba)
      ry.to_cross_product_of(rba,rx)
      deriv(1:3) = ry*dba

      ! Derivative wrt a: see (6a)
      ! NOTE: this equation is actually Nabla3
      rx.to_cross_product_of(rba,rbc)
      ry.to_cross_product_of(rbc,rx)
      deriv(7:9) = ry*dbc

      ! Derivative wrt b: use translational invariance
      deriv(4:6) = - deriv(1:3) - deriv(7:9)

      ! Divide by sin: see (6c)
      deriv = -sn*deriv

   end

   torsion_angle_deriv(a,b,c,d,deriv,abc_colinear,bcd_colinear)
   ! Return the torsion angle derivative "deriv" between atoms "a",
   ! "b", "c" and "d". NOTE: If the result is -ONE, either a--b--c or
   ! b--c--d are colinear, and the variables "abc_colinear" and
   ! "bcd_colinear" are set.  See Tuzun et al (2000) J. Comp. Chem 21
   ! p. 553-561 equation (9).
      a,b,c,d :: INT, IN
      deriv :: VEC{REAL}(12)
      abc_colinear,bcd_colinear :: BIN, optional, OUT

      rba,rcb,rdc,tba,tdc :: VEC{REAL}(3)
      dba,dcb,ddc, sin_abc,sin_bcd,cos_abc,cos_bcd, cc,bb :: REAL

      if (present(abc_colinear)) abc_colinear = FALSE
      if (present(bcd_colinear)) bcd_colinear = FALSE

      ! Vectors point from d -> c -> b -> a
      rba = self(a).position - self(b).position
      rcb = self(b).position - self(c).position
      rdc = self(c).position - self(d).position

      ! Lengths and normalise
      dba = rba.norm; rba = rba/dba
      dcb = rcb.norm; rcb = rcb/dcb
      ddc = rdc.norm; rdc = rdc/ddc

      ! Normals to planes
      tba.to_cross_product_of(rba,rcb)
      tdc.to_cross_product_of(rdc,rcb)

      ! Collinear test
      if (abs(tba.norm)<TOL(5)) then
         deriv = ZERO
         if (present(abc_colinear)) abc_colinear = TRUE
         return
      end
      if (abs(tdc.norm)<TOL(5)) then
         deriv = ZERO
         if (present(bcd_colinear)) bcd_colinear = TRUE
         return
      end

      ! sin's and cos's
      sin_abc = ONE/tba.norm
      sin_bcd = ONE/tdc.norm
      cos_abc = -dot_product(rba,rcb)
      cos_bcd = -dot_product(rcb,rdc)


      ! Gradient's
      deriv( 1: 3) = -tba*sin_abc*sin_abc/dba    ! wrt a: see (9a)
      deriv(10:12) = -tdc*sin_bcd*sin_bcd/ddc    ! wrt d: see (9b)
      cc = dba*cos_abc/dcb - ONE                 ! wrt b: see (9d)
      bb = ddc*cos_bcd/dcb
      deriv( 4: 6) = cc*deriv(1:3) - bb*deriv(10:12)
      deriv( 7: 9) = -deriv(1:3)-deriv(4:6)-deriv(10:12)

   end

!  ========================
!  Size information methods
!  ========================

   no_of_electrons result (res) ::: pure
   ! If the atom list is *not* a single explicit "El" electron:
   ! . Return the number of electrons in the atom list assuming
   !   that it is *neutrally charged*. Any explicit "El" electrons
   !   are ignored i.e. they have no electrons.
   ! . Else return 1 ... the explicit "El" electron is assumed to be
   !   surrounded by one (beta) electron. This ensures a good initial
   !   guess is obtained for promolecule guess SCF calculations.
      self :: IN
      res :: INT

   ENSURE(.dim>0,"zero size atom list")

      res = VEC{INT}:sum(self(:).atomic_number)

   end

   no_of_occupied_ANOs(ANOkind,tol) result (res)
   ! Returns the number of non-zero occupied atomic natural orbitals. For this
   ! purpose, zero is defined to be "tol" if present, or TOL(7) otherwise
      ANOkind :: STR, optional
      tol :: REAL, optional
      res :: INT

   ENSURE(self(1).occupation_numbers.created,"no occupation numbers")

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).no_of_occupied_NOs(ANOkind,tol)
      end

   end

!  ==============================
!  Basis size information methods
!  ==============================

   no_of_shells result (res) ::: pure
   ! Work out and return the number of gaussian shells in the basis set for the
   ! molecule
      self :: IN
      res :: INT
      a :: INT
      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_shells
      end
   end

   n_shell result (res) ::: pure
   ! Work out and return the number of gaussian shells in the basis set for the
   ! molecule
      self :: IN
      res :: INT
      a :: INT
      res = 0
      do a = 1,.dim
         res = res + self(a).basis.n_shell
      end
   end

   n_shell_pairs result (res) ::: pure
   ! Return the number of shell pairs in the basis set for the molecule
      self :: IN
      res :: INT
      n_shell :: INT
      n_shell = .n_shell
      res = n_shell*(n_shell+1)/2
   end

!   n_shell_for_atom(i) result (res) ::: pure
!   ! Work out and return the number of gaussian shells in the basis set for the
!   ! molecule
!      self :: IN
!       i :: INT, IN
!      res :: INT
!      res = self(i).basis.n_shell
!   end

   no_of_primitive_shells result (res) ::: pure
   ! Work out and return the number of primitive gaussian shells in
   ! the concatenated basis sets
      self :: IN
      res :: INT
      a :: INT
      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_primitive_shells
      end
   end

   no_of_basis_functions result (res) ::: pure
   ! Work out and return the number of basis functions in the concatenated
   ! basis set for the atom list.
      self :: IN
      res :: INT
      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_basis_functions
      end

   end

   no_of_sph_basis_functions result (res) ::: pure
   ! Work out and return the number of spherical basis functions in
   ! the concatenated basis set for the atom list.
      self :: IN
      res :: INT
      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_sph_basis_functions
      end

   end

   n_bf result (res) ::: pure
   ! Work out and return the number of basis functions in the concatenated
   ! basis set for the atom list.
      self :: IN
      res :: INT
      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).basis.n_bf
      end

   end

   no_of_primitives result (res) ::: pure
   ! Work out and return the number of primitives in the concatenated
   ! basis sets.
      self :: IN
      res :: INT
       a :: INT
      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_primitives
      end
   end

   no_of_sph_primitives result (res) ::: pure
   ! Work out and return the number of spherical primitives in the
   ! concatenated basis sets.
      self :: IN
      res :: INT
       a :: INT
      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_sph_primitives
      end
   end

   n_prim result (res) ::: pure
   ! Work out and return the number of primitives in the concatenated
   ! basis sets.
      self :: IN
      res :: INT
       a :: INT
      res = 0
      do a = 1,.dim
         res = res + self(a).basis.n_prim
      end
   end

!  ===============================
!  Basis set existence information
!  ===============================

   bases_are_resolved result (res) ::: template
   ! Return TRUE if all basis sets are associated AND their shell list
   ! parts are also associated, dummy-atoms excepted
      res :: BIN

      a :: INT

      res = TRUE

      do a = 1,.dim

         if (self(a).TEST?.is_created_and_resolved) cycle
         if (self(a).has_a_dummy_label) cycle

         res = FALSE
         exit

      end

   end

   bases_are_resolved result (res) ::: get_from(VEC{ATOM}:bases_are_resolved, TEST?=>basis)
   ! Return TRUE if all basis sets are associated AND their shell list
   ! parts are also associated, dummy-atoms excepted
   end

   slaterbases_are_resolved result (res) ::: get_from(VEC{ATOM}:bases_are_resolved, TEST?=>slaterbasis)
   ! Return TRUE if all basis sets are associated AND their shell list
   ! parts are also associated, dummy-atoms excepted
   end

   coppensbases_are_resolved result (res) ::: get_from(VEC{ATOM}:bases_are_resolved, TEST?=>coppensbasis)
   ! Return TRUE if all basis sets are associated AND their shell list
   ! parts are also associated, dummy-atoms excepted
   end

   bases_are_all_labeled result (res) ::: template
   ! Return TRUE if all basis set labels exist (i.e. are not blank)
   ! Note: If a dummy atom has a basis it should have a label
      res :: BIN

      a :: INT

      res = TRUE

      do a = 1,.dim

         if (self(a).TEST?.is_created_and_has_label) cycle
         if (self(a).has_a_dummy_label) cycle

         res = FALSE
         exit

      end

   end

   bases_are_all_labeled result (res) ::: get_from(VEC{ATOM}:bases_are_all_labeled, TEST?=>basis)
   ! Return TRUE if all basis set labels exist (i.e. are not blank)
   ! Note: If a dummy atom has a basis it should have a label
   end

   slaterbases_are_all_labeled result (res) ::: get_from(VEC{ATOM}:bases_are_all_labeled, TEST?=>slaterbasis)
   ! Return TRUE if all basis set labels exist (i.e. are not blank)
   ! Note: If a dummy atom has a basis it should have a label
   end

   coppensbases_are_all_labeled result (res) ::: get_from(VEC{ATOM}:bases_are_all_labeled, TEST?=>coppensbasis)
   ! Return TRUE if all basis set labels exist (i.e. are not blank)
   ! Note: If a dummy atom has a basis it should have a label
   end


   get_distance_from(atomvec,distance,t1,t2)
   ! Calculates the shortest distance between an atom in self and one in
   ! atomvec.  Will set the distance to zero if calculated to less than 10^-6.
   ! If present, t1 and t2 are the indices of the two closest atoms.
      atomvec :: VEC{ATOM}, IN
      self :: IN
      distance :: REAL
      t1,t2 :: INT, optional
      dist :: REAL
      i,j,dim1,dim2 :: INT
      difference :: VEC{REAL}(3)

      dim1 = .dim
      dim2 = size(atomvec)
      ENSURE(present(t1) EQV present(t2),"need 0 or 2 optional arguments")

      ! Do the first pair explicitly to set a starting distance.
      ! We also work with distance^2 until the end - saves computation.
      difference = self(1).position(:) - atomvec(1).position(:)
      distance = dot_product(difference,difference)

      do i=1,dim1
       do j=1,dim2
         difference = self(i).position(:) - atomvec(j).position(:)
         dist = dot_product(difference,difference)
         if (dist < TOL(6)) dist = ZERO
         if (dist < distance) then
           distance = dist
           if (present(t1)) then
             t1=i; t2=j
           end
         end
       end
      end

      distance = sqrt(distance)
   end

   get_distance_from(pos,distance,t1)
   ! Calculates the shortest distance of "pos" to an atom in self.
   ! If present, t1 is the index of the closest atom.
      pos :: VEC{REAL}(3), IN
      self :: IN
      distance :: REAL
      t1 :: INT, optional
      dist :: REAL
      difference :: VEC{REAL}(3)
      i :: INT

      ! Do the first pair explicitly to set a starting distance.
      ! We also work with distance^2 until the end - saves computation.
      difference = self(1).position(:) - pos(:)
      distance = dot_product(difference,difference)

      do i = 1, .dim
       difference = self(i).position(:) - pos(:)
       dist = dot_product(difference,difference)
       if (dist < TOL(6)) dist = ZERO
       if (dist < distance) then
         distance = dist
         if (present(t1)) t1=i
       end
      end

      distance = sqrt(distance)
   end

   same_as(atomvec) result (res)
   ! Returns true if the two atomvecs contain the same atoms, though maybe in a
   ! different order.  Checks atomic number and position of each atom, but not
   ! the basis sets.
      atomvec :: VEC{ATOM}, IN
      res :: BIN
      matched :: VEC{BIN}(size(self))
      match_pos,match_kind,match :: BIN
      n,q,dim :: INT

      res = FALSE
      dim = .dim
      if (dim/=size(atomvec)) return ! different number of atoms in each.
      matched = FALSE

      do n = 1, dim
         match=FALSE
         do q = 1, dim
            match_kind =  (self(n).atomic_number == atomvec(q).atomic_number)
            match_pos  =  self(n).position.same_as( atomvec(q).position, TOL(3) )
            if (match_pos AND match_kind AND (NOT matched(q))) then
               matched(q) = TRUE
               match = TRUE
               exit
            end
         end
         if (NOT match) return ! atom n doesn't have a match.
      end

      do q = 1, dim           ! If not all of q are matched then atomvecs not same.
         if (NOT matched(q)) return
      end

      res = TRUE

   end

!  =============
!  Crystal stuff
!  =============

   translate_by(v)
   ! Translate self by vector.
      self :: INOUT
      v :: VEC{REAL}(3), IN

      pos :: VEC{REAL}(3)
      a :: INT

      if (v.is_zero) return

      do a = 1,.dim
         pos = self(a).position + v
         self(a).set_position(pos)
      end

   end

   rotate_by(matrix)
   ! Rotate the atom positions by the rotation matrix
      self :: INOUT
      matrix :: MAT{REAL}(3,3), IN

      .rotate_positions_by(matrix)
      .rotate_ADP_tensors_by(matrix)

   end

   rotate_positions_by(matrix)
   ! Rotate the atom positions by the rotation matrix
      self :: INOUT
      matrix :: MAT{REAL}(3,3), IN

      a :: INT
      pos :: VEC{REAL}(3)

      do a = 1,.dim
         pos.to_product_of(matrix,self(a).position)
         self(a).set_position(pos)
      end

   end

   rotate_ADP_tensors_by(matrix)
   ! Rotate the atom ADP (thermal) tensors by the rotation matrix:
   ! this is the rotation matrix which transforms the cartesian
   ! position to a new position.
   ! WARNING: does not do ADP3 and ADP4 yet
      self :: INOUT
      matrix :: MAT{REAL}(3,3), IN

      a :: INT
      ADP :: MAT{REAL}(3,3)

      do a = 1,.dim
         self(a).ADP_tensor.back_transform_to(ADP,matrix)
         self(a).set_ADP_tensor(ADP)
      end

   end

   change_ADP_axis_system_to(axis_system,form,cell)
   ! Convert all ADP tensors into the desired "axis_system".
      self :: INOUT
      axis_system,form :: STR, IN
      cell :: UNIT_CELL, IN

      a :: INT

      do a = 1,.dim
         self(a).change_ADP_axis_system_to(axis_system,form,cell)
      end

   end

   default_multiplicity result (res)
   ! Return the default multiplicity for an atomvec/molecule.
      self :: IN
      res :: REAL
      if (.dim==1) then
        res = self(1).ground_state_multiplicity
      else
        res = mod(.no_of_electrons,2) + 1
      end
   end

!  =========
!  Integrals
!  =========

!   make_nuclear_matrix(Z)
!   ! Calculate the nuclear attraction matrix "Z" for the atoms in the list.
!   ! Includes dummay atoms
!      self :: target
!      Z :: MAT{REAL}
!   ENSURE(.bases_are_resolved, "no basis set")
!   ENSURE(Z.is_square,"Z is not square")
!   ENSURE(Z.dim1==.n_bf,"wrong size, Z")
!      atom :: ATOM*
!      Z_c :: MAT{REAL}*
!      q,c,fa,la,fb,lb :: INT
!      sh :: SHELL2
!      .make_index_info
!      Z = ZERO
!      do q = 1,.n_shell_pairs
!        .get_shell_pair(sh,q,fa,la,fb,lb)
!        Z_c.create(sh.a.n_comp,sh.b.n_comp)
!        do c = 1,.dim
!           atom => self(c)
!           sh.get_nuc(Z_c,atom.mass,atom.position)
!           Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.nuclear_charge * Z_c
!        end
!        Z_c.destroy
!        sh.destroy_ptr_part
!      end
!      Z.symmetric_reflect
!      .destroy_index_info
!   end
!
!   make_nuclear_matrix(Z,nuclei)
!   ! Calculate the nuclear attraction matrix "Z" for the basis functions on all
!   ! atoms in the list, but only for the positive nuclei specified in the
!   ! "nuclei" list.  Includes dummay atoms
!      self :: target
!      Z :: MAT{REAL}
!      nuclei :: VEC{INT}
!   ENSURE(.bases_are_resolved, "no basis set")
!   ENSURE(Z.is_square,"Z is not square")
!   ENSURE(Z.dim1==.n_bf,"wrong size, Z")
!      atom :: ATOM*
!      Z_c :: MAT{REAL}*
!      q,c,fa,la,fb,lb :: INT
!      sh :: SHELL2
!      .make_index_info
!      Z = ZERO
!      do q = 1,.n_shell_pairs
!        .get_shell_pair(sh,q,fa,la,fb,lb)
!        Z_c.create(sh.a.n_comp,sh.b.n_comp)
!        do c = 1,size(nuclei)
!           atom => self(nuclei(c))
!           sh.get_nuc(Z_c,atom.mass,atom.position)
!           Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.nuclear_charge * Z_c
!        end
!        Z_c.destroy
!        sh.destroy_ptr_part
!      end
!      Z.symmetric_reflect
!      .destroy_index_info
!   end
!
!   make_index_info ::: leaky
!   ! Define a vector of atom numbers corresponding to the molecule
!   ! basis set shell numbers; also define a vector of atom shell numbers
!   ! corresponding to the molecule basis set shell number
!      atom_4_shell       => .atom_for_shell
!      atom_shell_4_shell => .atom_shell_for_shell
!      first_shell_4_atom => .first_shell_for_atom
!      .make_shell_limits(first_basis_fn_4_shell,last_basis_fn_4_shell,angular_moment_4_shell)
!      .make_atom_basis_fn_limits(first_basis_fn_4_atom,last_basis_fn_4_atom)
!      index_info_created = TRUE
!   end
!
!   destroy_index_info ::: leaky
!   ! Destroythe private index information. There may be problems with this for
!   ! compilers without default initialisation ...
!      atom_4_shell.destroy
!      atom_shell_4_shell.destroy
!      first_shell_4_atom.destroy
!      first_basis_fn_4_shell.destroy
!      last_basis_fn_4_shell.destroy
!      first_basis_fn_4_atom.destroy
!      last_basis_fn_4_atom.destroy
!      index_info_created = FALSE
!   end

!  ===========
!  Shell pairs
!  ===========

!   get_shell_pair(shell,index,fa,la,fb,lb) ::: leaky
!   ! Get the SHELL2 object "shell" correponding to the pair index "index"
!   ! Also return the basis function start indices "fa", "la", etc ...
!      index :: INT, IN
!      shell :: SHELL2, OUT
!      fa,la,fb,lb :: INT, OUT
!   ENSURE(index_info_created,"no index information")
!      a,b,aa,sa,bb,sb :: INT
!      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
!      b  = index - a*(a-1)/2
!      fa = first_basis_fn_4_shell(a) ! These are module variables
!      fb = first_basis_fn_4_shell(b)
!      la = last_basis_fn_4_shell(a)
!      lb = last_basis_fn_4_shell(b)
!      aa = atom_4_shell(a)
!      bb = atom_4_shell(b)
!      sa = atom_shell_4_shell(a)
!      sb = atom_shell_4_shell(b)
!      shell.copy(self(aa).basis.shell(sa), self(bb).basis.shell(sb), &
!                 self(aa).position, self(bb).position )
!   end
!
!   get_shell_pair(shell,index,fa,la,fb,lb,atom_a,atom_b) ::: leaky
!   ! Get the SHELL2 object "shell" correponding to the pair index "index"
!   ! Also return the basis function start indices "fa", "la", etc ...
!   ! Plus the atoms the shells are located on, "atom_a" and "atom_b".
!      index :: INT, IN
!      shell :: SHELL2, OUT
!      fa,la,fb,lb,atom_a,atom_b :: INT, OUT
!   ENSURE(index_info_created,"no index information")
!      a,b,sa,sb :: INT
!      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
!      b  = index - a*(a-1)/2
!      fa = first_basis_fn_4_shell(a)
!      fb = first_basis_fn_4_shell(b)
!      la = last_basis_fn_4_shell(a)
!      lb = last_basis_fn_4_shell(b)
!      atom_a = atom_4_shell(a)
!      atom_b = atom_4_shell(b)
!      sa = atom_shell_4_shell(a)
!      sb = atom_shell_4_shell(b)
!      shell.copy(self(atom_a).basis.shell(sa), self(atom_b).basis.shell(sb), &
!                self(atom_a).position, self(atom_b).position )
!   end

!  ==============
!  Output methods
!  ==============

   dump(object_name) ::: get_from(VEC{OBJECT})
   ! Dump a vector object
   end

   dmpp(object_name) ::: get_from(VEC{OBJECT})
   ! Dump a vector pointer object
   end

   put
   ! Output atom information, without full basis set info

      stdout.flush
      stdout.text("=====================")
      stdout.text("Atom list information")
      stdout.text("=====================")
      stdout.flush

      stdout.show("Chemical Formula       =",trim(.chemical_formula(with_spaces=TRUE)))
      stdout.show("No of atoms            =",size(self))
      stdout.show("No of electrons        =",.no_of_electrons)

      if (.has_residue_codes) then; .put_mm_info
      else;                         .put_coordinate_info
      end
      if (.has_restraints)          .put_restraint_atoms

   end

   put_list
   ! Output atom information,

      a :: INT
      title :: STR

      stdout.flush
      stdout.text("=====================")
      stdout.text("Atom list information")
      stdout.text("=====================")
      stdout.flush

      stdout.show("Chemical Formula       =",trim(.chemical_formula(with_spaces=TRUE)))
      stdout.show("No of atoms            =",size(self))
      stdout.show("No of electrons        =",.no_of_electrons)
      stdout.flush

      do a = 1,.dim
         title = "Atom "//trim(a.to_str)
         stdout.text(trim(title))
         stdout.text(repeat("=",len_trim(title)))
         self(a).put
         stdout.flush
      end

   end

   put_coordinate_info
   ! Output atom coordinate information, including bond lengths, angles

      .put_coordinates

      if (.has_nonzero_ADP_tensors) .put_ADPs

      .put_bond_length_table
      .put_bond_angle_table
      .put_torsion_angle_table

   end

!  ======================
!  Coordinate information
!  ======================

   put_coordinates(no_header)
   ! Output the atom coordinates information.
      self :: IN
      no_header :: BIN, IN, optional

      if      (.has_disorder) then; .put_coords_disorder_y(no_header)
      else if (.has_groups)   then; .put_coords_groups_y(no_header)
      else;                         .put_coords(no_header)
      end

   end

   put_coords(no_header) ::: private
   ! Output the atom coordinates information without disorder
      self :: IN
      no_header :: BIN, IN, optional

      fac :: REAL
      xyz,err :: MAT{REAL}*
      Z  :: VEC{REAL}*
      lab,ID :: VEC{STR}*
      table :: VEC{TABLE_COLUMN}*
      la,lb,ka,kb :: INT
      header,has_unique_labels :: BIN

      header = TRUE
      if (present(no_header)) header = NOT no_header

      ! Use angstroms
      fac = STR:conversion_factor("angstrom")

      ! Table column data
      lab.create(.dim)
      ID.create(.dim)
      Z.create(.dim)
      xyz.create(.dim,3)
      err.create(.dim,3)

      ! Get table column data
      lab = self.label
      ID  = self.tag
      Z   = self.nuclear_charge
      .put_pos_vector_to(xyz,fac)
      .put_pos_errors_to(err,fac)

      ! Title
      if (header) then
      stdout.flush
      stdout.flush
      stdout.text("================")
      stdout.text("Atom coordinates")
      stdout.text("================")
      end

      ! Has unique labels?
      .get_1st_repeated_labels(la,lb)
      .get_1st_repeated_xtal_kinds(ka,kb)
      has_unique_labels = (la==0 AND ka==0) OR .dim==1

      ! Unique labels?
      if (has_unique_labels) then

         if (header) then
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush
         end

         ! Table headings
         table.create(5)
         table(1).set_heading("ID")
         table(2).set_heading("Z")
         table(2).set_subheading("/au")
         table(2).set_real_precision(1)
         table(3).set_heading("- x -")
         table(4).set_heading("- y -")
         table(5).set_heading("- z -")
         table(4).set_subheading("/A")

         ! Set table column data
         table(1).set_values(ID)
         table(2).set_values(Z)
         if (NOT .has_nonzero_pADP2_errors) then
         table(3).set_values(xyz(:,1))
         table(4).set_values(xyz(:,2))
         table(5).set_values(xyz(:,3))
         else
         table(3).set_values_and_errors(xyz(:,1),err(:,1))
         table(4).set_values_and_errors(xyz(:,2),err(:,2))
         table(5).set_values_and_errors(xyz(:,3),err(:,3))
         end

      else ! Not unique labels

         if (header) then
         stdout.flush
         stdout.text(". Unique atom labels were not set for each atom.")
         stdout.text("  Therefore, unique symbol-number ID tags are used.")
         if (la/=0) then
         stdout.flush
         stdout.text(". First repeated labels are for atoms "//trim(la.to_str)//" and "//trim(lb.to_str)//".")
         end
         if (ka/=0) then
         stdout.flush
         stdout.text(". First repeated xtal kinds are for atoms "//trim(ka.to_str)//" and "//trim(kb.to_str)//".")
         end
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush
         end

         ! Table headings
         table.create(6)
         table(1).set_heading("Label")
         table(2).set_heading("ID")
         table(2).set_subhead("tag")
         table(3).set_heading("Z")
         table(3).set_subheading("/au")
         table(3).set_real_precision(1)
         table(4).set_heading("- x -")
         table(5).set_heading("- y -")
         table(6).set_heading("- z -")
         table(5).set_subheading("/A")

         ! Set table column data
         table(1).set_values(lab)
         table(2).set_values(ID)
         table(3).set_values(Z)
         if (NOT .has_nonzero_pADP2_errors) then
         table(4).set_values(xyz(:,1))
         table(5).set_values(xyz(:,2))
         table(6).set_values(xyz(:,3))
         else
         table(4).set_values_and_errors(xyz(:,1),err(:,1))
         table(5).set_values_and_errors(xyz(:,2),err(:,2))
         table(6).set_values_and_errors(xyz(:,3),err(:,3))
         end

      end

      ! Make the table
      table.put

      ! Clean
      table.destroy
      err.destroy
      xyz.destroy
      Z.destroy
      ID.destroy
      lab.destroy

   end

   put_coords_disorder_y(no_header) ::: private
   ! Output the atom coordinates information with disorder
      self :: IN
      no_header :: BIN, IN, optional

      fac :: REAL
      xyz :: MAT{REAL}*
      Z,occ  :: VEC{REAL}*
      lab,ID :: VEC{STR}*
      grp :: VEC{INT}*
      table :: VEC{TABLE_COLUMN}*
      la,lb,ka,kb :: INT
      header,has_unique_labels :: BIN

      header = TRUE
      if (present(no_header)) header = NOT no_header

      ! Use angstroms
      fac = STR:conversion_factor("angstrom")

      ! Title
      if (header) then
      stdout.flush
      stdout.flush
      stdout.text("================")
      stdout.text("Atom coordinates")
      stdout.text("================")
      end

      ! Table column data
      lab.create(.dim)
      ID.create(.dim)
      Z.create(.dim)
      grp.create(.dim)
      occ.create(.dim)
      xyz.create(.dim,3)

      ! Get table column data
      lab = self.label
      ID  = self.tag
      Z   = self.nuclear_charge
      grp = self.site_disorder_group
      occ = self.site_occupancy
      .put_coordinates_to(xyz,positions_as_rows=TRUE)
      xyz = xyz * fac

      ! Has unique labels?
      .get_1st_repeated_labels(la,lb)
      .get_1st_repeated_xtal_kinds(ka,kb)
      has_unique_labels = (la==0 AND ka==0) OR .dim==1

      ! Unique labels?
      if (has_unique_labels) then

         if (header) then
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush
         end

         ! Table headings
         table.create(7)
         table(1).set_heading("ID")
         table(2).set_heading("Z")
         table(2).set_subhead("/au")
         table(2).set_real_precision(1)
         table(3).set_heading("Group")
         table(3).set_subhead("#")
         table(4).set_heading("Site")
         table(4).set_subhead("occupancy")
         table(5).set_heading("- x -")
         table(6).set_heading("- y -")
         table(7).set_heading("- z -")
         table(6).set_subhead("/A")

         ! Set table column data
         table(1).set_values(ID)
         table(2).set_values(Z)
         table(3).set_values(grp)
         table(4).set_values(occ)
         table(5).set_values(xyz(:,1))
         table(6).set_values(xyz(:,2))
         table(7).set_values(xyz(:,3))

      else ! Not unique labels

         if (header) then
         stdout.flush
         stdout.text(". Unique atom labels were not set for each atom.")
         stdout.text("  Therefore, unique symbol-number ID tags are used.")
         if (la/=0) then
         stdout.flush
         stdout.text(". First repeated labels are for atoms "//trim(la.to_str)//" and "//trim(lb.to_str)//".")
         end
         if (ka/=0) then
         stdout.flush
         stdout.text(". First repeated xtal kinds are for atoms "//trim(ka.to_str)//" and "//trim(kb.to_str)//".")
         end
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush
         end

         ! Table headings
         table.create(8)
         table(1).set_heading("Label")
         table(2).set_heading("ID")
         table(2).set_subhead("tag")
         table(3).set_heading("Z")
         table(3).set_subhead("/au")
         table(4).set_real_precision(1)
         table(4).set_heading("Group")
         table(4).set_subhead("#")
         table(5).set_heading("Site")
         table(5).set_subhead("occupancy")
         table(6).set_heading("- x -")
         table(7).set_heading("- y -")
         table(8).set_heading("- z -")
         table(7).set_subhead("/A")

         ! Set table column data
         table(1).set_values(lab)
         table(2).set_values(ID)
         table(3).set_values(Z)
         table(4).set_values(grp)
         table(5).set_values(occ)
         table(6).set_values(xyz(:,1))
         table(7).set_values(xyz(:,2))
         table(8).set_values(xyz(:,3))

      end

      ! Make the table
      table.put

      ! Clean
      table.destroy
      xyz.destroy
      occ.destroy
      grp.destroy
      Z.destroy
      ID.destroy
      lab.destroy

   end

   put_coords_groups_y(no_header) ::: private
   ! Output the atom coordinates with groups (no disorder)
      self :: IN
      no_header :: BIN, IN, optional

      fac :: REAL
      xyz :: MAT{REAL}*
      Z,occ  :: VEC{REAL}*
      lab,ID :: VEC{STR}*
      grp :: VEC{INT}*
      table :: VEC{TABLE_COLUMN}*
      la,lb,ka,kb :: INT
      header,has_unique_labels :: BIN

      header = TRUE
      if (present(no_header)) header = NOT no_header

      ! Use angstroms
      fac = STR:conversion_factor("angstrom")

      ! Title
      if (header) then
      stdout.flush
      stdout.flush
      stdout.text("================")
      stdout.text("Atom coordinates")
      stdout.text("================")
      end

      ! Table column data
      lab.create(.dim)
      ID.create(.dim)
      Z.create(.dim)
      grp.create(.dim)
      occ.create(.dim)
      xyz.create(.dim,3)

      ! Get table column data
      lab = self.label
      ID  = self.tag
      Z   = self.nuclear_charge
      grp = self.group
      occ = self.site_occupancy
      .put_coordinates_to(xyz,positions_as_rows=TRUE)
      xyz = xyz * fac

      ! Has unique labels?
      .get_1st_repeated_labels(la,lb)
      .get_1st_repeated_xtal_kinds(ka,kb)
      has_unique_labels = (la==0 AND ka==0) OR .dim==1

      ! Unique labels?
      if (has_unique_labels) then

         if (header) then
         stdout.flush
         stdout.text(". This molecule has non trivial group indices, assigned")
         stdout.text("  explicitly or by CCDC connectivity criteria")
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush
         end

         ! Table headings
         table.create(6)
         table(1).set_heading("ID")
         table(2).set_heading("Z")
         table(2).set_subhead("/au")
         table(2).set_real_precision(1)
         table(3).set_heading("Group")
         table(3).set_subhead("#")
         table(4).set_heading("- x -")
         table(5).set_heading("- y -")
         table(6).set_heading("- z -")
         table(5).set_subhead("/A")

         ! Set table column data
         table(1).set_values(ID)
         table(2).set_values(Z)
         table(3).set_values(grp)
         table(4).set_values(xyz(:,1))
         table(5).set_values(xyz(:,2))
         table(6).set_values(xyz(:,3))

      else ! Not unique labels

         if (header) then
         stdout.flush
         stdout.text(". This molecule has non trivial group indices, asssigned")
         stdout.text("  explicityly or by CCDC connectivity criteria")
         stdout.flush
         stdout.text(". Unique atom labels were not set for each atom.")
         stdout.text("  Therefore, unique symbol-number ID tags are used.")
         if (la/=0) then
         stdout.flush
         stdout.text(". First repeated labels are for atoms "//trim(la.to_str)//" and "//trim(lb.to_str)//".")
         end
         if (ka/=0) then
         stdout.flush
         stdout.text(". First repeated xtal kinds are for atoms "//trim(ka.to_str)//" and "//trim(kb.to_str)//".")
         end
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush
         end

         ! Table headings
         table.create(7)
         table(1).set_heading("Label")
         table(2).set_heading("ID")
         table(2).set_subhead("tag")
         table(3).set_heading("Z")
         table(3).set_subhead("/au")
         table(4).set_real_precision(1)
         table(4).set_heading("Group")
         table(4).set_subhead("#")
         table(5).set_heading("- x -")
         table(6).set_heading("- y -")
         table(7).set_heading("- z -")
         table(6).set_subhead("/A")

         ! Set table column data
         table(1).set_values(lab)
         table(2).set_values(ID)
         table(3).set_values(Z)
         table(4).set_values(grp)
         table(5).set_values(xyz(:,1))
         table(6).set_values(xyz(:,2))
         table(7).set_values(xyz(:,3))

      end

      ! Make the table
      table.put

      ! Clean
      table.destroy
      xyz.destroy
      occ.destroy
      grp.destroy
      Z.destroy
      ID.destroy
      lab.destroy

   end

   put_pdb(pdbfile)
   ! Output the atoms in pdb file format to "pdbfile" (blame Birger)
      pdbfile :: TEXTFILE*

      i,in,ic,ip,len_code,len_pnum,element_len :: INT
      label,element_name,residue_number,code,three_letter_code,position_symbol,position_number :: STR

      ! Save PDB settings for later
      pdbfile.save

      ! Loop over atoms
      do i = 1,.dim

         ! The ATOM number
         pdbfile.put("ATOM",width=4)
         pdbfile.put(i,width=7)

         ! Start to analyze the atom label
         label = self(i).label
       ! print *,"label =",trim(label)

         ! Get start of atom index, hence the element name
         label.replace_all("(",'')
         label.replace_all(")",'')
         in = label.index_of_digit
         DIE_IF(in==0,"no atom index in atom label: "//trim(label))
         ! Get rid of left bracket
         element_name = label(1:in-1)
       ! print *,"in =",in
       ! print *,"element_name =",trim(element_name)

         ! Get start of residue code, hence the residue number
         ic = label(in:).index_of_nondigit
         DIE_IF(ic==0,"no residue code in atom label: "//trim(label))
         ic = ic + in - 1
         residue_number = label(in:ic-1)
       ! print *,"ic =",ic
       ! print *,"residue_number =",trim(residue_number)

         ! Get start of position symbol, hence residue code, position
         ! symbol and position number (could be blank)
         ! position symbols are alpha (a)
         ! position symbols are beta (b)
         ! position symbols are gamma (c,g)
         ! position symbols are delta (d)
         ! position symbols are epsilon (e)
         ! position symbols are nu (n)
         ! position symbols are terminal (t)
         ! position symbols are zeta (z)
         ! position symbols are peptide bond (')

         ip = label(ic:).index_of_character_in("'abcgdentz")
         if (ip/=0) then
            ip = ip + ic - 1
            code = label(ic:ip-1)
            position_symbol = label(ip:ip)
            position_number = label(ip+1:)
         else
            code = label(ic:)
            position_symbol = " "
            position_number = " "
         end
       ! print *,"ip =",ip
       ! print *,"code =",trim(code)
       ! print *,"position_symbol =",trim(position_symbol)
       ! print *,"position_number =",trim(position_number)

         ! Do some checks ...
         len_code = len_trim(code)
         DIE_IF(NOT (len_code==1 OR len_code==3),"residue code must be 1 or 3 characters: "//trim(label))
         len_pnum = len_trim(position_number)
         DIE_IF(len_pnum>1,"position number code cannot exceed 1 character: "//trim(label))
         if (position_number/=" ") then
         DIE_IF(NOT position_number.is_included_in("123456789"),"unknown position number: "//trim(label))
         end

         ! If the code is a one letter code, convert it
         if (len_code == 3) then
            select case (code)
               case ("UNK","AIB","IVA","WAT","EOH","TER","DLE","DVA","FOR","ETA")
               case ("ALA","ARG","GLN","GLY","VAL","LEU","ILE","SER","THR","CYS")
               case ("MET","PRO","HIS","ASN","GLU","ASP","PHE","TRP","TYR","LYS")
               case ("ACD","HSE","ACE","HYP","HYL","ALB","ALI","ABU","ARO","ORN")
               case ("ASX","PCA","BAS","SAR","BET","TAU","THY","GLX","HET")
               case default; DIE("unknown three letter residue code: "//trim(code))
            end
            three_letter_code = code
         else if (len_code == 1) then
            select case (code)
               case ("X"); three_letter_code = "UNK"
               case ("~"); three_letter_code = "WAT"
               case ("_"); three_letter_code = "EOH"
               case ("B"); three_letter_code = "DLE"
               case ("O"); three_letter_code = "DVA"
               case ("U"); three_letter_code = "AIB"
               case ("A"); three_letter_code = "ALA"
               case ("R"); three_letter_code = "ARG"
               case ("Q"); three_letter_code = "GLN"
               case ("G"); three_letter_code = "GLY"
               case ("V"); three_letter_code = "VAL"
               case ("L"); three_letter_code = "LEU"
               case ("I"); three_letter_code = "ILE"
               case ("J"); three_letter_code = "IVA"
               case ("S"); three_letter_code = "SER"
               case ("T"); three_letter_code = "THR"
               case ("C"); three_letter_code = "CYS"
               case ("M"); three_letter_code = "MET"
               case ("P"); three_letter_code = "PRO"
               case ("H"); three_letter_code = "HIS"
               case ("N"); three_letter_code = "ASN"
               case ("E"); three_letter_code = "GLU"
               case ("D"); three_letter_code = "ASP"
               case ("F"); three_letter_code = "PHE"
               case ("W"); three_letter_code = "TRP"
               case ("Y"); three_letter_code = "TYR"
               case ("K"); three_letter_code = "LYS"
               case ("Z"); three_letter_code = "TER"
               case default; DIE("unknown one letter residue code: "//trim(code))
            end
         else
            DIE("code must be one or three characters")
         end

         ! Print the new atom label from one read in
         pdbfile.tab(width=1)
         if (position_number==" ") then
         pdbfile.tab(width=1)
         else
         pdbfile.put(position_number,width=1,left=TRUE)
         end
         pdbfile.put(element_name,width=len_trim(element_name),left=TRUE)
         if (position_symbol.is_included_in("'abcgdentz")) then
         position_symbol.to_upper_case
         pdbfile.put(position_symbol,width=1,left=TRUE)
         pdbfile.tab(width=1)
         else
         pdbfile.tab(width=2)
         end
         element_len = len_trim(element_name)
         if (element_len == 1) then
         pdbfile.tab(width=1)
         end
         pdbfile.put(three_letter_code,width=3,left=TRUE)
         pdbfile.tab(width=2)
         pdbfile.put(residue_number,width=4)
         pdbfile.tab(width=4)
         pdbfile.set_real_precision(3)
         pdbfile.set_real_width(8)
         pdbfile.put(self(i).position(1).to_units("angstrom"))
         pdbfile.put(self(i).position(2).to_units("angstrom"))
         pdbfile.put(self(i).position(3).to_units("angstrom"))
         pdbfile.set_real_precision(2)
         pdbfile.set_real_width(6)
         pdbfile.put(self(i).site_occupancy)
         pdbfile.put(8*PI*PI*self(i).U_iso)
         pdbfile.put(self(i).chemical_symbol,width=12)
         pdbfile.flush

         ! Print Anisotropic U's if non-hydrogen
         if (self(i).atomic_number==1) cycle

         pdbfile.put("ANISOU",width=6)
         pdbfile.put(i,width=5)
         pdbfile.tab(width=1)
         if (position_number==" ") then
         pdbfile.tab(width=1)
         else
         pdbfile.put(position_number,width=1,left=TRUE)
         end
         pdbfile.put(element_name,width=len_trim(element_name),left=TRUE)
         if (position_symbol.is_included_in("'ABCGDENTZ")) then
         position_symbol.to_upper_case
         pdbfile.put(position_symbol,width=1,left=TRUE)
         pdbfile.tab(width=1)
         else
         pdbfile.tab(width=2)
         end
         element_len = len_trim(element_name)
         if (element_len == 1) then
         pdbfile.tab(width=1)
         end
         pdbfile.put(three_letter_code,width=3,left=TRUE)
         pdbfile.tab(width=2)
         pdbfile.put(residue_number,width=4)
         pdbfile.tab(width=2)
         pdbfile.set_int_width(7)

         ! Order for the ADP's .......
         ! u11 u22 u33 u12 u13 u23 XD-format
         ! u11 u22 u33 u12 u23 u13 SHELX
         ! u11 u22 u33 u13 u23 u12 PDB-format
         pdbfile.put(nint(self(i).ADP_tensor(1,1).to_units("angstrom^2")*10000))
         pdbfile.put(nint(self(i).ADP_tensor(2,2).to_units("angstrom^2")*10000))
         pdbfile.put(nint(self(i).ADP_tensor(3,3).to_units("angstrom^2")*10000))
         pdbfile.put(nint(self(i).ADP_tensor(1,3).to_units("angstrom^2")*10000))
         pdbfile.put(nint(self(i).ADP_tensor(2,3).to_units("angstrom^2")*10000))
         pdbfile.put(nint(self(i).ADP_tensor(1,2).to_units("angstrom^2")*10000))

         ! Last thing on line, chemical symbol
         pdbfile.put(self(i).chemical_symbol,width=8)

         ! Flush the line
         pdbfile.flush

      end
      pdbfile.unsave
   end

   put_coordinates_and_charges
   ! Output the atom coordinate information
      .put_coords_and_charges
      .put_coords_and_charges(angstrom=TRUE)
   end

   put_coords_and_charges(angstrom) ::: private
   ! Output the atom coordinates and charges
      angstrom :: BIN, optional
      i :: INT
      in_angstrom :: BIN
      in_angstrom = FALSE
      if (present(angstrom)) in_angstrom = angstrom
      stdout.flush
      if (NOT in_angstrom) then
      stdout.text("Atom list information:")
      else
      stdout.text("Atom list information (in angstrom):")
      end
      stdout.dash(int_fields=3,real_fields=4)
      stdout.put("#",int_width=TRUE)
      stdout.put("ID",int_width=TRUE)
      stdout.put("Z",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.put("charge")
      stdout.flush
      stdout.dash(int_fields=3,real_fields=4)
      do i = 1,.dim
         stdout.put(i)
         stdout.put(self(i).label,int_width=TRUE)
         stdout.put(self(i).nuclear_charge,int_width=TRUE)
         if (NOT in_angstrom) then
         stdout.put(self(i).position(1))
         stdout.put(self(i).position(2))
         stdout.put(self(i).position(3))
         else
         stdout.put(self(i).position(1).to_units("angstrom"))
         stdout.put(self(i).position(2).to_units("angstrom"))
         stdout.put(self(i).position(3).to_units("angstrom"))
         end
         stdout.put(self(i).charge)
         stdout.flush
      end
      stdout.dash(int_fields=3,real_fields=4)
   end

!  =====
!  ADP's
!  =====

   put_ADPs(no_header)
   ! Output the ADP information
   ! Output position and ADP errors if there.
   ! Always use Angstrom units for display.
      self :: IN
      no_header :: BIN, IN, optional

      .put_ADP2s(no_header)

      ! Plot ADP3's and ADP4's if present
      if (.has_any_ADP3s_and_errors) .put_ADP3s
      if (.has_any_ADP4s_and_errors) .put_ADP4s

   end

   put_ADP2s(no_header)
   ! Output the ADP information
   ! Output position and ADP errors if there.
   ! Always use Angstrom units for display.
      self :: IN
      no_header :: BIN, IN, optional

      ID,Uc :: VEC{STR}*
      U,dU :: MAT{REAL}*
      is_flat,is_npd :: VEC{BIN}*
      ratio :: VEC{REAL}*
      table :: VEC{TABLE_COLUMN}*
      fac :: REAL
      i :: INT
      header :: BIN

      header = TRUE
      if (present(no_header)) header = NOT no_header

      ! Use angstroms/angstrom^2
      fac  = STR:conversion_factor("angstrom")

      ! Create columns
      ID.create(.dim)
      Uc.create(6)
      U.create(.dim,6)
      dU.create(.dim,6)
      is_flat.create(.dim)
      is_npd.create(.dim)
      ratio.create(.dim)

      ! Get columns
      ID  = .tag
      .put_ADP2_labels_to(Uc)
      .put_ADP2_vector_to(U,fac)
      is_flat = .has_flat_ADP
      is_npd  = .has_NPD_ADP
      ratio   = .ADP_principal_axis_ratio

      ! Title
      if (header) then
      stdout.flush
      stdout.text("=====================================")
      stdout.text("Atomic displacement parameters (ADPs)")
      stdout.text("=====================================")
      stdout.flush
      stdout.text(". The ADPs are referred to cartesian axes.")
      stdout.text(". The length units are in Angstrom.")
      stdout.text(". An ADP is deemed bad if the max-on-min axis ratio")
      stdout.text("  - is greater than 4 (i.e. flat)")
      stdout.text("  - or is non-positive-definite (i.e. NPD)")
      stdout.flush
      stdout.show("No. of NPD  ADPs =",.no_of_NPD_ADPs)
      stdout.show("No. of Flat ADPs =",.no_of_flat_ADPs)
      stdout.flush
      end

      ! Set table headings & data
      table.create(10)
      table.set_spacing(2)

      if (NOT .has_nonzero_pADP2_errors) then

         ! Set table
         table(1).set_heading("ID")
         table(1).set_values(ID)
         do i = 1,6
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values(U(:,i))
         end

      else ! have position/ADP errors

         ! Get error column data
         .put_ADP2_errors_to(dU,fac)

         ! Set table
         table(1).set_heading("ID")
         table(1).set_values(ID)
         do i = 1,6
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values_and_errors(U(:,i),dU(:,i))
         end

      end

      ! Units headings
      table(4).set_subhead(trim("/A^2"))

      ! ADP diagonistics
      table( 8).set_heading("NPD?")
      table( 8).set_values(is_npd)
      table( 9).set_heading("Flat?")
      table( 9).set_values(is_flat)
      table(10).set_heading(" Axis")
      table(10).set_subhead("ratio")
      table(10).set_values(ratio)

      ! Make the table
      table.put

      ! Clean
      table.clear_columns
      table.destroy

      ratio.destroy
      is_npd.destroy
      is_flat.destroy
      dU.destroy
      U.destroy
      Uc.destroy
      ID.destroy

   end

   put_ADP3s ::: private
   ! Output the ADP3 information. Always comes after the ADP
   ! information. Use Angstroms.

      U,dU :: MAT{REAL}*
      Uc :: VEC{STR}*
      ID :: VEC{STR}*
      list :: VEC{INT}*
      table :: VEC{TABLE_COLUMN}*
      fac,sfac :: REAL
      i,n :: INT

      if (NOT .has_any_ADP3s_and_errors) return

      ! Use angstroms/angstrom^2
      fac  = STR:conversion_factor("angstrom")

      ! Scale factor
      sfac = CIF_GC3_SCALE_FACTOR
      stdout.flush
      stdout.show(". The cartesian ADP3s below have been scaled, scale factor =",sfac)

      ! No. of atoms with ADP3s
      n = .no_of_ADP3_atoms

      ! Create columns
      list.create(n)
      ID.create(n)
      Uc.create(10)
      U.create(n,10)
      dU.create(n,10)

      ! Get columns
      .put_ADP3_atom_list_to(list)
      ID = self(list).tag
      .put_ADP3_labels_to(Uc)
      .put_ADP3_vector_to(U,fac)
      U = sfac*U

      ! Set table headings & data
      table.create(11)
      table.set_spacing(2)

      if (NOT .has_nonzero_ADP3_errors) then

         ! Set table
         table(1).set_heading("ID")
         table(1).set_values(ID)
         do i = 1,10
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values(U(:,i))
         end

      else ! have position/ADP errors

         ! Get error column data
         .put_ADP3_errors_to(dU,fac)
         dU = sfac*dU

         ! Set table
         table(1).set_heading("ID")
         table(1).set_values(ID)
         do i = 1,10
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values_and_errors(U(:,i),dU(:,i))
         end

      end

      ! Units headings
      table(6).set_subhead(trim("/A^3"))

      ! Make the table
      table.put

      ! Clean
      table.clear_columns
      table.destroy
      dU.destroy
      U.destroy
      Uc.destroy
      ID.destroy
      list.destroy

   end

   put_ADP4s ::: private
   ! Output the ADP4 information. Always comes after the ADP
   ! information. Use Angstroms.

      U,dU :: MAT{REAL}*
      Uc :: VEC{STR}*
      ID :: VEC{STR}*
      list :: VEC{INT}*
      table :: VEC{TABLE_COLUMN}*
      fac,sfac :: REAL
      i,n :: INT

      if (NOT .has_any_ADP4s_and_errors) return

      ! Use angstroms/angstrom^2
      fac  = STR:conversion_factor("angstrom")

      ! Scale factor
      sfac = CIF_GC4_SCALE_FACTOR
      stdout.flush
      stdout.show(". The cartesian ADP4s below have been scaled, scale factor =",sfac)

      ! No. of atoms with ADP4
      n = .no_of_ADP4_atoms

      ! Create columns
      list.create(n)
      ID.create(n)
      Uc.create(15)
      U.create(n,15)
      dU.create(n,15)

      ! Get columns
      .put_ADP4_atom_list_to(list)
      ID = self(list).tag
      .put_ADP4_labels_to(Uc)
      .put_ADP4_vector_to(U,fac)
      U = sfac*U

      ! Set table headings & data
      table.create(16)
      table.set_spacing(2)

      if (NOT .has_nonzero_ADP4_errors) then

         ! Set table
         table(1).set_heading("ID")
         table(1).set_values(ID)
         do i = 1,15
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values(U(:,i))
         end

      else ! have position/ADP errors

         ! Get error column data
         .put_ADP4_errors_to(dU,fac)
         dU = sfac*dU

         ! Set table
         table(1).set_heading("ID")
         table(1).set_values(ID)
         do i = 1,15
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values_and_errors(U(:,i),dU(:,i))
         end

      end

      ! Units headings
      table(8).set_subhead(trim("/A^4"))

      ! Make the table
      table.put

      ! Clean
      table.clear_columns
      table.destroy
      dU.destroy
      U.destroy
      Uc.destroy
      ID.destroy
      list.destroy

   end

   put_pADPs
   ! Output the pADP vector information
   ! Genrally used for debugging only.

      mx :: MAT{REAL}*
      n :: INT
      fac :: REAL

      ! Use angstroms/angstrom^2
      fac = STR:conversion_factor("angstrom")

      ! No. of ADP's.
      n = .no_of_pADPs

      ! Get then
      mx.create(n,2)
      .put_pADP_vector_to(mx(:,1),fac)
      .put_pADP_errors_to(mx(:,2),fac)

      ! Title
      stdout.flush
      stdout.text("===================")
      stdout.text("Position/ADP vector")
      stdout.text("===================")
      stdout.flush
      stdout.text(". Column 1 is the pADP vector")
      stdout.text(". Column 2 are the corresponding errors")
      stdout.text(". The length unit is Angstrom")
      stdout.flush
      stdout.show("No. of pADPs =",n)
      stdout.flush

      ! Put
      stdout.put(mx)

      ! Clean
      mx.destroy

   end

   put_crystal_ADPs_with_errors
   ! Output the ADP information with errors.
   ! Always use Angstrom units for display.
   DIE_IF(NOT .has_nonzero_pADP2_errors,"must have ADP errors!")
   DIE_IF(any(self(:).ADP_axis_system/="crystal"),"must be in crystal axis system!")

      ID :: VEC{STR}*
      U,dU :: MAT{REAL}*
      Uc :: VEC{STR}*
      table :: VEC{TABLE_COLUMN}*
      fac :: REAL
      i :: INT

      ! Use angstroms/angstrom^2
      fac  = STR:conversion_factor("angstrom")

      ! Create columns
      ID.create(.dim)
      Uc.create(6)
      U.create(.dim,6)
      dU.create(.dim,6)

      ! Get columns of data
      ID  = .tag
      .put_ADP2_labels_to(Uc)
      .put_ADP2_vector_to(U,fac)
      .put_ADP2_errors_to(dU,fac)

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("=====================================")
      stdout.text("Atomic displacement parameters (ADPs)")
      stdout.text("=====================================")
      stdout.flush
      stdout.text(". The ADPs and errors are in crystal axes system.")
      stdout.text(". Units are in Angstrom^2.")
      stdout.flush

      ! Set table headings & data
      table.create(13)
      table.set_spacing(2)

      ! Set table
      table(1).set_heading("ID")
      table(1).set_values(ID)
      do i = 1,6
      table(2*i  ).set_heading(Uc(i))
      table(2*i  ).set_values(U(:,i))
      table(2*i+1).set_heading(" Est.")
      table(2*i+1).set_subhead("error")
      table(2*i+1).set_values(dU(:,i))
      end

      ! Make the table
      table.put

      ! Clean
      table.clear_columns
      table.destroy
      dU.destroy
      U.destroy
      Uc.destroy
      ID.destroy

   end

!  ============
!  Bond lengths
!  ============

   put_bond_length_table
   ! Output the bond length table.

      table :: VEC{TABLE_COLUMN}*
      atom_kind :: VEC{VEC_{INT}}*
      no_of_bonds, n_kind,k1,k2,n_bonds :: INT
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      dist :: VEC{REAL}*
      pair :: MAT{INT}*
      has_unique_labels :: BIN

      ! Anything to do?
      if (.dim<2) return

      no_of_bonds = .no_of_bonds
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("============")
      stdout.text("Bond lengths")
      stdout.text("============")
      stdout.flush
      stdout.text(". The bond-detection criteria is the same as used")
      stdout.text("  by the Cambridge Structural Database (CSD).")
      if (NOT has_unique_labels) then
      stdout.flush
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number tags are used.")
      end
      stdout.flush
      stdout.show("No. of bonds =",no_of_bonds)
      if (no_of_bonds>VEC_ATOM_MAX_BONDS_IN_TABLE) then
      stdout.flush
      stdout.text("There are too many bonds to display in a table.")
      return
      end
      stdout.flush

      ! Get atom kind list
      .make_atom_kind_list(atom_kind)

      ! Skip dummy atoms
      n_kind = atom_kind.dim
      if (self(atom_kind(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(7)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self.chemical_symbols)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_heading("B")
      table(3).set_width(table(1).width)
      table(3).set_left_justify(TRUE)

      table(4).set_heading("A")
      table(4).set_width_from(self.tag)

      table(5).set_spacing(0)
      table(5).set_heading("--")
      table(5).set_width(2)

      table(6).set_heading("B")
      table(6).set_width(table(4).width)
      table(6).set_left_justify(TRUE)

      table(7).set_heading("R(A--B)")
      table(7).set_subheading("/A")
      table(7).set_width_from(ONE)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_atoms(pair,dist,atom_kind,k1,k2)
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_bonds,2)
         symbols = " "
         symbols(1,1) = self(atom_kind(k1)[1]).chemical_symbol
         symbols(1,2) = self(atom_kind(k2)[1]).chemical_symbol

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = self(pair(:,1)).tag
         labels(:,2) = self(pair(:,2)).tag

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table(1).set_values(symbols(:,1))
         table(2).set_values(dsh1)
         table(3).set_values(symbols(:,2))
         table(4).set_values(labels(:,1))
         table(5).set_values(dash)
         table(6).set_values(labels(:,2))
         table(7).set_values(dist)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.clear_columns
      table.destroy
      atom_kind.destroy

   end

   put_bond_length_table(covariance,parentheses)
   ! Output the bond length table with errors, given the "covariance"
   ! matrix between all atomic positions. Set "paretheses" FALSE if
   ! you want errors without them.
      covariance :: MAT{REAL}, IN
      parentheses :: BIN, IN, optional

      table :: VEC{TABLE_COLUMN}*
      atom_kind :: VEC{VEC_{INT}}*
      no_of_bonds, n_kind,k1,k2,n_bonds :: INT
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      dist,esds :: VEC{REAL}*
      pair :: MAT{INT}*
      use_brackets,has_unique_labels :: BIN

      ! Anything to do?
      if (.dim<2) return

      no_of_bonds = .no_of_bonds
      if (no_of_bonds<1) return

      ! Parentheses
      use_brackets = TRUE
      if (present(parentheses)) use_brackets = parentheses

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("============")
      stdout.text("Bond lengths")
      stdout.text("============")
      stdout.flush
      stdout.text(". The bond-detection criteria is the same as used")
      stdout.text("  by the Cambridge Structural Database (CSD).")
      if (NOT has_unique_labels) then
      stdout.flush
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number ID tags are used.")
      end
      stdout.flush
      stdout.show("No. of bonds =",no_of_bonds)
      stdout.flush

      ! Get atom kind list
      .make_atom_kind_list(atom_kind)

      ! Skip dummy atoms
      n_kind = atom_kind.dim
      if (self(atom_kind(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      if (use_brackets) then; table.create(7)
      else;                   table.create(8)
      end

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self.chemical_symbols)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_heading("B")
      table(3).set_width(table(1).width)
      table(3).set_left_justify(TRUE)

      table(4).set_heading("A")
      table(4).set_width_from(self.tag)

      table(5).set_spacing(0)
      table(5).set_heading("--")
      table(5).set_width(2)

      table(6).set_heading("B")
      table(6).set_width(table(4).width)
      table(6).set_left_justify(TRUE)

      table(7).set_heading("R(A--B)")
      table(7).set_subheading("/A")
      table(7).set_width_from(ONE)

      if (NOT use_brackets) then
      table(8).set_heading("Error")
      table(8).set_width_from(ONE)
      end

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_atoms(pair,dist,esds,atom_kind,k1,k2,covariance) ! leaky
         dist = dist*ANGSTROM_PER_BOHR
         esds = esds*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            esds.destroy
            dist.destroy
            pair.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_bonds,2)
         symbols = " "
         symbols(1,1) = self(atom_kind(k1)[1]).chemical_symbol
         symbols(1,2) = self(atom_kind(k2)[1]).chemical_symbol

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = self(pair(:,1)).tag
         labels(:,2) = self(pair(:,2)).tag

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table(1).set_values(symbols(:,1))
         table(2).set_values(dsh1)
         table(3).set_values(symbols(:,2))
         table(4).set_values(labels(:,1))
         table(5).set_values(dash)
         table(6).set_values(labels(:,2))
         if (use_brackets) then
         table(7).set_real_precision(stdout.real_precision) ! Must do, for every block
         table(7).set_values_and_errors(dist,esds)
         else
         table(7).set_values(dist)
         table(8).set_values(esds)
         end

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         esds.destroy
         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.clear_columns
      table.destroy
      atom_kind.destroy

   end

   get_bonded_atoms(pair,dist,atom_kind,k1,k2,H_bonded) ::: leaky, private
   ! Get the bonded-atom "pair"s, and the distances "dist" between
   ! them. The pair has "atom_kind" of "k1" and "k2", respectively.
      pair :: MAT{INT}*
      dist :: VEC{REAL}*
      atom_kind :: VEC{VEC_{INT}}, IN
      k1,k2 :: INT, IN
      H_bonded :: BIN, IN, optional

      i1,i2,a1,a2, n :: INT

      ! How many pairs, n, are there?
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2<=a1) cycle
            if (NOT .bonded(a1,a2,H_bonded=H_bonded)) cycle

            ! Count
            n = n + 1

         end
      end

      ! Allocate
      pair.create(n,2)
      dist.create(n)

      ! Make the list
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2<=a1) cycle
            if (NOT .bonded(a1,a2,H_bonded=H_bonded)) cycle

            ! Add the data
            n = n + 1
            pair(n,1) = a1
            pair(n,2) = a2
            dist(n)   = .bond_distance(a1,a2)

         end
      end

   end

   get_bonded_atoms(pair,dist,esds,atom_kind,k1,k2,covariance,H_bonded) ::: leaky, private
   ! Get the bonded-atom "pair"s, and the distances "dist" between
   ! them, and the associated "esds". The pair has "atom_kind" of "k1"
   ! and "k2", respectively. The "covariance" matrix for *all* atom
   ! coordinates is also given.
      pair :: MAT{INT}*
      dist,esds :: VEC{REAL}*
      atom_kind :: VEC{VEC_{INT}}, IN
      k1,k2 :: INT, IN
      covariance :: MAT{REAL}
      H_bonded :: BIN, IN, optional

   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      i1,i2,a1,a2, n :: INT
      err :: REAL
      der :: VEC{REAL}(6)
      cov :: MAT{REAL}(6,6)

      ! How many pairs, n, are there?
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2<=a1) cycle
            if (NOT .bonded(a1,a2,H_bonded=H_bonded)) cycle

            ! Count
            n = n + 1

         end
      end

      ! Allocate
      pair.create(n,2)
      dist.create(n)
      esds.create(n)

      ! Make the list
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2<=a1) cycle
            if (NOT .bonded(a1,a2,H_bonded=H_bonded)) cycle

            ! Extract covariances for atom a, b positions
            covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2])

            ! Make error
            .bond_distance_deriv(a1,a2,der)
            err = cov.dot(der,der)
            err = sqrt(err)

            ! Add the data
            n = n + 1
            pair(n,1) = a1
            pair(n,2) = a2
            dist(n)   = .bond_distance(a1,a2)
            esds(n)   = err

         end
      end

   end

   put_bond_length_with_error(a1,a2,covariance) ::: leaky
   ! Get the bonded-atom "pair"s, and the distances "dist" between
   ! them, and the associated "esds". The pair has "atom_kind" of "k1"
   ! and "k2", respectively. The "covariance" matrix for *all* atom
   ! coordinates is also given.
      a1,a2 :: INT, IN
      covariance :: MAT{REAL}

   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      err,dist :: REAL
      der :: VEC{REAL}(6)
      cov :: MAT{REAL}(6,6)

      ! Extract position covariances for atom a1, a2
      covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2])

      ! Make error
      .bond_distance_deriv(a1,a2,der)
      err = cov.dot(der,der)
      err = sqrt(err)
      err.convert_to("angstrom")

      ! Add the data
      dist   = .bond_distance(a1,a2)
      dist.convert_to("angstrom")

      ! Output
      stdout.flush
      stdout.text("======================")
      stdout.text("Bond length with error")
      stdout.text("======================")
      stdout.show("Atom 1        =",self(a1).tag)
      stdout.show("Atom 2        =",self(a2).tag)
      stdout.show("Bond length   =",dist)
      stdout.show("Error         =",err)

   end

!  ===========
!  Bond angles
!  ===========

   put_bond_angle_table
   ! Output the bond angle table.

      table :: VEC{TABLE_COLUMN}*
      atom_kind :: VEC{VEC_{INT}}*
      no_of_angles, n_kind,k1,k2,k3,n_angles,w :: INT
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      triple :: MAT{INT}*
      angle :: VEC{REAL}*
      val :: STR
      has_unique_labels :: BIN

      if (.dim<3) return

      no_of_angles = .no_of_angles
      if (no_of_angles<1) return

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("===========")
      stdout.text("Bond Angles")
      stdout.text("===========")
      stdout.flush
      stdout.text(". Atom B of Angle(A--B--C) is the middle atom.")
      stdout.flush
      if (NOT has_unique_labels) then
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number ID tags are used.")
      end
      stdout.flush
      stdout.show("No. of bond angles =",no_of_angles)
      if (no_of_angles>VEC_ATOM_MAX_ANGLES_IN_TABLE) then
      stdout.flush
      stdout.text("There are too many angles to display in a table.")
      return
      end
      stdout.flush

      ! Get atom kind list
      .make_atom_kind_list(atom_kind)

      ! Skip dummy atoms
      n_kind = atom_kind.dim
      if (self(atom_kind(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(11)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.chemical_symbols)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_spacing(0)
      table(3).set_heading("B")
      table(3).set_width_from(.chemical_symbols)

      table(4).set_spacing(0)
      table(4).set_heading("--")
      table(4).set_width(2)

      table(5).set_spacing(0)
      table(5).set_heading("C")
      table(5).set_width(table(2).width)
      table(5).set_left_justify(TRUE)

      table(6).set_heading("A")
      table(6).set_width_from(self(.angle_outer_atoms).tag)

      table(7).set_spacing(0)
      table(7).set_heading("--")
      table(7).set_width(2)

      table(8).set_spacing(0)
      table(8).set_heading("B")
      table(8).set_width_from(self(.angle_center_atoms).tag)
      w = table(8).width
      val = "B"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(8).set_heading(val(1:w))

      table(9).set_spacing(0)
      table(9).set_heading("--")
      table(9).set_width(2)

      table(10).set_spacing(0)
      table(10).set_heading("C")
      table(10).set_width_from(self(.angle_outer_atoms).tag)
      table(10).set_left_justify(TRUE)

      table(11).set_heading("Angle(A--B--C)")
      table(11).set_subheading("/degree")
      table(11).set_width_from(ONE)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = 1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_angles(triple,angle,atom_kind,k1,k2,k3)
         angle = angle*DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            angle.destroy
            triple.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,3)
         symbols = " "
         symbols(1,1) = self(atom_kind(k1)[1]).chemical_symbol
         symbols(1,2) = self(atom_kind(k2)[1]).chemical_symbol
         symbols(1,3) = self(atom_kind(k3)[1]).chemical_symbol

         ! Labels
         labels.create(n_angles,3)
         labels(:,1) = self(triple(:,1)).tag
         labels(:,2) = self(triple(:,2)).tag
         labels(:,3) = self(triple(:,3)).tag

         labels(:,2).pad_with("-",width=w,prepad=TRUE)

         ! Dashes
         dash.create(n_angles)
         dsh1.create(n_angles)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(dsh1)
         table( 5).set_values(symbols(:,3))
         table( 6).set_values(labels(:,1))
         table( 7).set_values(dash)
         table( 8).set_values(labels(:,2))
         table( 9).set_values(dash)
         table(10).set_values(labels(:,3))
         table(11).set_values(angle)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         angle.destroy
         triple.destroy

      end
      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      atom_kind.destroy

   end

   put_bond_angle_table(covariance,parentheses)
   ! Output the bond angle table with errors given the "covariance"
   ! matrix between all atomic positions. Set "parentheses" FALSE if
   ! you don't want them for errors.
      covariance :: MAT{REAL}, IN
      parentheses :: BIN, IN, optional

      table :: VEC{TABLE_COLUMN}*
      atom_kind :: VEC{VEC_{INT}}*
      no_of_angles, n_kind,k1,k2,k3,n_angles,w :: INT
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      angle,esds :: VEC{REAL}*
      triple :: MAT{INT}*
      val :: STR
      use_brackets,has_unique_labels :: BIN

      if (.dim<3) return

      no_of_angles = .no_of_angles
      if (no_of_angles<1) return

      ! Parentheses
      use_brackets = TRUE
      if (present(parentheses)) use_brackets = parentheses

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("===========")
      stdout.text("Bond Angles")
      stdout.text("===========")
      stdout.flush
      stdout.text("Atom B of Angle(A--B--C) is the middle atom.")
      stdout.flush
      if (NOT has_unique_labels) then
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number ID tags are used.")
      end
      stdout.flush
      stdout.show("No. of bond angles =",.no_of_angles)
      if (no_of_angles>VEC_ATOM_MAX_ANGLES_IN_TABLE) then
      stdout.flush
      stdout.text("There are too many angles to display in a table.")
      return
      end
      stdout.flush

      ! Get atom kind list
      .make_atom_kind_list(atom_kind)

      ! Skip dummy atoms
      n_kind = atom_kind.dim
      if (self(atom_kind(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      if (use_brackets) then; table.create(11)
      else;                   table.create(12)
      end

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.chemical_symbols)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_spacing(0)
      table(3).set_heading("B")
      table(3).set_width_from(.chemical_symbols)

      table(4).set_spacing(0)
      table(4).set_heading("--")
      table(4).set_width(2)

      table(5).set_spacing(0)
      table(5).set_heading("C")
      table(5).set_width(table(2).width)
      table(5).set_left_justify(TRUE)

      table(6).set_heading("A")
      table(6).set_width_from(self(.angle_outer_atoms).tag)

      table(7).set_spacing(0)
      table(7).set_heading("--")
      table(7).set_width(2)

      table(8).set_spacing(0)
      table(8).set_heading("B")
      table(8).set_width_from(self(.angle_center_atoms).tag)
      w = table(8).width
      val = "B"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(8).set_heading(val(1:w))

      table(9).set_spacing(0)
      table(9).set_heading("--")
      table(9).set_width(2)

      table(10).set_spacing(0)
      table(10).set_heading("C")
      table(10).set_width_from(self(.angle_outer_atoms).tag)
      table(10).set_left_justify(TRUE)

      table(11).set_heading("Angle(A--B--C)")
      table(11).set_subheading("/degree")
      table(11).set_width_from(ONE)

      if (NOT use_brackets) then
      table(12).set_heading("Error")
      table(12).set_width_from(ONE)
      end

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = 1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_angles(triple,angle,esds,atom_kind,k1,k2,k3,covariance)
         angle = angle*DEGREE_PER_RADIAN
         esds  = esds *DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            esds.destroy
            angle.destroy
            triple.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,3)
         symbols = " "
         symbols(1,1) = self(atom_kind(k1)[1]).chemical_symbol
         symbols(1,2) = self(atom_kind(k2)[1]).chemical_symbol
         symbols(1,3) = self(atom_kind(k3)[1]).chemical_symbol

         ! Labels
         labels.create(n_angles,3)
         labels(:,1) = self(triple(:,1)).tag
         labels(:,2) = self(triple(:,2)).tag
         labels(:,3) = self(triple(:,3)).tag

         labels(:,2).pad_with("-",width=w,prepad=TRUE)

         ! Dashes
         dash.create(n_angles)
         dsh1.create(n_angles)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(dsh1)
         table( 5).set_values(symbols(:,3))
         table( 6).set_values(labels(:,1))
         table( 7).set_values(dash)
         table( 8).set_values(labels(:,2))
         table( 9).set_values(dash)
         table(10).set_values(labels(:,3))
         if (use_brackets) then
         table(11).set_real_precision(stdout.real_precision) ! Must do, for every block
         table(11).set_values_and_errors(angle,esds)
         else
         table(11).set_values(angle)
         table(12).set_values(esds)
         end

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         esds.destroy
         angle.destroy
         triple.destroy

      end
      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      atom_kind.destroy

   end

   get_bonded_angles(triple,angle,atom_kind,k1,k2,k3) ::: leaky, private
   ! Get the bonded-atom "triple"s, and the "angles" between them. The
   ! triple has "atom_kind" of "k1", "k2", and "k3", respectively.
      triple :: MAT{INT}*
      angle :: VEC{REAL}*
      atom_kind :: VEC{VEC_{INT}}, IN
      k1,k2,k3 :: INT, IN

      i1,i2,i3,a1,a2,a3, n :: INT

      ! How many triples, n, are there?
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,atom_kind(k3).element.dim
               a3 = atom_kind(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle
               if (a3<a1) cycle

               ! Count
               n = n + 1

            end
         end
      end

      ! Allocate
      triple.create(n,3)
      angle.create(n)

      ! Make the list
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,atom_kind(k3).element.dim
               a3 = atom_kind(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle
               if (a3<a1) cycle

               ! Add data
               n = n + 1
               triple(n,1) = a1
               triple(n,2) = a2
               triple(n,3) = a3
               angle(n) = .bond_angle(a1,a2,a3)

            end
         end
      end

   end

   get_bonded_angles(triple,angle,esds,atom_kind,k1,k2,k3,covariance) ::: leaky, private
   ! Get the bonded-atom "triple"s, and the "angles" between them, and
   ! the associated "esds". The triple has "atom_kind" of "k1", "k2",
   ! and "k3", respectively. The "covariance" matrix between *all*
   ! atom coordinates is also given.
      triple :: MAT{INT}*
      angle,esds :: VEC{REAL}*
      atom_kind :: VEC{VEC_{INT}}, IN
      k1,k2,k3 :: INT, IN
      covariance :: MAT{REAL}, IN

   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      i1,i2,i3,a1,a2,a3, n :: INT
      err :: REAL
      der :: VEC{REAL}(9)
      cov :: MAT{REAL}(9,9)

      ! How many triples, n, are there?
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,atom_kind(k3).element.dim
               a3 = atom_kind(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle
               if (a3<a1) cycle

               ! Count
               n = n + 1

            end
         end
      end

      ! Allocate
      triple.create(n,3)
      angle.create(n)
      esds.create(n)

      ! Make the list
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,atom_kind(k3).element.dim
               a3 = atom_kind(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle
               if (a3<a1) cycle

               ! Extract covariances for atoms a, b, c
               covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2,a3])

               ! Make error
               .bond_angle_deriv(a1,a2,a3,der)
               err = cov.dot(der,der)
               if (err<ZERO) then
                  err = ZERO
               end
               err = sqrt(err)

               ! Add data
               n = n + 1
               triple(n,1) = a1
               triple(n,2) = a2
               triple(n,3) = a3
               angle(n)    = .bond_angle(a1,a2,a3)
               esds(n)     = err

            end
         end
      end

   end

   put_bond_angle_with_error(a1,a2,a3,covariance) ::: leaky
   ! Get the bonded-atom "pair"s, and the distances "dist" between
   ! them, and the associated "esds". The pair has "atom_kind" of "k1"
   ! and "k2", respectively. The "covariance" matrix for *all* atom
   ! coordinates is also given.
      a1,a2,a3 :: INT, IN
      covariance :: MAT{REAL}
   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      err,ang :: REAL
      der :: VEC{REAL}(9)
      cov :: MAT{REAL}(9,9)

      ! Extract covariances for atom a, b, c positions
      covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2,a3])

      ! Make error
      .bond_angle_deriv(a1,a2,a3,der)
      err = cov.dot(der,der)
      err = sqrt(err)
      err.convert_to("degree")

      ! Add the data
      ang   = .bond_angle(a1,a2,a3)
      ang.convert_to("degree")

      ! Output
      stdout.flush
      stdout.text("=====================")
      stdout.text("Bond angle with error")
      stdout.text("=====================")
      stdout.show("Atom 1        =",self(a1).tag)
      stdout.show("Atom 2        =",self(a2).tag)
      stdout.show("Atom 3        =",self(a3).tag)
      stdout.show("Bond angle    =",ang)
      stdout.show("Error         =",err)

   end

!  ================
!  Torsions angles
!  ================

   put_torsion_angle_table
   ! Output the torsion angle table.

      table :: VEC{TABLE_COLUMN}*
      atom_kind :: VEC{VEC_{INT}}*
      no_of_torsions, n_kind,k1,k2,k3,k4,n_angles,w :: INT
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      quad :: MAT{INT}*
      angle :: VEC{REAL}*
      val :: STR
      has_unique_labels :: BIN

      if (.dim<4) return

      no_of_torsions = .no_of_torsion_angles
      if (no_of_torsions<1) return

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("==============")
      stdout.text("Torsion angles")
      stdout.text("==============")
      stdout.flush
      stdout.text(". The angle shown is the one that looking down B->C")
      stdout.text("  i.e. it's the one between r(A)-r(B) and r(D)-r(C)")
      stdout.flush
      stdout.text(". The angle is +ve if r(D)-r(C) is clockwise of r(A)-r(B)")
      stdout.flush
      if (NOT has_unique_labels) then
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number ID tags are used.")
      end
      stdout.flush
      stdout.show("No. of torsion angles =",no_of_torsions)
      if (no_of_torsions>VEC_ATOM_MAX_TORSIONS_IN_TABLE) then
      stdout.flush
      stdout.text("There are too many angles to display in a table.")
      return
      end
      stdout.flush

      ! Get atom kind list
      .make_atom_kind_list(atom_kind)

      ! Skip dummy atoms
      n_kind = atom_kind.dim
      if (self(atom_kind(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(15)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.chemical_symbols)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_spacing(0)
      table(3).set_heading("B")
      table(3).set_width_from(.chemical_symbols)

      table(4).set_spacing(0)
      table(4).set_heading("--")
      table(4).set_width(2)

      table(5).set_spacing(0)
      table(5).set_heading("C")
      table(5).set_width_from(.chemical_symbols)

      table(6).set_spacing(0)
      table(6).set_heading("--")
      table(6).set_width(2)

      table(7).set_spacing(0)
      table(7).set_heading("D")
      table(7).set_width(table(2).width)
      table(7).set_left_justify(TRUE)

      table(8).set_heading("A")
      table(8).set_width_from(self(.torsion_angle_1st_atoms).tag)

      table(9).set_spacing(0)
      table(9).set_heading("--")
      table(9).set_width(2)

      table(10).set_spacing(0)
      table(10).set_heading("B")
      table(10).set_width_from(self(.torsion_angle_2nd_atoms).tag)
      w = table(10).width
      val = "B"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(10).set_heading(val(1:w))

      table(11).set_spacing(0)
      table(11).set_heading("--")
      table(11).set_width(2)

      table(12).set_spacing(0)
      table(12).set_heading("C")
      table(12).set_width_from(self(.torsion_angle_3rd_atoms).tag)
      w = table(12).width
      val = "C"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(12).set_heading(val(1:w))

      table(13).set_spacing(0)
      table(13).set_heading("--")
      table(13).set_width(2)

      table(14).set_spacing(0)
      table(14).set_heading("D")
      table(14).set_width_from(self(.torsion_angle_4th_atoms).tag)
      table(14).set_left_justify(TRUE)

      table(15).set_heading("Angle(A--B--C--D)")
      table(15).set_subheading("/degree")
      table(15).set_width_from(ONE)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = 1,n_kind
      do k4 = 1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_torsions(quad,angle,atom_kind,k1,k2,k3,k4)
         angle = angle*DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            angle.destroy
            quad.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,4)
         symbols = " "
         symbols(1,1) = self(atom_kind(k1)[1]).chemical_symbol
         symbols(1,2) = self(atom_kind(k2)[1]).chemical_symbol
         symbols(1,3) = self(atom_kind(k3)[1]).chemical_symbol
         symbols(1,4) = self(atom_kind(k4)[1]).chemical_symbol

         ! Labels
         labels.create(n_angles,4)
         labels(:,1) = self(quad(:,1)).tag
         labels(:,2) = self(quad(:,2)).tag
         labels(:,3) = self(quad(:,3)).tag
         labels(:,4) = self(quad(:,4)).tag

         labels(:,2).pad_with("-",width=w,prepad=TRUE)
         labels(:,3).pad_with("-",width=w,prepad=TRUE)

         ! Dashes
         dash.create(n_angles)
         dsh1.create(n_angles)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(dsh1)
         table( 5).set_values(symbols(:,3))
         table( 6).set_values(dsh1)
         table( 7).set_values(symbols(:,4))

         table( 8).set_values(labels(:,1))
         table( 9).set_values(dash)
         table(10).set_values(labels(:,2))
         table(11).set_values(dash)
         table(12).set_values(labels(:,3))
         table(13).set_values(dash)
         table(14).set_values(labels(:,4))

         table(15).set_values(angle)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         angle.destroy
         quad.destroy

      end
      end
      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      atom_kind.destroy

   end

   put_torsion_angle_table(covariance,parentheses)
   ! Output the torsion angle table with errors given the "covariance"
   ! matrix between all atomic positions. Set "parentheses" FALSE if
   ! ypou don't want them for errors.
      covariance :: MAT{REAL}, IN
      parentheses :: BIN, IN, optional

      table :: VEC{TABLE_COLUMN}*
      atom_kind :: VEC{VEC_{INT}}*
      no_of_torsions, n_kind,k1,k2,k3,k4,n_angles,w :: INT
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      angle,esds :: VEC{REAL}*
      quad :: MAT{INT}*
      val :: STR
      use_brackets,has_unique_labels :: BIN

      if (.dim<4) return

      no_of_torsions = .no_of_torsion_angles
      if (no_of_torsions<1) return

      ! Parentheses
      use_brackets = TRUE
      if (present(parentheses)) use_brackets = parentheses

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("==============")
      stdout.text("Torsion angles")
      stdout.text("==============")
      stdout.flush
      stdout.text("The angle shown is the one that looking down B->C")
      stdout.text("i.e. it's the one between r(A)-r(B) and r(D)-r(C).")
      stdout.flush
      stdout.text("The angle is +ve if r(D)-r(C) is clockwise of r(A)-r(B).")
      stdout.flush
      if (NOT has_unique_labels) then
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number ID tags are used.")
      end
      stdout.flush
      stdout.show("No. of torsion angles =",no_of_torsions)
      if (no_of_torsions>VEC_ATOM_MAX_TORSIONS_IN_TABLE) then
      stdout.flush
      stdout.text("There are too many angles to display in a table.")
      return
      end
      stdout.flush

      ! Get atom kind list
      .make_atom_kind_list(atom_kind)

      ! Skip dummy atoms
      n_kind = atom_kind.dim
      if (self(atom_kind(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      if (use_brackets) then; table.create(15)
      else;                   table.create(16)
      end

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.chemical_symbols)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_spacing(0)
      table(3).set_heading("B")
      table(3).set_width_from(.chemical_symbols)

      table(4).set_spacing(0)
      table(4).set_heading("--")
      table(4).set_width(2)

      table(5).set_spacing(0)
      table(5).set_heading("C")
      table(5).set_width_from(.chemical_symbols)

      table(6).set_spacing(0)
      table(6).set_heading("--")
      table(6).set_width(2)

      table(7).set_spacing(0)
      table(7).set_heading("D")
      table(7).set_width(table(2).width)
      table(7).set_left_justify(TRUE)

      table(8).set_heading("A")
      table(8).set_width_from(self(.torsion_angle_1st_atoms).tag)

      table(9).set_spacing(0)
      table(9).set_heading("--")
      table(9).set_width(2)

      table(10).set_spacing(0)
      table(10).set_heading("B")
      table(10).set_width_from(self(.torsion_angle_2nd_atoms).tag)
      w = table(10).width
      val = "B"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(10).set_heading(val(1:w))

      table(11).set_spacing(0)
      table(11).set_heading("--")
      table(11).set_width(2)

      table(12).set_spacing(0)
      table(12).set_heading("C")
      table(12).set_width_from(self(.torsion_angle_3rd_atoms).tag)
      w = table(12).width
      val = "C"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(12).set_heading(val(1:w))

      table(13).set_spacing(0)
      table(13).set_heading("--")
      table(13).set_width(2)

      table(14).set_spacing(0)
      table(14).set_heading("D")
      table(14).set_width_from(self(.torsion_angle_4th_atoms).tag)
      table(14).set_left_justify(TRUE)

      table(15).set_heading("Angle(A--B--C--D)")
      table(15).set_subheading("/degree")
      table(15).set_width_from(ONE)

      if (NOT use_brackets) then
      table(16).set_heading("Error")
      table(16).set_width_from(ONE)
      end

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = 1,n_kind
      do k4 = 1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_torsions(quad,angle,esds,atom_kind,k1,k2,k3,k4,covariance)
         angle = angle*DEGREE_PER_RADIAN
         esds  =  esds*DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            esds.destroy
            angle.destroy
            quad.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,4)
         symbols = " "
         symbols(1,1) = self(atom_kind(k1)[1]).chemical_symbol
         symbols(1,2) = self(atom_kind(k2)[1]).chemical_symbol
         symbols(1,3) = self(atom_kind(k3)[1]).chemical_symbol
         symbols(1,4) = self(atom_kind(k4)[1]).chemical_symbol

         ! Labels
         labels.create(n_angles,4)
         labels(:,1) = self(quad(:,1)).tag
         labels(:,2) = self(quad(:,2)).tag
         labels(:,3) = self(quad(:,3)).tag
         labels(:,4) = self(quad(:,4)).tag

         labels(:,2).pad_with("-",width=w,prepad=TRUE)
         labels(:,3).pad_with("-",width=w,prepad=TRUE)

         ! Dashes
         dash.create(n_angles)
         dsh1.create(n_angles)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(dsh1)
         table( 5).set_values(symbols(:,3))
         table( 6).set_values(dsh1)
         table( 7).set_values(symbols(:,4))

         table( 8).set_values(labels(:,1))
         table( 9).set_values(dash)
         table(10).set_values(labels(:,2))
         table(11).set_values(dash)
         table(12).set_values(labels(:,3))
         table(13).set_values(dash)
         table(14).set_values(labels(:,4))

         if (use_brackets) then
         table(15).set_real_precision(stdout.real_precision) ! Must do, for every block
         table(15).set_values_and_errors(angle,esds)
         else
         table(15).set_values(angle)
         table(16).set_values(esds)
         end

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Put spacer if not last block
         if (NOT (k1==n_kind AND k2==n_kind AND k3==n_kind AND k4==n_kind)) stdout.flush

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         esds.destroy
         angle.destroy
         quad.destroy

      end
      end
      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      atom_kind.destroy

   end

   get_bonded_torsions(quad,angle,atom_kind,k1,k2,k3,k4) ::: leaky, private
   ! Get the bonded-atom "quad"ruples, and the "angles" between them.
   ! The quadruple has "atom_kind" of "k1", "k2", and "k3", respectively.
      quad :: MAT{INT}*
      angle :: VEC{REAL}*
      atom_kind :: VEC{VEC_{INT}}, IN
      k1,k2,k3,k4 :: INT, IN

      i1,i2,i3,i4,a1,a2,a3,a4, n :: INT

      ! How many quadruples, n, are there?
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,atom_kind(k3).element.dim
               a3 = atom_kind(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle

               do i4 = 1,atom_kind(k4).element.dim
                  a4 = atom_kind(k4)[i4]

                  if (a4==a1 OR a4==a2 OR a4==a3) cycle
                  if (NOT .bonded(a3,a4)) cycle
                  if (a4<a1) cycle

                  ! Count
                  n = n + 1

               end
            end
         end
      end

      ! Allocate
      quad.create(n,4)
      angle.create(n)

      ! Make the list
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,atom_kind(k3).element.dim
               a3 = atom_kind(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle

               do i4 = 1,atom_kind(k4).element.dim
                  a4 = atom_kind(k4)[i4]

                  if (a4==a1 OR a4==a2 OR a4==a3) cycle
                  if (NOT .bonded(a3,a4)) cycle
                  if (a4<a1) cycle

                  ! Add data
                  n = n + 1
                  quad(n,1) = a1
                  quad(n,2) = a2
                  quad(n,3) = a3
                  quad(n,4) = a4
                  angle(n)  = .torsion_angle(a1,a2,a3,a4)

               end
            end
         end
      end

   end

   get_bonded_torsions(quad,angle,esds,atom_kind,k1,k2,k3,k4,covariance) ::: leaky, private
   ! Get the bonded-atom "quad"ruples, and the "angles" between them.
   ! The quadruple has "atom_kind" of "k1", "k2", and "k3", respectively.
      quad :: MAT{INT}*
      angle,esds :: VEC{REAL}*
      atom_kind :: VEC{VEC_{INT}}, IN
      k1,k2,k3,k4 :: INT, IN
      covariance :: MAT{REAL}, IN

   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      i1,i2,i3,i4,a1,a2,a3,a4, n :: INT
      err :: REAL
      der :: VEC{REAL}(12)
      cov :: MAT{REAL}(12,12)

      ! How many quadruples, n, are there?
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,atom_kind(k3).element.dim
               a3 = atom_kind(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle

               do i4 = 1,atom_kind(k4).element.dim
                  a4 = atom_kind(k4)[i4]

                  if (a4==a1 OR a4==a2 OR a4==a3) cycle
                  if (NOT .bonded(a3,a4)) cycle
                  if (a4<a1) cycle

                  ! Count
                  n = n + 1

               end
            end
         end
      end

      ! Allocate
      quad.create(n,4)
      angle.create(n)
      esds.create(n)

      ! Make the list
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,atom_kind(k3).element.dim
               a3 = atom_kind(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle

               do i4 = 1,atom_kind(k4).element.dim
                  a4 = atom_kind(k4)[i4]

                  if (a4==a1 OR a4==a2 OR a4==a3) cycle
                  if (NOT .bonded(a3,a4)) cycle
                  if (a4<a1) cycle

                  ! Extract covariances for atoms a, b, c
                  covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2,a3,a4])

                  ! Make error
                  .torsion_angle_deriv(a1,a2,a3,a4,der)
                  err = cov.dot(der,der)
                  if (err<ZERO) then
                     err = ZERO
                  end
                  err = sqrt(err)

                  ! Add data
                  n = n + 1
                  quad(n,1) = a1
                  quad(n,2) = a2
                  quad(n,3) = a3
                  quad(n,4) = a4
                  angle(n)  = .torsion_angle(a1,a2,a3,a4)
                  esds(n)   = err

               end
            end
         end
      end

   end

   put_torsion_angle_with_error(a1,a2,a3,a4,covariance) ::: leaky
   ! Get the bonded-atom "pair"s, and the distances "dist" between
   ! them, and the associated "esds". The pair has "atom_kind" of "k1"
   ! and "k2", respectively. The "covariance" matrix for *all* atom
   ! coordinates is also given.
      a1,a2,a3,a4 :: INT, IN
      covariance :: MAT{REAL}
   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      err,tor :: REAL
      der :: VEC{REAL}(12)
      cov :: MAT{REAL}(12,12)

      ! Extract covariances for atom a, b positions
      covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2,a3,a4])

      ! Make error
      .torsion_angle_deriv(a1,a2,a3,a4,der)
      err = cov.dot(der,der)
      err = sqrt(err)
      err.convert_to("degree")

      ! Add the data
      tor   = .torsion_angle(a1,a2,a3,a4)
      tor.convert_to("degree")

      ! Output
      stdout.flush
      stdout.text("========================")
      stdout.text("Torsion angle with error")
      stdout.text("========================")
      stdout.show("Atom 1        =",self(a1).tag)
      stdout.show("Atom 2        =",self(a2).tag)
      stdout.show("Atom 3        =",self(a3).tag)
      stdout.show("Atom 4        =",self(a4).tag)
      stdout.show("Torsion angle =",tor)
      stdout.show("Error         =",err)

   end

!  ==============
!  Principal axes
!  ==============

   put_principal_axes
   ! Put out the principal axis information

      pm,pn :: VEC{REAL}(3)
      pa :: MAT{REAL}(3,3)
      reorder :: BIN

      .make_principal_moments(pm,pa,reorder)

      pn = pm/maxval(pm) ! normalised moments

      stdout.flush
      stdout.text("Principal moments and axes:")
      stdout.flush
      stdout.show("Center of mass    =",.center_of_mass)
      stdout.show("Principal moments =",pm)
      stdout.show("Spherical top?    =",.is_spherical_top(pn))
      stdout.show("Symmetric top?    =",.is_symmetric_top(pn))
      stdout.show("Prolate top?      =",.is_prolate_top(pn))
      stdout.show("Oblate top?       =",.is_oblate_top(pn))
      stdout.flush
      stdout.text("Principal axes:")
      stdout.put(pa)

   end

!  ==
!  MM
!  ==

   put_mm_info ::: private
   ! Output a table of the residue names, sequence numbers, charges, but
   ! no basis sets. This is in PDB input format.
      i :: INT
      stdout.flush
      stdout.text("Residue information:")
      stdout.flush
      stdout.dash(width=42)
      stdout.put(" ",width=4)
      stdout.put("#",width=7)
      stdout.put("Name",width=4)
      stdout.put("Residue",width=5)
      stdout.put("Sequence",width=6)
      stdout.put("x",width=3)
      stdout.put("y",width=3)
      stdout.put("z",width=3)
      stdout.put("Charge",width=3)
      stdout.put("Element",width=4)
      stdout.flush
      stdout.dash(width=42)
      stdout.dash(int_fields=6,real_fields=5)
      do i = 1,size(self)
         stdout.put("ATOM",width=4)
         stdout.put(i,width=7)
         stdout.put(self(i).residue_atom_code,width=4)
         stdout.put(self(i).residue_code,width=5)
         stdout.put(self(i).residue_sequence_number,width=6)
         stdout.put(self(i).position(1),width=8,precision=3)
         stdout.put(self(i).position(2),width=8,precision=3)
         stdout.put(self(i).position(3),width=8,precision=3)
         stdout.put(self(i).mm_charge,width=7,precision=3)
         stdout.put(self(i).label,width=4)
         stdout.flush
      end
      stdout.dash(width=42)
   end

   put_restraint_atoms ::: private
   ! Output a table of the atom names, residue names and restraint atom
   ! information
      i :: INT
      stdout.text("Restraint atoms:")
      stdout.save
      stdout.set_int_width(9)
      stdout.set_real_width(9)
      stdout.set_real_precision(3)
      stdout.dash(int_fields=5,real_fields=3)
      stdout.put(" ",int_width=TRUE)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Residue",int_width=TRUE)
      stdout.put("Sequence")
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.put("Force",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=5,real_fields=3)
      do i = 1,size(self)
         if (self(i).restraining_force_constant.is_zero) cycle
         stdout.put(" ",int_width=TRUE)
         stdout.put(self(i).residue_atom_code,int_width=TRUE)
         stdout.put(self(i).residue_code,int_width=TRUE)
         stdout.put(self(i).residue_sequence_number)
         stdout.put(self(i).restraining_position(1))
         stdout.put(self(i).restraining_position(2))
         stdout.put(self(i).restraining_position(3))
         stdout.put(self(i).restraining_force_constant)
         stdout.flush
      end
      stdout.dash(int_fields=5,real_fields=3)
      stdout.unsave
   end

!  ====
!  VRML
!  ====

   put_vrml(out)
   ! Put vrml version of the atomvec to the file in object "out".
      out :: TEXTFILE

      out.set_real_precision(5)
      out.set_real_width(12)

      stdout.text("Generating VRML atoms...")
      VEC{ATOM}::put_vrml_header(out)
      .put_vrml_atoms(out)
      .put_vrml_bonds(out)
      stdout.text("done VRML atoms")
      stdout.flush

   end

   put_vrml_header(out) ::: selfless, private
   ! Put vrml header, and prototype bond and spheres, to the file.
      out :: TEXTFILE

      out.text("PROTO Atom " // achar(91))
      out.text("   field SFColor col 1 0 0")
      out.text("   field SFFloat rad 1")
      out.text("   field SFVec3f pos 0 0 0")
      out.text(achar(93))
      out.text("{")
      out.text("   Transform {")
      out.text("      translation IS pos")
      out.text("      children " // achar(91))
      out.text("         Shape {")
      out.text("            appearance Appearance {")
      out.text("               material Material {")
      out.text("                  diffuseColor IS col")
      out.text("               }")
      out.text("            }")
      out.text("            geometry Sphere {")
      out.text("              radius IS rad")
      out.text("            }")
      out.text("         }")
      out.text("      " // achar(93))
      out.text("   }")
      out.text("}")

      out.flush

      out.text("PROTO Bond " // achar(91))
      out.text("   field SFColor col 1 0 0")
      out.text("   field SFFloat hgt 1")
      out.text("   field SFVec3f pos 0 0 0")
      out.text("   field SFRotation rot 1 0 0 0")
      out.text(achar(93))
      out.text("{")
      out.text("   Transform {")
      out.text("      translation IS pos")
      out.text("      rotation IS rot")
      out.text("      children " // achar(91))
      out.text("         Shape {")
      out.text("            appearance Appearance {")
      out.text("               material Material {")
      out.text("                 diffuseColor IS col")
      out.text("               }")
      out.text("            }")
      out.text("            geometry Cylinder {")
      out.text("               radius 0.304245979")
      out.text("               height IS hgt")
      out.text("               top    FALSE")
      out.text("               bottom FALSE")
      out.text("            }")
      out.text("         }")
      out.text("      " // achar(93))
      out.text("   }")
      out.text("}")

      out.flush

   end

   put_vrml_atoms(out) ::: private
   ! Put spheres for the atoms to view as vrml.
      out :: TEXTFILE

      colour :: VEC{REAL}(3)
      label :: STR(len=2)
      radius :: REAL
      n,Z :: INT

      do n = 1,.dim

         Z = self(n).atomic_number
         label = self(n).chemical_symbol

         select case (label)
            case ("H ","D ","T ");           colour = (/191,196,192/)
            case ("He","Rn");                colour = (/88,196,160/)
            case ("Li","Be","Na","Mg");      colour = (/144,149,145/)
            case ("B ");                     colour = (/187,4,187/)
            case ("C ");                     colour = (/160,80,17/)
            case ("N ","Al");                colour = (/126,169,176/)
            case ("Si");                     colour = (/192,172,137/)
            case ("S ");                     colour = (/192,165,0/)
            case ("Cl");                     colour = (/0,165,0/)
            case ("O ","Ca","Ge","As");      colour = (/192,12,8/)
            case ("Se","Br","Sr","I ");      colour = (/192,12,8/)
            case default;                    colour = (/192,148,25/)
         end

         select case (Z)
            case (1:54);     radius = self(n).bragg_slater_radius
            case default;    radius = 1.30d0
         end

         colour = colour / 256
         out.text("Atom {")
         out.text(" col " // trim(colour.to_concatenated_str("f15.8",separator=", ")))
         out.text(" pos " // trim(self(n).position.to_concatenated_str("f15.8",separator=", ")))
         out.text(" rad " // trim(radius.to_str("f15.8")))
         out.text("}")

      end

   end

   put_vrml_bonds(out) ::: private
   ! Put bonds for the atoms to view as vrml.
      out :: TEXTFILE

      col_a,col_b,posa,posb,pos1,pos2,AB,center :: VEC{REAL}(3)
      rot :: VEC{REAL}(4)
      hgta,hgtb,rada,radb :: REAL
      a,b :: INT

      do a = 1,.dim
      do b = 1,a-1

         if (.bonded(a,b)) then

            posa = self(a).position
            posb = self(b).position
            AB = posb-posa
            AB.normalise

            rada = self(a).bragg_slater_radius
            radb = self(b).bragg_slater_radius
            center = HALF*(posa+rada*AB + posb-radb*AB)

            hgta = (center - posa).norm
            hgtb = (posb - center).norm

            pos1 = HALF*(center + posa)
            pos2 = HALF*(center + posb)

            rot(4) = PI
            rot(1:3) = AB + (/ZERO,ONE,ZERO/)
            rot(1:3).normalise

            select case (self(a).chemical_symbol)
               case ("H ","D ","T ");           col_a = (/191,196,192/)
               case ("He","Rn");                col_a = (/88,196,160/)
               case ("Li","Be","Na","Mg");      col_a = (/144,149,145/)
               case ("B ");                     col_a = (/187,4,187/)
               case ("C ");                     col_a = (/160,80,17/)
               case ("N ","Al");                col_a = (/126,169,176/)
               case ("Si");                     col_a = (/192,172,137/)
               case ("S ");                     col_a = (/192,165,0/)
               case ("Cl");                     col_a = (/0,165,0/)
               case ("O ","Ca","Ge","As");      col_a = (/192,12,8/)
               case ("Se","Br","Sr","I ");      col_a = (/192,12,8/)
               case default;                    col_a = (/192,148,25/)
            end

            select case (self(b).chemical_symbol)
               case ("H ");                     col_b = (/191,196,192/)
               case ("He","Rn");                col_b = (/88,196,160/)
               case ("Li","Be","Na","Mg");      col_b = (/144,149,145/)
               case ("B ");                     col_b = (/187,4,187/)
               case ("C ");                     col_b = (/160,80,17/)
               case ("N ","Al");                col_b = (/126,169,176/)
               case ("Si");                     col_b = (/192,172,137/)
               case ("S ");                     col_b = (/192,165,0/)
               case ("Cl");                     col_b = (/0,165,0/)
               case ("O ","Ca","Ge","As");      col_b = (/192,12,8/)
               case ("Se","Br","Sr","I ");      col_b = (/192,12,8/)
               case default;                    col_b = (/192,148,25/)
            end

            col_a = col_a / 256
            col_b = col_b / 256
            out.text("Bond {")
            out.text(" col " //  trim(col_a.to_concatenated_str("f15.8",separator=", ")))
            out.text(" pos " //  trim(pos1.to_concatenated_str("f15.8",separator=", ")))
            out.text(" rot " //  trim(rot.to_concatenated_str("f15.8",separator=", ")))
            out.text(" hgt " //  trim(hgta.to_str("f15.8")))
            out.text("}")
            out.text("Bond {")
            out.text(" col " //  trim(col_b.to_concatenated_str("f15.8",separator=", ")))
            out.text(" pos " //  trim(pos2.to_concatenated_str("f15.8",separator=", ")))
            out.text(" rot " //  trim(rot.to_concatenated_str("f15.8",separator=", ")))
            out.text(" hgt " //  trim(hgtb.to_str("f15.8")))
            out.text("}")

         end

      end
      end

   end

   put_atom_groups
   ! Put out the atom group information
      self :: IN

   ENSURE(.has_groups,"no atom group information")

      n,i :: INT
      list :: VEC{VEC_{INT}}*

      .make_atom_group_list(list)

      stdout.save
      stdout.set_int_width(3)
      stdout.set_no_of_fields_per_line(25)
      stdout.set_using_array_labels(FALSE)

      stdout.flush
      stdout.text("Atom group information")
      stdout.flush
      stdout.show("n_groups =",list.dim)

      do n = 1,list.dim
         stdout.put("group "// trim(n.to_str) //"  =")
         do i = 1,list(n).element.dim
            stdout.put(list(n).element(i))
         end
         stdout.flush
      end

      stdout.unsave
      list.destroy

   end

   put_CX(label,angstrom)
   ! Outputs some information for the Crystal Explorer program
      label :: STR
      angstrom :: BIN, optional

      a :: INT
      pos :: VEC{REAL}(3)
      angst :: BIN

      angst = FALSE
      if (present(angstrom)) angst = angstrom

      ! Print atom_coords
      stdout.flush
      stdout.text("begin atom_coords " // label.trim)

      do a = 1,.dim

         stdout.put(self(a).label)
         stdout.put(self(a).chemical_symbol)

         pos = self(a).position
         if (angst) pos = ANGSTROM_PER_BOHR*pos
         stdout.put(pos(1))
         stdout.put(pos(2))
         stdout.put(pos(3))

         stdout.put(" IN")

         stdout.put(self(a).site_disorder_group)
         stdout.put(self(a).site_occupancy)

         stdout.flush

      end

      stdout.text("end atom_coords")

   end

!  ================
!  Put cif routines
!  ================

   put_CIF(cif)
   ! Output the atoms in CIF format to "stdout" in crystal axis
   ! system. This version does not produce errors. See below.
   ! The "cif" file defines the format, units of the anharmonic
   ! constants.
      cif :: CIF, IN

      i,w :: INT
      lab :: STR
      ADP :: MAT{REAL}(3,3)
      ADP3v :: VEC{REAL}(10)
      ADP4v :: VEC{REAL}(15)
      fac1,fac2 :: REAL
      fac3,fac4 :: REAL

      ! Unit conversion for ADP's
      fac1 =  ANGSTROM_PER_BOHR
      fac2 = fac1*fac1
      fac3 = fac2*fac1
      fac4 = fac2*fac2

      ! Reset accuracy
      stdout.save
      stdout.set_real_precision(5)
      stdout.set_real_width(9)

      ! CIF coordinate header
      stdout.flush
      stdout.text("# =====================")
      stdout.text("# Coordinates and ADP's")
      stdout.text("# =====================")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_label")
      stdout.text("_atom_site_fract_x")
      stdout.text("_atom_site_fract_y")
      stdout.text("_atom_site_fract_z")
      stdout.text("_atom_site_adp_type")
      stdout.text("_atom_site_occupancy")

      ! Get max tag width
      w = maxval(len_trim(self(:).tag))

      ! Put coordinates, NO errors (crystal axis system; unitless)
      do i = 1,.dim

         stdout.put(self(i).tag.trim,width=w,left=TRUE)

         stdout.put(self(i).position(1))
         stdout.put(self(i).position(2))
         stdout.put(self(i).position(3))
         stdout.put(trim("Uani"),width=5)
         stdout.put(self(i).site_occupancy,width=0,left=TRUE)
         stdout.flush

      end

      ! CIF ADP header
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_aniso_label")
      do i = 1,6
      lab = self(1).ADP_label(i,form="underscore-123-repeated")
      stdout.text("_atom_site_aniso_"//trim(lab))
      end

      ! Put ADP's in angstrom^2, no errors
      do i = 1,.dim

         stdout.put(self(i).label.trim,width=len_trim(self(i).label))

         ! Get values
         ADP =  fac2 * self(i).ADP_tensor

         ! Print ADP
         stdout.put(ADP(1,1))
         stdout.put(ADP(2,2))
         stdout.put(ADP(3,3))
         stdout.put(ADP(1,2))
         stdout.put(ADP(1,3))
         stdout.put(ADP(2,3))

         stdout.flush

      end

      ! Put ADP3's ==========
      if (.has_any_ADP3s_and_errors) then

      stdout.flush
      stdout.text("# NOTE: these numbers are usually multiplied by 1000")
      stdout.text("#       Divide by this factor to get the true constant")
      stdout.flush
      stdout.text(trim(cif.GC3_label)//"scale_factor "//trim(cif.GC3_scale_factor.to_str))
      stdout.flush
      stdout.text("loop_")
      stdout.text(trim(cif.GC3_label)//"label")
      do i = 1,10
      lab = self(1).ADP3_index_label(i,form="underscore-123-repeated")
      stdout.text(trim(cif.GC3_label)//trim(lab))
      end

      do i = 1,.dim

         if (NOT self(i).has_ADP3s_and_errors) cycle

         stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)

         ! Get values
         self(i).put_ADP3_vector_to(ADP3v)
         if (cif.GC_format=="u") ADP3v = fac3*ADP3v
                                 ADP3v = cif.GC3_scale_factor*ADP3v

         ! Print ADP3
         stdout.flush
         stdout.put(ADP3v( 1))
         stdout.put(ADP3v( 2))
         stdout.put(ADP3v( 3))
         stdout.flush
         stdout.put(ADP3v( 4))
         stdout.put(ADP3v( 5))
         stdout.put(ADP3v( 6))
         stdout.put(ADP3v( 7))
         stdout.flush
         stdout.put(ADP3v( 8))
         stdout.put(ADP3v( 9))
         stdout.put(ADP3v(10))
         stdout.flush

      end

      end

      ! Put ADP4's ==========
      if (.has_any_ADP4s_and_errors) then

      stdout.flush
      stdout.text("# NOTE: these numbers are multiplied by 10,000")
      stdout.text("#       Divide by 10,000 to get the true constant")
      stdout.flush
      stdout.text(trim(cif.GC4_label)//"scale_factor "//trim(cif.GC4_scale_factor.to_str))
      stdout.flush
      stdout.text("loop_")
      stdout.text(trim(cif.GC4_label)//"label")
      do i = 1,15
      lab = self(1).ADP4_index_label(i,form="underscore-123-repeated")
      stdout.text(trim(cif.GC4_label)//trim(lab))
      end

      do i = 1,.dim

         if (NOT self(i).has_ADP4s_and_errors) cycle

         stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)

         ! Get values
         self(i).put_ADP4_vector_to(ADP4v)
         if (cif.GC_format=="u") ADP4v = fac4*ADP4v
                                 ADP4v = cif.GC4_scale_factor*ADP4v

         ! Print ADP3
         stdout.flush
         stdout.put(ADP4v( 1))
         stdout.put(ADP4v( 2))
         stdout.put(ADP4v( 3))
         stdout.flush
         stdout.put(ADP4v( 4))
         stdout.put(ADP4v( 5))
         stdout.put(ADP4v( 6))
         stdout.flush
         stdout.put(ADP4v( 7))
         stdout.put(ADP4v( 8))
         stdout.put(ADP4v( 9))
         stdout.flush
         stdout.put(ADP4v(10))
         stdout.put(ADP4v(11))
         stdout.put(ADP4v(12))
         stdout.flush
         stdout.put(ADP4v(13))
         stdout.put(ADP4v(14))
         stdout.put(ADP4v(15))
         stdout.flush

      end

      end

      ! Revert
      stdout.unsave

   end

   put_CIF_with_errors(cif,esd)
   ! Output the atoms in CIF format to "stdout"
   ! The units, and format for the errors "esd" are defined by the
   ! "cif", and are in the crystal axis system, but this is stupid.
      cif :: CIF, IN
      esd :: VEC{REAL}, IN

   ENSURE(esd.dim==.no_of_pADPS,"wrong sizem esd")

      ADP :: VEC{REAL}(15)
      err :: VEC{REAL}(15)
      pos :: VEC{REAL}(3)
      lab :: STR
      i,k,w :: INT
      fac1,fac2 :: REAL
      fac3,fac4 :: REAL

      ! Unit conversion for ADP's
      fac1 = ANGSTROM_PER_BOHR
      fac2 = fac1*fac1
      fac3 = fac2*fac1
      fac4 = fac2*fac2

      ! Reset precision for errors
      stdout.save
      stdout.set_real_width(stdout.saved.real_width+3)
      stdout.set_real_precision(stdout.saved.real_precision+3)

      ! CIF coordinate header
      stdout.flush
      stdout.text("# =====================")
      stdout.text("# Coordinates and ADP's")
      stdout.text("# =====================")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_label")
      stdout.text("_atom_site_fract_x")
      stdout.text("_atom_site_fract_y")
      stdout.text("_atom_site_fract_z")
      stdout.text("_atom_site_adp_type")
      stdout.text("_atom_site_occupancy")

      ! Get max tag width
      w = maxval(len_trim(self(:).tag))

      ! Put positions and errors (crystal exis system; unitless)
      k = 0
      do i = 1,.dim

         stdout.put(self(i).tag.trim,width=w,left=TRUE)

         pos      = self(i).position
         err(1:3) = esd(k+1:k+3)

         stdout.put(pos(1),err(1),width=0,left=TRUE) ! Unitless
         stdout.put(pos(2),err(2),width=0,left=TRUE)
         stdout.put(pos(3),err(3),width=0,left=TRUE)
         stdout.put(trim("Uani"),width=5)
         stdout.put(self(i).site_occupancy,width=0,left=TRUE)
         stdout.flush

         k = k + self(i).no_of_pADPs

      end

      ! CIF ADP header
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_aniso_label")
      do i = 1,6
      lab = self(1).ADP_label(i,form="underscore-123-repeated")
      stdout.text("_atom_site_aniso_"//trim(lab))
      end

      ! Put ADP's in Angstrom^2 (crystal axis system)
      k = 0
      do i = 1,.dim

         stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)

         ! Get values and errors
         self(i).put_ADP2_vector_to(ADP(1:6))
         ADP(1:6) = fac2*ADP(1:6)
         err(1:6) = fac2*esd(k+4:k+9)

         ! Put quantity q with error e in format q(e)
         stdout.put(ADP(1),err(1),width=0,left=TRUE)
         stdout.put(ADP(2),err(2),width=0,left=TRUE)
         stdout.put(ADP(3),err(3),width=0,left=TRUE)
         stdout.put(ADP(4),err(4),width=0,left=TRUE)
         stdout.put(ADP(5),err(5),width=0,left=TRUE)
         stdout.put(ADP(6),err(6),width=0,left=TRUE)
         stdout.flush

         k = k + self(i).no_of_pADPs

      end

      ! Put ADP3's ==========
      if (.has_any_ADP3s_and_errors) then

      stdout.flush
      stdout.text("# NOTE 1: these numbers are multiplied by 1,000")
      stdout.text("#         Divide by 1000 to get the true constant")
      stdout.flush
      stdout.text(trim(cif.GC3_label)//"scale_factor "//trim(cif.GC3_scale_factor.to_str))
      stdout.flush
      stdout.text("loop_")
      stdout.text(trim(cif.GC3_label)//"label")
      do i = 1,10
      lab = self(1).ADP3_index_label(i,form="underscore-123-repeated")
      stdout.text(trim(cif.GC3_label)//trim(lab))
      end

      k = 0
      do i = 1,.dim

         if (NOT self(i).has_ADP3s_and_errors) cycle

         stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)

         ! Get values and errors (dimensionless)
         self(i).put_ADP3_vector_to(ADP(1:10))
         err(1:10) = esd(k+10:k+19)
         if (cif.GC_format=="u") then
            ADP(1:10) = ADP(1:10)*fac3
            err(1:10) = err(1:10)*fac3
         end
         ADP(1:10) = ADP(1:10)*cif.GC3_scale_factor
         err(1:10) = err(1:10)*cif.GC3_scale_factor

         ! Put quantity q with error e in format q(e)
         stdout.flush
         stdout.put(ADP( 1),err( 1),width=0,left=TRUE)
         stdout.put(ADP( 2),err( 2),width=0,left=TRUE)
         stdout.put(ADP( 3),err( 3),width=0,left=TRUE)
         stdout.flush
         stdout.put(ADP( 4),err( 4),width=0,left=TRUE)
         stdout.put(ADP( 5),err( 5),width=0,left=TRUE)
         stdout.put(ADP( 6),err( 6),width=0,left=TRUE)
         stdout.put(ADP( 7),err( 7),width=0,left=TRUE)
         stdout.flush
         stdout.put(ADP( 8),err( 8),width=0,left=TRUE)
         stdout.put(ADP( 9),err( 9),width=0,left=TRUE)
         stdout.put(ADP(10),err(10),width=0,left=TRUE)
         stdout.flush

         k = k + self(i).no_of_pADPs

      end

      end

      ! Put ADP4's ==========
      if (.has_any_ADP4s_and_errors) then

      stdout.flush
      stdout.text("# NOTE: these numbers are multiplied by 10,000")
      stdout.text("#       Divide by 10,000 to get the true constant")
      stdout.flush
      stdout.text(trim(cif.GC4_label)//"scale_factor "//trim(cif.GC4_scale_factor.to_str))
      stdout.flush
      stdout.text("loop_")
      stdout.text(trim(cif.GC4_label)//"label")
      do i = 1,15
      lab = self(1).ADP4_index_label(i,form="underscore-123-repeated")
      stdout.text(trim(cif.GC4_label)//trim(lab))
      end

      k = 0
      do i = 1,.dim

         if (NOT self(i).has_ADP4s_and_errors) cycle

         stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)

         ! Get values and errors (dimensionless)
         self(i).put_ADP4_vector_to(ADP(1:15))
         err(1:15) = esd(k+20:k+34)
         if (cif.GC_format=="u") then
            ADP(1:10) = ADP(1:10)*fac4
            err(1:10) = err(1:10)*fac4
         end
         ADP(1:15) = ADP(1:15)*cif.GC4_scale_factor
         err(1:15) = err(1:15)*cif.GC4_scale_factor

         ! Put quantity q with error e in format q(e)
         stdout.flush
         stdout.put(ADP( 1),err( 1),width=0,left=TRUE)
         stdout.put(ADP( 2),err( 2),width=0,left=TRUE)
         stdout.put(ADP( 3),err( 3),width=0,left=TRUE)
         stdout.flush
         stdout.put(ADP( 4),err( 4),width=0,left=TRUE)
         stdout.put(ADP( 5),err( 5),width=0,left=TRUE)
         stdout.put(ADP( 6),err( 6),width=0,left=TRUE)
         stdout.flush
         stdout.put(ADP( 7),err( 7),width=0,left=TRUE)
         stdout.put(ADP( 8),err( 8),width=0,left=TRUE)
         stdout.put(ADP( 9),err( 9),width=0,left=TRUE)
         stdout.flush
         stdout.put(ADP(10),err(10),width=0,left=TRUE)
         stdout.put(ADP(11),err(11),width=0,left=TRUE)
         stdout.put(ADP(12),err(12),width=0,left=TRUE)
         stdout.flush
         stdout.put(ADP(13),err(13),width=0,left=TRUE)
         stdout.put(ADP(14),err(14),width=0,left=TRUE)
         stdout.put(ADP(15),err(15),width=0,left=TRUE)
         stdout.flush

         k = k + self(i).no_of_pADPs

      end

      end ! =========

      ! Revert
      stdout.unsave

   end

   put_accurate_CIF(cif)
   ! Output the atoms in CIF format to "stdout".  If present, the full
   ! (symmetric) cartesian "covariance" matrix is printed out.
   ! This version is used for Tonto restarts. The "cif" file defines
   ! the labels and units for any anharmonic constants.
      cif :: CIF, IN

      i,w :: INT
      lab :: STR
      ADP :: MAT{REAL}(3,3)
      ADP3v :: VEC{REAL}(10)
      ADP4v :: VEC{REAL}(15)
      fac1,fac2 :: REAL
      fac3,fac4 :: REAL

      ! Unit conversion for ADP's
      fac1 = ANGSTROM_PER_BOHR
      fac2 = fac1*fac1
      fac3 = fac2*fac1
      fac4 = fac2*fac2

      ! Reset accuracy
      stdout.save
    ! stdout.set_real_style("f")
    ! stdout.set_real_width(18)
    ! stdout.set_real_precision(10)

      ! CIF coordinate header
      stdout.flush
      stdout.text("# =====================")
      stdout.text("# Coordinates and ADP's")
      stdout.text("# =====================")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_label")
      stdout.text("_atom_site_fract_x")
      stdout.text("_atom_site_fract_y")
      stdout.text("_atom_site_fract_z")
      stdout.text("_atom_site_adp_type")
      stdout.text("_atom_site_occupancy")

      ! Get max tag width
      w = maxval(len_trim(self(:).tag))

      ! Put positions, NO errors (crystal exis system; unitless)
      do i = 1,.dim

         stdout.put(self(i).tag.trim,width=w,left=TRUE)

         stdout.put(self(i).position(1))
         stdout.put(self(i).position(2))
         stdout.put(self(i).position(3))
         stdout.put(trim("Uani"),width=5)
         stdout.put(self(i).site_occupancy,width=0,left=TRUE)
         stdout.flush

      end

      ! CIF ADP header
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_aniso_label")
      do i = 1,6
      lab = self(1).ADP_label(i,form="underscore-123-repeated")
      stdout.text("_atom_site_aniso_"//trim(lab))
      end

      ! Put ADP's in angtsrom
      do i = 1,.dim

         stdout.put(self(i).tag.trim,width=len_trim(self(i).tag))

         ! Get values (Angstrom^2)
         ADP =  fac2 * self(i).ADP_tensor

         ! Print ADP
         stdout.put(ADP(1,1))
         stdout.put(ADP(2,2))
         stdout.put(ADP(3,3))
         stdout.put(ADP(1,2))
         stdout.put(ADP(1,3))
         stdout.put(ADP(2,3))

         stdout.flush

      end

      ! Put ADP3's ==========
      if (.has_any_ADP3s_and_errors) then

      stdout.flush
      stdout.text("# NOTE: these numbers are multiplied by 1,000")
      stdout.text("#       Divide by 1000 to get the true constant")
      stdout.flush
      stdout.text(trim(cif.GC3_label)//"scale_factor "//trim(cif.GC3_scale_factor.to_str))
      stdout.flush
      stdout.text("loop_")
      stdout.text(trim(cif.GC3_label)//"label")
      do i = 1,10
      lab = self(1).ADP3_index_label(i,form="underscore-123-repeated")
      stdout.text(trim(cif.GC3_label)//trim(lab))
      end

      do i = 1,.dim

         if (NOT self(i).has_ADP3s_and_errors) cycle

         stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)

         ! Get values
         self(i).put_ADP3_vector_to(ADP3v)
         if (cif.GC_format=="u") ADP3v = fac3*ADP3v
                                 ADP3v = cif.GC3_scale_factor*ADP3v

         ! Print ADP3
         stdout.flush
         stdout.put(ADP3v( 1))
         stdout.put(ADP3v( 2))
         stdout.put(ADP3v( 3))
         stdout.flush
         stdout.put(ADP3v( 4))
         stdout.put(ADP3v( 5))
         stdout.put(ADP3v( 6))
         stdout.put(ADP3v( 7))
         stdout.flush
         stdout.put(ADP3v( 8))
         stdout.put(ADP3v( 9))
         stdout.put(ADP3v(10))
         stdout.flush

      end

      end

      ! Put ADP4's ==========
      if (.has_any_ADP4s_and_errors) then

      stdout.flush
      stdout.text("# NOTE: these numbers are multiplied by 10,000")
      stdout.text("#       Divide by 10,000 to get the true constant")
      stdout.flush
      stdout.text(trim(cif.GC4_label)//"scale_factor "//trim(cif.GC4_scale_factor.to_str))
      stdout.flush
      stdout.text("loop_")
      stdout.text(trim(cif.GC4_label)//"label")
      do i = 1,15
      lab = self(1).ADP4_index_label(i,form="underscore-123-repeated")
      stdout.text(trim(cif.GC4_label)//trim(lab))
      end

      do i = 1,.dim

         if (NOT self(i).has_ADP4s_and_errors) cycle

         stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)

         ! Get values
         self(i).put_ADP4_vector_to(ADP4v)
         if (cif.GC_format=="u") ADP4v = fac4*ADP4v
                                 ADP4v = cif.GC4_scale_factor*ADP4v

         ! Print ADP3
         stdout.flush
         stdout.put(ADP4v( 1))
         stdout.put(ADP4v( 2))
         stdout.put(ADP4v( 3))
         stdout.flush
         stdout.put(ADP4v( 4))
         stdout.put(ADP4v( 5))
         stdout.put(ADP4v( 6))
         stdout.flush
         stdout.put(ADP4v( 7))
         stdout.put(ADP4v( 8))
         stdout.put(ADP4v( 9))
         stdout.flush
         stdout.put(ADP4v(10))
         stdout.put(ADP4v(11))
         stdout.put(ADP4v(12))
         stdout.flush
         stdout.put(ADP4v(13))
         stdout.put(ADP4v(14))
         stdout.put(ADP4v(15))
         stdout.flush

      end

      end

      ! Revert
      stdout.unsave

   end

   put_NKA_with_errors(T_sequence_no)
   ! Output the atom positions, ADP's, ADP sigmas in NKA file format
   ! to "stdout".
      T_sequence_no :: INT

      i,k :: INT
      fac :: REAL
      ADP :: MAT{REAL}(3,3)
      pos :: VEC{REAL}(3)
      err :: VEC{REAL}(6)

      ! Unit conversion for ADP's
      fac =  ANGSTROM_PER_BOHR*ANGSTROM_PER_BOHR

      ! Coordinates and ADP's in A^2
      stdout.flush
      do i = 1,.dim

         stdout.put(self(i).chemical_symbol,width=3)

         ! Coordinates in crystal or cartesian system
         pos = ANGSTROM_PER_BOHR * self(i).position
         stdout.put(pos(1))
         stdout.put(pos(2))
         stdout.put(pos(3))
         stdout.put(1,width=2)
         stdout.put(T_sequence_no,width=3)
         stdout.flush

         ! Get values and errors
         ADP =  fac * self(i).ADP_tensor

         ! ADP's always in cartesians and A^2
         stdout.put(ADP(1,1))
         stdout.put(ADP(2,2))
         stdout.put(ADP(3,3))
         stdout.put(ADP(1,2))
         stdout.put(ADP(1,3))
         stdout.put(ADP(2,3))

         stdout.flush

      end

      ! Now the ADP errors
      stdout.flush
      k = -9
      do i = 1,.dim

         k = k + 9

         stdout.put("SIG",width=3)
         stdout.put(self(i).chemical_symbol,width=3)
         stdout.put(T_sequence_no,width=3)

         ! Get values and errors
         err = fac * self(i).pADP_errors(4:9)

         ! Print ADPs
         stdout.put(err(1))
         stdout.put(err(2))
         stdout.put(err(3))
         stdout.put(err(4))
         stdout.put(err(5))
         stdout.put(err(6))

         stdout.flush

      end

   end

   put_excel_with_errors(esd,temperature)
   ! Output the atoms in Excel file format to "stdout"
   ! This should be in the crystal coordinate system.
      esd :: VEC{REAL}
      temperature :: REAL

   ENSURE(self(1).pos_axis_system=="crystal","must be in crystal axis system")

      i,k :: INT
      fac :: REAL
      ADP :: MAT{REAL}(3,3)
      err :: VEC{REAL}(6)
      lab :: STR

      ! Unit conversion for ADP's
      fac =  ANGSTROM_PER_BOHR*ANGSTROM_PER_BOHR

      ! Coordinates in crystal axis system
      stdout.show("Coordinates refined at T =",temperature)
      stdout.flush
      k = 0
      do i = 1,.dim

         stdout.put("x")
         stdout.put(self(i).position(1))
         stdout.put(esd(k+1))
         stdout.put(self(i).tag)
         stdout.flush

         stdout.put("y")
         stdout.put(self(i).position(2))
         stdout.put(esd(k+2))
         stdout.put(self(i).tag)
         stdout.flush

         stdout.put("z")
         stdout.put(self(i).position(3))
         stdout.put(esd(k+3))
         stdout.put(self(i).tag)
         stdout.flush

         k = k + 9

      end

      ! ADP's in crystal (CIF) axis system, angstrom^2 units
      stdout.show("ADP's refined at T =",temperature)
      stdout.flush
      k = 0
      do i = 1,.dim

         ! Get values and errors
         ADP = fac * self(i).ADP_tensor
         err = fac * esd(k+4:k+9)
         lab = self(i).tag

         ! Print
         stdout.put("U11"); stdout.put(ADP(1,1)); stdout.put(err(1)); stdout.put(lab); stdout.flush
         stdout.put("U22"); stdout.put(ADP(2,2)); stdout.put(err(2)); stdout.put(lab); stdout.flush
         stdout.put("U33"); stdout.put(ADP(3,3)); stdout.put(err(3)); stdout.put(lab); stdout.flush
         stdout.put("U12"); stdout.put(ADP(1,2)); stdout.put(err(4)); stdout.put(lab); stdout.flush
         stdout.put("U13"); stdout.put(ADP(1,3)); stdout.put(err(5)); stdout.put(lab); stdout.flush
         stdout.put("U23"); stdout.put(ADP(2,3)); stdout.put(err(6)); stdout.put(lab); stdout.flush

         k = k + 9

      end

   end

   initialize_local_H_modes(L)
   ! Initialize local H modes as columns. These come in triples.
   ! The first is the XH stretch. The next two are the two XH bends.
      L :: MAT{REAL}

   ENSURE(L.dim1==3*.dim,"wrong size, dim1")
   ENSURE(L.dim2==3*count(self.atomic_number==1),"wrong size, dim2")

      unit :: MAT{REAL}(3,3)
      r1,r2,r3 :: VEC{REAL}(3)
      h,i,x, fh,lh :: INT

      ! Make the connection table
      .make_connection_table

      ! Initialise L
      L = ZERO

      ! Set unit vectors
      unit.to_unit_matrix

      ! Make the H modes
      i  = 0
      lh = 0

      do h = 1,.dim

         fh = lh + 1
         lh = lh + 3

         ! Only look for a = H atom
         if(self(h).atomic_number>1) cycle

         ! Make sure H atom connects one other
         if (connections_for(h).element.dim>1) then
            DIE("H atom connected tomore than one other")
         end

         ! Get XH vector
         x  = connections_for(h)[1]
         r1 = self(h).position - self(x).position
         r1.normalise

         ! Get the two perpendicular vectors
         r2.to_cross_product_of(r1,unit(:,1))
         if (r2.is_zero) &
         r2.to_cross_product_of(r1,unit(:,2))
         r2.normalise
         r3.to_cross_product_of(r1,r2)

         ! Set L
         L(fh:lh,i+1) = r1
         L(fh:lh,i+2) = r2
         L(fh:lh,i+3) = r3

         ! Next H mode
         i = i + 3

      end

      ! Clean
      connections_for.destroy

   end

end
