!---------------------------------------------------------------------------
!
! VEC{ATOM}: ATOM vectors
!
! Copyright (C) Dylan Jayatilaka, 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!---------------------------------------------------------------------------

module VEC{ATOM}

   USE dftd3_api

   implicit none

   ! Atom connection table, to save work
   connections_for :: VEC{VEC_{INT}}*, private DEFAULT_NULL

contains

!  ==================
!  Allocation methods
!  ==================

   create(dim) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Create space for object
   end

   destroy ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Destroy space for object
   end

   nullify_ptr_part ::: get_from(VEC{OBJECT}), PURE
   ! Nullify the pointer parts of self
   end

   nullify_bases ::: PURE
   ! Nullify all the bases
      self :: INOUT

      .nullify_basis_part
      .nullify_slaterbasis_part
      .nullify_coppensbasis_part

   end

   nullify_basis_part ::: PURE
   ! Nullify the basis parts of self
      self :: INOUT

      a :: INT

      do a = 1,.dim
         nullify(self(a).basis)
      end

   end

   nullify_slaterbasis_part ::: PURE
   ! Nullify the slaterbasis parts of self
      self :: INOUT

      a :: INT

      do a = 1,.dim
         nullify(self(a).slaterbasis)
      end

   end

   nullify_coppensbasis_part ::: PURE
   ! Nullify the coppensbasis parts of self
      self :: INOUT

      a :: INT

      do a = 1,.dim
         nullify(self(a).coppensbasis)
      end

   end

   destroy_ptr_part ::: PURE
   ! Destroy the pointer parts of self
      self :: INOUT

      a :: INT

      ! Bases are never destroyed, they are always resolved externally
      ! to this module. (You just have to know that).
      .nullify_bases

      ! Destroy unique ptr parts (made outside of this module)
      if (.has_all_ANOs_made)           .destroy_ANOs
      if (.has_all_ANO_interpolators)   .destroy_ANO_interpolators
      if (.has_all_shell_info)          .destroy_shell_info

      ! Destroy non-unique ptr parts (made outside of this module)
      ! Each atom has a non-aliased object
      if (.has_all_spherical_atom_data) .destroy_spherical_atom_data
      if (.has_all_interpolators)       .destroy_interpolators

      ! Now safe to destroy ...
      do a = 1,.dim
         self(a).destroy_ptr_part
      end

   end

   destroy_ANOs ::: leaky, PURE
   ! Destroy the (unique-atom) ANOs
      self :: INOUT

      a :: INT

      do a = 1,.dim
         self(a).destroy_ANOs
      end

   end

   destroy_ANO_interpolators ::: leaky, PURE
   ! Destroy the (unique-atom) ANO interpolators
      self :: INOUT

      a :: INT

      do a = 1,.dim
         self(a).destroy_ANO_interpolators
      end

   end

   destroy_shell_info ::: leaky, PURE
   ! Destroy the (unique-atom) shell info
      self :: INOUT

      a :: INT

      do a = 1,.dim
         self(a).destroy_shell_info
      end

   end

   destroy_spherical_atom_data ::: leaky, PURE
   ! Destroy the (non-unique) ANO data
      self :: INOUT

      a :: INT

      do a = 1,.dim
         self(a).destroy_spherical_atom_data
      end

   end

   destroy_interpolators ::: leaky, PURE
   ! Destroy (non-unique) interpolator parts
      self :: INOUT

      a :: INT

      do a = 1,.dim
         self(a).interpolator.destroy
      end

   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
   end

!  ====
!  Copy
!  ====

   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky
   ! Create a replica copy of "vec".
   end

   create_copy(vec,list) ::: get_from(VEC{OBJECT}), leaky
   ! Create a copy of "vec" for the elements in "list".
   end

   copy(vec) ::: leaky
   ! Copy "vec".
      vec :: VEC{ATOM}

   ENSURE(.dim==vec.dim,"vec size does not match")

      a :: INT

      ! Copy
      do a = 1,vec.dim
         self(a).copy(vec(a))
      end

      ! Update unique atoms
      .update

   end

   copy(vec,list) ::: leaky
   ! Copy "vec" for the elements in "list".
      vec  :: VEC{ATOM}, IN
      list :: VEC{INT}, IN

   ENSURE(.dim==list.dim,"wrong size, list")

      a,b :: INT

      ! Copy
      do a = 1,list.dim
         b = list(a)
         self(a).copy(vec(b))
      end

      ! Update unique atoms
      .update

   end

!  ======================
!  Shrink, expand, append
!  ======================

   shrink(dim)
   ! Shrink the atomvec to dimension "dim", retaining contents.
      self :: PTR
      dim :: INT, IN
      ENSURE(.associated,"no self array")
      ENSURE(dim<=.dim,"dim too large")
      old :: VEC{ATOM}*
      n :: INT
      if (dim==.dim) return
      old => self
      nullify(self)
      self.create(dim)
      do n=1,dim
       self(n).copy(old(n))
      end
      old.nullify_basis_part
      old.destroy
   end

   expand(dim) ::: get_from(VEC{OBJECT}), leaky
   ! Expand the vector "self" to "dim". New slots are left undefined.
   end

   append(v) ::: get_from(VEC{OBJECT}), leaky
   ! Expands self and appends the contents of vector "v".
   end

   append(value) ::: get_from(VEC{OBJECT}), leaky
   ! Expands self by 1, and appends the single scalar "value" onto the end.
   end

   prune_element(k) ::: get_from(VEC{OBJECT}), leaky
   ! Removes the single element at position "k" from the vector.
   ! The order of the elements is unchanged.
   end

!  ===
!  Set
!  ===

   set_defaults ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Set default values
   end

!  ==========
!  Set labels
!  ==========

   set_atom_data_from_labels(labels)
   ! Set "labels" for the atoms and also their atomic numbers.
      labels :: VEC{STR}

   ENSURE(labels.dim==.dim,"wrong length for labels")

      a :: INT

      do a = 1,.dim
         self(a).set_atom_data_from_label(labels(a))
      end

   end

   set_labels(labels)
   ! Set the "labels" ONLY for the atoms; use the above routine to set the
   ! atomic numbers as well.
      labels :: VEC{STR}

   ENSURE(labels.dim==.dim,"wrong length for labels")

      self%label = labels

   end

   set_recognised_labels(list) ::: leaky
   ! Set "list" to be the list of recognised labels. If all labels are
   ! recognised then "list" is not created.
      list :: VEC{INT}*
      n :: INT
      nullify(list)
      do n = 1,.dim
         if (NOT self(n).has_recognised_label) cycle
         list.append(n)
      end
      if (list.dim==.dim) list.destroy
   end

   set_use_interpolators(use_interp)
   ! Read whether to use interpolators for spherical atom densities
      use_interp :: BIN, IN
      a :: INT

      self%use_interpolator = use_interp

      if (.has_all_slater_bases)  then
         do a = 1,.dim
            self(a).slaterbasis.use_interpolator = use_interp
         end
      end

      if (.has_all_coppens_bases) then
         do a = 1,.dim
            self(a).coppensbasis.use_interpolator = use_interp
         end
      end

   end

   set_unique_tags ::: PURE
   ! Set the unique tags.
      self :: INOUT

      Z_list :: VEC{VEC_{INT}}*
      a,k,n,nk :: INT

      ! Get the atom Z list
      .make_atom_Z_list(Z_list)

      ! Label atoms consecutively Xn, X=symbol, n=1,...
      do k = 1,Z_list.dim

         nk = Z_list(k).element.dim

         do n = 1,nk

            ! Atom index
            a = Z_list(k)[n]

            ! Skip dummy
            if (self(a).is_a_dummy_atom) cycle

            ! Set tag
            if (nk==1) then; self(a)%tag = trim(self(a).chemical_symbol)
            else;            self(a)%tag = trim(self(a).chemical_symbol) // trim(n.to_str)
            end

         end

      end

      ! Clean
      Z_list.destroy

   end

   set_basis_suffix(suffix)
   ! Set the "basis_label" to be a library-style label using "suffix"
      suffix :: STR, IN

      val :: STR
      a :: INT

      do a = 1,.dim
         val = self(a).library_basis_label(suffix)
         self(a).set_basis_label(val)
      end

   end

!  =========
!  Set kinds
!  =========

   set_kinds(n_kind) ::: PURE
   ! Set the kinds and whether the atoms are basis-unique.
   ! . They are the same kind if they have the same kind of basis
   !   and same atomic number.
   ! . This is used for ANO or other QM type calculations.
      self :: INOUT
      n_kind :: INT, optional, OUT

      k,a,b :: INT

      ! Initially all different kind
      do a = 1,.dim
         self(a).set_kind(a)
      end

      ! Kind index
      k = 0

      ! Loop on atoms "a"
      do a = 1,.dim

         ! Already found this kind?
         if (self(a).kind<=k) cycle

         ! New kind
         k = k + 1
         self(a).set_kind(k)
         self(a).set_is_unique_kind(TRUE)

         ! Set non-unique kinds
         do b = a+1,.dim

            if (self(b).kind<=k) cycle
            if (NOT .same_kind_of_atoms(a,b)) cycle

            self(b).set_kind(k)
            self(b).set_is_unique_kind(FALSE)

         end

      end

      if (present (n_kind)) n_kind = k

   end

   set_is_unique_kind(val)
   ! Generic set
      val :: BIN, IN

      a :: INT

      do a = 1,.dim
         self(a).set_is_unique_kind(val)
      end

   end

   set_basis_kind(val)
   ! Generic set
      self :: INOUT
      val :: STR, IN

      a :: INT

      do a = 1,.dim
         self(a).set_basis_kind(val)
      end

   end

!  ===========================
!  Set whether data/info made
!  ===========================

   set_ANOs_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>self%ANOs_made)
   ! Generic set
   end

   set_spherical_atom_data_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>self%spherical_atom_data_made)
   ! Generic set
   end

   set_ANO_interpolators_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>self%ANO_interpolators_made)
   ! Generic set
   end

   set_interpolators_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>self%interpolators_made)
   ! Generic set
   end

   set_shell_info_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>self%shell_info_made)
   ! Generic set
   end

!  =============
!  Set positions
!  =============

   set_positions_from_vector(v)
   ! Set the positions from "v", a flat vector, where the xyz
   ! positions increment fastest
      self :: INOUT
      v :: VEC{REAL}

   ENSURE(v.dim==3*.dim,"wrong size, v")

      .set_positions_to(reshape(v, [3, .dim]))
   end

   set_positions_to(mx) ::: PURE
   ! Set the positions from matrix "mx". The shape must be (3xN).
      self :: INOUT
      mx :: MAT{REAL}, IN

   ENSURE(mx.dim1==3,   "dim1 is not 3")
   ENSURE(mx.dim2==.dim,"dim2 is incompatible")

      a :: INT

      do a = 1,.dim
         self(a).set_position(mx(:,a))
      end

   end

   set_position_errors_to(me)
   ! Set the position_erroros from matrix "mx". The shape must be (3xN).
      self :: INOUT
      me :: MAT{REAL}, IN

   ENSURE(me.dim1==3,   "dim1 is not 3")
   ENSURE(me.dim2==.dim,"dim2 is incompatible")

      a :: INT

      do a = 1,.dim
         self(a).set_position_error(me(:,a))
      end

   end

!  ====================
!  Set site occupancies
!  ====================

   set_site_occupancies(val)
   ! Generic set
      val :: VEC{REAL}, IN

   ENSURE(val.dim==.dim,"wrong size for occupancies")

      a :: INT

      do a = 1,.dim
         self(a).set_site_occupancy(val(a))
      end

   end

   set_site_disorder_groups(val)
   ! Generic set
      self :: INOUT
      val :: VEC{INT}, IN

   ENSURE(val.dim==.dim,"wrong size for occupancies")

      a :: INT

      do a = 1,.dim
         self(a).set_site_disorder_group(val(a))
      end

   end

!  ===============
!  Set axis system
!  ===============

   set_axis_system_to(val) ::: PURE
   ! Generic set
      self :: INOUT
      val :: STR, IN

      a :: INT

      do a = 1,.dim
         self(a).set_axis_system_to(val)
      end

   end

   set_pos_axis_system_to(val) ::: PURE
   ! Generic set
      self :: INOUT
      val :: STR, IN

      a :: INT

      do a = 1,.dim
         self(a).set_pos_axis_system_to(val)
      end

   end

   set_ADP_axis_system_to(val) ::: PURE
   ! Generic set
      self :: INOUT
      val :: STR, IN

      a :: INT

      do a = 1,.dim
         self(a).set_ADP_axis_system_to(val)
      end

   end

   set_ADPn_axis_system_to(val) ::: PURE
   ! Generic set
      self :: INOUT
      val :: STR, IN

      a :: INT

      do a = 1,.dim
         self(a).set_ADPn_axis_system_to(val)
      end

   end

!  ============
!  pADP/ADP set
!  ============

   set_ADP_tensor(val) ::: PURE
   ! Generic set
      self :: INOUT
      val :: REAL, IN

      a :: INT

      do a = 1,.dim
         self(a).set_ADP_tensor(val)
      end

   end

! Set U_iso

   set_isotropic_H_ADP ::: PURE
   ! Set the isotropic hydrogen ADPs
      self :: INOUT

      a :: INT

      do a = 1,.dim
         if (self(a).atomic_number==1) then
            self(a).set_isotropic_ADP
         end
      end

   end

   set_isotropic_ADPs(tags) ::: PURE
   ! Set isotropic ADPs for the atoms wich have tags given in "tags"
      self :: INOUT
      tags :: VEC{STR}, IN

      a :: INT

      do a = 1,.dim
         if (any(self(a).tag==tags)) then
            self(a).set_isotropic_ADP
         end
      end

   end

   set_U_iso(val) ::: PURE
   ! Generic set
      self :: INOUT
      val :: REAL, IN

      a :: INT

      do a = 1,.dim
         self(a).set_U_iso(val)
      end

   end

   set_U_iso(val) ::: PURE
   ! Generic set
      self :: INOUT
      val :: VEC{REAL}, IN

      a :: INT

      do a = 1,.dim
         self(a).set_U_iso(val(a))
      end

   end

   set_U_iso_error(err) ::: PURE
   ! Generic set
      self :: INOUT
      err :: VEC{REAL}, IN

   ENSURE(err.dim==.dim,"wrong size for occupancies")

      a :: INT

      do a = 1,.dim
         self(a).set_U_iso_error(err(a))
      end

   end

! Reset pADPs

   reset_pADPs_and_errors(dim) ::: leaky
   ! Allocate the positional-ADP parameters to a set size "dim".
   ! NOTE: assigning 4th order tags implies 3rd order.
      self :: INOUT
      dim :: INT, IN

      n,a :: INT

      ! Make sure at least 9 long.
      n = max(dim,9)

      ! Reset each pADP
      do a = 1,.dim
         self(a).reset_pADPs_and_errors(n)
      end

   end

   reset_pADPs_and_errors(anharm3_tags,anharm4_tags) ::: leaky
   ! Allocate the positional-ADP parameters based on the given tags.
   ! NOTE: assigning 4th order tags implies 3rd order.
      self :: PTR
      anharm3_tags,anharm4_tags :: VEC{STR}*

      t,a :: INT
      tag :: STR

      ! Find the 4th-order tags, resize pADP_vector, and set to 0
      ! If the atoms are already fourth order do nothing.
      if (anharm4_tags.associated) then

         do t = 1,anharm4_tags.dim
            tag = anharm4_tags(t)
            a   = self(:).tag.index_of(tag)
            DIE_IF(a==0,"no atom for 4th-order tag: "//trim(tag))
            self(a).reset_pADPs_and_errors(34)
         end

      end

      ! Find the 3rd-order tags, resize pADP_vector, and set to 0
      ! If they were already 3rd or 4th order, do nothing
      if (anharm3_tags.associated) then

         do t = 1,anharm3_tags.dim
            tag = anharm3_tags(t)
            a   = self(:).tag.index_of(tag)
            DIE_IF(a==0,"no atom for 3rd-order tag: "//trim(tag))
            self(a).reset_pADPs_and_errors(19)
         end

      end

      ! Make sure at least 9 long.
      do a = 1,.dim
         self(a).reset_pADPs_and_errors(9)
      end

   end

! Set pADPs

   set_pADP_vector_to(X) ::: leaky
   ! Set the pADP vector from vector "X".
   ! NOTE: positions and ADP_tensors are set!
      X :: VEC{REAL}, IN

   DIE_IF(X.dim/=.no_of_pADPs,"wrong size, X")

      a,f,l :: INT

      l = 0
      do a = 1,.dim

         ! Limits
         f = l + 1
         l = l + self(a).no_of_pADPs

         ! Leaky
         self(a).set_pADP_vector_to(X(f:l))

      end

   end

   set_pADP_errors_to(dX,H_U_iso)
   ! Set the pADP errors from vector "dX".
      dX :: VEC{REAL}, IN
      H_U_iso :: BIN, IN

   DIE_IF(dX.dim/=.no_of_pADPs,"wrong size, dX")

      a,f,l :: INT

      l = 0
      do a = 1,.dim

         ! Limits
         f = l + 1
         l = l + self(a).no_of_pADPs

         ! Not leaky
         self(a).set_pADP_errors_to(dX(f:l),H_U_iso)

      end

   end

   zero_pADP_errors
   ! Set the pADP_errors
      self :: INOUT

      a :: INT

      do a = 1,.dim
         self(a).zero_pADP_error
      end

   end

   check_position_and_pADP
   ! Check if the .position and .pADP vector are consistent
      self :: IN

      a :: INT

      do a = 1,.dim
         self(a).check_position_and_pADP
      end

   end

!  =====
!  Modes
!  =====

   initialize_local_H_modes(L)
   ! Initialize local H modes as columns. These come in triples.
   ! The first is the XH stretch. The next two are the two XH bends.
      L :: MAT{REAL}

   ENSURE(L.dim1==3*.dim,"wrong size, dim1")
   ENSURE(L.dim2==3*count(self.atomic_number==1),"wrong size, dim2")

      unit :: MAT{REAL}(3,3)
      r1,r2,r3 :: VEC{REAL}(3)
      h,i,x, fh,lh :: INT

      ! Make the connection table
      .make_connection_table

      ! Initialise L
      L = ZERO

      ! Set unit vectors
      unit.to_unit_matrix

      ! Make the H modes
      i  = 0
      lh = 0

      do h = 1,.dim

         fh = lh + 1
         lh = lh + 3

         ! Only look for a = H atom
         if(self(h).atomic_number>1) cycle

         ! Make sure H atom connects one other
         if (connections_for(h).element.dim>1) then
            DIE("H atom connected tomore than one other")
         end

         ! Get XH vector
         x  = connections_for(h)[1]
         r1 = self(h).position - self(x).position
         r1.normalise

         ! Get the two perpendicular vectors
         r2.to_cross_product_of(r1,unit(:,1))
         if (r2.is_zero) &
         r2.to_cross_product_of(r1,unit(:,2))
         r2.normalise
         r3.to_cross_product_of(r1,r2)

         ! Set L
         L(fh:lh,i+1) = r1
         L(fh:lh,i+2) = r2
         L(fh:lh,i+3) = r3

         ! Next H mode
         i = i + 3

      end

      ! Clean
      connections_for.destroy

   end

!  ============
!  pADP/ADP put
!  ============

   put_pADP_vector_to(X,fac) ::: PURE
   ! Put the whole pADP vector into vector "X".
   ! If present, include length-conversion factor "fac".
      self :: IN
      X :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(X.dim==.no_of_pADPs,"wrong size, X")

      a,f,l :: INT

      l = 0

      do a = 1,.dim

         ! Limits
         f = l + 1
         l = l + self(a).no_of_pADPs

         ! Set
         self(a).put_pADP_vector_to(X(f:l),fac)

      end

   end

   put_pADP_errors_to(dX,fac) ::: PURE
   ! Put all the pADP errors into vector "dX".
   ! If present, include length-conversion factor "fac".
      self :: IN
      dX :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dX.dim==.no_of_pADPs,"wrong size, dX")

      a,f,l :: INT

      l = 0

      do a = 1,.dim

         ! Limits
         f = l + 1
         l = l + self(a).no_of_pADPs

         ! Set
         self(a).put_pADP_errors_to(dX(f:l),fac)

      end

   end

   put_pos_vector_to(X,fac) ::: PURE
   ! Put the position vector into matrix "X".
   ! If present, include length-conversion factor "fac".
      self :: IN
      X :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(X.dim1==.dim,"wrong size, X")
   ENSURE(X.dim2==3   ,"wrong size, X")

      a :: INT

      do a = 1,.dim
         self(a).put_pos_vector_to(X(a,:),fac)
      end

   end

   put_pos_errors_to(dX,fac) ::: PURE
   ! Put the position errors into matrix "dX".
   ! If present, include length conversion factor "fac".
      self :: IN
      dX :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dX.dim1==.dim,"wrong size, dX")
   ENSURE(dX.dim2==3   ,"wrong size, dX")

      a :: INT

      do a = 1,.dim
         self(a).put_pos_errors_to(dX(a,:),fac)
      end

   end

   put_pos_errors_to(dX,esd,fac) ::: PURE
   ! Put the position errors into matrix "dX" from the supplied
   ! "esd" vector made from a external refinement.
      self :: IN
      dX :: MAT{REAL}, OUT
      esd :: VEC{REAL}, IN
      fac :: REAL, optional, IN

   ENSURE(dX.dim1==.dim,"wrong size, dX")
   ENSURE(dX.dim2==3   ,"wrong size, dX")
   ENSURE(esd.dim==.no_of_pADPS,"wrong size, esd")

      a,k :: INT

      k = 0

      do a = 1,.dim

         dX(a,1) = esd(k+1)
         dX(a,2) = esd(k+2)
         dX(a,3) = esd(k+3)

         k = k + self(a).no_of_pADPs

      end

      if (present(fac)) dX = fac*dX

   end

   put_pADP2_vector_to(X,fac) ::: PURE
   ! Put the second-order pADP vector into matrix "X".
   ! If present, include length-conversion factor "fac".
      self :: IN
      X :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(X.dim1==.dim,"wrong size, X")
   ENSURE(X.dim2==9   ,"wrong size, X")

      a :: INT

      do a = 1,.dim
         self(a).put_pADP2_vector_to(X(a,:),fac)
      end

   end

   put_pADP2_errors_to(dX,fac) ::: PURE
   ! Put the pADP errors into matrix "dX".
   ! If present, include length conversion factor "fac".
      self :: IN
      dX :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dX.dim1==.dim,"wrong size, dX")
   ENSURE(dX.dim2==9   ,"wrong size, dX")

      a :: INT

      do a = 1,.dim
         self(a).put_pADP2_errors_to(dX(a,:),fac)
      end

   end

   put_ADP2_errors_to(dU,fac,esd) ::: PURE
   ! Put the ADP2 errors into matrix "dU" from the supplied
   ! "esd" vector made from a external refinement.
      self :: IN
      dU :: MAT{REAL}, OUT
      fac :: REAL, optional, IN
      esd :: VEC{REAL}, IN

   ENSURE(dU.dim1==.dim,"wrong dim1, dU")
   ENSURE(dU.dim2==6   ,"wrong dim2, dU")

      a,k :: INT

      k = 0

      do a = 1,.dim
      
         dU(a,1) = esd(k+4) 
         dU(a,2) = esd(k+5) 
         dU(a,3) = esd(k+6) 
         dU(a,4) = esd(k+7) 
         dU(a,5) = esd(k+8) 
         dU(a,6) = esd(k+9) 
      
         k = k + self(a).no_of_pADPs
      
      end

      ! Change units
      if (present(fac)) dU = fac*fac*dU

   end

   put_ADP2_errors_to(dU,list,fac,esd) ::: PURE
   ! Put the ADP2 errors into matrix "dU" from the supplied
   ! "esd" vector made from a external refinement. "list" is
   ! the sub list of atoms to use
      self :: IN
      dU :: MAT{REAL}, OUT
      list :: VEC{INT}, IN
      fac :: REAL, optional, IN
      esd :: VEC{REAL}, IN

   ENSURE(dU.dim1==list.dim,"wrong dim1, dU")
   ENSURE(dU.dim2==6       ,"wrong dim2, dU")
   ENSURE(esd.dim==.no_of_pADPS,"wrong size, esd")

      i,a,k :: INT

      k = 0

      do i = 1,list.dim

         a = list(i)
      
         k = .no_of_pADPs_up_to_atom(a)
      
         dU(i,1) = esd(k+4) 
         dU(i,2) = esd(k+5) 
         dU(i,3) = esd(k+6) 
         dU(i,4) = esd(k+7) 
         dU(i,5) = esd(k+8) 
         dU(i,6) = esd(k+9) 
      
      end

      ! Change units
      if (present(fac)) dU = fac*fac*dU

   end

   put_ADP2_vector_to(U,fac) ::: PURE
   ! Put the second-order ADP parameters into vector "U".
   ! If present, include length conversion factor "fac".
      self :: IN
      U :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(U.dim==6*.dim,"wrong size, U")

      a,f,l :: INT

      l = 0
      do a = 1,.dim
         f = l + 1
         l = l + 6
         self(a).put_ADP2_vector_to(U(f:l),fac)
      end

   end

   put_ADP2_errors_to(dU,fac) ::: PURE
   ! Put the ADP2 errors into vector "dU".
   ! If present, include length-conversion factor "fac".
      self :: IN
      dU :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dU.dim==6*.dim,"wrong size, dU")

      a,f,l :: INT

      l = 0
      do a = 1,.dim
         f = l + 1
         l = l + 6
         self(a).put_ADP2_errors_to(dU(f:l),fac)
      end

   end

   put_ADP2_vector_to(U,fac) ::: PURE
   ! Put the second-order ADP vector into matrix "U".
   ! If present, include length-conversion factor "fac".
   ! This routine used for making tables
      self :: IN
      U :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(U.dim1==.dim,"wrong size, U")
   ENSURE(U.dim2==6   ,"wrong size, U")

      a :: INT

      do a = 1,.dim
         self(a).put_ADP2_vector_to(U(a,:),fac)
      end

   end

   put_ADP2_errors_to(dU,fac) ::: PURE
   ! Put the ADP2 errors into matrix "dU".
   ! If present, include length conversion factor "fac".
   ! This routine used for making tables
      self :: IN
      dU  :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dU.dim1==.dim,"wrong size, dU")
   ENSURE(dU.dim2==6   ,"wrong size, dU")

      a :: INT

      do a = 1,.dim
         self(a).put_ADP2_errors_to(dU(a,:),fac)
      end

   end

   put_ADP3_vector_to(U,fac) ::: PURE
   ! Put the ADP3 parameters into vector "U".
   ! If present, include length conversion factor "fac".
      self :: IN
      U :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(U.dim==.no_of_ADP3s,"wrong size, X")

      a,f,l :: INT

      l = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP3s_and_errors) cycle

         ! Set ADP3's
         f = l + 1
         l = l + 10
         self(a).put_ADP3_vector_to(U(f:l),fac)

      end

   end

   put_ADP3_errors_to(dU,fac) ::: PURE
   ! Put the ADP3 errors into vector "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dU.dim==.no_of_ADP3s,"wrong size, dU")

      a,f,l :: INT

      l = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP3s_and_errors) cycle

         ! Set ADP3's
         f = l + 1
         l = l + 10
         self(a).put_ADP3_errors_to(dU(f:l),fac)

      end

   end

   put_ADP3_vector_to(U,fac) ::: PURE
   ! Put the ADP3 parameters into matrix "U".
   ! If present, include length conversion factor "fac".
      self :: IN
      U :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(U.dim1==.no_of_ADP3_atoms,"wrong size, U")
   ENSURE(U.dim2==10               ,"wrong size, U")

      a,i :: INT

      i = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP3s_and_errors) cycle

         ! Set ADP3's
         i = i + 1
         self(a).put_ADP3_vector_to(U(i,:),fac)

      end

   end

   put_ADP3_errors_to(dU,fac) ::: PURE
   ! Put the ADP3 errors into matrix "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dU.dim1==.no_of_ADP3_atoms,"wrong size, dU")
   ENSURE(dU.dim2==10               ,"wrong size, U")

      a,i :: INT

      i = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP3s_and_errors) cycle

         ! Set ADP3's
         i = i + 1
         self(a).put_ADP3_errors_to(dU(i,:),fac)

      end

   end

   put_ADP4_vector_to(U,fac) ::: PURE
   ! Put the ADP4 parameters into vector "U".
   ! If present, include length conversion factor "fac".
      self :: IN
      U :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(U.dim==.no_of_ADP4s,"wrong size, X")

      a,f,l :: INT

      l = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP4s_and_errors) cycle

         ! Set ADP4's
         f = l + 1
         l = l + 15
         self(a).put_ADP4_vector_to(U(f:l),fac)

      end

   end

   put_ADP4_errors_to(dU,fac) ::: PURE
   ! Put the ADP4 errors into vector "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dU.dim==.no_of_ADP4s,"wrong size, dU")

      a,f,l :: INT

      l = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP4s_and_errors) cycle

         ! Set ADP4's
         f = l + 1
         l = l + 10
         self(a).put_ADP4_errors_to(dU(f:l),fac)

      end

   end

   put_ADP4_vector_to(U,fac) ::: PURE
   ! Put the ADP4 parameters into matrix "U".
   ! If present, include length conversion factor "fac".
      self :: IN
      U :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(U.dim1==.no_of_ADP4_atoms,"wrong size, U")
   ENSURE(U.dim2==15               ,"wrong size, U")

      a,i :: INT

      i = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP4s_and_errors) cycle

         ! Set ADP4's
         i = i + 1
         self(a).put_ADP4_vector_to(U(i,:),fac)

      end

   end

   put_ADP4_errors_to(dU,fac) ::: PURE
   ! Put the ADP4 errors into matrix "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: MAT{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dU.dim1==.no_of_ADP4_atoms,"wrong size, dU")
   ENSURE(dU.dim2==15               ,"wrong size, dU")

      a,i :: INT

      i = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP4s_and_errors) cycle

         ! Set ADP4's
         i = i + 1
         self(a).put_ADP4_errors_to(dU(i,:),fac)

      end

   end

! Put pADPx atom list

   put_ADP3_atom_list_to(list) ::: PURE
   ! Put the ADP3 atom list to "list".
      self :: IN
      list :: VEC{INT}, OUT

   ENSURE(list.dim==.no_of_ADP3_atoms,"wrong size, list")

      a,i :: INT

      i = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP3s_and_errors) cycle

         ! List of atoms
         i = i + 1
         list(i) = a

      end

   end

   put_ADP4_atom_list_to(list) ::: PURE
   ! Put the ADP4 atom list to "list".
      self :: IN
      list :: VEC{INT}, OUT

   ENSURE(list.dim==.no_of_ADP4_atoms,"wrong size, list")

      a,i :: INT

      i = 0
      do a = 1,.dim

         if (NOT self(a).has_ADP4s_and_errors) cycle

         ! List of atoms
         i = i + 1
         list(i) = a

      end

   end

!  ===============
!  Coordinate info
!  ===============

   coordinates_ptr(skip_dummies) result (res) ::: leaky
   ! Create the 3 x .dim coordinate matrix pointer
      self :: IN
      skip_dummies :: BIN, IN, optional
      res :: MAT{REAL}*

      n_atom :: INT
      skip :: BIN

      skip = FALSE
      if (present(skip_dummies)) skip = skip_dummies

      if (skip) then
         n_atom = .no_of_nondummy_atoms
         res.create(3,n_atom)
         .put_coordinates_to(res,positions_as_rows=FALSE,skip_dummies=TRUE)
      else
         res.create(3,.dim)
         .put_coordinates_to(res,positions_as_rows=FALSE)
      end

   end

   put_coordinates_to(mx,positions_as_rows,skip_dummies) ::: PURE
   ! Put the atom coordinates in a matrix "mx".
   ! If put_coordinates_as_rows=TRUE  then "mx" is dim x 3
   ! If put_coordinates_as_rows=FALSE then "mx" is 3 x dim
   ! If skip_dummies=FALSE then dim = .dim1 (default)
   ! If skip_dummies=TRUE  then dim = .no_of_nondummy_atoms
      self :: IN
      mx :: MAT{REAL}, OUT
      positions_as_rows :: BIN, IN
      skip_dummies :: BIN, optional, IN

      i,a :: INT
      skip :: BIN

      skip = FALSE
      if (present(skip_dummies)) skip = skip_dummies

      ! Put all atoms
      if (NOT skip) then

         if (positions_as_rows) then

            ENSURE(mx.dim1==.dim AND mx.dim2==3,"wrong shape, mx")

            do a = 1,.dim
               mx(a,:) = self(a).position
            end

         else

            ENSURE(mx.dim2==.dim AND mx.dim1==3,"wrong shape, mx")

            do a = 1,.dim
               mx(:,a) = self(a).position
            end

         end

      ! Put non-dummy atoms
      else

         if (positions_as_rows) then

            ENSURE(mx.dim1==.no_of_nondummy_atoms AND mx.dim2==3,"wrong shape, mx")

            i = 0
            do a = 1,.dim
               if (self(a).is_a_dummy_atom) cycle
               i = i + 1
               mx(i,:) = self(a).position
            end

         else

            ENSURE(mx.dim2==.no_of_nondummy_atoms AND mx.dim1==3,"wrong shape, mx")

            i = 0
            do a = 1,.dim
               if (self(a).is_a_dummy_atom) cycle
               i = i + 1
               mx(:,i) = self(a).position
            end

         end

      end

   end

   coordinate_vector result (res)
   ! Return the coordinates as a flat vector "res" where the xyz
   ! positions increment fastest, useful for optimisations
      self :: IN
      res :: VEC{REAL}(3*.dim)
      .put_coordinate_vector_to(res)
   end

   put_coordinate_vector_to(v)
   ! Put the coordinates as a flat vector in "v" where the xyz
   ! positions increment fastest, useful for optimisations
      self :: IN
      v :: VEC{REAL}, OUT

   ENSURE(v.dim==3*.dim,"wrong size, v")

      k,i :: INT

      k = 0

      do i = 1,.dim

         v(k+1) = self(i).position(1)
         v(k+2) = self(i).position(2)
         v(k+3) = self(i).position(3)
        
         k = k + 3

      end

   end

!  ========
!  Finalize
!  ========

   update
   ! Update/finalize, as far as possible.
      self :: INOUT


      ! Update the labels?
      .update_labels

      ! Make atom kinds/unique atoms
      ! Should we always set the kinds?
      .set_kinds

      ! Set groups
      ! Probs here? --dylan 5/14
      if (any(self(:).group==0)) .set_connected_groups

      ! Set any dispersion coefficients
      if (self(1).xray_dispersion_entered) .set_tabular_dispersion

   end

   update_labels ::: private, PURE
   ! Update the labels and/or tags.
   ! NOTE: Only update the labels if the label data are not
   ! unique, so as to preserve previous unique labels (and
   ! hopefully kinds) which can happen if a subset of a
   ! processed atom list is being updated.
   ! NOTE: It is assumed that is you set a different label
   ! you really mean that the atom is a different kind.
      self :: INOUT

      unique_labels,unique_tags :: BIN

      ! Unique labels?
      unique_labels = .has_unique_labels
      unique_tags   = .has_unique_tags

      ! Set unique labels/tags
      if (unique_labels) then

         ! Set unique tags from labels
         if (NOT unique_tags) self(:)%tag = self(:)%label

      else ! not unique labels

         ! Set unique tags if needed
         if (NOT unique_tags) .set_unique_tags

         ! Set labels from tags
         self(:)%label = self(:)%tag

      end

   end

!  =======================
!  List-based I/O Routines
!  =======================

   read_list_keywords ::: get_from(VEC{OBJECT}), recursive, leaky
   ! Read in and process list-based keywords from "stdin". List-based keywords
   ! are those that are intended to apply to each individual element of the list
   ! through a list of "keys" stored in the associated list-element type module.
   ! NOTE: this routine will create the list, if required.
   end

   process_list_keyword(keyword) ::: get_from(VEC{OBJECT}), leaky
   ! Process a list-type "keyword", common to all list-type objects.
   end

   read_data ::: get_from(VEC{OBJECT}), leaky
   ! Repeatedly process the "keys" to read in the data list.
   ! Opening and closing braces are needed.
   end

   read_data_sans_braces ::: get_from(VEC{OBJECT}), leaky
   ! Repeatedly process the "keys" to read in the data list.
   ! Opening and closing braces are not needed.
   end

   data_length result (length) ::: get_from(VEC{OBJECT})
   ! Read ahead in stdin to get the "length" of the data list, i.e. the number
   ! of data items in the list. The data must begin with the first data item,
   ! *not* a "{" symbol.  The order of data items comprising the list is given
   ! by keys defined in the associated list-element type module. The data list
   ! must be terminated by a "}" symbol.
   end

   read_altered_data ::: get_from(VEC{OBJECT}), leaky
   ! Read in a sublist of the complete list, and alter the data for that
   ! sublist.  The order of the data items in the sublist is given by the "keys"
   ! defined in the associated list-element type module.
   end

   read_append_data ::: get_from(VEC{OBJECT}), leaky
   ! Read in a set of data to append to an existing set.
   end

   process_keys ::: get_from(VEC{OBJECT}), leaky
   ! Process the "keys" on each element of the list.
   end

   process_keys_once ::: get_from(VEC{OBJECT})
   ! Process the "keys" just once on an anonymous object. This is useful if the
   ! "keys" set global variables in the list module (e.g. the default order of
   ! lists *within* the list data) as opposed to being keys pertaining to each
   ! element of the list.
   end

   keys_created result (res) ::: get_from(VEC{OBJECT})
   ! Return TRUE if the list-element keys are created.
   end

   set_keys(the_keys) ::: get_from(VEC{OBJECT})
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(VEC{OBJECT}), leaky
   ! This is for destroying the "keys" externally.
   end

   read_keys ::: get_from(VEC{OBJECT}), leaky
   ! Read a new set of keys
   end

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input
   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file
   end

!  ===========================
!  Non-list based I/O routines
!  ===========================

   read_keywords ::: get_from(VEC{OBJECT}), recursive, leaky
   ! Read in and process normal (non list-type) keywords from "stdin".
   end

   process_keyword(keyword) ::: leaky
   ! Process a normal (non list-type) "keyword".
      self :: PTR
      keyword :: STR

      word :: STR

      word = keyword
      word.to_lower_case
      select case (word)
       case("}") ! do nothing.
       case("dump                          "); .dump("atoms")
       case("find_n_terminal_atoms         "); .find_N_terminal_atoms
       case("find_protein_backbone         "); .find_protein_backbone
       case("put                           "); .put
       case("put_bond_angle_table          "); .put_bond_angle_table
       case("put_bond_length_table         "); .put_bond_length_table
       case("put_coordinates               "); .put_coordinates
       case("put_coordinates_and_charges   "); .put_coordinates_and_charges
       case("put_invariom_labels           "); .put_invariom_labels
       case("put_smiles_invariom_labels    "); .put_smiles_invariom_labels
       case("put_mm_info                   "); .put_mm_info
       case("put_torsion_angle_table       "); .put_torsion_angle_table
       case("put_protein_sequence          "); .put_protein_sequence
       case("put_restraint_atoms           "); .put_restraint_atoms
       case("read_cif                      "); .read_CIF
       case("redirect                      "); .redirect
       case("revert                        "); .revert
       case("set_covalent_radii_ccdc       "); ATOM:set_covalent_radii_ccdc
       case("use_interpolators=            "); .read_use_interpolators
       case default;               UNKNOWN(word)
      end

   end

! CIF

   read_CIF ::: leaky
   ! Read information from a Crystallographic Information File whose
   ! name is read from "stdin".
      self :: PTR

      name :: STR

      ! Read name cif name from stdin
      stdin.read(name)

      ! Read CIF
      .read_CIF(name)

   end

   read_CIF(name) ::: leaky
   ! Read information from a Crystallographic Information File "name"
      self :: PTR
      name :: STR, IN

      cif :: CIF*
      found :: BIN

      ! Create the CIF and find data
      cif.create(name)
      cif.open
      cif.find_crystal_data_block(found)
      ENSURE(found,"no crystal data block found")

      ! Read
      .read_CIF(cif)

      ! Clean
      cif.destroy

   end

   read_CIF(cif) ::: leaky
   ! Read information from a Crystallographic Information File "name"
      self :: PTR
      cif :: CIF

      ! Read
      .read_CIF_atoms(cif)
      .read_CIF_ADPs(cif)
      VEC{ATOM}::read_CIF_dispersion(cif)

   end


   read_CIF_atoms(cif) ::: leaky
   ! Read information from a Crystallographic Information File, "cif".
      self :: PTR
      cif :: CIF, INOUT

      fail :: BIN

      fail = FALSE
      .read_CIF_atoms_cart(cif,fail)

      if (NOT fail) return

      .destroy
      fail = FALSE
      .read_CIF_atoms_xtal(cif,fail)

      DIE_IF(fail,"failed")

   end

   read_CIF_atoms_cart(cif,fail) ::: leaky
   ! Read Tonto information from a "cif".  Cartesian format extends
   ! existing items in the standard CIF dictionary.
   ! NOTE: self is destroyed and created from this file!
      self :: PTR
      cif :: CIF, INOUT
      fail :: BIN, OUT

      fl,fc,fe,fo :: BIN
      IDs,labels :: VEC{STR}*
      pos,err :: MAT{REAL}*

      ! Read the site labels FIRST because these seem to correlate with
      ! the anisotropic U's.
      nullify(labels)
      cif.read_looped_item("_atom_site_Cartn_label",labels,fl)

      fail = NOT fl 
      if (fail) return

      ! Destroy the old atom list (if there)
      .destroy

      ! Create the new atom list
      .create(labels.dim)
      .set_atom_data_from_labels(labels)
      labels.destroy

      ! Read the coordinates
      IDs.create(3)
      IDs = ["_atom_site_Cartn_x", &
             "_atom_site_Cartn_y", &
             "_atom_site_Cartn_z"  ]
      cif.read_looped_items(IDs,pos,found=fc)
      IDs.destroy

      fail = NOT fc
      if (fail) return

      ! Set the positions
      .set_pos_axis_system_to("cartesian")
      .reset_pADPs_and_errors(9)
      pos.convert_from("angstrom")
      .set_positions_to(pos)
      pos.destroy

      ! Read errors
      IDs.create(3)
      IDs = ["_atom_site_Cartn_x_esu", &
             "_atom_site_Cartn_y_esu", &
             "_atom_site_Cartn_z_esu"  ]
      cif.read_looped_items(IDs,err,found=fe)
      IDs.destroy

      if (fe) then

         ! Set the positions
         err.convert_from("angstrom")
         .set_position_errors_to(err)
         pos.destroy

      end

      ! Read occupancies and disorder group
      IDs.create(2)
      IDs = ["_atom_site_Cartn_occupancy     ", &
             "_atom_site_Cartn_disorder_group"]
      cif.read_looped_items(IDs,err,transpose=TRUE,found=fo)
      IDs.destroy

      if (fo) then

         ! Set the occupancies
         .set_site_occupancies(err(:,1))
         .set_site_disorder_groups(nint(err(:,2)))
         err.destroy

      end

      ! Clean
      IDs.destroy

      ! Update?
      .update

   end

   read_CIF_atoms_xtal(cif,fail) ::: leaky
   ! Read information from a Crystallographic Information File, "cif".
   ! It is an error if there are no atom coordinates in the file.
   ! It is NOT an error if the ADP (thermal) tensors are missing.
   ! NOTE: self is destroyed and created from this file!
      self :: PTR
      cif :: CIF, INOUT
      fail :: BIN, OUT

      fs,fc,fd,fo,fl :: BIN
      IDs,labels,symbols :: VEC{STR}*
      disorder_group :: MAT{STR}*
      pos,err :: MAT{REAL}*
      dg :: STR
      i :: INT

      ! Read the site labels FIRST because these seem to correlate with
      ! the anisotropic U's.
      nullify(symbols)
      nullify(labels)
      cif.read_looped_item("_atom_site_type_symbol",symbols,fs)
      cif.read_looped_item("_atom_site_label",labels,fl)

      fail = NOT (fs OR fl)

      ! Destroy the old atom list (if there)
      .destroy

      ! Create new atom list & read labels
      if (symbols.associated) then
         .create(symbols.dim)
         .set_atom_data_from_labels(symbols)     ! For Z's
         if (labels.associated) .set_labels(labels) ! For U's
      else if (labels.associated) then
         .create(labels.dim)
         .set_atom_data_from_labels(labels)      ! This may not work
      end

      labels.destroy
      symbols.destroy

      ! Read the site coordinates, and possibly occupancies
      cif.find_looped_item("_atom_site_occupancy",fo)
      if (fo) then
         IDs.create(4)
         IDs = ["_atom_site_fract_x  ", &
                "_atom_site_fract_y  ", &
                "_atom_site_fract_z  ", &
                "_atom_site_occupancy"]
         cif.read_looped_items(IDs,pos,err,found=fc)
      else
         IDs.create(3)
         IDs = ["_atom_site_fract_x  ", &
                "_atom_site_fract_y  ", &
                "_atom_site_fract_z  "]
         cif.read_looped_items(IDs,pos,err,found=fc)
      end
      IDs.destroy

      fail = NOT fc
      if (fail) return

      ! Assign the positions and pADPs
      .set_pos_axis_system_to("crystal")
      .reset_pADPs_and_errors(9)
      .set_positions_to(pos(1:3,:))
      .set_position_errors_to(err(1:3,:))
      if (fo) .set_site_occupancies(pos(4,:))
      err.destroy
      pos.destroy

      ! Read the disorder, group if there
      cif.find_looped_item("_atom_site_disorder_group",fd)
      if (fd) then
         IDs.create(1)
         IDs = ["_atom_site_disorder_group"]
         cif.read_looped_items(IDs,disorder_group)
         ENSURE(disorder_group.dim2==.dim,"inconsistent # of _atom_site_disorder_groups")
         do i = 1,disorder_group.dim2
            dg = disorder_group(1,i)
            if      (dg==".")   then; self(i).set_site_disorder_group(0)
            else if (dg.is_int) then; self(i).set_site_disorder_group(dg.to_int)
            end
         end
         disorder_group.destroy
         IDs.destroy
      end

      ! Clean
      IDs.destroy

      ! Update?
      .update

   end


   read_CIF_ADPs(cif) ::: leaky
   ! Read ADP information from the "cif" file.
      self :: INOUT
      cif :: CIF, INOUT

   DIE_IF(self(:).label.no_of_unique_elements/=.dim,"not all ADP site symbols are unique!")

      ! Read 4th order anharmonic ADPs
      .read_CIF_ADP4(cif)

      ! Read 3rd order anharmonic ADPs
      .read_CIF_ADP3(cif)

      ! Read 2nd order ADPs
      .read_CIF_ADP2(cif)

   end


   read_CIF_ADP2(cif) ::: leaky
   ! Read ADP2 information from the "cif" file.
      self :: INOUT
      cif :: CIF, INOUT

   DIE_IF(self(:).label.no_of_unique_elements/=.dim,"not all ADP site symbols are unique!")

      fail :: BIN

      ! Read cartesian 2nd order ADPs
      .read_CIF_ADP2_cart(cif,fail)

      if (NOT fail) return

      ! Read standard/crystal U's as last resort
      .read_CIF_ADP2_xtal(cif,fail)

   end

   read_CIF_ADP2_cart(cif,fail) ::: private, leaky
   ! Read the cartesian ADP information from the "cif" file.
      self :: INOUT
      cif :: CIF, INOUT
      fail :: BIN, OUT

   DIE_IF(self(:).label.no_of_unique_elements/=.dim,"not all ADP site symbols are unique!")

      fi,fd,fu,fl :: BIN
      IDs,esd,labels :: VEC{STR}*
      i,ind :: INT
      U,dU :: MAT{REAL}*
      U_iso,d_U_iso :: VEC{REAL}*
      lab :: STR

      ! Read Cartn U_iso values
      nullify(  U_iso)
      nullify(d_U_iso)
      cif.read_looped_item("_atom_site_Cartn_U_iso_or_equiv",      U_iso,found=fi)
      cif.read_looped_item("_atom_site_Cartn_U_iso_or_equiv_esu",d_U_iso,found=fd)

      ! Are they there?
      if (fi AND fd) then

         ! Make space
         .reset_pADPs_and_errors(9)

         ! Convert
           U_iso.convert_from("angstrom^2")
         d_U_iso.convert_from("angstrom^2")

         ! Set
         .set_U_iso(U_iso)
         .set_U_iso_error(d_U_iso)

         ! Clean
         d_U_iso.destroy
           U_iso.destroy

      end

      ! Read Cartn ADP2 tensor
      nullify(labels)
      nullify(U)
      nullify(dU)
      IDs.create(6)
      esd.create(6)
      do i = 1,6
         lab = ATOM:ADP_label(i,form="underscore-123-repeated")
         lab = "_atom_site_Cartn_ADP2_"//trim(lab)
         IDs(i) = trim(lab)
         esd(i) = trim(lab)//"_esu"
      end
      cif.read_looped_item("_atom_site_Cartn_ADP2_U_label",labels,fl)
      cif.read_looped_items(IDs, U,found=fu)
      cif.read_looped_items(esd,dU,found=fd)
      esd.destroy
      IDs.destroy

      ! Are they there?
      fail = NOT (fl AND fu AND fd)

      if (NOT fail) then

         ! Change U units to au^2
          U.convert_from("angstrom^2")
         dU.convert_from("angstrom^2")

         ! Match the anisotropic U labels and assign the U tensors
         do i = 1,labels.dim

            ! Find matching index "ind"
            ind = self(:).label.index_of(labels(i))
            DIE_IF(ind==0,"unmatching atom_site_Cartn_ADP_U_label, "//trim(labels(i)))

            ! Assign ADP
            self(ind).reset_pADPs_and_errors(9)
            self(ind).set_ADP_tensor(U(:,i))
            self(ind).set_ADP2_errors_to(dU(:,i),FALSE)

         end
   
         ! Set the crystal axis system. For anharmonic ADPs (if any)
         ! the form "g" or "u" was already detected and set.
         .set_ADP_axis_system_to("cartesian")

      end

      ! Clean
      if (fd) dU.destroy
      if (fu)  U.destroy
      if (fl) labels.destroy

   end

   read_CIF_ADP2_xtal(cif,fail) ::: private, leaky
   ! Read fractional ADP information from the "cif".
   ! It is an error if there are no atom coordinates in the file.
   ! It is NOT an error if the ADP (thermal) tensors are missing.
      self :: INOUT
      cif :: CIF, INOUT
      fail :: BIN, OUT

   DIE_IF(self(:).label.no_of_unique_elements/=.dim,"not all ADP site symbols are unique!")

      fi,fu,fl :: BIN
      IDs,labels :: VEC{STR}*
      i,ind :: INT
      U,dU :: MAT{REAL}*
      U_iso,d_U_iso :: VEC{REAL}*
      fac :: REAL
      lab :: STR

      ! Read U_iso values
      nullify(  U_iso)
      nullify(d_U_iso)
      cif.read_looped_item("_atom_site_U_iso_or_equiv",U_iso,d_U_iso,found=fi)

      ! Are they there?
      if (fi) then

         ! Convert B factor
         if (cif.U_iso_is_B_iso) then
            fac = ONE/(EIGHT*PI*PI)
            U_iso   = fac*  U_iso
            d_U_iso = fac*d_U_iso
         end

         ! Make space
         .reset_pADPs_and_errors(9)

         ! Set
         U_iso.convert_from("angstrom^2")
         .set_U_iso(U_iso)
         U_iso.destroy

         ! Set errors
         if (d_U_iso.associated) then
            d_U_iso.convert_from("angstrom^2")
            .set_U_iso_error(d_U_iso)
            d_U_iso.destroy
         end


      end

      ! Read U tensor
      IDs.create(6)
      do i = 1,6
         lab = ATOM:ADP_label(i,form="underscore-123-repeated")
         IDs(i) = "_atom_site_aniso_"//trim(lab)
      end
      cif.read_looped_item("_atom_site_aniso_label",labels,fl)
      cif.read_looped_items(IDs,U,dU,found=fu)
      IDs.destroy

      ! Are they there?
      fail = NOT (fl AND fu)

      ! Read the ADP2s
      if (NOT fail) then
   
         ! Convert B factors
         if (cif.U_is_B) then
            fac = ONE/(EIGHT*PI*PI)
            U   = fac*U
         end
   
         ! Change U units to au^2
          U.convert_from("angstrom^2")
         dU.convert_from("angstrom^2")
   
         ! Match the anisotropic U labels and assign the U tensors
         do i = 1,labels.dim
   
            ! Find matching index "ind"
            ind = self(:).label.index_of(labels(i))
            DIE_IF(ind==0,"unmatching atom_site_aniso_label, "//trim(labels(i)))
   
            ! Assign ADP
            self(ind).reset_pADPs_and_errors(9)
            self(ind).set_ADP_tensor(U(:,i))
            self(ind).set_ADP2_errors_to(dU(:,i),FALSE)
   
         end
   
         ! Set the crystal axis system. For anharmonic ADPs (if any)
         ! the form "g" or "u" was already detected and set.
         .set_ADP_axis_system_to("crystal")
   
      end

      ! Clean
      if (fu) then
        dU.destroy
         U.destroy
      end

      if (fl) labels.destroy

   end


   read_CIF_ADP3(cif) ::: private, leaky
   ! Detect if the "cif" file has anharmonic ADP3s, either
   ! dimensionless "g" (crystal) or dimensioned "u" (cartesian)
   ! Gram-Charlier coefficients. The cif.GC_format will be set to this
   ! value, accordingly. It looks for "u" format first.
      self :: INOUT
      cif :: CIF, INOUT

      GC_format :: VEC{STR}(2) = ["u", "g"]
      fmt :: INT
      f3 :: BIN

      do fmt = 1,GC_format.dim

         ! Detect fmt
         cif.set_GC_format(GC_format(fmt))
         .read_CIF_ADP3_helper(cif,f3)

         ! If fmt found exit
         if (f3) exit

      end

   end

   read_CIF_ADP3_helper(cif,f3) ::: private, leaky
   ! Detect if stdout has ADP3s in the specified "cif.GC_format", either
   ! dimensionless "g" cartesian "u" form; and if so set "f3" TRUE,
   ! and set the ADP3's of "self".
      self :: INOUT
      cif :: CIF, INOUT
      f3 :: BIN, OUT

   ENSURE(cif.GC_format.is_one_of(["u","g"]),"incorrect fmt")

      labels,IDs,esd :: VEC{STR}*
      U,dU :: MAT{REAL}*
      fl,fu,fd :: BIN
      lab :: STR
      i,ind :: INT

      cif.read_looped_item(trim(cif.GC3_label)//"label",labels,fl)

      ! Any ADP3's to read?
      f3 = fl
      if (NOT fl) return

      select case (cif.GC_format)

      case ("u") 

         ! U format ... should by C format?
         IDs.create(10)
         esd.create(10)
         do i = 1,10
            lab = ATOM:ADP3_index_label(i,form="underscore-123-repeated")
            lab = trim(cif.GC3_label)//trim(lab)
            IDs(i) = trim(lab)
            esd(i) = trim(lab)//"_esu"
         end

         ! Read U & dU
         cif.read_looped_items(IDs, U,found=fu)
         cif.read_looped_items(esd,dU,found=fd)

         ! Found?
         f3 = fl AND fu AND fd

         ! Clean
         esd.destroy
         IDs.destroy

         ! Unit conversion?
         if (f3) then
             U.convert_from("angstrom^3")
            dU.convert_from("angstrom^3")
         end

      case ("g")
      
         ! G format
         IDs.create(10)
         do i = 1,10
            lab = ATOM:ADP3_index_label(i,form="underscore-123-repeated")
            lab = trim(cif.GC3_label)//trim(lab)
            IDs(i) = trim(lab)
         end

         ! Read U & dU
         cif.read_looped_items(IDs,U,dU,found=fu)

         ! Found?
         f3 = fu AND fl

         ! Clean
         IDs.destroy

      end

      !!!!!!!!!!!!!!!!!!
      if (NOT f3) return
      !!!!!!!!!!!!!!!!!!

      ! Read scale factor & scale
      cif.read_item(trim(cif.GC3_label)//"scale_factor",cif.GC3_scale_factor)
       U =  U/cif.GC3_scale_factor
      dU = dU/cif.GC3_scale_factor

      ! Match the labels and assign the U3 tensors
      do i = 1,labels.dim

         ! Find matching index "ind"
         ind = self(:).label.index_of(labels(i))
         DIE_IF(ind==0,"unmatching label, "//trim(labels(i)))

         ! Assign ADP
         self(ind).reset_pADPs_and_errors(19)
         self(ind).set_ADP3_vector_to( U(:,i))
         self(ind).set_ADP3_errors_to(dU(:,i))

         ! Assign axes for later conversion
         if (cif.GC_format=="u") then
            self(ind).set_ADPn_axis_system_to("cartesian")
         else
            self(ind).set_ADPn_axis_system_to("crystal")
         end

      end

      ! Clean up
       U.destroy
      dU.destroy
      labels.destroy

   end


   read_CIF_ADP4(cif) ::: private, leaky
   ! Detect if the "cif" file has anharmonic ADP4s, either
   ! dimensionless "g" (crystal) or dimensioned "u" (cartesian)
   ! Gram-Charlier coefficients. The cif.GC_format will be set to this
   ! value, accordingly. It looks for "u" format first.
      self :: INOUT
      cif :: CIF, INOUT

      GC_format :: VEC{STR}(2) = ["u", "g"]
      fmt :: INT
      f4 :: BIN

      do fmt = 1,GC_format.dim

         ! Detect fmt
         cif.set_GC_format(GC_format(fmt))
         .read_CIF_ADP4_helper(cif,f4)

         ! If fmt found exit
         if (f4) exit

      end

   end

   read_CIF_ADP4_helper(cif,f4) ::: private, leaky
   ! Detect if stdout has ADP4s in the specified "cif.GC_format", either
   ! dimensionless "g" cartesian "u" form; and if so set "f4" TRUE,
   ! and set the ADP4's of "self".
      self :: INOUT
      cif :: CIF, INOUT
      f4 :: BIN, OUT

   ENSURE(cif.GC_format.is_one_of(["u","g"]),"incorrect fmt")

      labels,IDs,esd :: VEC{STR}*
      U,dU :: MAT{REAL}*
      fl,fu,fd :: BIN
      lab :: STR
      i,ind :: INT

      cif.read_looped_item(trim(cif.GC4_label)//"label",labels,fl)

      ! Any ADP4's to read?
      f4 = fl
      if (NOT fl) return

      select case (cif.GC_format)

      case ("u") 

         ! U format ... should by C format?
         IDs.create(15)
         esd.create(15)
         do i = 1,15
            lab = ATOM:ADP4_index_label(i,form="underscore-123-repeated")
            lab = trim(cif.GC4_label)//trim(lab)
            IDs(i) = trim(lab)
            esd(i) = trim(lab)//"_esu"
         end

         ! Read U & dU
         cif.read_looped_items(IDs, U,found=fu)
         cif.read_looped_items(esd,dU,found=fd)

         ! Found?
         f4 = fl AND fu AND fd

         ! Clean
         esd.destroy
         IDs.destroy

         ! Unit conversion?
         if (f4) then
             U.convert_from("angstrom^4")
            dU.convert_from("angstrom^4")
         end

      case ("g")
      
         ! G format
         IDs.create(15)
         do i = 1,15
            lab = ATOM:ADP4_index_label(i,form="underscore-123-repeated")
            lab = trim(cif.GC4_label)//trim(lab)
            IDs(i) = trim(lab)
         end

         ! Read U & dU
         cif.read_looped_items(IDs,U,dU,found=fu)

         ! Found?
         f4 = fu AND fl

         ! Clean
         IDs.destroy

      end

      !!!!!!!!!!!!!!!!!!
      if (NOT f4) return
      !!!!!!!!!!!!!!!!!!

      ! Read scale factor & scale
      cif.read_item(trim(cif.GC4_label)//"scale_factor",cif.GC4_scale_factor)
       U =  U/cif.GC4_scale_factor
      dU = dU/cif.GC4_scale_factor

      ! Match the labels and assign the U4 tensors
      do i = 1,labels.dim

         ! Find matching index "ind"
         ind = self(:).label.index_of(labels(i))
         DIE_IF(ind==0,"unmatching label, "//trim(labels(i)))

         ! Assign ADP
         self(ind).reset_pADPs_and_errors(34)
         self(ind).set_ADP4_vector_to( U(:,i))
         self(ind).set_ADP4_errors_to(dU(:,i))

         ! Assign axes for later conversion
         if (cif.GC_format=="u") then
            self(ind).set_ADPn_axis_system_to("cartesian")
         else
            self(ind).set_ADPn_axis_system_to("crystal")
         end

      end

      ! Clean up
       U.destroy
      dU.destroy
      labels.destroy

   end

   read_CIF_dispersion(cif) ::: selfless, leaky
   ! Read the anomalous dispersion coefficients (if present)
   ! from the "cif" file.
      cif :: CIF, INOUT

      IDs :: VEC{STR}*
      f_real,f_imag :: VEC{REAL}*
      fs,fr,fi :: BIN
      a,Z :: INT

      ! Read CIF
      nullify(IDs)
      nullify(f_real)
      nullify(f_imag)

      cif.read_looped_item("_atom_type_symbol",IDs,found=fs)
      cif.read_looped_item("_atom_type_scat_dispersion_real",f_real,found=fr)
      cif.read_looped_item("_atom_type_scat_dispersion_imag",f_imag,found=fi)

      ! Are they there?
      if (fs AND fr AND fi) then

         do a = 1,IDs.dim

            ! Get the atomic number Z
            Z = ATOM:atomic_number_from_label(IDs(a))

            ! Skip unrecognised element label
            if (Z==0) then
               WARN("atom_type_symbol "//trim(IDs(a))//" unrecognised for anamalous dispersion")
               cycle
            end

            ! Set them in the table
            ATOM:set_dispersion_coefficients(Z,f_real(a),f_imag(a))

         end

      end

      ! Clean
      if (fi) f_imag.destroy
      if (fr) f_real.destroy
      if (fs) IDs.destroy

   end

! mmCIF

   read_mmCIF ::: leaky
   ! Read information from a macromolecular Crystallographic
   ! Information File whose name is read from "stdin".
      self :: PTR

      name :: STR

      ! Read name cif name from stdin
      stdin.read(name)

      ! Read CIF
      .read_mmCIF(name)

   end

   read_mmCIF(name) ::: leaky
   ! Read information from a macromolecular  Crystallographic
   ! Information File "name"
      self :: PTR
      name :: STR, IN

      cif :: CIF*
      found :: BIN

      ! Create the CIF and find data
      cif.create(name)
      cif.open
      cif.find_crystal_data_block(found)
      ENSURE(found,"no crystal data block found")

      ! Read
      .read_mmCIF(cif)

      ! Clean
      cif.destroy

   end

   read_mmCIF(cif) ::: leaky
   ! Read information from a macromolwcular Crystallographic
   ! Information File "name"
      self :: PTR
      cif :: CIF

      fail :: BIN

      ! Read atom positions
      .read_mmCIF_atoms(cif,fail)
    
      ! Read ADPs including U_iso/B_iso
      .read_mmCIF_ADP2(cif,fail)

      ! Read dispersion
      VEC{ATOM}::read_mmCIF_dispersion(cif)

   end

   read_mmCIF_atoms(cif,fail) ::: leaky
   ! Read Tonto information from a macromolecular "cif".  Cartesian
   ! NOTE: self is destroyed and created from this file!
      self :: PTR
      cif :: CIF, INOUT
      fail :: BIN, OUT

      n_atoms,i,a :: INT
      fl,fc,fe,fo :: BIN
      ind :: VEC{INT}*
      IDs :: VEC{STR}*
      labels :: MAT{STR}*
      data :: MAT{REAL}*
      lab :: STR

      ! Read the site labels FIRST because these seem to correlate with
      ! the anisotropic U's.
      nullify(ind)
      cif.read_looped_item("_atom_site.id",ind,fl)

      fail = NOT fl 
      if (fail) return

      ! Destroy the old atom list (if there)
      n_atoms = ind.dim
      .destroy

      ! Create the new atom list
      .create(n_atoms)

      ! Read the labels
      IDs.create(6)
      IDs = [ &
         "_atom_site.type_symbol    ", &
         "_atom_site.label_atom_id  ", &
         "_atom_site.label_comp_id  ", &
         "_atom_site.label_seq_id   ", &
         "_atom_site.label_asym_id  ", &
         "_atom_site.label_entity_id"  &
         ]
      cif.read_looped_items(IDs,labels,found=fc)
      IDs.destroy

      ! Set the labels 
      do i = 1,n_atoms

         ! Atom index
         a = ind(i)

         ! Set atomic number from chemical symbol
         self(a).set_atomic_number_and_mass(labels(i,1)) 

         ! Set the label, Tonto style
         lab = trim(labels(2,i))
         lab = trim(lab)//"-"//trim(labels(3,i).lower_cased)
         lab = trim(lab)//"-"//trim(labels(4,i))
         lab = trim(lab)//"-"//trim(labels(5,i))
         lab = trim(lab)//"-"//trim(labels(6,i))
         self(a).set_label(lab)

      end
      labels.destroy

      ! Read the coordinates, occupancy, B value
      IDs.create(4)
      IDs = [ &
         "_atom_site.Cartn_x  ", &
         "_atom_site.Cartn_y  ", &
         "_atom_site.Cartn_z  ", &
         "_atom_site.occupancy"  &
         ]
      cif.read_looped_items(IDs,data,found=fc)
      IDs.destroy

      fail = NOT fc
      if (fail) return

      ! Set the positions
      .set_pos_axis_system_to("cartesian")
      .reset_pADPs_and_errors(9)
      data(1:3,:).convert_from("angstrom")
      .set_positions_to(data(1:3,:))

      ! Set occupancy
      .set_site_occupancies(data(:,4))
      data.destroy

      ! Read errors (if there)
      IDs.create(3)
      IDs = ["_atom_site.Cartn_x_esd", &
             "_atom_site.Cartn_y_esd", &
             "_atom_site.Cartn_z_esd"  ]
      cif.read_looped_items(IDs,data,found=fe)
      IDs.destroy

      if (fe) then
         ! Set the positions
         data.convert_from("angstrom")
         .set_position_errors_to(data)
         data.destroy
      end

      ! Update?
      .update

   end

   read_mmCIF_dispersion(cif) ::: selfless, leaky
   ! Read the anomalous dispersion coefficients (if present)
   ! from the macromolecular "cif" file.
      cif :: CIF, INOUT

      IDs :: VEC{STR}*
      f_real,f_imag :: VEC{REAL}*
      fs,fr,fi :: BIN
      a,Z :: INT

      ! Read CIF
      nullify(IDs)
      nullify(f_real)
      nullify(f_imag)

      cif.read_looped_item("_atom_type.symbol",IDs,found=fs)
      cif.read_looped_item("_atom_type.scat_dispersion_real",f_real,found=fr)
      cif.read_looped_item("_atom_type.scat_dispersion_imag",f_imag,found=fi)

      ! Are they there?
      if (fs AND fr AND fi) then

         do a = 1,IDs.dim

            ! Get the atomic number Z
            Z = ATOM:atomic_number_from_label(IDs(a))

            ! Skip unrecognised element label
            if (Z==0) then
               WARN("atom_type_symbol "//trim(IDs(a))//" unrecognised for anamalous dispersion")
               cycle
            end

            ! Set them in the table
            ATOM:set_dispersion_coefficients(Z,f_real(a),f_imag(a))

         end

      end

      ! Clean
      if (fi) f_imag.destroy
      if (fr) f_real.destroy
      if (fs) IDs.destroy

   end

   read_mmCIF_ADP2(cif,fail) ::: leaky
   ! Read fractional ADP information from the macromolecular "cif".
   ! It is an error if there are no atom coordinates in the file.
      self :: INOUT
      cif :: CIF, INOUT
      fail :: BIN, OUT

      fi,fu :: BIN
      IDs,labels :: VEC{STR}*
      a,i :: INT
      U :: MAT{REAL}*
      U_iso :: VEC{REAL}*
      ind :: VEC{INT}*
      fac :: REAL
      lab :: STR

      ! Read the site labels FIRST
      ! These should match -atom_site.id but this is not checked
      nullify(ind)
      cif.read_looped_item("_atom_site_anisotrop.id",ind,fi)

      fail = NOT fi 
      if (fail) return

      ! Read U_iso values
      nullify(U_iso)
      cif.read_looped_item("_atom_site.U_iso_or_equiv",U_iso,found=fi)

      ! Read B_iso values if U_iso's are not there ...
      if (NOT fi) then

         cif.read_looped_item("_atom_site.B_iso_or_equiv",U_iso,found=fi)

         fac = ONE/(EIGHT*PI*PI)
         U_iso   = fac*  U_iso

      end

      ! If there set the values
      if (fi) then

         ! Set
         U_iso.convert_from("angstrom^2")
         .set_U_iso(U_iso)
         U_iso.destroy

      end

      ! Read U tensor
      IDs.create(6)
      do i = 1,6
         lab = ATOM:ADP_label(i,form="123-repeated-square-braces")
         IDs(i) = "_atom_site_anisotrop.U"//trim(lab)
      end
      cif.read_looped_items(IDs,U,found=fu)
      IDs.destroy

      ! Read B tensor in U is not there ...
      if (NOT fu) then

         IDs.create(6)
         do i = 1,6
            lab = ATOM:ADP_label(i,form="123-repeated-square-braces")
            IDs(i) = "_atom_site_anisotrop.B"//trim(lab)
         end
         cif.read_looped_items(IDs,U,found=fu)
         IDs.destroy

         ! Rescale B's
         fac = ONE/(EIGHT*PI*PI)
         U_iso   = fac*  U_iso

      end

      ! Are they there?
      fail = NOT fu

      ! Read the ADP2s
      if (NOT fail) then
   
         ! Change U units to au^2
         U.convert_from("angstrom^2")
   
         ! Match the anisotropic U labels and assign the U tensors
         do i = 1,.dim
   
            ! Get atom index
            a = ind(a)
   
            ! Assign ADP
            self(a).reset_pADPs_and_errors(9)
            self(a).set_ADP_tensor(U(:,i))
   
         end
   
         ! Set the crystal axis system. For anharmonic ADPs (if any)
         ! the form "g" or "u" was already detected and set.
         .set_ADP_axis_system_to("crystal")
   
      end

      ! Clean
      U.destroy
      U_iso.destroy
      ind.destroy

   end


   read_use_interpolators
   ! Read whether to use interpolators for spherical atom densities
      self :: PTR
      use_interp :: BIN

      stdin.read(use_interp)

      if (.disassociated) return

      .set_use_interpolators(use_interp)

   end

!  =============
!  Resolve bases
!  =============

   resolve_bases(basis,suffix) ::: template
   ! Resolve the basis sets for each atom -- by pointer assigning its basis to
   ! the element in "basis" which matches either the atoms .basis_label, or else
   ! matches a label constructed in a standard way, by joining the atom chemical
   ! symbol with the ":suffix" string.
      basis :: VEC{BASIS?}*
      suffix :: STR, optional

      a :: INT

      do a = 1,.dim
         self(a).resolve_basis(basis,suffix)
      end

   end

   resolve_bases(basis,suffix) ::: get_from(VEC{ATOM}, BASIS?=>BASIS)
   ! Resolve the basis sets for each atom -- by pointer assigning its basis to
   ! the element in "basis" which matches either the atoms .basis_label, or else
   ! matches a label constructed in a standard way, by joining the atom chemical
   ! symbol with the ":suffix" string.
   end

   resolve_bases(basis,suffix) ::: get_from(VEC{ATOM}, BASIS?=>SLATERBASIS)
   ! Resolve the basis sets for each atom -- by pointer assigning its basis to
   ! the element in "basis" which matches either the atoms .basis_label, or else
   ! matches a label constructed in a standard way, by joining the atom chemical
   ! symbol with the ":suffix" string.
   end

   resolve_bases(basis,suffix) ::: get_from(VEC{ATOM}, BASIS?=>COPPENSBASIS)
   ! Resolve the basis sets for each atom -- by pointer assigning its basis to
   ! the element in "basis" which matches either the atoms .basis_label, or else
   ! matches a label constructed in a standard way, by joining the atom chemical
   ! symbol with the ":suffix" string.
   end

!  ===================
!  Axis system changes
!  ===================

   change_axis_system_to(axis_system,cell,H_U_iso,change_ESDs) ::: PURE
   ! Change the atom axis systems to the desired "axis_system".
   ! If "change_ESDs" is present and TRUE, the ESDs are changed
   ! in a straighforward way using the unit_cell, otherwise not.
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN
      H_U_iso :: BIN, IN
      change_ESDs :: BIN, optional, IN

      a :: INT

      do a = 1,.dim
         self(a).change_axis_system_to(axis_system,cell,H_U_iso,change_ESDs)
      end

   end

!  ===============
!  Change geometry
!  ===============

   extend_bond_lengths(z1,z2,factor) ::: PURE
   ! Uniformly extend the bond lengths between all BONDED atoms with
   ! atomic number "z1" and "z2" by a "factor". Only the coordinates
   ! of the atoms with atomic number "z2" are altered.
      self :: INOUT
      z1,z2 :: INT, IN
      factor :: REAL, IN

      z1_ind,z2_ind,a1,a2 :: INT
      r21,new :: VEC{REAL}(3)

      if (all(self(:).atomic_number/=z1) OR all(self(:).atomic_number/=z2)) return

      ! First occurence of the atoms
      z1_ind = self(:).atomic_number.index_of_value(z1)
      z2_ind = self(:).atomic_number.index_of_value(z2)

      do a1 = z1_ind,.dim

         if (self(a1).atomic_number/=z1) cycle

         do a2 = z2_ind,.dim

            if (self(a2).atomic_number/=z2) cycle

            if (NOT .bonded(a1,a2)) cycle

            r21 = self(a2).position - self(a1).position
            new = self(a1).position + factor*r21
            self(a2).set_position(new)

         end

      end

   end

   set_bond_lengths(z1,z2,length) ::: PURE
   ! Uniformly set the bond lengths between all BONDED atoms with atomic number
   ! "z1" and "z2" to be "length". Only the coordinates of the atoms with atomic
   ! number "z2" are altered.
      self :: INOUT
      z1,z2 :: INT, IN
      length :: REAL, IN

      z1_ind,z2_ind,a1,a2 :: INT
      r21,new :: VEC{REAL}(3)

      if (all(self(:).atomic_number/=z1) OR all(self(:).atomic_number/=z2)) return

      ! First occurence of the atoms
      z1_ind = self(:).atomic_number.index_of_value(z1)
      z2_ind = self(:).atomic_number.index_of_value(z2)

      do a1 = z1_ind,.dim

         if (self(a1).atomic_number/=z1) cycle

         do a2 = z2_ind,.dim

            if (self(a2).atomic_number/=z2) cycle

            if (NOT .bonded(a1,a2)) cycle

            r21 = self(a2).position - self(a1).position
            r21.normalise
            new = self(a1).position + length*r21
            self(a2).set_position(new)

         end

      end

   end

!  ===================
!  Information methods
!  ===================

   no_of_dummy_atoms result (res) ::: pure
   ! Return the number of dummy atoms
      self :: IN
      res :: INT
      if (.dim==0) then
         res = 0
      else
         res = count(ATOM:is_a_dummy_atom(self))
      end
   end

   dummy_atoms result (ind) ::: pure
   ! Return the list of dummy atoms
      self :: IN
      ind :: VEC{INT}(.no_of_dummy_atoms)
      i :: INT

      if (.no_of_dummy_atoms==0) return

      i = 0
      ind = pack([(i, i=1,.dim)],mask=ATOM:is_a_dummy_atom(self))

   end

   no_of_nondummy_atoms result (res) ::: pure
   ! Return the number of non-dummy atoms
      self :: IN
      res :: INT
      if (.dim==0) then
         res = 0
      else
         res = count(ATOM:is_a_nondummy_atom(self))
      end
   end

   nondummy_atoms result (ind) ::: pure
   ! Return TRUE if all atoms have unique labels
      self :: IN
      ind :: VEC{INT}(.no_of_nondummy_atoms)

      i :: INT

      if (.no_of_nondummy_atoms==0) return

      i = 0
      ind = pack([(i, i=1,.dim)],mask=ATOM:is_a_nondummy_atom(self))

   end

   no_of_atoms_with_bases result (res) ::: pure
   ! Return the number of atoms with bases
      self :: IN
      res :: INT
      res = count(ATOM:has_basis(self))
   end

   atoms_with_bases result (ind) ::: pure
   ! Return TRUE if all atoms have unique labels
      self :: IN
      ind :: VEC{INT}(.no_of_atoms_with_bases)
      i :: INT
      i = 0
      ind = pack([(i, i=1,.dim)],mask=ATOM:has_basis(self))
   end

   chemical_formula(with_spaces) result (res) ::: public
   ! Return the chemical formula for the molecule, as a string, in
   ! alphabetical order of elements
      with_spaces :: BIN, optional
      res :: STR
      ENSURE(.dim > 0,"Must have at least one atom for a chemical formula")

      a, na :: INT
      spaces :: BIN
      symbol :: VEC{STR}*

      ! Do we want spaces between the elements?
      spaces = FALSE
      if (present(with_spaces)) spaces = with_spaces

      ! Get alphabetical list of chemical symbols
      symbol.create(.dim)
      do a = 1,.dim
         symbol(a) = self(a).chemical_symbol
      end
      symbol.quick_sort

      ! Make the chemical symbol
      res = " "
      a = 1
      do
         if (a>.dim) exit
         na = count(symbol==symbol(a))
         if (spaces AND res/=" ") then; res = trim(res) // " " // trim(symbol(a))
         else;                          res = trim(res) //        trim(symbol(a))
         end
         if (na>1) &
            res = trim(res) // trim(na.to_str)
         a = a + na
      end

      ! Clean up
      symbol.destroy

   end

   molecular_weight result (res) ::: pure
   ! Return the molceular weight for this atomvec
      self :: IN
      res :: REAL

      a :: INT

      res = ZERO

      do a = 1,.dim
         res = res + self(a).mass
      end

   end

   get_mean_neutron_numbers(NN)
   ! Get the atom coordinates in a matrix object "coord"
      NN :: VEC{REAL}
       a :: INT
      do a = 1,.dim
         NN(a) = self(a).mean_neutron_number
      end
   end

   no_of_H_atoms result (res) ::: pure
   ! Return the number of H atoms
      self :: IN
      res :: INT

      res = count(ATOM:is_a_H_atom(self))

   end

   no_of_non_H_atoms result (res) ::: pure
   ! Return the number of non H atoms
      self :: IN
      res :: INT

      res = count(ATOM:is_not_a_H_atom(self))

   end

   list_of_non_H_atoms result (res) ::: leaky
   ! Return the list of indices of non-H atoms
      self :: IN
      res :: VEC{INT}*

      n,a,i :: INT

      n = .no_of_non_H_atoms

      res.create(n)

      i = 0
      do a = 1,.dim
         if (self(a).is_not_a_H_atom) then
            i = i + 1
            res(i) = a
         end
      end

   end

   no_of_nonmetal_atoms result (res) ::: pure
   ! Return the number of non-dummy atoms
      self :: IN
      res :: INT
      res = count(ATOM:is_a_nonmetal(self))
   end

   no_of_metalloid_atoms result (res) ::: pure
   ! Return the number of non-dummy atoms
      self :: IN
      res :: INT
      res = count(ATOM:is_a_metalloid(self))
   end

   no_of_metal_atoms result (res) ::: pure
   ! Return the number of non-dummy atoms
      self :: IN
      res :: INT
      res = count(ATOM:is_a_metal(self))
   end

   list_of_metal_atoms result (res) ::: leaky
   ! Return the indices of the metal atoms
      self :: IN
      res :: VEC{INT}*

      n,a,i :: INT

      n = .no_of_metal_atoms

      res.create(n)

      i = 0
      do a = 1,n
         if (NOT self(a).is_a_metal) cycle
         i = i + 1
         res(i) = a
      end

   end

!  =====================
!  Symbols, labels, tags
!  =====================

   unique_tags result (res) ::: leaky, PURE
   ! Return the unique tags
      self :: IN
      res :: VEC{STR}*

      res.create(.dim)
      res = self.tag

   end

   non_H_atom_tags result (tags) ::: leaky
   ! Return the list of non-H atom tags
      self :: IN
      tags :: VEC{STR}*

      list :: VEC{INT}*
      n :: INT

      n = .no_of_non_H_atoms

      tags.create(n)

      ! Get the list
      list => .list_of_non_H_atoms

      ! Get the tags
      tags = self(list).tag

      ! Clean up
      list.destroy

   end

   chemical_symbols result (res)
   ! Return an array of the chemical symbols for each atom
      res :: VEC{STR}(size(self))
      res = ATOM:chemical_symbol(self)
   end

   has_dummy_labels result (res)
   ! Return TRUE if any atom has a dummy charge labels
      self :: IN
      res :: BIN
      res = any(ATOM:has_a_dummy_label(self))
   end

! pADP's

   no_of_NPD_ADPs result (res)
   ! Return the number of non-positive definite ADPs
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         if (self(a).has_NPD_ADP) res = res + 1
      end

   end

   no_of_flat_ADPs result (res)
   ! Return the number of flat ADPs
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         if (self(a).has_flat_ADP) res = res + 1
      end

   end

   no_of_pADPs result (res) ::: pure
   ! Return the number of positional and ADP parameters.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).no_of_pADPs
      end

   end

   no_of_pADPs_up_to_atom(a) result (res) ::: PURE
   ! Return the no. of the pADPs up to but *not* including atom "a".
      self :: IN
      a :: INT, IN
      res :: INT

   ENSURE(a>0,"a must be +ve")
   ENSURE(a<=.dim,"a too large")

      b,n :: INT

      res = 0
      do b = 1,a-1
         n = self(b).no_of_pADPs
         res = res + n
      end

   end

   max_no_of_pADPs_per_atom result (res) ::: pure
   ! Return the *maximum* number of pADP parameters per atom
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         res = max(res,self(a).no_of_pADPs)
      end

   end

   get_atom_for_pADP_index(par_index,res,last_index) ::: PURE
   ! Return the atom for the cumulative position-ADP index "par_index".
   ! Also return the cumulative index up to the previous atom.
      self :: IN
      par_index :: INT, IN
      res :: INT, OUT
      last_index :: INT, OUT

   ENSURE(par_index>0,"par_index must be +ve")
   ENSURE(par_index<=.no_of_pADPs,"par_index too large")

      a,n,l :: INT

      n = 0
      l = 0

      do a = 1,.dim

         n = self(a).no_of_pADPs
         l = l + n

         if (par_index>l) cycle

         exit

      end

      res = a
      
      last_index = l - n

   end

   tag_pADP_label(par_index) result (res) ::: PURE
   ! Return the unique tag with the parameter (positional-ADP) label
   ! for the *cumulative* parameter index "par_index"
      self :: IN
      par_index :: INT, IN
      res :: STR

      a,ind :: INT

      .get_atom_for_pADP_index(par_index,a,ind)

      ind = par_index - ind

      res = self(a).tag_pADP_label(ind)

   end

   tag_pADP_labels result (res) ::: leaky, PURE
   ! Return *all* the tags and positional-ADP labels.
      self :: IN
      res :: VEC{STR}*

      a,n,i,l,dim :: INT

      ! No. of parameters
      dim = .no_of_pADPs

      ! Leaky
      res.create(dim)

      l = 0

      ! Get the labels
      do a = 1,.dim

         n = self(a).no_of_pADPs

         do i = 1,n
            res(l+i) = self(a).tag_pADP_label(i)
         end

         l = l + n

      end

   end

   tag_pADP_labels(par_indices) result (res) ::: leaky, PURE
   ! Return the tag and positional-ADP parameter with  the indices
   ! "par_indices"
      self :: IN
      par_indices :: VEC{INT}, IN
      res :: VEC{STR}*

      i :: INT

      ! Create the label arrays (leaky)
      res.create(par_indices.dim)

      ! Get the labels
      do i = 1,par_indices.dim
         res(i) = .tag_pADP_label(par_indices(i))
      end

   end

! ADP's

   no_of_ADP3s result (res) ::: pure
   ! Return the number of ADP3 parameters.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         if (NOT self(a).has_ADP3s_and_errors) cycle
         res = res + 10
      end

   end

   no_of_ADP3_atoms result (res) ::: pure
   ! Return the number of atoms with ADP3 parameters.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         if (NOT self(a).has_ADP3s_and_errors) cycle
         res = res + 1
      end

   end

   no_of_ADP4s result (res) ::: pure
   ! Return the number of ADP4 parameters.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         if (NOT self(a).has_ADP4s_and_errors) cycle
         res = res + 15
      end

   end

   no_of_ADP4_atoms result (res) ::: pure
   ! Return the number of atoms with ADP4 parameters.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         if (NOT self(a).has_ADP4s_and_errors) cycle
         res = res + 1
      end

   end

!  ================
!  Nuclear energies
!  ================

   sum_of_nuclear_charges result (res) ::: pure
   ! Return the sum of the nuclear_charges
   ! Note: dummy atoms may have non-zero nuclear charge
      self :: IN
      res :: REAL

      res = sum(self(:).nuclear_charge)

   end

   nuclear_repulsion_energy result (res) ::: pure
   ! Return the nuclear repulsion energy.
      self :: IN
      res :: REAL

      i,j :: INT
      qi,qj :: REAL
      r :: VEC{REAL}(3)


      res = ZERO

      do i = 1,.dim

         qi = self(i).nuclear_charge

         do j = 1,i-1

            qj = self(j).nuclear_charge

            r   =  self(j).position - self(i).position
            res = res + qi*qj/sqrt(dot_product(r,r))

         end

      end

   end

   nuclear_repulsion_energy(atoms) result (res) ::: pure
   ! Return the nuclear repulsion energy felt by the group of atoms
   ! "a" in the field of all the nuclei in "self"
      self :: IN
      atoms :: VEC{INT}, IN
      res :: REAL

      a,i,j :: INT
      qi,qj :: REAL
      r :: VEC{REAL}(3)

      res = ZERO

      do i = 1,atoms.dim

         a  = atoms(i)
         qi = self(a).nuclear_charge

         do j = 1,.dim

            if (any(atoms==j)) cycle

            qj = self(j).nuclear_charge

            r =  self(j).position - self(a).position
            res = res + qi*qj/sqrt(dot_product(r,r))

         end

      end

      res = HALF*res ! only count half the interaction energy
      res = res + self(atoms).nuclear_repulsion_energy

   end

   nuclear_repulsion_energy(atoms,nuclei) result (res) ::: pure
   ! Return the nuclear repulsion energy felt by the group of atoms
   ! "a" in the field of all the nuclei in "nuclei"
      self :: IN
      atoms, nuclei :: VEC{INT}, IN
      res :: REAL

      a, i,j,k, n_atoms, n_field :: INT
      qi,qj :: REAL
      r :: VEC{REAL}(3)


      res = ZERO

      n_atoms = size(atoms)
      n_field = size(nuclei)

      do i=1,n_atoms

         a  = atoms(i)
         qi = self(a).nuclear_charge

         do k=1,n_field

            j = nuclei(k)
            if (any(atoms==j)) cycle

            qj = self(j).nuclear_charge
            r =  self(j).position - self(a).position

            res = res + qi*qj/sqrt(dot_product(r,r))

         end

      end

      res = res + self(atoms).nuclear_repulsion_energy

   end

   nuclear_repulsion_for_atom(a) result (res) ::: pure
   ! Return the nuclear repulsion energy felt by atom "a" in the field
   ! of all the nuclei in "self"
      self :: IN
      a :: INT, IN
      res :: REAL

      j :: INT
      qa,qj,r2 :: REAL
      r :: VEC{REAL}(3)

      res = ZERO

      qa = self(a).nuclear_charge

      do j = 1,.dim

         if (j==a) cycle

         qj  = self(j).nuclear_charge
         r   = self(j).position - self(a).position
         r2  = dot_product(r,r)
         res = res + qj*qa/sqrt(r2)

      end

   end

!  ======================
!  Center of mass & shape
!  ======================

   center_of_mass result (res) ::: pure
   ! Return the center of mass
      self :: IN
      res :: VEC{REAL}(3)

      a :: INT
      mw :: REAL

      res = ZERO

      do a = 1,.dim
         res = res + self(a).position*self(a).mass
      end

      mw  = ONE/.molecular_weight
      res = res*mw

   end

   move_origin_to_center_of_mass ::: PURE
   ! Move the origin to the center of mass
      self :: INOUT

      .translate_by(-.center_of_mass)

   end

   change_to_principal_axes
   ! Move the origin to the center of mass and change the coordinates to be with
   ! respect to the principal axes
      pm :: VEC{REAL}(3)
      pa :: MAT{REAL}(3,3)
      .translate_by(-.center_of_mass)
      .make_principal_moments(pm,pa)
      .change_coordinate_axes(pa)
   end

   change_to_principal_top_axes
   ! Move the origin to the center of mass and change the coordinates to be with
   ! respect to the principal top axes i.e. in the case of symmetric tops the
   ! last axis is the unique axes.
      self :: INOUT

      pm :: VEC{REAL}(3)
      pa :: MAT{REAL}(3,3)
      reorder :: BIN

      .translate_by(-.center_of_mass)
      .make_principal_moments(pm,pa,reorder)
      .change_coordinate_axes(pa)

   end

   change_coordinate_axes(axes)
   ! Change the coordinates of the atoms to be with respect to the columns of
   ! "axes", which must be an orthogonal matrix.
      axes :: MAT{REAL}(3,3)
      a :: INT
      do a = 1,.dim
         self(a).change_coordinate_axes(axes)
      end
   end

   displacement_mass_vector result (res) ::: pure
   ! Return the length 3*.dim mass vector used for weighting the
   ! cartesian force contant matrix
      self :: IN
      res :: VEC{REAL}(3*.dim)

      a,i,ia :: INT

      ia = 0
      do a = 1,.dim
      do i = 1,3
         ia = ia + 1
         res(ia) = self(a).mass
      end
      end

   end

   mass result (res) ::: pure
   ! Return the mass of the molecule
      self :: IN
      res :: REAL

      a :: INT

      res = ZERO

      do a = 1,.dim
         res = res + self(a).mass
      end

   end

   reduced_mass result(mu) ::: PURE
   ! Return the center of mass
      self :: IN
      mu :: REAL

      a :: INT

      mu = ZERO

      do a = 1,.dim
         mu = mu + ONE / self(a).mass
      end

      mu = ONE/mu

   end

   make_inertia_tensor(it) ::: PURE
   ! Make the moment of inertia tensor wrt the center of mass
      self :: IN
      it :: MAT{REAL}(3,3), OUT

      m :: MAT{REAL}(3,3)
      com,r :: VEC{REAL}(3)
      trace :: REAL
      a :: INT

      com = .center_of_mass

      it = ZERO

      do a = 1,.dim
         r = self(a).position - com
         m = spread(r,dim=1,ncopies=3)*spread(r,dim=2,ncopies=3)
         m = self(a).mass * m
         trace = m.trace
         m = -m
         m.increment_diagonal_by(trace)
         it = it + m
      end

   end

   make_principal_moments(pm,pa,reorder) ::: PURE
   ! Make the principal moments "pm" and principal axes "pm" wrt the center of
   ! mass.  If "reorder" is present then the principal axes are made to be right
   ! handed. Also:
   ! - For sperical tops, the local x,y,z axes are the pricipal axes
   ! - For symmetric tops, the C axis is unique
   ! - For asymmetric tops, the pricipal axes are aligned close to the local
   !    x,y,z axes
      self :: IN
      pm :: VEC{REAL}(3), OUT
      pa :: MAT{REAL}(3,3), OUT
      reorder :: BIN, optional, IN

      pn :: VEC{REAL}(3)
      it :: MAT{REAL}(3,3)

      ! Make the inertia tensor and axes
      .make_inertia_tensor(it)
      it.diagonalize_by_jacobi(pm,pa)

      ! Set small moments to zero
      if (NOT present(reorder)) return

      where (pm<TOL(6))
         pm = ZERO
      end

      ! Make principal axes close to x,y,z
      if (abs(pa(1,2)) > abs(pa(1,1))) then
         pa.swap_columns(1,2)
         pm.swap_elements(1,2)
      end
      if (abs(pa(1,3)) > abs(pa(1,1))) then
         pa.swap_columns(1,3)
         pm.swap_elements(1,3)
      end
      if (abs(pa(2,3)) > abs(pa(2,2))) then
         pa.swap_columns(2,3)
         pm.swap_elements(2,3)
      end

      ! Use normalised moments for now
      pn = pm/maxval(abs(pm))

      if (.is_spherical_top(pn)) then

            ! Spherical top? ... axes are x,y,z
            pa.to_unit_matrix

      else if (.is_symmetric_top(pn)) then

         ! Symmetric top? ... C axis is unique
         if (abs(pn(1)-pn(3)) < TOL(2)) then
            pa.swap_columns(2,3)
            pm.swap_elements(2,3)
         else if (abs(pn(2)-pn(3)) < TOL(2)) then
            pa.swap_columns(1,3)
            pm.swap_elements(1,3)
         end

      end

      ! Make positive diagonals
      if (pa(1,1)<ZERO AND pa(2,2)<ZERO) then
         pa(:,1) = -pa(:,1)
         pa(:,2) = -pa(:,2)
      end

      ! Lehthanded system?
      if (pa.determinant>ZERO) return

      ! Make axes are right handed
      if (abs(pm(1)-pm(2)) < TOL(6)) then

         ! Swap columns 1,2 if equal moments
         pm.swap_elements(1,2)
         pa.swap_columns(1,2)

      else if (abs (pm(2)-pm(3)) < TOL(6)) then

         ! Swap columns 2,3 if equal moments
         pm.swap_elements(2,3)
         pa.swap_columns(2,3)
      else

         ! Reverse all C axis
         pa(:,3) = -pa(:,3)

      end

   end

   make_shape_tensor(st) ::: PURE
   ! Make the shape tensor "st" wrt the center of atoms. This is the
   ! same as the moment of inertia tensor except that each atom is
   ! assumed to have unit mass.
      self :: IN
      st :: MAT{REAL}(3,3), OUT

      m :: MAT{REAL}(3,3)
      c,r :: VEC{REAL}(3)
      a :: INT

      c = .center_of_atoms

      st = ZERO

      do a = 1,.dim
         r = self(a).position - c
         m = spread(r,dim=1,ncopies=3)*spread(r,dim=2,ncopies=3)
         m.increment_diagonal_by(-m.trace)
         st = st - m
      end

   end

   make_shape_moments(sm,sa) ::: PURE
   ! Make the shape moments "sm" and principal shape axes "sa" wrt the
   ! center of atoms. The shape axes are the same as the principal
   ! moment of inertia axes except that each atom is assumed to have
   ! unit mass. The principal shape axes are made right handed.
      self :: IN
      sm :: VEC{REAL}(3), OUT
      sa :: MAT{REAL}(3,3), OUT

      st :: MAT{REAL}(3,3)

      .make_shape_tensor(st)

      st.diagonalize_by_jacobi(sm,sa)

      ! Make axes are close to x,y,z
      if (abs(sa(1,2)) > abs(sa(1,1))) then
         sa.swap_columns(1,2)
         sm.swap_elements(1,2)
      end
      if (abs(sa(1,3)) > abs(sa(1,1))) then
         sa.swap_columns(1,3)
         sm.swap_elements(1,3)
      end
      if (abs(sa(2,3)) > abs(sa(2,2))) then
         sa.swap_columns(2,3)
         sm.swap_elements(2,3)
      end

      ! Make axes +ve
      if (sa(1,1)<ZERO)        sa(:,1) = -sa(:,1)
      if (sa(2,2)<ZERO)        sa(:,2) = -sa(:,2)
      if (sa.determinant<ZERO) sa(:,3) = -sa(:,3)

   end

!  ===========
!  Shape tests
!  ===========

   is_linear(pm) result (res) ::: PURE
   ! Return TRUE if the geometry is linear.
   ! Needs principal moments of inertia "pm"
      self :: IN
      pm :: VEC{REAL}(3), optional, IN
      res :: BIN

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)

      if (present(pm)) then; mi = pm
      else;                  .make_principal_moments(mi,ma,reorder=TRUE)
      end

      res = any(mi==ZERO)

   end

   is_spherical_top(pm) result (res) ::: PURE
   ! Return TRUE if the geometry is a spherical top
   ! Needs principal moments of inertia "pm"
      self :: IN
      pm :: VEC{REAL}(3), optional, IN
      res :: BIN

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)

      if (present(pm)) then; mi = pm
      else;                  .make_principal_moments(mi,ma,reorder=TRUE)
      end

      res = .no_of_same_principal_moments(mi)==3

   end

   is_symmetric_top(pm) result (res) ::: PURE
   ! Return TRUE if the geometry is a symmetric top
   ! Needs principal moments of inertia "pm"
      self :: IN
      pm :: VEC{REAL}(3), optional, IN
      res :: BIN

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)

      if (present(pm)) then
         mi = pm
      else
         .make_principal_moments(mi,ma)
      end

      res = .no_of_same_principal_moments(mi)==1

   end

   is_prolate_top(pm) result (res) ::: PURE
   ! Return TRUE if the geometry is a prolate top
   ! Needs principal moments of inertia "pm" after alignment
      self :: IN
      pm :: VEC{REAL}(3), optional, IN
      res :: BIN

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)

      if (present(pm)) then; mi = pm
      else;                  .make_principal_moments(mi,ma,reorder=TRUE)
      end

      res = .is_symmetric_top(pm) AND (mi(3)<mi(1))

   end

   is_oblate_top(pm) result (res) ::: PURE
   ! Return TRUE if the geometry is a oblate top
   ! Needs principal moments of inertia "pm" after alignment
      self :: IN
      pm :: VEC{REAL}(3), optional, IN
      res :: BIN

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)

      if (present(pm)) then; mi = pm
      else;                  .make_principal_moments(mi,ma,reorder=TRUE)
      end

      res = .is_symmetric_top(pm) AND (mi(3)>mi(1))

   end

   is_asymmetric_top(pm) result (res) ::: PURE
   ! Return TRUE if the geometry is a asymmetric top
   ! Needs principal moments of inertia "pm"
      self :: IN
      pm :: VEC{REAL}(3), optional, IN
      res :: BIN

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)

      if (present(pm)) then; mi = pm
      else;                  .make_principal_moments(mi,ma,reorder=TRUE)
      end

      res = .no_of_same_principal_moments(mi)==0

   end

   no_of_same_principal_moments(pm) result(same) ::: PURE
   ! Return the number of "same" pairs of principal moments of inertia.
   ! Needs principal moments of inertia "pm"
      self :: IN
      pm :: VEC{REAL}(3), optional, IN
      same :: INT

      mi :: VEC{REAL}(3)
      ma :: MAT{REAL}(3,3)
      i,j :: INT

      if (present(pm)) then; mi = pm
      else;                  .make_principal_moments(mi,ma,reorder=TRUE)
      end

      same = 0
      do i = 1,3
      do j = 1,i-1
         if (abs(mi(i)-mi(j))<=TOL(2)) then
            same = same + 1
         end
      end
      end

   end

!  =============
!  Box centering
!  =============

   center_of_atoms(axes) result(center) ::: PURE
   ! Return the centroid of the atom positions in "center". If "axes" is present
   ! then the "center" is expressed with respect to the new "axes", where the
   ! columns of "axes" are the coordinates of the new axes in terms of the old.
      self :: IN
      axes :: MAT{REAL}(3,3), optional, IN
      center :: VEC{REAL}(3)

      a :: INT
      c :: VEC{REAL}(3)

      center = ZERO
      do a = 1,.dim
         center = center + self(a).position
      end
      center = center/.dim

      if (present(axes)) then
         c = center
         center.to_product_of(axes,c,transpose_a=TRUE)
      end

   end

   move_origin_to_center_of_atoms ::: PURE
   ! Move the origin to the center of atoms
      self :: INOUT

      .translate_by(-.center_of_atoms)

   end

   bounding_cube_width result(width) ::: PURE
   ! Return "width" which is a width of a side of a cube in which the molecule
   ! nicely sits.
   ! Suitable for generating plot widths.
      self :: IN
      width :: REAL

      center,dist :: VEC{REAL}(3)
      length :: REAL
      a :: INT

      width = ZERO

      center = .center_of_atoms

      do a = 1,.dim
         dist = self(a).position - center
         length = dist.norm + self(a).bragg_slater_radius*BOHR_PER_ANGSTROM*TWO
         length = max(length, dist.norm*TWO)
         width  = max(width,length)
      end

      width = TWO*width

   end

   bounding_box_widths(axes) result(box) ::: PURE
   ! Return "box" which are three widths of a side of a box in which
   ! the molecule nicely sits. If "axes" is present, the "box"
   ! coordinates are expressed in terms of the new "axes", where the
   ! columns of "axes" are the coordinates of the new axes in terms of
   ! the old. These "axes" may be (typically) the principal moment
   ! axes. This routine is suitable for generating plot widths.
      self :: IN
      axes :: MAT{REAL}(3,3), optional, IN

      box :: VEC{REAL}(3)

      center,v,dist :: VEC{REAL}(3)
      a :: INT

      box = ZERO
      center = .center_of_atoms

      do a = 1,.dim

         ! Position relative to center
         dist = self(a).position - center

         ! Position in new axis system
         if (present(axes)) then
            v = dist
            dist.to_product_of(axes,v,transpose_a=TRUE)
         end

         ! Flip to +ve quadrant and add boundary
         dist = abs(dist)
         dist = dist + self(a).bragg_slater_radius*BOHR_PER_ANGSTROM*TWO

         ! Get box width
         box  = max(box,dist)

      end

      box = FOUR*box

   end

!  ===========================================
!  Presence/absence of features and properties
!  ===========================================

   has_sequence_numbers result (res) ::: PURE
   ! Return TRUE if any atom in the list has a non zero sequence number
      self :: IN
      res :: BIN

      res = any(self.residue_sequence_number > 1)

   end

   has_nonzero_position_errors result (res) ::: PURE
   ! Return TRUE if all atom have non-zero position errors
      self :: IN
      res :: BIN

      i :: INT

      res = TRUE

      do i = 1,.dim
         if (REAL:is_zero(self(i).position_error.norm)) then
            res = FALSE
            exit
         end
      end

   end

   has_nonzero_ADP_tensors result (res) ::: PURE
   ! Return TRUE if any atom has a non-zero ADP tensor
      self :: IN
      res :: BIN

      i :: INT

      res = FALSE

      do i = 1,.dim
         if (all(self(i).ADP_tensor==ZERO)) cycle
         res = TRUE
         exit
      end

   end

   has_nonzero_U_iso result (res) ::: PURE
   ! Return TRUE if any atom in the list has a non zero U_iso
      self :: IN
      res :: BIN

      res = any(self.U_iso>ZERO)

   end

   has_nonzero_ADPs result (res) ::: PURE
   ! Return TRUE if any atom in the list has a non zero ADP tensor
   ! OR non zero isotropic thermal factor.
      self :: IN
      res :: BIN

      res = .has_nonzero_ADP_tensors OR .has_nonzero_U_iso

   end

   has_nonzero_pos_errors result (res) ::: PURE
   ! Return TRUE if *any* atom has a non-zero position errors
      self :: IN
      res :: BIN

      a :: INT

      res = FALSE

      do a = 1,.dim
         if (NOT self(a).has_pADPs_and_errors) cycle
         if (REAL:is_zero(self(a).pADP_errors(1:3).norm)) cycle
         res = TRUE
         exit
      end

   end

   has_nonzero_pADP2_errors result (res) ::: PURE
   ! Return TRUE if *any* atom has a non-zero pADP2 errors
      self :: IN
      res :: BIN

      a :: INT

      res = FALSE

      do a = 1,.dim
         if (NOT self(a).has_pADPs_and_errors) cycle
         if (REAL:is_zero(self(a).pADP_errors(1:9).norm)) cycle
         res = TRUE
         exit
      end

   end

   has_nonzero_ADP3_errors result (res) ::: PURE
   ! Return TRUE if *any* atom has a non-zero pADP3 error
      self :: IN
      res :: BIN

      a :: INT

      res = FALSE

      do a = 1,.dim
         if (NOT self(a).has_ADP3s_and_errors) cycle
         if (REAL:is_zero(self(a).pADP_errors(10:19).norm)) cycle
         res = TRUE
         exit
      end

   end

   has_nonzero_ADP4_errors result (res) ::: PUTE
   ! Return TRUE if *any* atom has a non-zero ADP4 error
      self :: IN
      res :: BIN

      a :: INT

      res = FALSE

      do a = 1,.dim
         if (NOT self(a).has_ADP4s_and_errors) cycle
         if (REAL:is_zero(self(a).pADP_errors(20:34).norm)) cycle
         res = TRUE
         exit
      end

   end

   has_any_ADP3s_and_errors result (res) ::: pure
   ! Return TRUE if there are *any* ADP3s
      self :: IN
      res :: BIN

      a :: INT

      res = FALSE

      do a = 1,.dim
         if (NOT self(a).has_ADP3s_and_errors) cycle
         res = TRUE
         exit
      end

   end

   has_any_ADP4s_and_errors result (res) ::: pure
   ! Return TRUE if there are *any* ADP4s
      self :: IN
      res :: BIN

      a :: INT

      res = FALSE

      do a = 1,.dim
         if (NOT self(a).has_ADP4s_and_errors) cycle
         res = TRUE
         exit
      end

   end

   has_residue_codes result (res) ::: PURE
   ! Return TRUE if any atom in the list has a residue names
      self :: IN
      res :: BIN

      res = any(self(:).residue_code /= " " )

   end

   has_restraints result (res) ::: PURE
   ! Return TRUE if any atom in the list has a restrained position
   ! or restrained force constants
      self :: IN
      res :: BIN

      res = any(self(:).restraining_force_constant/=ZERO)

   end

   has_dipoles result (has) ::: PURE
   ! Return TRUE if any of the atoms have dipoles
      self :: IN
      has :: BIN

      a :: INT

      has = FALSE

      do a = 1,.dim
         has = self(a).has_dipole
         if (has) exit
      end

   end

   has_polarisabilities result (has) ::: PURE
   ! Return TRUE if any of the atoms have polarisabilities
      self :: IN
      has :: BIN

      a :: INT

      has = FALSE

      do a = 1,.dim
         has = self(a).has_polarisability
         if (has) exit
      end

   end

   has_any_dispersion result (res) ::: PURE
   ! Return TRUE if any atom has an anomalous scattering factor
      self :: IN
      res :: BIN

      res = any(ATOM:has_dispersion(self(:)))

   end

!  ====================
!  ADP inquiry methods
!  ====================

   has_NPD_ADP result (res) ::: PURE
   ! Return TRUE if the ADP is non-zero and non-positive definite.
      self :: IN
      res :: VEC{BIN}(.dim)

      a :: INT

      do a = 1,.dim
         res(a) = self(a).has_NPD_ADP
      end

   end

   has_flat_ADP(ratio) result (res) ::: PURE
   ! Return TRUE if the ADP is flat i.e. the the max to
   ! the min eigenvalue is greater than "ratio" (or FOUR
   ! if not supplied).
      self :: IN
      ratio :: REAL, IN, optional
      res :: VEC{BIN}(.dim)

      a :: INT

      do a = 1,.dim
         res(a) = self(a).has_flat_ADP(ratio)
      end

   end

   ADP_principal_axis_ratio result (res)  ::: PURE
   ! Return the actual max/min ADP principal axis ratio
   ! (or 1000 if the min eigenvalue is zero).
      self :: IN
      res :: VEC{REAL}(.dim)

      a :: INT

      do a = 1,.dim
         res(a) = self(a).ADP_principal_axis_ratio
      end

   end

   ADP_type(refine_H_U_iso) result (res) ::: PURE 
   ! Return whether the atom is refined "Uani" or "Uiso"
      self :: IN
      refine_H_U_iso :: BIN, IN
      res :: VEC{STR}(.dim)

      a :: INT

      if (NOT refine_H_U_iso OR all(self(:).atomic_number>1)) then

         res = "Uani"

      else

         do a = 1,.dim
            if (self(a).atomic_number>1) then; res(a) = "Uani"
            else;                              res(a) = "Uiso"
            end
         end

      end

   end

!  ================
!  Bases and labels
!  ================

   has_unique_labels result (has) ::: PURE
   ! Return TRUE if all non-dummy atoms have unique labels.
   ! A dummy atom has zero charge, no basis and a dummy-type label.
      self :: IN
      has :: BIN


      unique_labels,unique_x_kind :: BIN
      dum :: VEC{INT}*
      n :: INT

      n = .no_of_nondummy_atoms

      if (n==0) then

         has = TRUE

      else

         dum.create(n)
         dum = .nondummy_atoms
         unique_labels = NOT self(dum).label.has_repetitions
         unique_x_kind =     self(dum).has_unique_xtal_kinds
         has = unique_labels AND unique_x_kind
         dum.destroy

      end

   end

   get_1st_repeated_labels(li,lj) ::: PURE
   ! Return the indices of the first repeated labels
   ! in "li" and "lj".
      self :: IN
      li,lj :: INT, OUT

      dum :: VEC{INT}*
      n :: INT

      n = .no_of_nondummy_atoms

      if (n==0) then

         li = 0
         lj = 0

      else

         dum.create(n)
         dum = .nondummy_atoms
         self(dum).label.get_1st_repetition(li,lj)
         dum.destroy

      end

   end

   has_unique_tags result (has) ::: PURE
   ! Return TRUE if all non-dummy atoms have unique tags.
   ! A dummy atom has zero charge, no basis and a dummy-type label.
      self :: IN
      has :: BIN

      dum :: VEC{INT}*
      n :: INT

      n = .no_of_nondummy_atoms

      if (.no_of_nondummy_atoms==0) then

         has = TRUE

      else

         dum.create(n)
         dum = .nondummy_atoms
         has = NOT self(dum).tag.has_repetitions AND NOT any(self(dum).tag==" ")
         dum.destroy

      end

   end

   has_unique_kinds result (has) ::: pure
   ! Return TRUE if all atoms have unique kinds
      self :: IN
      has :: BIN

      has = NOT self(:).kind.has_repetitions

   end

   has_unique_xtal_kinds result (unq) ::: pure
   ! Return TRUE if all atoms have unique *xtal* kinds
      self :: IN
      unq :: BIN

      a,b :: INT

      unq = TRUE

      do a = 2,.dim
      do b = 1,a-1

         if (NOT self(a).is_xtal_identical_to(self(b))) cycle

         unq = FALSE
         return

      end
      end

   end

   get_1st_repeated_xtal_kinds(ka,kb) ::: pure
   ! Return the indices of the first repeated xtal kinds
   ! in "ka" and "kb".
      self :: IN
      ka,kb :: INT, OUT

      a,b :: INT

      ka = 0
      kb = 0

      do a = 2,.dim
      do b = 1,a-1

         if (NOT self(a).is_xtal_identical_to(self(b))) cycle

         ka = a
         kb = b
         return

      end
      end

   end

   has_all_bases result (has) ::: pure
   ! Return TRUE if all atoms have a basis on one kind or another.
      self :: IN
      has :: BIN

      has = .has_all_gaussian_bases OR .has_all_slater_bases OR .has_all_coppens_bases

   end

   has_all_gaussian_bases result (has) ::: pure
   ! Return TRUE if all atom gaussian basis data exists
      self :: IN
      has :: BIN

      a :: INT

      has = TRUE
      do a = 1,.dim
         has = self(a).basis.associated
         if (NOT has) exit
      end

   end

   has_all_slater_bases result (has) ::: pure
   ! Return TRUE if all atom slater basis data exists
      self :: IN
      has :: BIN

      a :: INT

      has = TRUE
      do a = 1,.dim
         has = self(a).slaterbasis.associated
         if (NOT has) exit
      end

   end

   has_all_coppens_bases result (has) ::: pure
   ! Return TRUE if all atom slater basis data exists
      self :: IN
      has :: BIN

      a :: INT

      has = TRUE
      do a = 1,.dim
         has = self(a).coppensbasis.associated
         if (NOT has) exit
      end

   end

   has_all_density_data result(has) ::: pure
   ! Return TRUE if all atoms have some kind of atom density data, either
   ! slaterbasis, coppensbasis or gausian ANO data. This routine does NOT check
   ! that they are all the same kind of data!
      self :: IN
      has :: BIN

      has = .has_all_slater_bases OR .has_all_coppens_bases OR .has_all_ANOs_made

   end

   has_all_shell_info result (res) ::: PURE
   ! Return TRUE if all shell info is there for every atom.
      self :: IN
      res :: BIN

      res = all(self(:).shell_info_made)

   end


   minimum_basis_exponents result (res) ::: PURE
   ! Return the minimum exponent in the basis.
      self :: IN
      res :: VEC{REAL}(.dim)

      i :: INT

      do i = 1,.dim
         res(i) = self(i).minimum_basis_exponent
      end

   end


   tag_xyz_basis_fn_part result (res) ::: PURE
   ! Return a character representation for the cartesian product part
   ! of the gaussians in this shell.
      self :: IN
      res :: VEC{STR}(.no_of_basis_functions)

      a,i,f,l, width,spaces :: INT
      labels :: VEC{STR}@

      l = 0

      do a = 1,.dim

         f = l + 1
         l = l + self(a).basis.no_of_basis_functions

         labels = self(a).basis.xyz_basis_fn_part
         width  = maxval(len_trim(labels)) + 1
         do i = f,l
            spaces = width - len_trim(labels(i-f+1))
            res(i) = trim(self(a).tag) // repeat(" ",spaces) // trim(labels(i-f+1))
         end

      end

   end

   basis_labels result (labels) ::: leaky
   ! Return a list of basis set "labels". Missing labels are returned blank.
      self :: IN
      labels :: VEC{STR}*

      i :: INT

      labels.create(size(self))

      do i = 1,.dim
         if (self(i).basis_label/=" ") then; labels(i) = self(i).basis_label
         else;                               labels(i) = " "
         end
      end

   end

   library_basis_labels(suffix) result (labels) ::: leaky
   ! Return a list of library basis set labels, the atoms element name with
   ! ":suffix" appended to it. Only a unique list of basis labels is returned.
      suffix :: STR
      labels :: VEC{STR}*
      i :: INT
      labels.create(.dim)
      do i = 1,.dim
         labels(i) = self(i).library_basis_label(suffix)
      end
      labels.remove_repetitions
   end

   library_basis_labels(Z_max,suffix) result (labels) ::: selfless, leaky
   ! Return a list of library basis set labels, for the atoms with
   ! atomic numbers up to "Z_max", with ":suffix" appended to it. Only
   ! a unique list of basis labels is returned.
      Z_max :: INT
      suffix :: STR
      labels :: VEC{STR}*
      Z :: INT
      labels.create(Z_max)
      do Z = 1,Z_max
         labels(Z) = ATOM:library_basis_label(Z,suffix)
      end
   end

!  ======================
!  ANOs and interpolators
!  ======================

   has_all_NAOs_made result (res) ::: pure
   ! Return TRUE if the NAO data is made for every atom.
      self :: IN
      res :: BIN

      res = all(self(:).NAOs_made)

   end

   has_all_ANOs_made result (res) ::: pure
   ! Return TRUE if the ANO data is made for every atom.
      self :: IN
      res :: BIN

      res = all(self(:).ANOs_made)

   end

   has_all_NAO_matrices result (res) ::: pure
   ! Return TRUE if the NAOs are made for every atom.
      self :: IN
      res :: BIN

      a :: INT

      res = TRUE
      do a = 1,.dim
         res = self(a).has_NAO_matrices
         if (NOT res) exit
      end

   end

   has_all_ANO_matrices result (res) ::: pure
   ! Return TRUE if the ANOs are made for every atom.
      self :: IN
      res :: BIN

      a :: INT

      res = TRUE
      do a = 1,.dim
         res = self(a).has_ANO_matrices
         if (NOT res) exit
      end

   end

   has_all_spherical_atom_data result (res) ::: pure
   ! Return TRUE if the per-atom interpolators are made for every atom.
      self :: IN
      res :: BIN

      res = all(self(:).spherical_atom_data_made)

   end

!  =============
!  Interpolators
!  =============

   has_all_ANO_interpolators result (res) ::: pure
   ! Return TRUE if the ANO interpolators are made for every atom.
      self :: IN
      res :: BIN

      res = all(self(:).ANO_interpolators_made)

   end

   has_all_slater_interpolators result(has) ::: pure
   ! Return TRUE if all atoms have slaterbases which have interpolators.
      self :: IN
      has :: BIN

      a :: INT

      has = TRUE

      do a = 1,.dim

         has = self(a).slaterbasis.associated
         if (NOT has) exit

         has = self(a).slaterbasis.interpolator.associated
         if (NOT has) exit

      end

   end

   has_all_coppens_interpolators result(has) ::: pure
   ! Return TRUE if all atoms have coppensbases which have interpolators.
      self :: IN
      has :: BIN

      a :: INT

      has = TRUE
      do a = 1,.dim

         has = self(a).coppensbasis.associated
         if (NOT has) exit

         has = self(a).coppensbasis.interpolator.associated
         if (NOT has) exit

      end

   end

   has_all_interpolators result (res) ::: pure
   ! Return TRUE if the per-atom interpolators are made for every atom.
      self :: IN
      res :: BIN

      res = all(self(:).interpolators_made)

   end

   has_interpolators_any_kind result(has) ::: pure
   ! Return TRUE if all atoms have slaterbases which have interpolators, or all
   ! atoms have coppensbases with interpolators.
      self :: IN
      has :: BIN

      has = .has_all_atom_interpolators   &
         OR .has_all_slater_interpolators &
         OR .has_all_coppens_interpolators

   end

   has_all_atom_interpolators result(has) ::: pure
   ! Return TRUE if all atoms have interpolators.
      self :: IN
      has :: BIN

      a :: INT

      has = TRUE

      do a = 1,.dim

         has = self(a).interpolator.associated
         if (NOT has) exit

      end

   end

   max_interpolator_table_length(tol) result (res)
   ! Returns the maximum interpolator table length for a given table cutoff
   ! tolerance "tol".  This table length is used for setting the cluster radius,
   ! for calculations where the cluster size must be determined so that the
   ! Hirshfeld surface is accurate.
      self :: IN
      tol :: REAL, IN
      res :: REAL

   ENSURE(self(1).basis_kind.is_one_of(["slater  ","coppens ","gaussian"]),"unknown basis_kind")

      last :: REAL
      i :: INT

      res = ZERO

      select case (self(1).basis_kind)

      case ("slater")
         ENSURE(.has_all_slater_bases,"missing slater bases")
         do i = 1,.dim
            last = self(i).slaterbasis.interpolator_table_length(tol)
            res  = max(res,last)
         end

      case ("coppens")
         ENSURE(.has_all_coppens_bases,"missing coppens bases")
         do i = 1,.dim
            last = self(i).coppensbasis.interpolator_table_length(tol)
            res  = max(res,last)
         end

      case ("gaussian")
         ENSURE(.has_all_ANOs_made,"missing atom ANOs")
         do i = 1,.dim
            last = self(i).interpolator_table_length(tol)
            res  = max(res,last)
         end

      end

   end

!  =================
!  Axes and disorder
!  =================

   has_cartesian_axes result (res) ::: pure
   ! Return TRUE if all atom pisitions *and* ADP (thermal) tensors are
   ! in the cartesian axis system.
      self :: IN
      res :: BIN

      pos,ADP :: BIN
      a :: INT

      res = TRUE

      do a = 1,.dim

         pos = self(a).pos_axis_system=="cartesian"
         ADP = self(a).ADP_axis_system=="cartesian"
         res = pos AND ADP

         if (self(a).has_ADP3s) res = res AND self(a).ADPn_axis_system=="cartesian"
         if (self(a).has_ADP4s) res = res AND self(a).ADPn_axis_system=="cartesian"

         if (NOT res) exit

      end

   end

   has_cartesian_ADP_axes result (res) ::: pure
   ! Return TRUE if all atom ADP (thermal) tensors are in the
   ! cartesian axis system.
      self :: IN
      res :: BIN

      a :: INT

      res = TRUE
      do a = 1,.dim
         res = self(a).ADP_axis_system=="cartesian"
         if (NOT res) exit
      end

   end

   has_crystal_ADP_axes result(has) ::: pure
   ! Return TRUE if all atom ADP (thermal) tensors are in the crystal axis system.
      self :: IN
      has :: BIN

      a :: INT

      has = TRUE
      do a = 1,.dim
         has = self(a).ADP_axis_system=="crystal"
         if (NOT has) exit
      end

   end

   has_disorder result (has) ::: pure
   ! Return TRUE if any atom has disorder i.e. an occupancy which is not one.
      self :: IN
      has :: BIN

      has = NOT self(:).site_occupancy.has_all_equal_to(ONE)

   end

   atom_index_from_position(pos) result (res) ::: PURE
   ! Return the index of atom from its position "pos"
      self :: IN
      pos :: VEC{REAL}(3), IN
      res :: INT

      a :: INT
      found :: BIN

      found = FALSE
      do a = 1,.dim
         found = pos.same_as(self(a).position)
         if (found) exit
      end
      res = a

      ENSURE(found,"no atom for this position")

   end

!  =====
!  Radii
!  =====

   covalent_radii_ccdc result (res) ::: PURE
   ! Returns the CCDC covalent radius for this atom
      self :: IN
      res :: VEC{REAL}(.dim)

      a :: INT

      do a = 1,.dim
         res(a) = self(a).covalent_radius_ccdc
      end

   end

   vdw_radii_ccdc result (res) ::: PUFRE
   ! Returns the CCDC vdw radius for this atom
      self :: IN
      res :: VEC{REAL}(.dim)

      a :: INT

      do a = 1,.dim
         res(a) = self(a).vdw_radius_ccdc
      end

   end

   get_covalent_radii_ccdc(radii) ::: PURE
   ! Returns the CCDC covalent radius for this atom
      self :: IN
      radii :: VEC{REAL}(.dim), OUT

      a :: INT

      do a = 1,.dim
         radii(a) = self(a).covalent_radius_ccdc
      end

   end

   get_vdw_radii_ccdc(radii) ::: pure
   ! Returns the CCDC vdw radius for this atom
      self :: IN
      radii :: VEC{REAL}(.dim), OUT

      a :: INT

      do a = 1,.dim
         radii(a) = self(a).vdw_radius_ccdc
      end

   end

!  =======================
!  Spackman's coefficients
!  =======================

   get_Spackman86_a_coeffs_in(coeff) ::: pure
   ! Returns the GKR a-coefficients
      self :: IN
      coeff :: VEC{REAL}, OUT

      i :: INT

      do i = 1,.dim
         coeff(i) = ATOM::Spackman86_a_6_dispersion_coeff(self(i))
      end

   end

   get_Spackman86_b_coeffs_in(coeff) ::: pure
   ! Returns the GKR a-coefficients
      self :: IN
      coeff :: VEC{REAL}, OUT

      i :: INT

      do i = 1,.dim
         coeff(i) = ATOM::Spackman86_b_repulsion_coeff(self(i))
      end

   end

   get_Spackman86_c_coeffs_in(coeff) ::: pure
   ! Returns the GKR a-coefficients
      self :: IN
      coeff :: VEC{REAL}, OUT

      i :: INT

      do i = 1,.dim
         coeff(i) = ATOM::Spackman86_c_repulsion_coeff(self(i))
      end

   end

!  =====================
!  Grimme's coefficients
!  =====================

   get_Grimme06_a_coeffs_in(coeff) ::: pure
   ! Returns the Grimme a-coefficients
      self :: IN
      coeff :: VEC{REAL}, OUT

      i :: INT

      do i = 1,.dim
         coeff(i) = ATOM::Grimme06_a_6_dispersion_coeff(self(i))
      end

   end

   get_Grimme06_r_coeffs_in(coeff) ::: pure
   ! Returns the Grimme a-coefficients
      self :: IN
      coeff :: VEC{REAL}, OUT

      i :: INT

      do i = 1,.dim
         coeff(i) = ATOM::Grimme06_r_0_dispersion_coeff(self(i))
      end

   end


!  ================================
!  Moments, fields, field gradients
!  ================================

   nuclear_dipole_moment result (res)
   ! Return the dipole moment obtained from the atomic numbers.
   ! Dummy nuclear charges are not included
      res :: VEC{REAL}(3)
      a :: INT
      res = ZERO
      do a = 1,.dim
         res = res + self(a).atomic_number*self(a).position
      end
   end

   nuclear_quadrupole_moment result (res)
   ! Return the quadrupole moment obtained from the nuclear charges
   ! as a vector, in the order: xx, yy, zz, xy, xz, yz
   ! Dummy nuclear charges are not included
      self :: IN
      res :: VEC{REAL}(6)

      Z :: REAL
      a :: INT

      res = ZERO
      do a = 1,.dim
         Z = self(a).atomic_number
         res(1) = res(1) + Z * self(a).position(1) * self(a).position(1)
         res(2) = res(2) + Z * self(a).position(2) * self(a).position(2)
         res(3) = res(3) + Z * self(a).position(3) * self(a).position(3)
         res(4) = res(4) + Z * self(a).position(1) * self(a).position(2)
         res(5) = res(5) + Z * self(a).position(1) * self(a).position(3)
         res(6) = res(6) + Z * self(a).position(2) * self(a).position(3)
      end

   end

   nuclear_octupole_moment result (res)
   ! Return the octupole moment obtained from the nuclear charges as a vector,
   ! in the order: xxx, yyy, zzz, xxy, xxz, yyx, yyz, zzx, zzy, xyz
   ! Dummy nuclear charges are not included
      res :: VEC{REAL}(10)
      Z :: REAL
      a :: INT
      res = ZERO
      do a = 1,.dim
         Z = self(a).atomic_number
         res(1)  = res(1)  + Z * self(a).position(1) * self(a).position(1) * self(a).position(1)
         res(2)  = res(2)  + Z * self(a).position(2) * self(a).position(2) * self(a).position(2)
         res(3)  = res(3)  + Z * self(a).position(3) * self(a).position(3) * self(a).position(3)
         res(4)  = res(4)  + Z * self(a).position(1) * self(a).position(1) * self(a).position(2)
         res(5)  = res(5)  + Z * self(a).position(1) * self(a).position(1) * self(a).position(3)
         res(6)  = res(6)  + Z * self(a).position(2) * self(a).position(2) * self(a).position(1)
         res(7)  = res(7)  + Z * self(a).position(2) * self(a).position(2) * self(a).position(3)
         res(8)  = res(8)  + Z * self(a).position(3) * self(a).position(3) * self(a).position(1)
         res(9)  = res(9)  + Z * self(a).position(3) * self(a).position(3) * self(a).position(2)
         res(10) = res(10) + Z * self(a).position(1) * self(a).position(2) * self(a).position(3)
      end
   end

   nuclear_E_field_at_positions(pos) result (res)
   ! Return the nuclear contribution to the electric fields
   ! at the nuclei as a (3 x .dim) array
      pos :: MAT{REAL}, IN
      res :: MAT{REAL}(3,pos.dim2)
      Z,r :: REAL
      a,b :: INT
      ab :: VEC{REAL}(3)
      res = ZERO

      do a = 1,pos.dim2
         do b = 1,.dim
            Z  = self(b).nuclear_charge
            ab = pos(:,a) - self(b).position
            r  = ab.norm
            res(:,a) = res(:,a) + Z*ab/(r*r*r)
         end
      end
   end

   nuclear_E_field_at_nuclei result (res)
   ! Return the nuclear contribution to the electric fields
   ! at the nuclei as a (3 x .dim) array
      res :: MAT{REAL}(3,size(self))
      Z,r :: REAL
      a,b :: INT
      ab :: VEC{REAL}(3)
      res = ZERO
      do a = 1,.dim
         do b = 1,.dim
            if (b==a) cycle
            Z  = self(b).nuclear_charge
            ab = self(a).position - self(b).position
            r  = ab.norm
            res(:,a) = res(:,a) + Z*ab/(r*r*r)
         end
      end
   end

   nuclear_EFG_at_nuclei result (res)
   ! Return the nuclear contribution to the electric fields gradient
   ! (EFG) at the nuclei as a (6 x .dim) array
      res :: MAT{REAL}(6,size(self))
      Z,r,r3,r5 :: REAL
      a,b :: INT
      ab :: VEC{REAL}(3)
      res = ZERO
      do a = 1,.dim
         do b = 1,.dim
            if (b==a) cycle
            Z  = self(b).nuclear_charge
            ab = self(a).position - self(b).position
            r  = ab.norm
            r3 = r*r*r
            r5 = r3*r*r
            res(1,a) = res(1,a) - Z * (THREE*ab(1)*ab(1)/r5 - ONE/r3)
            res(2,a) = res(2,a) - Z * (THREE*ab(2)*ab(2)/r5 - ONE/r3)
            res(3,a) = res(3,a) - Z * (THREE*ab(3)*ab(3)/r5 - ONE/r3)
            res(4,a) = res(4,a) - Z * (THREE*ab(1)*ab(2)/r5)
            res(5,a) = res(5,a) - Z * (THREE*ab(1)*ab(3)/r5)
            res(6,a) = res(6,a) - Z * (THREE*ab(2)*ab(3)/r5)
         end
      end
   end

!  ========================
!  Atom kinds, unique atoms
!  ========================

   same_kind_of_atoms(a,b) result (res) ::: pure
   ! Return true if atoms "a" and "b" are the same kind
   ! . They are the same kind if they have the same kind of basis
   !   and same atomic number.
   ! . This is used for ANO or other QM type calculations.
      self :: IN
      a,b :: INT, IN
      res :: BIN

      res = self(a).is_same_kind_as(self(b))

   end

   make_atom_Z_list(Z_list) ::: leaky, PURE
   ! Make the atom Z list ... Z_list(k).element(c) is the c-th atom of
   ! the same atomic number (atomic numbers in decreasing order).
      self :: IN
      Z_list :: VEC{VEC_{INT}}*

      n_kind, n,k,Z_n :: INT
      Z,unique_Z :: VEC{INT}*

      ! Atomic numbers
      Z.create(.dim)
      Z = self(:).atomic_number

      ! Sorted unique atomic numvers
      unique_Z.to_unique_elements_of(Z)
      unique_Z.quick_sort(decreasing_order=TRUE)

      ! Assign each atom to its kind in
      ! decreasing order
      n_kind = unique_Z.dim
      Z_list.create(n_kind,0)
      do n = 1,.dim
         Z_n = self(n).atomic_number
         do k = 1,n_kind
            if (Z_n==unique_Z(k)) then
                Z_list(k).element.append(n)
                exit
            end
         end
      end

      ! Clean up
      unique_Z.destroy
      Z.destroy

   end

   make_atom_kind_list(atom_kind,n_kind) ::: PURE
   ! Make the atom=kind list ... atom_kind(k) is the kind index of
   ! the k-th atom, as determined by .same_kind_of_atoms(k,l)
      self :: IN
      atom_kind :: VEC{INT}, OUT
      n_kind :: INT, OUT

   ENSURE(atom_kind.dim==.dim,"atom_kind is incorrectly dimensioned")

      n_atom,n,k,l :: INT

      n_atom = .dim
      atom_kind = [ (n, n=1,n_atom) ]

      k = 0
      do n = 1,n_atom

         ! Found kind for atom n?
         if (atom_kind(n)<=k) cycle

         ! Set kind
         k = k + 1
         atom_kind(n) = k

         ! Set non-unique kinds
         do l = n+1,n_atom

            if (atom_kind(l)<=k) cycle
            if (NOT .same_kind_of_atoms(l,n)) cycle

            atom_kind(l) = k

         end

      end

      n_kind = k

   end

   make_unique_atom_list(unique_atom) ::: PURE
   ! "unique_atom(k)" is the index of the first atom which represents
   ! all the the atoms which are of the same kind, k. This requires
   ! "is_unique_kind" to have been made via "set_kinds".
      self :: IN
      unique_atom :: VEC{INT}, OUT

   ENSURE(unique_atom.dim==maxval(self(:).kind),"unique atom incorrectly dimensioned")

      n_kind,k,n :: INT

      n_kind = maxval(self(:).kind)

      ! Make the list
      k = 0
      do n = 1,.dim
         if (NOT self(n).is_unique_kind) cycle
         k = k + 1
         unique_atom(k) = n
      end

   end

   are_distinct(a,b) result (res) ::: pure
   ! Return true if atoms "a" and "b" are crystallographically
   ! distinct based on occupancy and atomic number
      self :: IN
      a,b :: INT, IN
      res :: BIN

      res = self(a).atomic_number      /=self(b).atomic_number       &
        OR  self(a).site_disorder_group/=self(b).site_disorder_group &
        OR NOT self(a).site_occupancy.equals(self(b).site_occupancy)

   end

!  ===========
!  Atom groups
!  ===========

   has_site_groups result (res) ::: pure
   ! Return TRUE if any crstal site dirder groups have been defined
      self :: IN
      res :: BIN

      if (any(self(:).site_disorder_group>0)) then; res = TRUE
      else;                                         res = FALSE
      end

   end

   has_groups result (res) ::: pure
   ! Return TRUE if any atom groups have been defined
   ! This only counts if there is more than one group!
      self :: IN
      res :: BIN

      if (any(self(:).group>1)) then; res = TRUE
      else;                           res = FALSE
      end

   end

   no_of_groups result (res) ::: pure
   ! Return the number of groups
      self :: IN
      res :: INT

      res = maxval(self(:).group)

   end

   set_connected_groups ::: PURE
   ! Search through the list of atoms as assigns each atom the same
   ! group number if the atom is a part of the same connected
   ! molecule.
      self :: INOUT

      atoms_bonded_to_atom :: VEC{VEC_{INT}}*
      group_for :: VEC{INT}*
      a,b,c,n, ga,gb :: INT

      ! Can only proceed in cartesian axes
      if (NOT all(ATOM:is_in_cartesian_system(self))) return

      ! Make the bond list
      .make_connection_table(atoms_bonded_to_atom)

      ! List of groups
      group_for.create(.dim)
      group_for = 0

      ! Loop over atoms
      do a = 1,.dim

         ! Get group for a
         ga = group_for(a)
         if (ga==0) then ! next group
            ga = maxval(group_for) + 1
            group_for(a) = ga
         end

         ! Loop over bonded atoms
         n = atoms_bonded_to_atom(a).element.dim
         do c = 1,n

            b  = atoms_bonded_to_atom(a)[c]
            gb = group_for(b)

            if (gb==0) then
               group_for(b) = ga
            else if (gb>ga) then
               where (group_for==gb) group_for = ga
            else if (gb<ga) then
               where (group_for==ga) group_for = gb
               ga = gb ! NOTE
            end

         end

      end

      ! Assign
      self(:).group = group_for

      ! Clean
      group_for.destroy
      !atoms_bonded_to_atom.destroy

   end

   make_atom_group_list(atom_group) ::: leaky
   ! This routine finds all the atoms in the same group and makes
   ! their indices as a atom_group of integers. The result is a
   ! "atom_group" of atom_group of integers. NOTE that "atom_group" is
   ! created.
      atom_group :: VEC{VEC_{INT}}*

      n_group,g,n,i :: INT
      group_indices :: VEC{INT}*

      ! Extract the group indices
      group_indices.create(.dim)
      group_indices = self.group
      n_group = group_indices.no_of_unique_elements

      ! Create the atom_group list of indices
      atom_group.create(n_group)

      ! All atoms in one group, size .dim
      if (n_group==1) then
         atom_group(1).element.create(.dim)
         atom_group(1).element = [ (i, i=1,.dim) ]
      ! Atoms in different groups, size n_group
      else
        do g = 1,n_group
           n = count(group_indices==g)
           DIE_IF(n==0,"group indices are not sequential!")
           atom_group(g).element.create(n)
           atom_group(g).element = pack( [ (i, i=1,.dim) ], group_indices==g)
        end
      end

      ! Clean
      group_indices.destroy

   end

   set_group_to(g)
   ! Set the atom "group" index to "g".
      self :: INOUT
      g :: INT, IN

      a :: INT

      do a = 1,.dim
         self(a).group = g
      end

   end

!  =========================
!  Shell information methods
!  =========================

   make_shell_limits(first,last,momentum) ::: leaky, PURE
   ! Get the shell function limit vectors "first" and "last" for
   ! corresponding to the concatenated vector of atomvec shells. Also
   ! get the angular "momentum" for the shell.
      self :: IN
      first,last,momentum :: VEC{INT}*, OUT

      n_shell, a,as,n,ss,f,l :: INT

      n_shell = .no_of_shells
      first.create(n_shell)
      last.create(n_shell)
      momentum.create(n_shell)

      ss = 0
      l  = 0

      do a = 1,.dim

         n = self(a).basis.shell.dim

         do as = 1,n
            ss = ss + 1
            f = l + 1
            l = f + self(a).basis.shell(as).n_bf - 1
            first(ss) = f
            last(ss)  = l
            momentum(ss) = self(a).basis.shell(as).l
         end

      end

   end

   make_atom_basis_fn_limits(first,last) ::: leaky, PURE
   ! Get the first and last basis functions for the atoms
      self :: IN
      first,last :: VEC{INT}*, OUT

      a,as,n,l :: INT

      first.create(.dim)
      last.create(.dim)

      l = 0
      do a = 1,.dim
         n = self(a).basis.shell.dim
         first(a) = l + 1
         do as = 1,n
            l = l + self(a).basis.shell(as).n_bf
         end
         last(a) = l
      end

   end

   make_primitive_limits(frst,last,atom,lmom,expo) ::: leaky, PURE
   ! Get the primitive function limit vectors "frst" and "last" and
   ! other data pertaining to the primitive function corresponding to
   ! the concatenated bases of all the atoms.
      self :: IN
      frst,last,atom,lmom :: VEC{INT}*, OUT
      expo :: VEC{REAL}*, OUT

      nps,a,as,ap,p,f,l :: INT

      nps = .no_of_primitive_shells

      frst.create(nps)
      last.create(nps)
      atom.create(nps)
      lmom.create(nps)
      expo.create(nps)

      p = 0
      l = 0

      do a = 1,.dim

         do as = 1,self(a).basis.shell.dim

            do ap = 1,self(a).basis.shell(as).n_cc

               p = p + 1
               f = l + 1
               l = l + self(a).basis.shell(as).n_bf

               frst(p) = f
               last(p) = l
               atom(p) = a
               lmom(p) = self(a).basis.shell(as).l
               expo(p) = self(a).basis.shell(as).exponent(ap)

            end

         end

      end

   end

!  ==============================
!  Atom-shell information methods
!  ==============================

   atom_for_shell(s) result (a) ::: pure
   ! Return the *atom* number "a" corresponding to the
   ! flattened shell number "s"
      self :: IN
      s :: INT, IN
      a :: INT

      ss,n :: INT

      ss = 0
      do a = 1,.dim
         n = self(a).basis.shell.dim
         ss = ss + n
         if (s<=ss) exit
      end

   end

   atom_for_shell result (res) ::: leaky, PURE
   ! Return a vector of *atom* numbers corresponding to the
   ! flattened shell numbers
      self :: IN
      res :: VEC{INT}*

      a,ss,n :: INT

      res.create(.no_of_shells)

      ss = 0
      do a = 1,.dim
         n = self(a).basis.shell.dim
         res(ss+1:ss+n) = a
         ss = ss + n
      end

   end

   atom_shell_for_shell(s) result (as) ::: pure
   ! Return the *atom* shell number "as" corresponding to the
   ! flattened shell number "s"
      self :: IN
      s :: INT, IN
      as :: INT

      a,ss,n :: INT

      n = 0
      ss = 0
      do a = 1,.dim
         n = self(a).basis.shell.dim
         ss = ss + n
         if (s<=ss) exit
      end

      as = s - ss + n

   end

   atom_shell_for_shell result (res) ::: leaky, PURE
   ! Return a vector of *atom* shell numbers corresponding to the
   ! flattened shell vector
      self :: IN
      res :: VEC{INT}*

      a,ss,n,as :: INT

      res.create(.no_of_shells)

      ss = 0
      do a = 1,.dim
         n = self(a).basis.shell.dim
         do as = 1,n
            res(ss+as) = as
         end
         ss = ss + n
      end

   end

   first_shell_for_atom(a) result (res) ::: pure
   ! Return the index of the first shell for atom "a"
      self :: IN
      a :: INT, IN
      res :: INT

      at,n :: INT

      res = 1
      do at = 1,(a-1)
         n = self(a).basis.shell.dim
         res = res + n
      end

   end

   make_shell_for_atom_limits(first,last) ::: pure
   ! Return the indices of the first and last shell for each atom
      self :: IN
      first,last :: VEC{INT}, OUT

      ss,a,n :: INT

      ss = 0
      do a = 1,.dim
         first(a) = ss + 1
         n = self(a).basis.shell.dim
         ss = ss + n
         last(a) = ss
      end

   end

   first_shell_for_atom result (res) ::: leaky, PURE
   ! Return the indices of the first shell for each atom
      self :: IN
      res :: VEC{INT}*

      ss,a,n :: INT

      res.create(.dim)

      ss = 0
      do a = 1,.dim
         n = self(a).basis.shell.dim
         res(a) = ss + 1
         ss = ss + n
      end

   end

!  ===============
!  Invariom labels
!  ===============

   neighbours_of(a,range_factor) result (res) ::: leaky
   ! Return the list of atoms bonded to atom "a".
      self :: IN
      a :: INT, IN
      range_factor :: REAL, optional, IN
      res :: VEC{INT}*

      b :: INT

      nullify(res)
      do b = 1,.dim
         if (b==a) cycle
         if (NOT .bonded(a,b,range_factor)) cycle
         res.append(b)
      end

   end

   is_next_neighbour_chiral(a) result (res) ::: leaky
   ! Return TRUE if there are four next nearest neighbours for the
   ! atom "a", and if they are all different.
      a :: INT
      res :: BIN
      neighbour :: VEC{INT}*
      Z :: VEC{INT}(4)
      neighbour => .neighbours_of(a)
      if (neighbour.disassociated) then
         res = FALSE
      else if (neighbour.dim==4) then
         Z = self(neighbour).atomic_number
         res = NOT Z.has_repetitions
      else
         res = FALSE
      end
      neighbour.destroy
   end

   next_neighbour_handedness_of(a) result (res) ::: leaky
   ! Return the handedness of the atom "a" based only on the four
   ! connecting atoms around it.
      a :: INT
      res :: STR
      n :: INT
      p2,p3,p4,pc :: VEC{REAL}(3)
      Z,order :: VEC{INT}(4)
      neighbour :: VEC{INT}*

      neighbour => .neighbours_of(a)
      DIE_IF(neighbour.disassociated,"there are no neighbours")
      n = neighbour.dim
      DIE_IF(neighbour.dim/=4,"must have four neighbours, n = "//trim(n.to_str))
    ! stdout.show("neighbours =",neighbour)

      Z = self(neighbour).atomic_number
      Z.quick_sort(order)
      neighbour = neighbour(order)
    ! stdout.show("sorted neighbours =",neighbour)

      p2 = self(neighbour(2)).position - self(a).position
      p3 = self(neighbour(3)).position - self(a).position
      p4 = self(neighbour(4)).position - self(a).position
      pc = p4.cross(p3)
      if (p2.dot(pc)>ZERO) then; res = "R"
      else;                      res = "S"
      end

      neighbour.destroy

   end


   invariom_labels result (res) ::: leaky
   ! Return the invariom label for the atom "a"
      res :: VEC{STR}*
      a :: INT
      res.create(.dim)
      do a = 1,.dim
         res(a) = .invariom_label_of(a)
      end
   end

   invariom_label_of(a) result (res)
   ! Return the invariom label for the atom "a"
      a :: INT
      res :: STR

      special_Z :: VEC{INT}(3) = [1,15,16]
      i,j,n,m,f2,l2,p :: INT
      Z,bond,order,neighbour,Z2,bond2,order2,neighbour2 :: VEC{INT}*
      bonds,bonds2,mesomer,ZZ :: VEC{STR}*
      special,do_2nd_neighbour :: BIN
      symbol :: STR

      ! Start with the R or S symbol, if the atom is chiral
      if (.is_next_neighbour_chiral(a)) then; res = trim(.next_neighbour_handedness_of(a))//"-"
      else;                                   res = " "
      end

      ! Start with "a" atoms chemical symbol
      res = trim(res)//self(a).chemical_symbol

      ! Get indices of the nearest neighbours; return if no neighbours
      neighbour => .neighbours_of(a)
      if (neighbour.disassociated) return
      neighbour.prune(a)
      if (neighbour.dim==0) return

      ! Create arrays to store the bond order (times 10) and string
      ! form of bond order
      n = neighbour.dim
      bond.create(n)
      bonds.create(n)

      ! Get the atomic numbers Z of neighbors and order them in
      ! decreasing bond-order/atomic number
      Z.create(n)
      order.create(n)
      Z = self(neighbour).atomic_number
      .allred_rochow_bond_orders(a,neighbour,bond,bonds)
      Z = 1000*bond + Z
      Z.quick_sort(order,decreasing_order=TRUE)
      neighbour = neighbour(order)
      bond  = bond(order)
      bonds = bonds(order)
      order.destroy; Z.destroy

      ! If special Z atoms switch on next nearest neighbour
      f2 = 0
      special = FALSE

      if (any(special_Z==self(a).atomic_number)) then
         f2 = 1
         l2 = bond.dim
         special = TRUE

      ! Find out how many mesomeric bonds there are
      else
         f2 = bond.index_of_value(15)
         l2 = 0
         if (f2>0) then
            if      (f2==bond.dim) then;       l2 = f2
            else if (bond(bond.dim)==15) then; l2 = bond.dim
            else;                              l2 = bond(f2+1:).index_of_value_ne_to(15)
                                               l2 = f2 + l2 - 1
            end
         end
      end

      do_2nd_neighbour = f2>0 AND l2>=f2

      nullify(mesomer)

      ! If we should do second nearest neighbours ...
      if (do_2nd_neighbour) then

         mesomer.create(f2,l2); mesomer = " "
         ZZ.create(f2,l2);      ZZ = "0"

         ! Loop over second nearest neighbour atoms or mesomeric atoms
         do i = f2,l2

            ! Get indices of the 2nd nearest neighbours; return if no neighbours
            neighbour2 => .neighbours_of(neighbour(i))
            DIE_IF(neighbour2.disassociated,"mesomeric atom has no neighbours")

            ! We don't want the original first neighbour
            neighbour2.prune(a)
            if (neighbour2.dim==0) then
               neighbour2.destroy
               cycle
            end

            ! Order the 2nd nearest neighbours in decreasing bond-order/atomic number
            m = neighbour2.dim
            bond2.create(m)
            bonds2.create(m)
            Z2.create(m)
            order2.create(m)
            Z2 = self(neighbour2).atomic_number
            .allred_rochow_bond_orders(neighbour(i),neighbour2,bond2,bonds2)
            Z2 = 1000*bond2 + Z2
            Z2.quick_sort(order2,decreasing_order=TRUE)
            neighbour2 = neighbour2(order2)
            Z2 = Z2(order2)
            bond2 = bond2(order2)
            bonds2 = bonds2(order2)

           ! Make and store the unsorted mesomer 2nd nearest neighbour invariom names
            mesomer(i) = achar(91)
            do j = 1,m
               symbol = self(neighbour2(j)).chemical_symbol
               mesomer(i) = trim(mesomer(i))// &
                            trim(bonds2(j))// &
                            trim(symbol.lower_cased)
            end
            mesomer(i) = trim(mesomer(i))//achar(93)

            ! Make the 2nd nearest neighbour ordering string ZZ
            p = 1
            do j = 1,m
               ZZ(i)(p:p+3) = trim(Z2(j).to_str)
               p = p + 4
            end

            order2.destroy
            Z2.destroy
            bonds2.destroy
            bond2.destroy
            neighbour2.destroy
         end

         ! Now reorder the mesomer strings according to ZZ
         if (l2>f2) then
            order.create(f2,l2)
            ZZ.quick_sort(order,decreasing_order=TRUE)
            order = order + f2 - 1
            neighbour(f2:l2) = neighbour(order)
            mesomer(f2:l2) = mesomer(order)
            order.destroy
         end

         ZZ.destroy

      end

      ! Now everything is sorted; just make the invariom label
      res = res.trim_blanks_from_start
      do i = 1,n
         symbol = self(neighbour(i)).chemical_symbol
         res = trim(res)//trim(bonds(i))//trim(symbol.lower_cased)
         if (bond(i)==15 OR special) then
            res = trim(res)//trim(mesomer(i))
         end
      end

      mesomer.destroy; bonds.destroy; bond.destroy; neighbour.destroy
   end

   put_invariom_labels
   ! Print out the invariom labels
      a :: INT
      do a = 1,.dim
         stdout.show("label for atom "//trim(a.to_str)//" = ",.invariom_label_of(a))
      end
   end

   allred_rochow_bond_orders(a,neighbours,bond,bonds)
   ! Given at atom "a" and its "neighbours" return the allred-rochow
   ! bond distinguishing parameters "bond" (times 10) and the
   ! cooresponding string form.
      a :: INT, IN
      neighbours :: VEC{INT}, IN
      bond :: VEC{INT}, OUT
      bonds :: VEC{STR}, OUT

   ENSURE(0<a AND a <=.dim,"index a out of range")
   ENSURE(bond.dim==neighbours.dim,"bond array, wrong size")
   ENSURE(bonds.dim==neighbours.dim,"bond array, wrong size")

      i,b :: INT
      br :: REAL

      do i = 1,neighbours.dim
         b = .bond_distinguisher(a,neighbours(i))
         bond(i) = b
         if (b==15) then
            br = b/TEN
            bonds(i) = br.to_str("f3.1")
         else
            b = b/10
            bonds(i) = b.to_str
         end
      end
   end

   bond_distinguisher(a,b) result (res)
   ! Return true if "self" is bonded to "b".  If present, "range_factor" is used
   ! to determine the distance range in which the atoms are regarded as bonded.
   ! This uses the CCDC method, as documented on their web page.
      a,b :: INT, IN
      res :: INT

      d,chi,cra,crb,ena,enb :: REAL

      d = .bond_distance(a,b)*ANGSTROM_PER_BOHR

      cra = self(a).invariom_covalent_radius
      crb = self(b).invariom_covalent_radius

      ena = self(a).allred_rochow_en
      enb = self(b).allred_rochow_en

      chi = cra + crb - 0.08 * abs(ena-enb) - d

      res = 0
           if (chi <= 0.0847 ) then; res = 10
      else if (chi <= 0.184 )  then; res = 15
      else if (chi <= 0.27 )   then; res = 20
      else if (chi >  0.27 )   then; res = 30
      end

   end


   smiles_invariom_labels result (res) ::: leaky
   ! Return the invariom label for the atom "a"
      res :: VEC{STR}*
      a :: INT
      res.create(.dim)
      do a = 1,.dim
         res(a) = .smiles_invariom_label_of(a)
      end
   end

   smiles_invariom_label_of(a) result (res)
   ! Return the invariom label for the atom "a"
      a :: INT
      res :: STR

      special_Z :: VEC{INT}(3) = [1,15,16]
      i,j,n,m,f2,l2,p :: INT
      Z,bond,order,neighbour,Z2,bond2,order2,neighbour2 :: VEC{INT}*
      bonds,bonds2,mesomer,ZZ :: VEC{STR}*
      special,do_2nd_neighbour :: BIN
      symbol :: STR

      ! Start with the R or S symbol, if the atom is chiral
      if (.is_next_neighbour_chiral(a)) then; res = trim(.next_neighbour_handedness_of(a))//"-"
      else;                                   res = " "
      end

      ! Start with "a" atoms chemical symbol
      res = trim(res)//self(a).chemical_symbol

      ! Get indices of the nearest neighbours; return if no neighbours
      neighbour => .neighbours_of(a)
      if (neighbour.disassociated) return
      neighbour.prune(a)
      if (neighbour.dim==0) return

      ! Create arrays to store the bond order (times 10) and string
      ! form of bond order
      n = neighbour.dim
      bond.create(n)
      bonds.create(n)

      ! Get the atomic numbers Z of neighbors and order them in
      ! decreasing bond-order/atomic number
      Z.create(n)
      order.create(n)
      Z = self(neighbour).atomic_number
      .smiles_bond_orders(a,neighbour,bond,bonds)
      Z = 1000*bond + Z
      Z.quick_sort(order,decreasing_order=TRUE)
      neighbour = neighbour(order)
      bond  = bond(order)
      bonds = bonds(order)
      order.destroy; Z.destroy

      ! If special Z atoms switch on next nearest neighbour
      f2 = 0
      special = FALSE

      if (any(special_Z==self(a).atomic_number)) then
         f2 = 1
         l2 = bond.dim
         special = TRUE

      ! Find out how many mesomeric bonds there are
      else
         f2 = bond.index_of_value(15)
         l2 = 0
         if (f2>0) then
            if      (f2==bond.dim) then;       l2 = f2
            else if (bond(bond.dim)==15) then; l2 = bond.dim
            else;                              l2 = bond(f2+1:).index_of_value_ne_to(15)
                                               l2 = f2 + l2 - 1
            end
         end
      end

      do_2nd_neighbour = f2>0 AND l2>=f2

      nullify(mesomer)

      ! If we should do second nearest neighbours ...
      if (do_2nd_neighbour) then

         mesomer.create(f2,l2); mesomer = " "
         ZZ.create(f2,l2);      ZZ = "0"

         ! Loop over second nearest neighbour atoms or mesomeric atoms
         do i = f2,l2

            ! Get indices of the 2nd nearest neighbours; return if no neighbours
            neighbour2 => .neighbours_of(neighbour(i))
            DIE_IF(neighbour2.disassociated,"mesomeric atom has no neighbours")

            ! We don't want the original first neighbour
            neighbour2.prune(a)
            if (neighbour2.dim==0) then
               neighbour2.destroy
               cycle
            end

            ! Order the 2nd nearest neighbours in decreasing bond-order/atomic number
            m = neighbour2.dim
            bond2.create(m)
            bonds2.create(m)
            Z2.create(m)
            order2.create(m)
            Z2 = self(neighbour2).atomic_number
            .smiles_bond_orders(neighbour(i),neighbour2,bond2,bonds2)
            Z2 = 1000*bond2 + Z2
            Z2.quick_sort(order2,decreasing_order=TRUE)
            neighbour2 = neighbour2(order2)
            Z2 = Z2(order2)
            bond2 = bond2(order2)
            bonds2 = bonds2(order2)

           ! Make and store the unsorted mesomer 2nd nearest neighbour invariom names
            mesomer(i) = "("
            do j = 1,m
               symbol = self(neighbour2(j)).chemical_symbol
               mesomer(i) = trim(mesomer(i))// &
                            trim(bonds2(j))// &
                            trim(symbol.lower_cased)
            end
            mesomer(i) = trim(mesomer(i))//")"

            ! Make the 2nd nearest neighbour ordering string ZZ
            p = 1
            do j = 1,m
               ZZ(i)(p:p+3) = trim(Z2(j).to_str)
               p = p + 4
            end

            order2.destroy
            Z2.destroy
            bonds2.destroy
            bond2.destroy
            neighbour2.destroy
         end

         ! Now reorder the mesomer strings according to ZZ
         if (l2>f2) then
            order.create(f2,l2)
            ZZ.quick_sort(order,decreasing_order=TRUE)
            order = order + f2 - 1
            neighbour(f2:l2) = neighbour(order)
            mesomer(f2:l2) = mesomer(order)
            order.destroy
         end

         ZZ.destroy

      end

      ! Now everything is sorted; just make the invariom label
      res = res.trim_blanks_from_start
      res = trim(res)//"("
      do i = 1,n
         symbol = self(neighbour(i)).chemical_symbol
         res = trim(res)//trim(bonds(i))//trim(symbol.lower_cased)
         if (bond(i)==15 OR special) then
            res = trim(res)//trim(mesomer(i))
         end
      end
      res = trim(res)//")"

      mesomer.destroy; bonds.destroy; bond.destroy; neighbour.destroy

   end

   put_smiles_invariom_labels
   ! Print out the invariom labels
      a :: INT
      do a = 1,.dim
         stdout.show("label for atom "//trim(a.to_str)//" = ",.smiles_invariom_label_of(a))
      end
   end

   smiles_bond_orders(a,neighbours,bond,bonds)
   ! Given at atom "a" and its "neighbours" return the allred-rochow
   ! bond distinguishing parameters "bond" (times 10) and the
   ! cooresponding string form.
      a :: INT, IN
      neighbours :: VEC{INT}, IN
      bond :: VEC{INT}, OUT
      bonds :: VEC{STR}, OUT

   ENSURE(0<a AND a <=.dim,"index a out of range")
   ENSURE(bond.dim==neighbours.dim,"bond array, wrong size")
   ENSURE(bonds.dim==neighbours.dim,"bond array, wrong size")

      i,b :: INT

      do i = 1,neighbours.dim
         b = .bond_distinguisher(a,neighbours(i))
         bond(i) = b
         select case (b)
         case (10);    bonds(i) = "-"
         case (15);    bonds(i) = ":"
         case (20);    bonds(i) = "="
         case (25);    bonds(i) = "%"
         case (30);    bonds(i) = "#"
         case default; bonds(i) = "?"
         end
      end
   end


!  =================
!  Protein detection
!  =================

   find_N_terminal_atoms
   ! Print the indices of the N terminal atoms.
      list :: VEC{INT}*

      .make_connection_table(skip_hydrogen=TRUE)
      .find_N_terminal_atoms(list)

      stdout.text("List of N terminal atoms:")
      stdout.put(list)

      list.destroy
      connections_for.destroy

   end

   find_N_terminal_atoms(list) ::: leaky
   ! Print the indices of the protein backbone atoms.
      list :: VEC{INT}*

   ENSURE(connections_for.associated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      N,Cp0,Ca,Cb,Cp,N1,Ot,Ct :: INT
      N_terminal :: BIN

      list.create(0)

      do N = 1,.dim
        if (self(N).atomic_number/=7) cycle
        Cp0 = 0
        if (NOT .is_protein_backbone_N(N,Cp0,Ca,Cb,Cp,N1,Ot,Ct,N_terminal,try=TRUE)) cycle
        if (NOT N_terminal) cycle
        list.append(N)
      end

   end


   find_protein_backbone
   ! Return the of indices of the N terminal atoms.
      backbone :: VEC{VEC_{INT}}*

      .make_connection_table(skip_hydrogen=TRUE)
      .find_protein_backbone(backbone)

      backbone.destroy
      connections_for.destroy

   end

   find_protein_backbone(backbone) ::: leaky
   ! Return the "backbone" of atom indices in each protein backbone.
      backbone :: VEC{VEC_{INT}}*

   ENSURE(connections_for.associated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      terminal :: VEC{INT}*
      N_terminal :: BIN
      i, N,Cp0,Ca,Cb,Cp,N1,Ot,Ct :: INT

      .find_N_terminal_atoms(terminal)

      backbone.create(terminal.dim,1)

      do i = 1,terminal.dim

        N = terminal(i)
        backbone(i)[1] = N
        Cp0 = 0

        do
           if (NOT .is_protein_backbone_N(N,Cp0,Ca,Cb,Cp,N1,Ot,Ct,N_terminal,try=TRUE)) exit
           if      (Ot/=0) then
              backbone(i).element.append([Ca,Cp,Ot])
              exit
           else if (Ct/=0) then
              backbone(i).element.append([Ca,Cp,Ct])
              exit
           else
              backbone(i).element.append([Ca,Cp,N1])
              N = N1
              Cp0 = Cp
           end
        end

        stdout.show("Backbone for protein strand =",i)
        stdout.put(backbone(i)[:])
      end

      terminal.destroy

   end

!   find_protein_backbone_from_N(N,C,found,Ca,Cc,N1,Ot)
!   ! Given the index "N" of a nitrogen atom and possibly the index "C"
!   ! of a connected carbon atom, return "found" as TRUE if that
!   ! nitrogen atom is part of a protein backbone. Also return the
!   ! index "Ca" of the C-alpha carbon, the index "Cc" of the C-carboxy
!   ! carbon, and either "N1" the next nitrogen in the backbone, or
!   ! "Ot" the terminal oxygen in the backbone. This assumes a
!   ! connection table has been made.
!     N,C :: INT, IN
!     found :: BIN, OUT
!     Ca,Cc,N1,Ot :: INT, OUT
!
!   ENSURE(connections_for.associated,"no connection table")
!   ENSURE(connections_for.dim==.dim,"wrong size connection table")
!   ENSURE(N>0 AND N<=.dim,"N index out of range")
!   ENSURE(self(N).atomic_number==7,"N is not the index of a nitrogen atom")
!   ENSURE(C>=0 AND C<=.dim,"C index out of range")
!
!     nn,na,ia,nc,ic,O2,X :: INT
!
!     ! Set defaults
!     found = FALSE
!     Ca = 0; Cc = 0; N1 = 0; Ot = 0
!
!     ! Check if C is bonded to N
!     if (C>0) then
!        DIE_IF(NOT self(N).is_bonded_to(self(C)),"N is not bonded to C")
!     end
!
!     ! # of connections for N
!     nn = connections_for(N).element.dim
!
!     ! A backbone N must have 1 connection and can't have
!     ! more than 2 connections
!     if (nn<=0) return
!     if (nn >2) return
!
!     ! Get the index of C-alpha atom
!     Ca = connections_for(N)[1]
!     if (Ca==C) then
!        DIE_IF(nn<2,"not enough connections to N = "//trim(N.to_str))
!        Ca = connections_for(N)[2]
!     end
!
!     ! C-alpha must be a carbon
!     if (self(Ca).atomic_number/=6) return
!
!     ! # of  connections for C-alpha
!     na = connections_for(Ca).element.dim
!
!     ! C-alpha must have 2 connections (GLY) or 3 connections
!     if (na/=3 AND na/=2) return
!
!     ! Now find C-carboxy carbon
!     do ia = 1,na
!        Cc = connections_for(Ca)[ia]          ! Index of C-carboxy
!        if (Cc==N) cycle                      ! Cc can't be the first N
!        if (self(Cc).atomic_number/=6) cycle  ! Cc must be a carbon
!        nc = connections_for(Cc).element.dim
!        if (nc/=3) cycle                      ! C-carboxy must have 3 connections
!        O2 = 0                                ! It must have a =O
!        N1 = 0                                ! It must have a -N, or
!        Ot = 0                                ! It must have a terminal -OH
!        do ic = 1,nc
!           X = connections_for(Cc)[ic]
!           if (X==Ca) cycle
!           if (self(X).atomic_number==7) N1 = X
!           if (self(X).atomic_number==8) then
!              if (Ot==0) then; O2 = X
!              else;            Ot = X
!              end
!           end
!        end
!        found = O2/=0 AND (N1/=0 OR Ot/=0)
!        if (found) exit
!     end
!   end


   is_protein_backbone_N(N,Cp0,Ca,Cb,Cp,N1,Ot,Ct,N_terminal,try) result (res)
   ! Return TRUE if "N" is the index of a nitrogen atom in the
   ! backbone of a protein, Cp0-N-Ca-Cp-(N1,Ot,Ct), given also
   ! (possibly) the index "Cp0" of a connected C prime carbon atom.
   ! Return the index "Ca" of the C-alpha carbon, the index of the
   ! beta carbon "Cb" (if it exists), the index "Cp" of the next C
   ! prime carboxy carbon, and either "N1" the next nitrogen in the
   ! backbone, or "Ot" the terminal oxygen in the backbone. If "N" is
   ! an N-terminal atom, return "N_terminal" as TRUE. This assumes a
   ! connection table has been made.
      N,Cp0 :: INT, IN
      Ca,Cb,Cp,N1,Ot,Ct :: INT, OUT
      N_terminal :: BIN, OUT
      try :: BIN, optional
      res :: BIN

   ENSURE(connections_for.associated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(N>0 AND N<=.dim,"N index out of range")
   ENSURE(self(N).atomic_number==7,"N is not the index of a nitrogen atom")
   ENSURE(Cp0>=0 AND Cp0<=.dim,"Cp0 index out of range")

      C1,C2,C3,O1, O11,Ca1,N11 :: INT

      res = FALSE
      N_terminal = FALSE

      ! One connection to N: Terminal N-Ca connection
      if (.has_1_connection(N,6,Ca)) then
        res = .is_protein_C_alpha(Ca,N,Cb,Cp,O1,N1,Ot,Ct)
        N_terminal = TRUE

      ! Two connections to N: Backbone or terminal PRO C1-N-C2 connection
      else if (.has_2_connections(N,6,6,C1,C2)) then

        Ca = 0
        if      (C1==Cp0) then; Ca = C2
        else if (C2==Cp0) then; Ca = C1
        end

        ! We found Cp0, so we know Ca
        if (Ca/=0) then
           res = .is_protein_C_alpha(Ca,N,Cb,Cp,O1,N1,Ot,Ct)

        ! Find which of C1 and C2 is Ca. If requested, determine which
        ! of C1 and C2 is NOT a Cp, which implies N_terminal. Also
        ! check for a terminal proline.
        else
           if      (.is_protein_C_alpha(C1,N,Cb,Cp,O1,N1,Ot,Ct)) then
              res = TRUE
              Ca = C1
              if (.has_ring(N,C2,[6,6,6])) N_terminal = TRUE
              if (NOT N_terminal AND present(try)) &
                 N_terminal = NOT .is_protein_C_prime_carbon(C2,N,O11,Ca1,N11)
           else if (.is_protein_C_alpha(C2,N,Cb,Cp,O1,N1,Ot,Ct)) then
              res = TRUE
              Ca = C2
              if (.has_ring(N,C1,[6,6,6])) N_terminal = TRUE
              if (NOT N_terminal AND present(try)) &
                 N_terminal = NOT .is_protein_C_prime_carbon(C1,N,O11,Ca1,N11)
           end

        end

      ! Three connections to N: Backbone PRO N-C1C2C3 connection
      ! NOTE: this only works if Cp0 is given
      else if (.has_3_connections(N,6,6,6,C1,C2,C3)) then
        if      (C1==Cp0) then; C1 = C2; C2 = C3; C3 = 0
        else if (C2==Cp0) then; C2 = C3; C3 = 0
        else if (C3==Cp0) then; C3 = 0
        end
        if (C3==0) then
           if      (.is_protein_C_alpha(C1,N,Cb,Cp,O1,N1,Ot,Ct)) then
              if (.has_ring(N,C2,[6,6,6])) then
                 Ca = C1
                 res = TRUE
              end
           else if (.is_protein_C_alpha(C2,N,Cb,Cp,O1,N1,Ot,Ct)) then
              if (.has_ring(N,C1,[6,6,6])) then
                 Ca = C2
                 res = TRUE
              end
           end
        end
      end

   end

   is_protein_C_alpha(Ca,N,Cb,Cp,O1,N1,Ot,Ct) result (res)
   ! Return TRUE if "Ca" is the index of a C-alpha atom in the
   ! backbone of a protein. You must supply the connected nitrogen
   ! atom "N". Returned are the index of the beta carbon "Cb", the
   ! index of the next C prime carboxy carbon "Cp", the connected
   ! oxygen atom "O1", and either the next nitrogen in the
   ! backbone "N1", or "Ot" the terminal oxygen in the backbone.
   ! NOTE: this is useful for travelling from N terminal to C terminal
   ! Diagram: N-CaCb-Cp=O1-(N1,Ot,Ct)
      Ca,N :: INT, IN
      Cb,Cp,O1,N1,Ot,Ct :: INT, OUT
      res :: BIN

   ENSURE(connections_for.associated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(N>0 AND N<=.dim,"N index out of range")
   ENSURE(Ca>=0 AND Ca<=.dim,"Ca index out of range")

      C1,C2,C3 :: INT

      res = FALSE

      ! GLY N-Ca-Cp connection
      if (.has_2_connections(Ca,N,6,Cp)) then
        if      (.is_CCOO_carbon(Cp,Ca,Ot,O1)) then ! two terminal oxygens
           N1 = 0
           Ct = 0
           Cb = 0
           res = TRUE
        else if (.is_CCON_carbon(Cp,Ca,O1,N1)) then ! Cp has =O and next nitrogen
           Ot = 0
           Ct = 0
           Cb = 0
           res = TRUE
        else if (.is_CCOC_carbon(Cp,Ca,O1,Ct)) then ! terminal methyl
           N1 = 0
           Ot = 0
           Cb = 0
           res = TRUE
        else if (.has_2_connections(Cp,Ca,7,N1)) then ! Cp has no oxygen
           Ot = 0
           Ct = 0
           Cb = 0
           res = TRUE
        end

      ! Any other residue, which of C1 and C2 is Cp?
      else if (.has_3_connections(Ca,N,6,6,C1,C2)) then
        if      (.is_CCOO_carbon(C1,Ca,Ot,O1)) then ! two terminal oxygens
           Cp = C1
           Cb = C2
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C1,Ca,O1,N1)) then ! Cp=C1 has =O and next nitrogen
           Cp = C1
           Cb = C2
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C1,Ca,O1,Ct)) then ! terminal methyl
           Cp = C1
           Cb = C2
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.is_CCOO_carbon(C2,Ca,Ot,O1)) then
           Cp = C2
           Cb = C1
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C2,Ca,O1,N1)) then
           Cp = C2
           Cb = C1
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C2,Ca,O1,Ct)) then ! terminal methyl
           Cp = C2
           Cb = C1
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.has_2_connections(C1,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C1
           Cb = C2
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.has_2_connections(C2,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C2
           Cb = C1
           Ot = 0
           Ct = 0
           res = TRUE
        end

      ! For non-standard branched residues, which of C1, C2, C3 is Cp?
      else if (.has_4_connections(Ca,N,6,C1,C2,C3)) then
        if      (.is_CCOO_carbon(C1,Ca,Ot,O1)) then
           Cp = C1
           Cb = 0
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C1,Ca,O1,N1)) then
           Cp = C1
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C1,Ca,O1,Ct)) then ! terminal methyl
           Cp = C1
           Cb = 0
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.is_CCOO_carbon(C2,Ca,Ot,O1)) then
           Cp = C2
           Cb = 0
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C2,Ca,O1,N1)) then
           Cp = C2
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C2,Ca,O1,Ct)) then ! terminal methyl
           Cp = C2
           Cb = 0
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.is_CCOO_carbon(C3,Ca,Ot,O1)) then
           Cp = C3
           Cb = 0
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C3,Ca,O1,N1)) then
           Cp = C3
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C3,Ca,O1,Ct)) then ! terminal methyl
           Cp = C3
           Cb = 0
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.has_2_connections(C1,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C1
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.has_2_connections(C2,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C2
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.has_2_connections(C3,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C3
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        end
      end
   end

   is_protein_C_prime_carbon(Cp,N,O,Ca,N1) result (res)
   ! Return TRUE if "Cp" is the index of a N-Cp-Ca-N1 carbon, where
   ! "N" is the index of a nitrogen bonded to "Cp". If TRUE, "O",
   ! "Ca" and "N1" are returned as the index of the bonded oxygen,
   ! alpha Carbon and previous nitrogen respectively.
      Cp,N :: INT, IN
      O,Ca,N1 :: INT, OUT
      res :: BIN

   ENSURE(connections_for.associated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"Cp index out of range")
   ENSURE( N>=0 AND  N<=.dim," N index out of range")

      Cb,Cb1,s,x,i :: INT
      list :: VEC{INT}*

      x = 6
      s = 7
      O  = 0
      Ca = 0
      N1 = 0
      res = FALSE

      if (.has_3_connections(Cp,N,8,6,O,Ca)) then      ! Cp=ON connection

        res =  .has_1_connection(O,Cp) &
          AND (.has_2_connections(Ca,Cp,7,N1) &
          OR   .has_3_connections(Ca,Cp,7,6,N1,Cb) &
          OR   .has_4_connections(Ca,Cp,s,x,x,N1,Cb,Cb1))

      else if (.has_a_connection(Cp,N)) then           ! Cp has no O connection

       if (.has_Z_connections(Cp,6,list)) then
          do i = 1,list.dim
             Ca = list(i)
             res = .has_2_connections(Ca,Cp,7,N1) &
              OR   .has_3_connections(Ca,Cp,7,6,N1,Cb) &
              OR   .has_4_connections(Ca,Cp,s,x,x,N1,Cb,Cb1)
              if (res) exit
          end
          list.destroy
       end

      end

   end

   is_NCOC_carbon(Cp,N,O,Ca,N1) result (res)
   ! Return TRUE if "Cp" is the index of a N-Cp=O-Ca-N1 carbon, where
   ! "N" is the index of a nitrogen bonded to "Cp". If TRUE, "O",
   ! "Ca" and "N1" are returned as the index of the bonded oxygen,
   ! alpha Carbon and next nitrogen respectively.
      Cp,N :: INT, IN
      O,Ca,N1 :: INT, OUT
      res :: BIN

   ENSURE(connections_for.associated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"Cp index out of range")
   ENSURE( N>=0 AND  N<=.dim," N index out of range")

      Cb,Cb1,s,x :: INT

      x = 6
      s = 7
      N1 = 0

      if (.has_3_connections(Cp,N,8,6,O,Ca)) then      ! Cp=ON connection

        res =  .has_1_connection(O,Cp) &
          AND (.has_2_connections(Ca,Cp,7,N1) &
          OR   .has_3_connections(Ca,Cp,7,6,N1,Cb) &
          OR   .has_4_connections(Ca,Cp,s,x,x,N1,Cb,Cb1))

      else

        res = FALSE

      end

   end

   is_CCOO_carbon(Cp,Ca,O1,O2) result (res)
   ! Return TRUE if "Cp" is the index of a Ca-Cp=OO carbon, where "Ca"
   ! is the index of an (alpha) carbon bonded to "Cp". If TRUE, "O1" and
   ! "O2" are returned as the indices of the bonded oxygens.
      Cp,Ca :: INT, IN
      O1,O2 :: INT, OUT
      res :: BIN

   ENSURE(connections_for.associated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"Cp index out of range")
   ENSURE(Ca>=0 AND Ca<=.dim,"Ca index out of range")

      if (.has_3_connections(Cp,Ca,8,8,O1,O2)) then      ! Cp=O1O2 connection
        res = .has_1_connection(O1,Cp) AND .has_1_connection(O2,Cp)
      else
        res = FALSE
      end

   end

   is_CCOC_carbon(Cp,Ca,O1,C) result (res)
   ! Return TRUE if "Cp" is the index of a Ca-Cp=OC carbon, where "Ca"
   ! is the index of an (alpha) carbon bonded to "Cp". If TRUE, "O1" and
   ! "C" are returned as the indices of the bonded oxygen and terminal
   ! methyl.
      Cp,Ca :: INT, IN
      O1,C :: INT, OUT
      res :: BIN

   ENSURE(connections_for.associated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"Cp index out of range")
   ENSURE(Ca>=0 AND Ca<=.dim,"Ca index out of range")

      if (.has_3_connections(Cp,Ca,8,6,O1,C)) then      ! Cp=O1C connection
        res = .has_1_connection(O1,Cp) AND .has_1_connection(C,Cp)
      else
        res = FALSE
      end

   end

   is_CCON_carbon(Cp,Ca,O1,N1) result (res)
   ! Return TRUE if "Cp" is the index of a Ca-Cp=ON carbon, where "Ca"
   ! is the index of an (alpha) carbon bonded to "Cp". If TRUE, "O1" and
   ! "N1" are returned as the indices of the bonded oxygen and
   ! nitrogen atom.
      Cp,Ca :: INT, IN
      O1,N1 :: INT, OUT
      res :: BIN

   ENSURE(connections_for.associated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"C index out of range")

      res = .has_3_connections(Cp,Ca,8,7,O1,N1)

   end

!  =================
!  Connection tables
!  =================

   make_connection_table(skip_hydrogen) ::: leaky
   ! Make the atom connection table "connections_for".  If
   ! "skip_hydrogen" is present and TRUE, connections are not made to
   ! any hydrogen atom.
      skip_hydrogen :: BIN, optional

      r :: REAL

      if (connections_for.associated) return

      r = 0.5d0
      r.convert_from("angstrom")
      ATOM:set_atom_bonded_range_factor(r)
      .make_connection_table(connections_for,skip_hydrogen)

   end

   make_connection_table(connections_for,skip_hydrogen,skip_self) ::: leaky, PURE
   ! Make the atom connection table "connections_for".  If
   ! "skip_hydrogen" is present and TRUE, connections are not made to
   ! any hydrogen atom.
      self :: IN
      connections_for :: VEC{VEC_{INT}}*
      skip_hydrogen :: BIN, optional, IN
      skip_self     :: BIN, optional, IN

      i,j,k :: INT
      skip_H,skip_s :: BIN

      skip_H = FALSE
      if (present(skip_hydrogen)) skip_H = skip_hydrogen

      skip_s = TRUE
      if (present(skip_self)) skip_s = skip_self

      connections_for.create(.dim,0)

      do i = 1,.dim

        if (skip_H) then
           if (self(i).atomic_number==1) cycle
        end

        if (skip_s) then; k = i + 1
        else;             k = i
        end

        do j = k,.dim

           if (skip_H) then
              if (self(j).atomic_number==1) cycle
           end

           if (self(i).is_bonded_to(self(j)) OR j==i) then
              connections_for(i).element.append(j)
              connections_for(j).element.append(i)
           end

        end

      end

   end

!  =====================
!  Atom connection tests
!  =====================

   has_a_connection(X,W) result (res)
   ! Returns TRUE if the atom with index "X" is connected to the atom
   ! with index "W".
      X,W :: INT, IN
      res :: BIN

   DIE_IF(X<1 OR X>.dim,"X index out of range")
   ENSURE(W>0 AND W<=.dim,"W index out of range")
   ENSURE(connections_for.associated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      res = any(connections_for(X)[:]==W)

   end

   has_Z_connection(X,Z) result (res)
   ! Returns TRUE if the atom with index "X" is connected to an atom
   ! with atomic number "Z".
      X,Z :: INT, IN
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(connections_for.associated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      res = any(self(connections_for(X)[:]).atomic_number==Z)

   end

   has_Z_connections(X,Z,list) result (res) ::: leaky
   ! Return "TRUE" if atom "X" has connections to atoms with atomic
   ! number "Z", and if so, return a "list" of the atom indices.
      X,Z :: INT, IN
      list :: VEC{INT}*
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(connections_for.associated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      nx,i,Y :: INT

      res = FALSE
      nx = connections_for(X).element.dim

      if (nx==0) return

      list.create(0)
      do i = 1,nx
        Y = connections_for(X)[i]            ! Index of atom connected to X
        if (self(Y).atomic_number/=Z) cycle  ! Y must have atomic number Z
        list.append(Y)
      end

      res = list.associated

   end

   has_0_connections(X) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" no connection
      X :: INT, IN
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")

      if (connections_for.disassociated) .make_connection_table
      res = connections_for(X).element.dim == 0

   end

   has_1_connection(X) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" only has one connection
      X :: INT, IN
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")

      if (connections_for.disassociated) .make_connection_table
      res = connections_for(X).element.dim == 1

   end

   has_1_connection(X,Y) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" only has one connection
   ! to an atom with index "Y".
      X,Y :: INT, IN
      res :: BIN

   DIE_IF(X<1 OR X>.dim,"X index out of range")
   ENSURE(Y>0 AND Y<=.dim,"Y index out of range")

      if (connections_for.disassociated) .make_connection_table

      res = connections_for(X).element.dim == 1
      if (NOT res) return

      res = connections_for(X)[1] == Y

   end

   has_1_connection(X,Z,Y) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" only has one connection
   ! to an atom with atomic number "Z".If there is a connection, return
   ! the index of the connected atom in "Y".
      X,Z :: INT, IN
      Y   :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")

      nx :: INT

      if (connections_for.disassociated) .make_connection_table

      res = FALSE
      nx = connections_for(X).element.dim
      if (nx/=1) return

      Y = connections_for(X)[1]
      if (self(Y).atomic_number/=Z) then
        Y = 0
      else
        res = TRUE
      end

   end

   has_2_connections(X) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has two connections
      X :: INT, IN
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")

      if (connections_for.disassociated) .make_connection_table
      res = connections_for(X).element.dim == 2

   end

   has_2_connections(X,Y1,Y2) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has two connections:
   ! one to the atom with index "Y1", the other to the atom with
   ! index "Y2".
      X,Y1,Y2 :: INT, IN
      res :: BIN

   DIE_IF(X<1 OR X>.dim,"X index out of range")

      if (connections_for.disassociated) .make_connection_table

      res = connections_for(X).element.dim == 2
      if (NOT res) return
      res = (connections_for(X)[1]==Y1 AND connections_for(X)[2]==Y2) &
         OR (connections_for(X)[2]==Y1 AND connections_for(X)[1]==Y2)
   end

   has_2_connections(X,Z1,Z2,Y1,Y2) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has two connections:
   ! one to an atom with atomic number "Z1", the other to an atom with
   ! atomic number "Z2". If there are connectons, return the indices
   ! of these atoms as "Y1" and "Y2" respectively.
      X,Z1,Z2 :: INT, IN
      Y1,Y2 :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")

      A1,A2 :: INT

      if (connections_for.disassociated) .make_connection_table

      Y1 = 0
      Y2 = 0
      res = FALSE
      if (connections_for(X).element.dim/=2) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]
      if      (self(A1).atomic_number==Z1 AND self(A2).atomic_number==Z2) then
        Y1 = A1
        Y2 = A2
        res = TRUE
      else if (self(A2).atomic_number==Z1 AND self(A1).atomic_number==Z2) then
        Y1 = A2
        Y2 = A1
        res = TRUE
      end
   end

   has_2_connections(X,W,Z,Y) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has two connections:
   ! one to the atom with index "W", the other to an atom with atomic
   ! number "Z".If there is a latter connection, return the index of
   ! atom with atomic number "Z" in "Y".
      X,W,Z :: INT, IN
      Y :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(W>0 AND W<=.dim,"W index out of range")
   ENSURE(connections_for.associated,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      nx,Y1,Y2 :: INT

      if (connections_for.disassociated) .make_connection_table

      Y = 0
      res = FALSE
      nx = connections_for(X).element.dim
      if (nx/=2) return

      Y1 = connections_for(X)[1]
      Y2 = connections_for(X)[2]
      if      (Y1==W AND self(Y2).atomic_number==Z) then
        Y = Y2
        res = TRUE
      else if (Y2==W AND self(Y1).atomic_number==Z) then
        Y = Y1
        res = TRUE
      end
   end

   has_3_connections(X) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has three connections
      X :: INT, IN
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")

      if (connections_for.disassociated) .make_connection_table
      res = connections_for(X).element.dim==3

   end

   has_3_connections(X,Z1,Z2,Z3,Y1,Y2,Y3) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has three connections:
   ! to atoms with atomic numbers "Z1", "Z2" and "Z3" with the atom
   ! indices returned in "Y1", "Y2" and "Y3".
      X,Z1,Z2,Z3 :: INT, IN
      Y1,Y2,Y3 :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")

      A1,A2,A3,N1,N2,N3 :: INT

      if (connections_for.disassociated) .make_connection_table

      Y1 = 0
      Y2 = 0
      Y3 = 0
      res = FALSE

      if (connections_for(X).element.dim/=3) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]
      A3 = connections_for(X)[3]

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number

      if      (Z1==N1 AND Z2==N2 AND Z3==N3) then; Y1=A1; Y2=A2; Y3=A3; res = TRUE
      else if (Z1==N1 AND Z2==N3 AND Z3==N2) then; Y1=A1; Y2=A3; Y3=A2; res = TRUE
      else if (Z1==N2 AND Z2==N1 AND Z3==N3) then; Y1=A2; Y2=A1; Y3=A3; res = TRUE
      else if (Z1==N2 AND Z2==N3 AND Z3==N1) then; Y1=A2; Y2=A3; Y3=A1; res = TRUE
      else if (Z1==N3 AND Z2==N1 AND Z3==N2) then; Y1=A3; Y2=A1; Y3=A2; res = TRUE
      else if (Z1==N3 AND Z2==N2 AND Z3==N1) then; Y1=A3; Y2=A2; Y3=A1; res = TRUE
      end

   end

   has_3_connections(X,W,Z1,Z2,Y1,Y2) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has three connections:
   ! one to the atom with index "W", the other two to atoms with atomic
   ! numbers "Z1" and "Z2".If there are these latter connections,
   ! return the indices of atoms with atomic numbers "Z1" and "Z2"
   ! in "Y1" and "Y2".
      X,W,Z1,Z2 :: INT, IN
      Y1,Y2 :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(W>0 AND W<=.dim,"W index out of range")

      A1,A2,A3,N1,N2,N3 :: INT

      if (connections_for.disassociated) .make_connection_table

      Y1 = 0
      Y2 = 0
      res = FALSE

      if (connections_for(X).element.dim/=3) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]
      A3 = connections_for(X)[3]

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number

      if      (A1==W AND Z1==N2 AND Z2==N3) then; Y1=A2; Y2=A3; res = TRUE
      else if (A1==W AND Z1==N3 AND Z2==N2) then; Y1=A3; Y2=A2; res = TRUE
      else if (A2==W AND Z1==N1 AND Z2==N3) then; Y1=A1; Y2=A3; res = TRUE
      else if (A2==W AND Z1==N3 AND Z2==N1) then; Y1=A3; Y2=A1; res = TRUE
      else if (A3==W AND Z1==N1 AND Z2==N2) then; Y1=A1; Y2=A2; res = TRUE
      else if (A3==W AND Z1==N2 AND Z2==N1) then; Y1=A2; Y2=A1; res = TRUE
      end

   end

   has_3_connections(X,V,W,Z,Y) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has three connections:
   ! two to atoms "V" and "W", and one to an atom with atomic
   ! numbers "Z".If there is this latter connection, return the
   ! index of this atom in "Y".
      X,V,W,Z :: INT, IN
      Y :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(V>0 AND V<=.dim,"V index out of range")
   ENSURE(W>0 AND W<=.dim,"W index out of range")

      A1,A2,A3,N1,N2,N3 :: INT

      if (connections_for.disassociated) .make_connection_table

      Y = 0
      res = FALSE

      if (connections_for(X).element.dim/=3) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]
      A3 = connections_for(X)[3]

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number

      if      (A1==V AND A2==W  AND Z==N1) then; Y=A1; res = TRUE
      else if (A1==W AND A2==V  AND Z==N1) then; Y=A1; res = TRUE
      else if (A1==V AND A2==W  AND Z==N2) then; Y=A2; res = TRUE
      else if (A1==W AND A2==V  AND Z==N2) then; Y=A2; res = TRUE
      else if (A1==V AND A2==W  AND Z==N3) then; Y=A3; res = TRUE
      else if (A1==W AND A2==V  AND Z==N3) then; Y=A3; res = TRUE
      end

   end

   has_4_connections(X) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has four connections
      X :: INT, IN
      res :: BIN

   DIE_IF(X<1 OR X>.dim,"X index out of range")

      if (connections_for.disassociated) .make_connection_table
      res = connections_for(X).element.dim==4

   end

   has_4_connections(X,W,Z1,Z2,Z3,Y1,Y2,Y3) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has four connections: one
   ! to the atom with index "W", the other three to atoms with atomic
   ! numbers "Z1", "Z2" and "Z3".If there are these latter
   ! connections, return the indices of atoms with thse atomic numbers
   ! in "Y1", "Y2" and "Y3" respectively.
      X,W,Z1,Z2,Z3 :: INT, IN
      Y1,Y2,Y3 :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(W>0 AND W<=.dim,"W index out of range")

      A1,A2,A3,A4,N1,N2,N3,N4 :: INT

      if (connections_for.disassociated) .make_connection_table

      Y1 = 0
      Y2 = 0
      Y3 = 0
      res = FALSE

      if (connections_for(X).element.dim/=4) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]
      A3 = connections_for(X)[3]
      A4 = connections_for(X)[4]

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number
      N4 = self(A4).atomic_number

      if      (A1==W AND Z1==N2 AND Z2==N3 AND Z3==N4) then; Y1=A2; Y2=A3; Y3=A4; res = TRUE
      else if (A1==W AND Z1==N2 AND Z2==N4 AND Z3==N3) then; Y1=A2; Y2=A4; Y3=A3; res = TRUE
      else if (A1==W AND Z1==N3 AND Z2==N2 AND Z3==N4) then; Y1=A3; Y2=A2; Y3=A4; res = TRUE
      else if (A1==W AND Z1==N3 AND Z2==N4 AND Z3==N2) then; Y1=A3; Y2=A4; Y3=A2; res = TRUE
      else if (A1==W AND Z1==N4 AND Z2==N2 AND Z3==N3) then; Y1=A4; Y2=A2; Y3=A3; res = TRUE
      else if (A1==W AND Z1==N4 AND Z2==N3 AND Z3==N2) then; Y1=A4; Y2=A3; Y3=A2; res = TRUE
      else if (A2==W AND Z1==N1 AND Z2==N3 AND Z3==N4) then; Y1=A1; Y2=A3; Y3=A4; res = TRUE
      else if (A2==W AND Z1==N1 AND Z2==N4 AND Z3==N3) then; Y1=A1; Y2=A4; Y3=A3; res = TRUE
      else if (A2==W AND Z1==N3 AND Z2==N1 AND Z3==N4) then; Y1=A3; Y2=A1; Y3=A4; res = TRUE
      else if (A2==W AND Z1==N3 AND Z2==N4 AND Z3==N1) then; Y1=A3; Y2=A4; Y3=A1; res = TRUE
      else if (A2==W AND Z1==N4 AND Z2==N1 AND Z3==N3) then; Y1=A4; Y2=A1; Y3=A3; res = TRUE
      else if (A2==W AND Z1==N4 AND Z2==N3 AND Z3==N1) then; Y1=A4; Y2=A3; Y3=A1; res = TRUE
      else if (A3==W AND Z1==N2 AND Z2==N1 AND Z3==N4) then; Y1=A2; Y2=A1; Y3=A4; res = TRUE
      else if (A3==W AND Z1==N2 AND Z2==N4 AND Z3==N1) then; Y1=A2; Y2=A4; Y3=A1; res = TRUE
      else if (A3==W AND Z1==N1 AND Z2==N2 AND Z3==N4) then; Y1=A1; Y2=A2; Y3=A4; res = TRUE
      else if (A3==W AND Z1==N1 AND Z2==N4 AND Z3==N2) then; Y1=A1; Y2=A4; Y3=A2; res = TRUE
      else if (A3==W AND Z1==N4 AND Z2==N2 AND Z3==N1) then; Y1=A4; Y2=A2; Y3=A1; res = TRUE
      else if (A3==W AND Z1==N4 AND Z2==N1 AND Z3==N2) then; Y1=A4; Y2=A1; Y3=A2; res = TRUE
      else if (A4==W AND Z1==N2 AND Z2==N3 AND Z3==N1) then; Y1=A2; Y2=A3; Y3=A1; res = TRUE
      else if (A4==W AND Z1==N2 AND Z2==N1 AND Z3==N3) then; Y1=A2; Y2=A1; Y3=A3; res = TRUE
      else if (A4==W AND Z1==N3 AND Z2==N2 AND Z3==N1) then; Y1=A3; Y2=A2; Y3=A1; res = TRUE
      else if (A4==W AND Z1==N3 AND Z2==N1 AND Z3==N2) then; Y1=A3; Y2=A1; Y3=A2; res = TRUE
      else if (A4==W AND Z1==N1 AND Z2==N2 AND Z3==N3) then; Y1=A1; Y2=A2; Y3=A3; res = TRUE
      else if (A4==W AND Z1==N1 AND Z2==N3 AND Z3==N2) then; Y1=A1; Y2=A3; Y3=A2; res = TRUE
      end

   end

   has_4_connections(X,W,Z,Y1,Y2,Y3) result (res) ::: leaky
   ! Returns TRUE if the atom with index "X" has four connections: one
   ! to the atom with index "W", the other three to atoms with atomic
   ! number "Z".If there are these latter connections, return the
   ! indices of atoms with this atomic number in "Y1", "Y2" and "Y3"
   ! respectively.
      X,W,Z :: INT, IN
      Y1,Y2,Y3 :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(W>0 AND W<=.dim,"W index out of range")

      A1,A2,A3,A4,N1,N2,N3,N4 :: INT

      if (connections_for.disassociated) .make_connection_table

      Y1 = 0
      Y2 = 0
      Y3 = 0
      res = FALSE

      if (connections_for(X).element.dim/=4) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]
      A3 = connections_for(X)[3]
      A4 = connections_for(X)[4]

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number
      N4 = self(A4).atomic_number

      if      (A1==W AND Z==N2 AND Z==N3 AND Z==N4) then; Y1=A2; Y2=A3; Y3=A4; res = TRUE
      else if (A2==W AND Z==N1 AND Z==N3 AND Z==N4) then; Y1=A1; Y2=A3; Y3=A4; res = TRUE
      else if (A3==W AND Z==N2 AND Z==N1 AND Z==N4) then; Y1=A2; Y2=A1; Y3=A4; res = TRUE
      else if (A4==W AND Z==N2 AND Z==N3 AND Z==N1) then; Y1=A2; Y2=A3; Y3=A1; res = TRUE
      end

   end

   has_ring(A,B,Z,R) result (res) ::: leaky
   ! Return TRUE if the atoms with indices "A" and "B" form part of a
   ! single connection ring of atoms whose atomic numbers after atom
   ! "B" are given in "Z". NOTE: "A" need not be single connected.
      A,B :: INT, IN
      Z :: VEC{INT}, IN
      R :: VEC{INT}, OUT, optional
      res :: BIN

   ENSURE(A>=0 AND A<=.dim,"A index out of range")
   ENSURE(B>=0 AND B<=.dim,"A index out of range")
   ENSURE(Z.dim>0,"Z array too small")

      i,W,X,Y :: INT

      if (connections_for.disassociated) .make_connection_table

      W = A
      X = B
      do i = 1,Z.dim
        res = .has_2_connections(X,W,Z(i),Y)
        if (NOT res) return
        if (present(R)) R(i) = Y
        W = X
        X = Y
      end
      res = .has_a_connection(X,A)

   end

   has_chain(A,B,Z,C) result (res) ::: leaky
   ! Return TRUE if the atoms with indices "A" and "B" form part of a
   ! single connection chain of atoms whose atomic numbers after atom
   ! "B" are given in "Z".
      A,B :: INT, IN
      Z :: VEC{INT}, IN
      C :: VEC{INT}, OUT, optional
      res :: BIN

   ENSURE(A>=0 AND A<=.dim,"A index out of range")
   ENSURE(B>=0 AND B<=.dim,"A index out of range")
   ENSURE(Z.dim>0,"Z array too small")

      i,W,X,Y :: INT

      if (connections_for.disassociated) .make_connection_table

      res = FALSE

      W = A
      X = B
      do i = 1,Z.dim
        res = .has_2_connections(X,W,Z(i),Y)
        if (NOT res) return
        if (present(C)) C(i) = Y
        W = X
        X = Y
      end

   end

!  ====================
!  Amino acid detectors
!  ====================

   put_protein_sequence ::: leaky
   ! Return the "backbone" of atom indices in each protein backbone.

      backbone :: VEC{VEC_{INT}}*
      terminal :: VEC{INT}*
      N_terminal :: BIN
      i, N,Cp0,Ca,Cb,Cp,N1,Ot,Ct :: INT

      .make_connection_table(skip_hydrogen=TRUE)

      .find_N_terminal_atoms(terminal)

      backbone.create(terminal.dim,1)

      do i = 1,terminal.dim

        N = terminal(i)
        backbone(i)[1] = N
        Cp0 = 0

        stdout.show("Sequence for protein strand =",i)

        do

           if (NOT .is_protein_backbone_N(N,Cp0,Ca,Cb,Cp,N1,Ot,Ct,N_terminal,try=TRUE)) exit

           if      (Ot/=0) then
              backbone(i).element.append([Ca,Cp,Ot])
              exit
           else if (Ct/=0) then
              backbone(i).element.append([Ca,Cp,Ct])
              exit
           else
              backbone(i).element.append([Ca,Cp,N1])
              N = N1
              Cp0 = Cp
           end

           if (Cb==0) then; stdout.text("GLY")
           else;            stdout.text(.protein_side_chain_3_code(Ca,Cb))
           end

        end

      end

      terminal.destroy
      backbone.destroy
      connections_for.destroy

   end

!   find_protein_backbone_from_N(N,C,found,Ca,Cc,N1,Ot)
!   ! Given the index "N" of a nitrogen atom and possibly the index "C"
!   ! of a connected carbon atom, return "found" as TRUE if that
!   ! nitrogen atom is part of a protein backbone. Also return the
!   ! index "Ca" of the C-alpha carbon, the index "Cc" of the C-carboxy
!   ! carbon, and either "N1" the next nitrogen in the backbone, or
!   ! "Ot" the terminal oxygen in the backbone. This assumes a
!   ! connection table has been made.
!     N,C :: INT, IN
!     found :: BIN, OUT
!     Ca,Cc,N1,Ot :: INT, OUT
!
!   ENSURE(connections_for.associated,"no connection table")
!   ENSURE(connections_for.dim==.dim,"wrong size connection table")
!   ENSURE(N>0 AND N<=.dim,"N index out of range")
!   ENSURE(self(N).atomic_number==7,"N is not the index of a nitrogen atom")
!   ENSURE(C>=0 AND C<=.dim,"C index out of range")
!
!     nn,na,ia,nc,ic,O2,X :: INT
!
!     ! Set defaults
!     found = FALSE
!     Ca = 0; Cc = 0; N1 = 0; Ot = 0
!
!     ! Check if C is bonded to N
!     if (C>0) then
!        DIE_IF(NOT self(N).is_bonded_to(self(C)),"N is not bonded to C")
!     end
!
!     ! # of connections for N
!     nn = connections_for(N).element.dim
!
!     ! A backbone N must have 1 connection and can't have
!     ! more than 2 connections
!     if (nn<=0) return
!     if (nn >2) return
!
!     ! Get the index of C-alpha atom
!     Ca = connections_for(N)[1]
!     if (Ca==C) then
!        DIE_IF(nn<2,"not enough connections to N = "//trim(N.to_str))
!        Ca = connections_for(N)[2]
!     end
!
!     ! C-alpha must be a carbon
!     if (self(Ca).atomic_number/=6) return
!
!     ! # of  connections for C-alpha
!     na = connections_for(Ca).element.dim
!
!     ! C-alpha must have 2 connections (GLY) or 3 connections
!     if (na/=3 AND na/=2) return
!
!     ! Now find C-carboxy carbon
!     do ia = 1,na
!        Cc = connections_for(Ca)[ia]          ! Index of C-carboxy
!        if (Cc==N) cycle                      ! Cc can't be the first N
!        if (self(Cc).atomic_number/=6) cycle  ! Cc must be a carbon
!        nc = connections_for(Cc).element.dim
!        if (nc/=3) cycle                      ! C-carboxy must have 3 connections
!        O2 = 0                                ! It must have a =O
!        N1 = 0                                ! It must have a -N, or
!        Ot = 0                                ! It must have a terminal -OH
!        do ic = 1,nc
!           X = connections_for(Cc)[ic]
!           if (X==Ca) cycle
!           if (self(X).atomic_number==7) N1 = X
!           if (self(X).atomic_number==8) then
!              if (Ot==0) then; O2 = X
!              else;            Ot = X
!              end
!           end
!        end
!        found = O2/=0 AND (N1/=0 OR Ot/=0)
!        if (found) exit
!     end
!   end

   protein_side_chain_3_code(Ca,Cb) result (res)
   ! Returns the 3 letter code for a side chain connected at carbon
   ! atoms "Ca" and "Cb".
      Ca,Cb :: INT, IN
      res :: STR
   ENSURE(Ca>=0 AND Ca<=.dim,"Ca index out of range")
   ENSURE(Cb>=0 AND Cb<=.dim,"Cb index out of range")
   ENSURE(self(Ca).atomic_number==6,"must suppy index of alpha carbon atom")
   ENSURE(self(Cb).atomic_number==6,"must suppy index of beta carbon atom")
      if      (.has_ALA(Ca,Cb)) then; res = "ALA"
      else if (.has_ARG(Ca,Cb)) then; res = "ARG"
      else if (.has_ASN(Ca,Cb)) then; res = "ASN"
      else if (.has_ASP(Ca,Cb)) then; res = "ASP"
      else if (.has_CYS(Ca,Cb)) then; res = "CYS"
      else if (.has_GLN(Ca,Cb)) then; res = "GLN"
      else if (.has_GLU(Ca,Cb)) then; res = "GLU"
      else if (.has_HIS(Ca,Cb)) then; res = "HIS"
      else if (.has_ILE(Ca,Cb)) then; res = "ILE"
      else if (.has_LEU(Ca,Cb)) then; res = "LEU"
      else if (.has_LYS(Ca,Cb)) then; res = "LYS"
      else if (.has_MET(Ca,Cb)) then; res = "MET"
      else if (.has_PHE(Ca,Cb)) then; res = "PHE"
      else if (.has_SER(Ca,Cb)) then; res = "SER"
      else if (.has_THR(Ca,Cb)) then; res = "THR"
      else if (.has_TRP(Ca,Cb)) then; res = "TRP"
      else if (.has_TYR(Ca,Cb)) then; res = "TYR"
      else if (.has_VAL(Ca,Cb)) then; res = "VAL"
      else;                           res = "UNK"
      end
   end

   has_ALA(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ALA
      Ca,Cb :: INT, IN
      res :: BIN
      res = .has_1_connection(Cb,Ca)
   end

   has_ARG(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ARG
      Ca,Cb :: INT, IN
      res :: BIN
      C :: VEC{INT}(4)
      Nz1,Nz2 :: INT
      res = .has_chain(Ca,Cb,[6,6,7,6],C)
      if (NOT res) return
      res = .has_3_connections(C(4),C(3),7,7,Nz1,Nz2)
      if (NOT res) return
      res = .has_1_connection(Nz1,C(4))
      if (NOT res) return
      res = .has_1_connection(Nz2,C(4))
   end

   has_ASN(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ASN
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Og,Ng :: INT
      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,6,7,Og,Ng)
      if (NOT res) return
      res = .has_1_connection(Og,Cg)
      if (NOT res) return
      res = .has_1_connection(Ng,Cg)
   end

   has_ASP(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ASP
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Og1,Og2 :: INT
      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,6,7,Og1,Og2)
      if (NOT res) return
      res = .has_1_connection(Og1,Cg)
      if (NOT res) return
      res = .has_1_connection(Og2,Cg)
   end

   has_CYS(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes CYS
      Ca,Cb :: INT, IN
      res :: BIN
      Sg :: INT
      res = .has_2_connections(Cb,Ca,16,Sg)
      if (NOT res) return
      res = .has_1_connection(Sg,Cb)
   end

   has_GLN(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes GLN
      Ca,Cb :: INT, IN
      res :: BIN
      C :: VEC{INT}(2)
      Ne,Oe :: INT
      res = .has_chain(Ca,Cb,[6,6],C)
      if (NOT res) return
      res = .has_3_connections(C(2),C(1),8,7,Oe,Ne)
      if (NOT res) return
      res = .has_1_connection(Ne,C(2))
      if (NOT res) return
      res = .has_1_connection(Oe,C(2))
   end

   has_GLU(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes GLU
      Ca,Cb :: INT, IN
      res :: BIN
      C :: VEC{INT}(2)
      Oe1,Oe2 :: INT
      res = .has_chain(Ca,Cb,[6,6],C)
      if (NOT res) return
      res = .has_3_connections(C(2),C(1),8,8,Oe1,Oe2)
      if (NOT res) return
      res = .has_1_connection(Oe1,C(2))
      if (NOT res) return
      res = .has_1_connection(Oe2,C(2))
   end

   has_HIS(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes HIS
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Nd,Cd :: INT
      res = .has_2_connections(Cb,Ca,16,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,7,6,Nd,Cd)
      if (NOT res) return
      res = .has_ring(Cg,Nd,[6,7,6])
   end

   has_ILE(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ILE
      Ca,Cb :: INT, IN
      res :: BIN
      Cg1,Cg2,Cd :: INT
      res = .has_3_connections(Cb,Ca,6,6,Cg1,Cg2)
      if (NOT res) return
      if      (.has_1_connection(Cg1,Cb)) then
        res = .has_2_connections(Cg2,Cb,6,Cd)
        if (NOT res) return
        res = .has_1_connection(Cd,Cg2)
      else if (.has_1_connection(Cg2,Cb)) then
        res = .has_2_connections(Cg1,Cb,6,Cd)
        if (NOT res) return
        res = .has_1_connection(Cd,Cg1)
      else
        res = FALSE
      end
   end

   has_LEU(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes LEU
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Cd1,Cd2 :: INT
      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,6,7,Cd1,Cd2)
      if (NOT res) return
      res = .has_1_connection(Cd1,Cg)
      if (NOT res) return
      res = .has_1_connection(Cd2,Cg)
   end

   has_LYS(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes LYS
      Ca,Cb :: INT, IN
      res :: BIN
      C :: VEC{INT}(4)
      res = .has_chain(Ca,Cb,[6,6,6,7],C)
      if (NOT res) return
      res = .has_1_connection(C(4),C(3))
   end

   has_MET(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes MET
      Ca,Cb :: INT, IN
      res :: BIN
      C :: VEC{INT}(3)
      res = .has_chain(Ca,Cb,[6,16,6],C)
      if (NOT res) return
      res = .has_1_connection(C(3),C(2))
   end

   has_PHE(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes PHE
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Cd1,Cd2 :: INT
      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,6,6,Cd1,Cd2)
      if (NOT res) return
      res = .has_ring(Cg,Cd1,[6,6,6,6])
   end

   has_SER(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes SER
      Ca,Cb :: INT, IN
      res :: BIN
      Og :: INT
      res = .has_2_connections(Cb,Ca,8,Og)
      if (NOT res) return
      res = .has_1_connection(Og,Cb)
   end

   has_THR(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes THR
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Og :: INT
      res = .has_3_connections(Cb,Ca,6,8,Cg,Og)
      if (NOT res) return
      res = .has_1_connection(Cg,Cb)
      if (NOT res) return
      res = .has_1_connection(Og,Cb)
   end

   has_TRP(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes TRP
      Ca,Cb :: INT, IN
      res :: BIN
      C :: VEC{INT}(4)
      Cg,Cd1,Cd2,Ne,Ce1,Cf1 :: INT
      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,6,6,Cd1,Cd2)
      if (NOT res) return
      if      (.has_2_connections(Cd1,Cg,7,Ne)) then
        res = .has_2_connections(Ne,Cd1,6,Ce1)
        if (NOT res) return
        res = .has_3_connections(Ce1,Ne,Cd2,6,Cf1)
        if (NOT res) return
        res = .has_chain(Ce1,Cf1,[6,6,6,6],C)
        if (NOT res) return
        res = C(4)==Cd2
      else if (.has_2_connections(Cd2,Cg,7,Ne)) then
        res = .has_2_connections(Ne,Cd2,6,Ce1)
        if (NOT res) return
        res = .has_3_connections(Ce1,Ne,Cd1,6,Cf1)
        if (NOT res) return
        res = .has_chain(Ce1,Cf1,[6,6,6,6],C)
        if (NOT res) return
        res = C(4)==Cd1
      else
        res = FALSE
      end
   end

   has_TYR(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes TYR
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Cd1,Cd2,Ce1,Ce2,Cz,Oz :: INT
      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,6,6,Cd1,Cd2)
      if (NOT res) return
      res = .has_2_connections(Cd1,Cg,6,Ce1)
      if (NOT res) return
      res = .has_2_connections(Cd2,Cg,6,Ce2)
      if (NOT res) return
      res = .has_2_connections(Ce1,Cg,6,Cz)
      if (NOT res) return
      res = .has_2_connections(Ce2,Cg,6,Cz)
      if (NOT res) return
      res = .has_3_connections(Cz,Ce1,Ce2,8,Oz)
      if (NOT res) return
      res = .has_1_connection(Oz,Cz)
   end

   has_VAL(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes THR
      Ca,Cb :: INT, IN
      res :: BIN
      Cg1,Cg2 :: INT
      res = .has_3_connections(Cb,Ca,6,6,Cg1,Cg2)
      if (NOT res) return
      res = .has_1_connection(Cg1,Cb)
      if (NOT res) return
      res = .has_1_connection(Cg2,Cb)
   end

!  ========================
!  Bonds, distances, angles
!  ========================

   nearest_atom_to(pos) result (res) ::: pure
   ! Return the index of the nearest atom to point "pos".
      self :: IN
      pos :: VEC{REAL}(3), IN
      res :: INT

      a :: INT
      dpos :: VEC{REAL}(3)
      dmin,dist :: REAL

      res = 1

      dmin = huge(ONE)
      do a = 1,.dim

         dpos = pos - self(a).position
         dist = dpos.norm

         if (dist<dmin) then
            dmin = dist
            res  = a
         end

      end

   end

   bonded(a,b,range_factor,H_bonded) result (res) ::: pure
   ! Return true if "self" is bonded to "b".  If present, "range_factor" is used
   ! to determine the distance range in which the atoms are regarded as bonded.
   ! This uses the CCDC method, as documented on their web page.
      self :: IN
      a,b :: INT, IN
      range_factor :: REAL, IN, optional
      H_bonded :: BIN, IN, optional
      res :: BIN

      res = self(a).is_bonded_to(self(b),range_factor)

      ! Check if H-bobds are to be considered
      if (present(H_bonded)) then
      if (H_bonded) then
      if (NOT res) then
      if (self(a).atomic_number==1 OR self(b).atomic_number==1) then
         res = self(a).is_vdw_bonded_to(self(b),range_factor)
      end
      end
      end
      end

   end

   are_nearby(a,b,dist) result (res) ::: pure
   ! Return whether atoms "a" and "b" are nearby, i.e. within length "dist".
      self :: IN
      a,b :: INT, IN
      dist :: REAL, IN
      res :: BIN

      tmp :: VEC{REAL}(3)
      r2 :: REAL

      tmp = self(a).position - self(b).position
      tmp = abs(tmp)
      if      (tmp(1)>dist) then; res = FALSE
      else if (tmp(2)>dist) then; res = FALSE
      else if (tmp(3)>dist) then; res = FALSE
      else
         r2 = dot_product(tmp,tmp)
         res = (r2 < dist*dist)
      end

   end

   connected(a,b,c,d) result (res) ::: pure
   ! Return true if atoms "a" "b" "c" and "d" are connected together
      self :: IN
      a,b,c,d :: INT, IN
      res :: BIN

      res = .bonded(a,b) OR .bonded(a,c) OR .bonded(a,d)
      res = res AND ( .bonded(b,a) OR .bonded(b,c) OR .bonded(b,d) )
      res = res AND ( .bonded(c,a) OR .bonded(c,b) OR .bonded(c,d) )
      res = res AND ( .bonded(d,a) OR .bonded(d,b) OR .bonded(d,c) )

   end


   vdw_bonded(a,b,range_factor,vdw_range_pc) result (res) ::: pure
   ! Return true if "a" is vdw bonded to "b". Atoms which are
   ! covalently bonded are not van-der-waals bonded.  If present,
   ! "range_factor" is used to determine the distance range in which
   ! the atoms are regarded as covalent bonded. If present
   ! "vdw_range_pc" is the percentage increase in the vdw radius to be
   ! tolerated while still regarding the atoms vdw bonded (default
   ! 10%). This uses the CCDC method, as documented on their web page.
      self :: IN
      a,b :: INT, IN
      range_factor,vdw_range_pc :: REAL, optional, IN
      res :: BIN

      res = self(a).is_vdw_bonded_to(self(b),range_factor,vdw_range_pc)

   end

   is_vdw_bonded_to(list,range_factor,vdw_range_pc) result (res) ::: pure
   ! Return true if "self" has any atom vdw bonded to "list".
      self :: IN
      list :: VEC{ATOM}, IN
      range_factor,vdw_range_pc :: REAL, optional, IN
      res :: BIN

      a,b :: INT

      res = FALSE
      do a = 1,.dim
      do b = 1,list.dim
         res = self(a).is_vdw_bonded_to(list(b),range_factor,vdw_range_pc)
         if (res) exit
      end
      end

   end


   has_vdw_bond result (res) ::: pure
   ! Return whether the atom list has two atoms involved in a
   ! (shortest) intermolecular bond. 
      self :: IN
      res :: BIN

      vdw :: VEC{INT}(2)

      vdw = .shortest_vdw_bond

      res = vdw(1)/=0 AND vdw(2)/=0
      ! More than one molecule?

   end

   shortest_vdw_bond result (res) ::: pure
   ! Return indices of the two atoms involved in the shortest
   ! IM van der waals bond. If there are none result is (0,0).
      self :: IN
      res :: VEC{INT}(2)

      a,b :: INT
      rab :: VEC{REAL}(3)
      dab,test :: REAL
      has_mols :: BIN

      res  = 0

      ! More than one molecule?
      has_mols = any(self(:).site_disorder_group>1) OR any(self(:).group>1)
      if (NOT has_mols) return

      test = HUGE(ONE)

      do a = 2,.dim
      do b = 1,a-1

         if (NOT .vdw_bonded(a,b)) cycle

         rab = self(a).position - self(b).position
         dab = rab.norm
         
         if (dab<test) then
         
            res(1) = a
            res(2) = b
            test   = dab
         
         end

      end
      end

   end

   shortest_vdw_bond_and_bonded(list,na,nb) ::: leaky, PURE
   ! Return indices of the two atoms involved in the shortest
   ! intermolecular v an der waals bond as list(1,1) and list(1,2).
   ! Also return any atoms connected to these atoms in list(:,1:2)
   ! with "na" the number connected to list(1,1) and "nb" the number
   ! connected to list(1,2).
      self :: IN
      list :: MAT{INT}*
      na,nb :: INT, OUT

      n,a,b :: INT
      connections_for :: VEC{VEC_{INT}}*
      vdw :: VEC{INT}(2)

      na = 0
      nb = 0

      vdw = .shortest_vdw_bond

      ! Any vdw bonds?
      if (all(vdw==0)) return

      a = vdw(1)
      b = vdw(2)

      ! Make connjection table
      .make_connection_table(connections_for,skip_self=TRUE)

      ! Get friend sizes
      if (connections_for(a).element.associated) na = connections_for(a).element.dim
      if (connections_for(b).element.associated) nb = connections_for(b).element.dim

      ! Make list
      n = 1 + na + nb 
      list.create(n,2)

      ! VDW bond - first
      list(1,1) = vdw(1)
      list(1,2) = vdw(2)

      ! a connections
      if (na>0) then
         list(2:na+1,1) = vdw(1)
         list(2:na+1,2) = connections_for(a)[:]
      end

      ! b connections
      if (nb>0) then
         list(na+2:n,1) = vdw(2)
         list(na+2:n,2) = connections_for(b)[:]
      end

      ! Clean
      connections_for.destroy

   end

   shorten_shortest_vdw_bond ::: leaky
   ! Shorten the shortest intermolecular vdw bond to be the sum of the
   ! covalent bond lengths + 0.6 bohr, and apply the shift to all
   ! atoms in the group (there must be only two groups).
      self :: INOUT

   DIE_IF(maxval(self(:).group)/=2,"more than two groups")
   DIE_IF(minval(self(:).group)/=1,"there are not two groups")

      vdw :: VEC{INT}(2)
      a,b,g :: INT
      ra,rb :: REAL
      r,d,v :: VEC{REAL}(3)

      ! Shortest vdw bond
      vdw = .shortest_vdw_bond
      a = vdw(1)
      b = vdw(2)

      ! Distance vector between atoms
      r = self(a).position - self(b).position

      ! Desired distance vector
      ra = self(a).covalent_radius_ccdc
      rb = self(b).covalent_radius_ccdc
      d  = (r/r.norm) * (ra + rb + 0.6)

      ! Shift
      v = d - r

      ! Molecule index of atom "a"
      g = self(a).group

      ! Shift group "a"
      .translate_group(g,v)

   end


   no_of_bonds(range_factor,H_bonded) result (res) ::: pure
   ! Return the number of bonded atoms
      self :: IN
      range_factor :: REAL, IN, optional
      H_bonded :: BIN, IN, optional
      res :: INT

      a,b :: INT

      res = 0

      do a = 1,.dim
      do b = 1,a-1
         if (.bonded(a,b,range_factor,H_bonded)) res = res + 1
      end
      end

   end

   bond_distance(a,b,angstrom) result (res) ::: PURE
   ! Return the bond distance between atoms "a" and "b"
      self :: IN
      a,b :: INT, IN
      angstrom :: BIN, optional, IN
      res :: REAL

      rab :: VEC{REAL}(3)
      change :: BIN

      rab = self(b).position - self(a).position
      res = sqrt(rab(1)*rab(1) + rab(2)*rab(2) + rab(3)*rab(3))

      change = FALSE
      if (present (angstrom)) change = angstrom
      if (change) res = res * ANGSTROM_PER_BOHR

   end


   no_of_angles result (res) ::: pure
   ! Return the number of angles within bond contact distance
      self :: IN
      res :: INT

      n,a,b,c :: INT

      n = .dim

      res = 0

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle

            res = res + 1

         end

      end
      end

   end

   bond_angle(a,b,c,degrees) result (res) ::: pure
   ! Return the bond angle between atoms "a" , "b" and "c".
   ! The central atom is "b". The angle is calculated as
   ! arccos(nba.nbc) . If "degrees" is present and TRUE,
   ! result is in degrees.
      self :: IN
      a,b,c :: INT, IN
      degrees :: BIN, optional, IN
      res :: REAL

      rba,rbc :: VEC{REAL}(3)
      change :: BIN

      rba = self(a).position - self(b).position
      rbc = self(c).position - self(b).position
      rba.normalise
      rbc.normalise
      res = rba.dot(rbc)
      res = res.arccos

      change = FALSE
      if (present (degrees)) change = degrees
      if (change) res = res * DEGREE_PER_RADIAN

   end

   no_of_angle_center_atoms result (res) ::: pure
   ! Return the number of list of atom indices B which belong to
   ! angles centers angle(ABC)
      self :: IN
      res :: INT

      n,a,b,c :: INT
      cnt :: VEC{BIN}*

      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle

            cnt(b) = TRUE

         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   angle_center_atoms result (res) ::: pure
   ! Return the list of atom indices B which belong to angles centers
   ! angle(ABC)
      self :: IN
      res :: VEC{INT}(.no_of_angle_center_atoms)

      n,a,b,c :: INT
      cnt :: VEC{BIN}*

      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle

            cnt(b) = TRUE

         end

      end
      end

      res = pack([( a, a=1,n)],mask=cnt)

      deallocate(cnt)

   end

   no_of_angle_outer_atoms result (res) ::: pure
   ! Return the number of list of atoms which are outer angle atoms
      self :: IN
      res :: INT

      n,a,b,c :: INT
      cnt :: VEC{BIN}*

      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle

            cnt(a) = TRUE
            cnt(c) = TRUE

         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   angle_outer_atoms result (res) ::: pure
   ! Return the list of atoms which are outer angle atoms
      self :: IN
      res :: VEC{INT}(.no_of_angle_outer_atoms)

      n,a,b,c :: INT
      cnt :: VEC{BIN}*

      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle

            cnt(a) = TRUE
            cnt(c) = TRUE

         end

      end
      end

      res = pack([( a, a=1,n)],mask=cnt)

      deallocate(cnt)

   end


   no_of_torsion_angles result (res) ::: pure
   ! Return the number of torsion angles within bond contact distance
      self :: IN
      res :: INT

      n,a,b,c,d :: INT

      n = .dim

      res = 0

      do a = 1,n
      do b = 1,n

         if (a==b) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (a==c OR b==c) cycle
            if (NOT .bonded(b,c)) cycle

            do d = 1,n

               if (a==d OR b==d OR c==d) cycle
               if (NOT .bonded(c,d)) cycle

               res = res + 1

            end
         end

      end
      end

      res = res/2

   end

   torsion_angle(a,b,c,d) result (res) ::: pure
   ! Return the torsion angle between atoms "a", "b", "c" and "d". The
   ! atoms are assumed connected like a--b--c--d and the angle
   ! returned is that between vectors (a-b) and (d-c) i.e. the torsion
   ! angle looking down the b--c bond.  torsion is positive if (a-b)
   ! is counterclockwise of (d-c). If "degrees" is present and TRUE,
   ! result is in degrees.  NOTE: If the result is -ONE, either
   ! a--b--c or b--c--d are colinear, and the variables "abc_colinear"
   ! and "bcd_colinear" are set.  See Tuzun et al (2000) J. Comp. Chem
   ! 21 p. 553-561
      self :: IN
      a,b,c,d :: INT, IN
      res :: REAL

      rba,rcb,rdc,tba,tdc :: VEC{REAL}(3)
      dot :: REAL

      ! Vectors point from d -> c -> b -> a
      rba = self(a).position - self(b).position
      rcb = self(b).position - self(c).position
      rdc = self(c).position - self(d).position
      rba.normalise
      rcb.normalise
      rdc.normalise

      tba.to_cross_product_of(rba,rcb)
      tdc.to_cross_product_of(rcb,rdc)

      ! Collinear test
      res = ZERO
      if (abs(tba.norm)<TOL(5)) then
         res = -ONE
      end
      if (abs(tdc.norm)<TOL(5)) then
         res = -ONE
      end
      if (res<ZERO) return

      tba.normalise
      tdc.normalise
      res = tba.dot(tdc)
      res = res.arccos

      ! Sign of angle: see Tozun et al eq. (11)
      ! And also Figure 1
      dot = -rdc.dot(tba)
      if (dot<ZERO) res = -res

   end

   torsion_angle(a,b,c,d,abc_colinear,bcd_colinear,degrees) result (res)
   ! Return the torsion angle between atoms "a", "b", "c" and "d". The
   ! atoms are assumed connected like a--b--c--d and the angle
   ! returned is that between vectors (a-b) and (d-c) i.e. the torsion
   ! angle looking down the b--c bond.  torsion is positive if (a-b)
   ! is counterclockwise of (d-c). If "degrees" is present and TRUE,
   ! result is in degrees.  NOTE: If the result is -ONE, either
   ! a--b--c or b--c--d are colinear, and the variables "abc_colinear"
   ! and "bcd_colinear" are set.  See Tuzun et al (2000) J. Comp. Chem
   ! 21 p. 553-561
      self :: IN
      a,b,c,d :: INT, IN
      abc_colinear,bcd_colinear :: BIN, OUT
      degrees :: BIN, optional, IN
      res :: REAL

      change :: BIN
      rba,rcb,rdc,tba,tdc :: VEC{REAL}(3)
      dot :: REAL

      abc_colinear = FALSE
      bcd_colinear = FALSE

      ! Vectors point from d -> c -> b -> a
      rba = self(a).position - self(b).position
      rcb = self(b).position - self(c).position
      rdc = self(c).position - self(d).position
      rba.normalise
      rcb.normalise
      rdc.normalise

      tba.to_cross_product_of(rba,rcb)
      tdc.to_cross_product_of(rcb,rdc)

      ! Collinear test
      res = ZERO
      if (abs(tba.norm)<TOL(5)) then
         res = -ONE
      end
      if (abs(tdc.norm)<TOL(5)) then
         res = -ONE
      end
      if (res<ZERO) return

      tba.normalise
      tdc.normalise
      res = tba.dot(tdc)
      res = res.arccos

      ! Sign of angle: see Tozun et al eq. (11)
      ! And also Figure 1
      dot = -rdc.dot(tba)
      if (dot<ZERO) res = -res

      change = FALSE
      if (present (degrees)) change = degrees
      if (change) res = res * DEGREE_PER_RADIAN

   end

   no_of_torsion_angle_1st_atoms result (res) ::: pure
   ! Return the number of list of indices of 1st atoms in a torsion angle
      self :: IN
      res :: INT

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a1) = TRUE

            end
         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   torsion_angle_1st_atoms result (res) ::: pure
   ! Return the list of indices of 1st atoms in a torsion angle
      self :: IN
      res :: VEC{INT}(.no_of_torsion_angle_1st_atoms)

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a1) = TRUE

            end
         end

      end
      end

      res = pack([ (a1, a1=1,n) ],mask=cnt)

      deallocate(cnt)

   end

   no_of_torsion_angle_2nd_atoms result (res) ::: pure
   ! Return the number of list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: INT

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a2) = TRUE

            end
         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   torsion_angle_2nd_atoms result (res) ::: pure
   ! Return the list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: VEC{INT}(.no_of_torsion_angle_2nd_atoms)

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a2) = TRUE

            end
         end

      end
      end

      res = pack([ (a1, a1=1,n) ],mask=cnt)

      deallocate(cnt)

   end

   no_of_torsion_angle_3rd_atoms result (res) ::: pure
   ! Return the number of list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: INT

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a3) = TRUE

            end
         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   torsion_angle_3rd_atoms result (res) ::: pure
   ! Return the list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: VEC{INT}(.no_of_torsion_angle_3rd_atoms)

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a3) = TRUE

            end
         end

      end
      end

      res = pack([ (a1, a1=1,n) ],mask=cnt)

      deallocate(cnt)

   end

   no_of_torsion_angle_4th_atoms result (res) ::: pure
   ! Return the umber list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: INT

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a4) = TRUE

            end
         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   torsion_angle_4th_atoms result (res) ::: pure
   ! Return the list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: VEC{INT}(.no_of_torsion_angle_4th_atoms)

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a4) = TRUE

            end
         end

      end
      end

      res = pack([ (a1, a1=1,n) ],mask=cnt)

      deallocate(cnt)

   end

   has_all_Hs_single_bonded(has_Hs) result (res)
   ! Return TRUE if "self" has all H atom single bonded. If there are
   ! no H's then the result is TRUE but "has_Hs" is set FALSE..
      res :: BIN
      has_Hs :: BIN, OUT

      a,b,n :: INT

      res = TRUE
      has_Hs = FALSE

      do a = 1,.dim

         if (self(a).atomic_number/=1) cycle

         has_Hs = TRUE

         n = 0
         do b = 1,.dim
            if (self(b).atomic_number<=1) cycle
            if (NOT self(a).is_bonded_to(self(b))) cycle
            n = n + 1
            if (n>1) exit
         end

         res = n==1
         if (NOT res) exit

      end

   end


   Spackman86_dispersion_energy(atom) result (res) ::: PURE
   ! Return Spackman's dispersion energy between "self" and "atom"s.
   ! See Spackman M. A. (1986) J. Chem. Phys. 85(11) p. 6579
      self :: IN
      atom :: VEC{ATOM}, IN
      res :: REAL

   ENSURE(self.has_all_Spackman86_a_coeffs,"self: missing Spackman a coefficients")
   ENSURE(atom.has_all_Spackman86_a_coeffs,"atom: missing Spackman a coefficients")

      i,j :: INT
      r, a_i,a_j :: REAL

      res = ZERO

      ! Loop over pairs
      do i = 1,.dim

         a_i = ATOM::Spackman86_a_6_dispersion_coeff(self(i))

         do j = 1,atom.dim

            a_j = ATOM::Spackman86_a_6_dispersion_coeff(atom(j))

            r = self(i).bond_distance_to(atom(j))

            res = res - a_i*a_j/r**6

         end

      end

   end

   Spackman86_repulsion_energy(atom) result (res) ::: PURE
   ! Return Spackman's repulsion energy between "self" and "atom"s.
   ! See Spackman M. A. (1986) J. Chem. Phys. 85(11) p. 6579
      self :: IN
      atom :: VEC{ATOM}, IN
      res :: REAL

   ENSURE(self.has_all_Spackman86_b_c_coeffs,"self: missing Spackman b/c coefficients")
   ENSURE(atom.has_all_Spackman86_b_c_coeffs,"atom: missing Spackman b/c coefficients")

      i,j, Z_i,Z_j :: INT
      r,r_offset, b_i,b_j, c_i,c_j :: REAL

      res = ZERO

      ! Loop over pairs
      do i = 1,.dim

         Z_i = self(i).atomic_number
         b_i = ATOM::Spackman86_b_repulsion_coeff(self(i))
         c_i = ATOM::Spackman86_c_repulsion_coeff(self(i))

         do j = 1,atom.dim

            Z_j = atom(j).atomic_number
            b_j = ATOM::Spackman86_b_repulsion_coeff(atom(j))
            c_j = ATOM::Spackman86_c_repulsion_coeff(atom(j))

            r = self(i).bond_distance_to(atom(j))

            ! Modify distance r only for repulsion term
            ! for H atoms ... just an approximate hack
            r_offset = ZERO
            if (Z_i==1  OR  Z_j==1) r_offset = HALF  * BOHR_PER_ANGSTROM ! X-H interactions
            if (Z_i== 1 AND Z_j==1) r_offset = TENTH * BOHR_PER_ANGSTROM ! H-H interactions
            r = r + r_offset

            res = res + b_i*b_j*exp(-r*(c_i+c_j))

         end

      end

   end

   Grimme06_dispersion_energy(atom) result (res) !::: PURE
   ! Return Grimmes's dispersion energy between "self" and "atom"s.
   ! Based on C6 terms from Grimme (2006) J. Comp. Chem.  27(15) p. 1787
   ! E_disp = sum over atoms (C6 / r^6).
      self :: IN
      atom :: VEC{ATOM}, IN
      res :: REAL

    ENSURE(self.has_all_Grimme06_a_coeffs,"self: missing Grimme a coefficients")
    ENSURE(atom.has_all_Grimme06_a_coeffs,"atom: missing Grimme a coefficients")

      i,j :: INT
      rij, a_i,a_j, r_i, r_j, d,rr,damping_factor :: REAL

      res = ZERO
      d = 20.0d0

      ! Loop over pairs
      do i = 1,.dim

         a_i = ATOM::Grimme06_a_6_dispersion_coeff(self(i))
         r_i = ATOM::Grimme06_r_0_dispersion_coeff(self(i))

         do j = 1,atom.dim

            a_j = ATOM::Grimme06_a_6_dispersion_coeff(atom(j))
            r_j = ATOM::Grimme06_r_0_dispersion_coeff(atom(j))

            rr = (r_i + r_j)
            rij   = self(i).bond_distance_to(atom(j))
            damping_factor = (ONE / (ONE + exp(-d * (rij/(rr) - ONE))))
            res = res - (a_i*a_j/rij**6 * damping_factor)

         end

      end

   end

   dispersion_energy(atom) result (res)
   ! Return the dispersion energy from various formula.
   ! Refs?
      self :: IN
      atom :: VEC{ATOM}, IN
      res :: REAL

      e1, e2, edisp :: REAL
      n1, n2 :: INT
      i :: INT
      s6, rs6, s18, rs18, alp :: REAL

      coords :: MAT{REAL}@
      atomic_numbers :: VEC{INT}@
      version :: INT
      type(dftd3_calc) calc
      type(dftd3_input) input
      n1 = .dim
      n2 = atom.dim
      allocate(coords(3, n1 + n2))
      allocate(atomic_numbers(n1 + n2))
      ! Versions:
      ! 6: DFT-D3 with Becke-Johnson damping parameters
      ! 5: DFT-D3 with zero damping parameters
      ! 4: DFT-D3 with Becke-Johnson finite-damping, variant 2 with their radii
      ! 3: DFT-D3 with no damping
      ! 2: DFT-D2
      version = 4

      ! include 3 body terms
      input%threebody = FALSE

      ! Numerical gradients
      input%numgrad = FALSE

      ! Cutoffs (should parameterize these)
      !input%cutoff = sqrt(9000.0d0)
      !input%cutoff_cn = sqrt(1600.0d0)

      call dftd3_init(calc, input)
      ! D2
!     rs6 = 1.0d0
!     s18 = 0.0d0
!     alp = 20.0d0

      ! hf
    ! s6 = 1.0 
    ! rs6 =0.3385
    ! s18 =0.9171
    ! rs18=2.8830

      ! b3lyp
      s6   = 1.0 
      rs6  = 0.3981
      s18  = 1.9889
      rs18 = 4.4211
      alp  = ZERO ! Remove warning

      call dftd3_set_params(calc, [s6, rs6, s18, rs18, alp], version)

      atomic_numbers = [self(:).atomic_number, atom(:).atomic_number]

      do i = 1,n1
          coords(:, i) = self(i).position
      end do

      do i = 1,n2
          coords(:, i+n1) = atom(i).position
      end do

      edisp = ZERO
      e1 = ZERO
      e2 = ZERO
      call dftd3_dispersion(calc, coords, atomic_numbers, edisp)
      call dftd3_dispersion(calc, coords(:,1:n1), atomic_numbers(1:n1), e1)
      call dftd3_dispersion(calc, coords(:,n1+1:n1+n2),&
                            atomic_numbers(n1+1:n1+n2), e2)

      res = edisp - e2 - e1
   end

   polarization_energy(F_sq, use_charged_values) result (res) !::: PURE
   ! Return simplified polarization energy
   ! Uses atomic polarizabilties from Thakkar and Lupinetti (2006)
      self :: IN
      F_sq :: VEC{REAL}, IN
      res :: REAL
      use_charged_values :: BIN, IN, optional

   ENSURE(self.has_all_Thakkar_atomic_polarizabilities,"self: missing Grimme a coefficients")

      i :: INT
      polarizability :: REAL

      res = ZERO
      do i = 1,.dim
         polarizability = ATOM::Thakkar_atomic_dipole_polarizability(self(i), use_charged_values)
         res = res + polarizability * F_sq(i)
      end

      res = -HALF * res


   end

   has_all_Spackman86_a_coeffs result (res) ::: pure
   ! Return TRUE if "self" has all dispersion coefficients.
      self :: IN
      res :: BIN

      res = all(ATOM::Spackman86_a_6_dispersion_coeff(self)/=ZERO)

   end

   has_all_Spackman86_b_c_coeffs result (res) ::: pure
   ! Return TRUE if "self" has all repulsion coefficients.
      self :: IN
      res :: BIN

      has_b,has_c :: BIN

      has_b = all(ATOM::Spackman86_b_repulsion_coeff(self)/=ZERO)
      has_c = all(ATOM::Spackman86_c_repulsion_coeff(self) /=ZERO)
      res = has_b AND has_c

   end

   has_all_Grimme06_a_coeffs result (res) ::: pure
   ! Return TRUE if "self" has all dispersion coefficients.
      self :: IN
      res :: BIN

      res = all(ATOM::Grimme06_a_6_dispersion_coeff(self)/=ZERO)

   end

   has_all_Thakkar_atomic_polarizabilities result (res) ::: pure
   ! Return TRUE if "self" has all atomic polarizabilities
      self :: IN
      res :: BIN

      res = all(ATOM::Thakkar_atomic_dipole_polarizability(self)/=ZERO)

   end

!  =====================================
!  Set anamalous dispersion coefficients
!  =====================================

!   set_dispersion_coefficients(wavelength)
!   ! set the anamalous dispersion coefficients at a certain
!   ! "wavelength" in bohr.
!      self :: inout
!      wavelength :: real, in
!
!      a :: int 
!
!      do a = 1,.dim
!         self(a).set_dispersion_coefficient(wavelength)
!      end
!
!   end

   set_tabular_dispersion ::: PURE
   ! set the anamalous dispersion coefficients enetered by the user in
   ! the table.
      self :: INOUT

      a :: INT

      do a = 1,.dim
         self(a).set_tabular_dispersion
      end

   end

!   has_all_dispersion result (res) ::: PURE
!   ! Return TRUE if all the elements in the unique atom list
!   ! have disperesion coefficient entries in the table.
!      self :: IN
!      res :: BIN
!
!      a :: INT
!
!      ! Any without?
!      res = TRUE
!      do a = 1,.dim
!         res = self(a).has_dispersion
!         if (NOT res) exit
!      end
!
!   end

!   has_part_tabular_dispersion result (res) ::: PURE
!   ! Return TRUE if nether all nor none of the elements in the unique
!   ! atom list have dispresion coefficient entries in the table.
!      self :: IN
!      res :: BIN
!
!      all,none :: BIN
!
!      all  = .has_all_tabular_dispersion
!      none = .has_no_tabular_dispersion
!      res  = (NOT all) AND (NOT none)
!
!   end

!   has_no_tabular_dispersion result (res) ::: PURE
!   ! Return TRUE if all of the elements in the unique atom list have
!   ! *no* disperesion coefficient entries in the table. No means
!   ! "none" here.
!      self :: IN
!      res :: BIN
!
!      n_kind,u :: INT
!      ulist :: VEC{INT}*
!
!      ! Unique atom list
!      n_kind = maxval(self(:).kind)
!      ulist.create(n_kind)
!      .make_unique_atom_list(ulist)
!
!      ! Any with
!      res = TRUE
!      do u = 1,n_kind
!         res = NOT self(ulist(u)).has_tabular_dispersion
!         if (res) exit
!      end
!
!      ! Clean
!      ulist.destroy
!
!   end

!   has_all_tabular_dispersion result (res) ::: PURE
!   ! Return TRUE if all the elements in the unique atom list
!   ! have disperesion coefficient entries in the table.
!      self :: IN
!      res :: BIN
!
!      n_kind,u :: INT
!      ulist :: VEC{INT}*
!
!      ! Unique atom list
!      n_kind = maxval(self(:).kind)
!      ulist.create(n_kind)
!      .make_unique_atom_list(ulist)
!
!      ! Any without?
!      res = TRUE
!      do u = 1,n_kind
!         res = self(ulist(u)).has_tabular_dispersion
!         if (NOT res) exit
!      end
!
!      ! Clean
!      ulist.destroy
!
!   end

   get_dispersion_correction(Fa,k_pts,rf)
   ! Adds the anomalous dispersion correction for every atom in "Fa"
   ! for a set of supplied "k_pts" which are the list of user-supplied
   ! (hkl)'s multiplied by all the symmetry operations. "rf" are the
   ! repetition factors  (site symmetry factor). 
      self :: IN
      Fa :: VEC{CPX}, INOUT
      k_pts :: MAT{REAL}, IN
      rf :: VEC{REAL}, IN

      a :: INT

      ! Loop over all atoms.
      ! Note that H U_iso refinement will not affect this section of code.
      do a = 1,.dim
         self(a).get_dispersion(Fa,k_pts,rf(a))
      end

   end

   add_dispersion_correction(Fc,k_pts,rf)
   ! Adds the dispersion correction for every atom into "Fc" for a set
   ! of supplied "k_pts" which are the list of user-supplied (hkl)'s
   ! multiplied by all the symmetry operations. "rf" are the
   ! repetition factors  (site symmetry factor). 
      self :: IN
      Fc :: VEC{CPX}, INOUT
      k_pts :: MAT{REAL}, IN
      rf :: VEC{REAL}, IN

      a :: INT

      ! Loop over all atoms.
      ! Note that H U_iso refinement will not affect this section of code.
      do a = 1,.dim
         self(a).add_dispersion(Fc,k_pts,rf(a))
      end

   end

!  ================================================
!  Position derivatives of bonds, distances, angles
!  ================================================

   bond_distance_deriv(a,b,deriv)
   ! Return the bond distance derivatives "deriv" wrt cartesian
   ! positions between atoms "a" and "b". The bond vector is rb - ra
      a,b :: INT, IN
      deriv :: VEC{REAL}(6)

      rab :: VEC{REAL}(3)
      dab :: REAL

      ! Vector rab and (inverse) length
      rab = self(b).position - self(a).position
      dab = sqrt(rab(1)*rab(1) + rab(2)*rab(2) + rab(3)*rab(3))
      dab = ONE/dab

      ! Derivative
      deriv(1:3) = -rab*dab ! wrt a
      deriv(4:6) =  rab*dab ! wrt b

   end

   bond_angle_deriv(a,b,c,deriv,abc_colinear)
   ! Return the bond angle derivatives "deriv" between atoms "a" , "b"
   ! and "c".  The central atom is "b". The angle is calculated as
   ! arccos(nba.nbc). See Tuzun et al (2000) J. Comp. Chem 21 p.
   ! 553-561 equation (6).
      a,b,c :: INT
      deriv :: VEC{REAL}(9)
      abc_colinear :: BIN, OUT, optional

      rba,rbc,rx,ry :: VEC{REAL}(3)
      dba,dbc,cs,sn :: REAL

      if (present(abc_colinear)) abc_colinear = FALSE

      ! Vectors
      rba = self(a).position - self(b).position
      rbc = self(c).position - self(b).position

      ! Get lengths and normalise
      dba = ONE/rba.norm; rba = rba*dba
      dbc = ONE/rbc.norm; rbc = rbc*dbc

      ! sin part
      cs = dot_product(rba,rbc)
      sn = sqrt((ONE-cs)*(ONE+cs))
      if (abs(sn)<TOL(5)) then
         deriv = ZERO
         if (present(abc_colinear)) abc_colinear = TRUE
         return
      else
         sn = ONE/sn
      end

      ! I checked the formula below myself

      ! Derivtive wrt c: see (6b)
      ! NOTE: this equation is actually -Nabla1
      rx.to_cross_product_of(rbc,rba)
      ry.to_cross_product_of(rba,rx)
      deriv(1:3) = ry*dba

      ! Derivative wrt a: see (6a)
      ! NOTE: this equation is actually Nabla3
      rx.to_cross_product_of(rba,rbc)
      ry.to_cross_product_of(rbc,rx)
      deriv(7:9) = ry*dbc

      ! Derivative wrt b: use translational invariance
      deriv(4:6) = - deriv(1:3) - deriv(7:9)

      ! Divide by sin: see (6c)
      deriv = -sn*deriv

   end

   torsion_angle_deriv(a,b,c,d,deriv,abc_colinear,bcd_colinear)
   ! Return the torsion angle derivative "deriv" between atoms "a",
   ! "b", "c" and "d". NOTE: If the result is -ONE, either a--b--c or
   ! b--c--d are colinear, and the variables "abc_colinear" and
   ! "bcd_colinear" are set.  See Tuzun et al (2000) J. Comp. Chem 21
   ! p. 553-561 equation (9).
      a,b,c,d :: INT, IN
      deriv :: VEC{REAL}(12)
      abc_colinear,bcd_colinear :: BIN, optional, OUT

      rba,rcb,rdc,tba,tdc :: VEC{REAL}(3)
      dba,dcb,ddc, sin_abc,sin_bcd,cos_abc,cos_bcd, cc,bb :: REAL

      if (present(abc_colinear)) abc_colinear = FALSE
      if (present(bcd_colinear)) bcd_colinear = FALSE

      ! Vectors point from d -> c -> b -> a
      rba = self(a).position - self(b).position
      rcb = self(b).position - self(c).position
      rdc = self(c).position - self(d).position

      ! Lengths and normalise
      dba = rba.norm; rba = rba/dba
      dcb = rcb.norm; rcb = rcb/dcb
      ddc = rdc.norm; rdc = rdc/ddc

      ! Normals to planes
      tba.to_cross_product_of(rba,rcb)
      tdc.to_cross_product_of(rdc,rcb)

      ! Collinear test
      if (abs(tba.norm)<TOL(5)) then
         deriv = ZERO
         if (present(abc_colinear)) abc_colinear = TRUE
         return
      end
      if (abs(tdc.norm)<TOL(5)) then
         deriv = ZERO
         if (present(bcd_colinear)) bcd_colinear = TRUE
         return
      end

      ! sin's and cos's
      sin_abc = ONE/tba.norm
      sin_bcd = ONE/tdc.norm
      cos_abc = -dot_product(rba,rcb)
      cos_bcd = -dot_product(rcb,rdc)


      ! Gradient's
      deriv( 1: 3) = -tba*sin_abc*sin_abc/dba    ! wrt a: see (9a)
      deriv(10:12) = -tdc*sin_bcd*sin_bcd/ddc    ! wrt d: see (9b)
      cc = dba*cos_abc/dcb - ONE                 ! wrt b: see (9d)
      bb = ddc*cos_bcd/dcb
      deriv( 4: 6) = cc*deriv(1:3) - bb*deriv(10:12)
      deriv( 7: 9) = -deriv(1:3)-deriv(4:6)-deriv(10:12)

   end

!  ========================
!  Size information methods
!  ========================

   no_of_electrons result (res) ::: PURE
   ! If the atom list is *not* a single explicit "El" electron:
   ! . Return the number of electrons in the atom list assuming
   !   that it is *neutrally charged*. Any explicit "El" electrons
   !   are ignored i.e. they have no electrons.
   ! . Else return 1 ... the explicit "El" electron is assumed to be
   !   surrounded by one (beta) electron. This ensures a good initial
   !   guess is obtained for promolecule guess SCF calculations.
      self :: IN
      res :: INT

   ENSURE(.dim>0,"zero size atom list")

      res = VEC{INT}:sum_elements(self(:).atomic_number)

   end

   no_of_occupied_NAOs(tol) result (res) ::: PURE
   ! Returns the number of non-zero occupied NAOs. For this purpose,
   ! zero is defined to be "tol" if present, or 1/14. See ROBY.
      self :: IN
      tol :: REAL, optional, IN
      res :: INT

   ENSURE(self(1).NAO_occupations.associated,"no ANO occupations")

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).no_of_occupied_NAOs(tol)
      end

   end

   no_of_occupied_ANOs(ANOkind,tol) result (res) ::: PURE
   ! Returns the number of non-zero occupied atomic natural orbitals. For this
   ! purpose, zero is defined to be "tol" if present, or TOL(7) otherwise
      self :: IN
      ANOkind :: STR, optional, IN
      tol :: REAL, optional, IN
      res :: INT

   ENSURE(self(1).occupation_numbers.associated,"no occupation numbers")

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).no_of_occupied_NOs(ANOkind,tol)
      end

   end

!  ==============================
!  Basis size information methods
!  ==============================

   no_of_shells result (res) ::: pure
   ! Work out and return the number of gaussian shells in the basis
   ! set for the molecule
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).basis.shell.dim
      end

   end

!   n_shell result (res) ::: pure
!   ! Work out and return the number of gaussian shells in the basis set for the
!   ! molecule
!      self :: IN
!      res :: INT
!
!      a :: INT
!
!      res = 0
!      do a = 1,.dim
!         res = res + self(a).basis.shell.dim
!      end
!
!   end

   no_of_shell_pairs result (res) ::: PURE
   ! Return the number of shell pairs in the concatenated  basis set
      self :: IN
      res :: INT

      n_shell :: INT

      n_shell = .no_of_shells
      ENSURE(n_shell<=sqrt(TWO)*(huge(1))**HALF,"too many shells")

      res = n_shell*(n_shell+1)/2

   end

   no_of_shell_quartets result (res) ::: PURE
   ! Return the number of shell quartets in the b concatenated asis set 
   ! Note, "res" will die at 22    shells for integer(2).
   !       "res" will die at 361   shells for integer(4).
   !       "res" will die at 92681 shells for integer(8).
      self :: IN
      res :: INT

      n_pairs :: INT

      n_pairs = .no_of_shell_pairs
      ENSURE(n_pairs<=sqrt(TWO)*(huge(1))**HALF,"too many shells")

      res = n_pairs*(n_pairs+1)/2

   end

   no_of_primitive_shells result (res) ::: pure
   ! Work out and return the number of primitive gaussian shells in
   ! the concatenated basis sets
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_primitive_shells
      end

   end

   no_of_basis_functions result (res) ::: pure
   ! Work out and return the number of basis functions in the concatenated
   ! basis set for the atom list.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_basis_functions
      end

   end

   no_of_sph_basis_functions result (res) ::: pure
   ! Work out and return the number of spherical basis functions in
   ! the concatenated basis set for the atom list.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_sph_basis_functions
      end

   end

!   n_bf result (res) ::: pure
!   ! Work out and return the number of basis functions in the concatenated
!   ! basis set for the atom list.
!      self :: IN
!      res :: INT
!
!      a :: INT
!
!      res = 0
!      do a = 1,.dim
!         res = res + self(a).basis.n_bf
!      end
!
!   end

   no_of_primitives result (res) ::: pure
   ! Work out and return the number of primitives in the concatenated
   ! basis sets.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_primitives
      end

   end

   no_of_sph_primitives result (res) ::: pure
   ! Work out and return the number of spherical primitives in the
   ! concatenated basis sets.
      self :: IN
      res :: INT

      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_sph_primitives
      end

   end

!   n_prim result (res) ::: pure
!   ! Work out and return the number of primitives in the concatenated
!   ! basis sets.
!      self :: IN
!      res :: INT
!
!      a :: INT
!
!      res = 0
!      do a = 1,.dim
!         res = res + self(a).basis.n_prim
!      end
!
!   end

!  ===============================
!  Basis set existence information
!  ===============================

   bases_are_resolved result (res) ::: template
   ! Return TRUE if all basis sets are associated AND their shell list
   ! parts are also associated, dummy-atoms excepted
      res :: BIN

      a :: INT

      res = TRUE

      do a = 1,.dim

         if (self(a).TEST?.is_created_and_resolved) cycle
         if (self(a).has_a_dummy_label) cycle

         res = FALSE
         exit

      end

   end

   bases_are_resolved result (res) ::: get_from(VEC{ATOM}:bases_are_resolved, TEST?=>basis)
   ! Return TRUE if all basis sets are associated AND their shell list
   ! parts are also associated, dummy-atoms excepted
   end

   slaterbases_are_resolved result (res) ::: get_from(VEC{ATOM}:bases_are_resolved, TEST?=>slaterbasis)
   ! Return TRUE if all basis sets are associated AND their shell list
   ! parts are also associated, dummy-atoms excepted
   end

   coppensbases_are_resolved result (res) ::: get_from(VEC{ATOM}:bases_are_resolved, TEST?=>coppensbasis)
   ! Return TRUE if all basis sets are associated AND their shell list
   ! parts are also associated, dummy-atoms excepted
   end

   bases_are_all_labeled result (res) ::: template
   ! Return TRUE if all basis set labels exist (i.e. are not blank)
   ! Note: If a dummy atom has a basis it should have a label
      res :: BIN

      a :: INT

      res = TRUE

      do a = 1,.dim

         if (self(a).TEST?.is_created_and_has_label) cycle
         if (self(a).has_a_dummy_label) cycle

         res = FALSE
         exit

      end

   end

   bases_are_all_labeled result (res) ::: get_from(VEC{ATOM}:bases_are_all_labeled, TEST?=>basis)
   ! Return TRUE if all basis set labels exist (i.e. are not blank)
   ! Note: If a dummy atom has a basis it should have a label
   end

   slaterbases_are_all_labeled result (res) ::: get_from(VEC{ATOM}:bases_are_all_labeled, TEST?=>slaterbasis)
   ! Return TRUE if all basis set labels exist (i.e. are not blank)
   ! Note: If a dummy atom has a basis it should have a label
   end

   coppensbases_are_all_labeled result (res) ::: get_from(VEC{ATOM}:bases_are_all_labeled, TEST?=>coppensbasis)
   ! Return TRUE if all basis set labels exist (i.e. are not blank)
   ! Note: If a dummy atom has a basis it should have a label
   end


   get_distance_to(atomvec,distance,t1,t2)
   ! Calculates the shortest distance between an atom in self and one in
   ! atomvec.  Will set the distance to zero if calculated to less than 10^-6.
   ! If present, t1 and t2 are the indices of the two closest atoms.
      self :: IN
      atomvec :: VEC{ATOM}, IN
      self :: IN
      distance :: REAL
      t1,t2 :: INT, optional, OUT

   ENSURE(present(t1) EQV present(t2),"need 0 or 2 optional arguments")

      dist :: REAL
      i,j,dim1,dim2 :: INT
      difference :: VEC{REAL}(3)

      dim1 = .dim
      dim2 = size(atomvec)

      ! Do the first pair explicitly to set a starting distance.
      ! We also work with distance^2 until the end - saves computation.
      difference = self(1).position(:) - atomvec(1).position(:)
      distance   = dot_product(difference,difference)

      do i = 1,dim1
      do j = 1,dim2

         difference = self(i).position(:) - atomvec(j).position(:)
         dist       = dot_product(difference,difference)

         if (dist < TOL(6)) dist = ZERO

         if (dist < distance) then
            distance = dist
            if (present(t1)) then
               t1 = i
               t2 = j
            end
         end

      end
      end

      distance = sqrt(distance)
   end

   get_distance_to(pos,distance,t1)
   ! Calculates the shortest distance of "pos" to an atom in self.
   ! If present, t1 is the index of the closest atom.
      self :: IN
      pos :: VEC{REAL}(3), IN
      distance :: REAL, OUT
      t1 :: INT, optional, OUT

      dist :: REAL
      difference :: VEC{REAL}(3)
      i :: INT

      ! Do the first pair explicitly to set a starting distance.
      ! We also work with distance^2 until the end - saves computation.
      difference = self(1).position(:) - pos(:)
      distance   = dot_product(difference,difference)

      do i = 1, .dim

         difference = self(i).position(:) - pos(:)
         dist       = dot_product(difference,difference)

         if (dist < TOL(6)) dist = ZERO

         if (dist < distance) then
            distance = dist
            if (present(t1)) t1=i
         end

      end

      distance = sqrt(distance)

   end

   same_as(atomvec) result (res)
   ! Returns true if the two atomvecs contain the same atoms, though maybe in a
   ! different order.  Checks atomic number and position of each atom, but not
   ! the basis sets.
      atomvec :: VEC{ATOM}, IN
      res :: BIN
      matched :: VEC{BIN}(size(self))
      match_pos,match_kind,match :: BIN
      n,q,dim :: INT

      res = FALSE
      dim = .dim
      if (dim/=size(atomvec)) return ! different number of atoms in each.
      matched = FALSE

      do n = 1, dim
         match=FALSE
         do q = 1, dim
            match_kind =  (self(n).atomic_number == atomvec(q).atomic_number)
            match_pos  =  self(n).position.same_as( atomvec(q).position, TOL(3) )
            if (match_pos AND match_kind AND (NOT matched(q))) then
               matched(q) = TRUE
               match = TRUE
               exit
            end
         end
         if (NOT match) return ! atom n doesn't have a match.
      end

      do q = 1, dim           ! If not all of q are matched then atomvecs not same.
         if (NOT matched(q)) return
      end

      res = TRUE

   end

!  =============
!  Crystal stuff
!  =============

   translate_by(v) ::: PURE
   ! Translate self by vector.
      self :: INOUT
      v :: VEC{REAL}(3), IN

      pos :: VEC{REAL}(3)
      a :: INT

      if (v.is_zero) return

      do a = 1,.dim
         pos = self(a).position + v
         self(a).set_position(pos)
      end

   end

   rotate_by(matrix) ::: PURE
   ! Rotate the atom positions by the rotation matrix
      self :: INOUT
      matrix :: MAT{REAL}(3,3), IN

      .rotate_positions_by(matrix)
      .rotate_ADP_tensors_by(matrix)

   end

   rotate_positions_by(matrix) ::: PURE
   ! Rotate the atom positions by the rotation matrix
      self :: INOUT
      matrix :: MAT{REAL}(3,3), IN

      a :: INT
      pos :: VEC{REAL}(3)

      do a = 1,.dim
         pos.to_product_of(matrix,self(a).position)
         self(a).set_position(pos)
      end

   end

   rotate_ADP_tensors_by(matrix) ::: PURE
   ! Rotate the atom ADP (thermal) tensors by the rotation matrix:
   ! this is the rotation matrix which transforms the cartesian
   ! position to a new position.
   ! WARNING: does not do ADP3 and ADP4 yet
      self :: INOUT
      matrix :: MAT{REAL}(3,3), IN

      a :: INT
      ADP :: MAT{REAL}(3,3)

      do a = 1,.dim
         self(a).ADP_tensor.back_transform_to(ADP,matrix)
         self(a).set_ADP_tensor(ADP)
      end

   end

   change_ADP_axis_system_to(axis_system,cell)
   ! Convert all ADP tensors into the desired "axis_system".
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN

      a :: INT

      do a = 1,.dim
         self(a).change_ADP_axis_system_to(axis_system,cell)
      end

   end

   default_multiplicity result (res)
   ! Return the default multiplicity
      self :: IN
      res :: REAL

      if (.dim==1) then
         res = self(1).ground_state_multiplicity
      else
         res = mod(.no_of_electrons,2) + 1
      end

   end

   translate_group(g,v) ::: PURE
   ! Translate group "g" by vector "v".
      self :: INOUT
      g :: INT, IN
      v :: VEC{REAL}(3), IN

      pos :: VEC{REAL}(3)
      a :: INT

      if (v.is_zero) return
      if (all(self(:).group/=g)) return

      do a = 1,.dim

         if (self(a).group/=g) cycle

         pos = self(a).position + v
         self(a).set_position(pos)

      end

   end

!  ====
!  Dump
!  ====

   dump(object_name) ::: get_from(VEC{OBJECT})
   ! Dump a vector object
   end

   dmpp(object_name) ::: get_from(VEC{OBJECT})
   ! Dump a vector pointer object
   end

!  ==============
!  Output methods
!  ==============

   put
   ! Output atom information, without full basis set info
      self :: IN

      stdout.flush
      stdout.text("=====================")
      stdout.text("Atom list information")
      stdout.text("=====================")
      stdout.flush

      stdout.show("Chemical Formula       =",trim(.chemical_formula(with_spaces=TRUE)))
      stdout.show("No of atoms            =",size(self))
      stdout.show("No of electrons        =",.no_of_electrons)

      if (.has_residue_codes) then; .put_mm_info
      else;                         .put_coordinate_info
      end

      if (.has_restraints)          .put_restraint_atoms

   end

   put_list
   ! Output atom information,

      a :: INT
      title :: STR

      stdout.flush
      stdout.text("=====================")
      stdout.text("Atom list information")
      stdout.text("=====================")
      stdout.flush

      stdout.show("Chemical Formula       =",trim(.chemical_formula(with_spaces=TRUE)))
      stdout.show("No of atoms            =",size(self))
      stdout.show("No of electrons        =",.no_of_electrons)
      stdout.flush

      do a = 1,.dim
         title = "Atom "//trim(a.to_str)
         stdout.text(trim(title))
         stdout.text(repeat("=",len_trim(title)))
         self(a).put
         stdout.flush
      end

   end

   put_coordinate_info
   ! Output atom coordinate information, including bond lengths, angles
      self :: IN

      .put_coordinates

      if (.has_nonzero_ADP_tensors) &
         .put_ADPs

      if (self(1).xray_dispersion_entered) &
         .put_dispersion_factors

      .put_bond_length_table
      .put_bond_angle_table
      .put_torsion_angle_table

   end

!  ======================
!  Coordinate information
!  ======================

   put_coordinates(no_header)
   ! Output the atom coordinates information.
      self :: IN
      no_header :: BIN, IN, optional

      if      (.has_disorder) then; .put_coords_disorder_y(no_header)
      else if (.has_groups)   then; .put_coords_groups_y(no_header)
      else;                         .put_coords(no_header)
      end

   end

   put_coords(no_header) ::: private
   ! Output the atom coordinates information without disorder
      self :: IN
      no_header :: BIN, IN, optional

      fac :: REAL
      xyz,err :: MAT{REAL}*
      Z  :: VEC{REAL}*
      lab,ID :: VEC{STR}*
      table :: VEC{TABLE_COLUMN}*
      la,lb,ka,kb :: INT
      cartesian,header,has_unique_labels :: BIN

      header = TRUE
      if (present(no_header)) header = NOT no_header

      ! Axis system
      cartesian = self(1).pos_axis_system=="cartesian"

      ! Use angstroms
      if (cartesian) then
         fac = STR:conversion_factor("angstrom")
      else
         fac = ONE
      end

      ! Table column data
      lab.create(.dim)
      ID.create(.dim)
      Z.create(.dim)
      xyz.create(.dim,3)
      err.create(.dim,3)

      ! Get table column data
      lab = self.label
      ID  = self.tag
      Z   = self.nuclear_charge
      .put_pos_vector_to(xyz,fac)
      .put_pos_errors_to(err,fac)

      ! Title
      if (header) then
      stdout.flush
      stdout.flush
      stdout.text("================")
      stdout.text("Atom coordinates")
      stdout.text("================")
      end

      ! Has unique labels?
      .get_1st_repeated_labels(la,lb)
      .get_1st_repeated_xtal_kinds(ka,kb)
      has_unique_labels = (la==0 AND ka==0) OR .dim==1

      ! Unique labels?
      if (has_unique_labels) then

         if (header) then
         if (NOT cartesian) then
         stdout.flush
         stdout.text(". The coordinates are referred to cell axes")
         end
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush
         end

         ! Table headings
         table.create(5)
         table(1).set_heading("ID")
         table(2).set_heading("Z")
         table(2).set_subheading("/au")
         table(2).set_real_precision(1)
         table(3).set_heading("- x -")
         table(4).set_heading("- y -")
         table(5).set_heading("- z -")
         if (cartesian) then
         table(4).set_subheading("/A")
         end

         ! Set table column data
         table(1).set_values(lab)
         table(2).set_values(Z)
         if (NOT .has_nonzero_pADP2_errors) then
         table(3).set_values(xyz(:,1))
         table(4).set_values(xyz(:,2))
         table(5).set_values(xyz(:,3))
         else
         table(3).set_values_and_errors(xyz(:,1),err(:,1))
         table(4).set_values_and_errors(xyz(:,2),err(:,2))
         table(5).set_values_and_errors(xyz(:,3),err(:,3))
         end

      else ! Not unique labels

         if (header) then
         if (NOT cartesian) then
         stdout.flush
         stdout.text(". The coordinates are referred to cell axes")
         end
         stdout.flush
         stdout.text(". Unique atom labels were not set for each atom.")
         stdout.text("  Therefore, unique ID tags are provided.")
         if (la/=0) then
         stdout.flush
         stdout.text(". First repeated labels are for atoms "//trim(la.to_str)//" and "//trim(lb.to_str)//".")
         end
         if (ka/=0) then
         stdout.flush
         stdout.text(". First repeated xtal kinds are for atoms "//trim(ka.to_str)//" and "//trim(kb.to_str)//".")
         end
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush
         end

         ! Table headings
         table.create(6)
         table(1).set_heading("Label")
         table(2).set_heading("ID")
         table(2).set_subhead("tag")
         table(3).set_heading("Z")
         table(3).set_subheading("/au")
         table(3).set_real_precision(1)
         table(4).set_heading("- x -")
         table(5).set_heading("- y -")
         table(6).set_heading("- z -")
         if (cartesian) then
         table(5).set_subheading("/A")
         end

         ! Set table column data
         table(1).set_values(lab)
         table(2).set_values(ID)
         table(3).set_values(Z)
         if (NOT .has_nonzero_pADP2_errors) then
         table(4).set_values(xyz(:,1))
         table(5).set_values(xyz(:,2))
         table(6).set_values(xyz(:,3))
         else
         table(4).set_values_and_errors(xyz(:,1),err(:,1))
         table(5).set_values_and_errors(xyz(:,2),err(:,2))
         table(6).set_values_and_errors(xyz(:,3),err(:,3))
         end

      end

      ! Make the table
      table.put

      ! Clean
      table.destroy
      err.destroy
      xyz.destroy
      Z.destroy
      ID.destroy
      lab.destroy

   end

   put_coords_disorder_y(no_header) ::: private
   ! Output the atom coordinates information with disorder
      self :: IN
      no_header :: BIN, IN, optional

      fac :: REAL
      xyz :: MAT{REAL}*
      Z,occ  :: VEC{REAL}*
      lab,ID :: VEC{STR}*
      grp :: VEC{INT}*
      table :: VEC{TABLE_COLUMN}*
      la,lb,ka,kb :: INT
      cartesian,header,has_unique_labels :: BIN

      header = TRUE
      if (present(no_header)) header = NOT no_header

      ! Axis system
      cartesian = self(1).pos_axis_system=="cartesian"

      ! Use angstroms
      if (cartesian) then
         fac = STR:conversion_factor("angstrom")
      else
         fac = ONE
      end

      ! Title
      if (header) then
      stdout.flush
      stdout.flush
      stdout.text("================")
      stdout.text("Atom coordinates")
      stdout.text("================")
      end

      ! Table column data
      lab.create(.dim)
      ID.create(.dim)
      Z.create(.dim)
      grp.create(.dim)
      occ.create(.dim)
      xyz.create(.dim,3)

      ! Get table column data
      lab = self.label
      ID  = self.tag
      Z   = self.nuclear_charge
      grp = self.site_disorder_group
      occ = self.site_occupancy
      .put_coordinates_to(xyz,positions_as_rows=TRUE)
      xyz = xyz * fac

      ! Has unique labels?
      .get_1st_repeated_labels(la,lb)
      .get_1st_repeated_xtal_kinds(ka,kb)
      has_unique_labels = (la==0 AND ka==0) OR .dim==1

      ! Unique labels?
      if (has_unique_labels) then

         if (header) then
         if (NOT cartesian) then
         stdout.flush
         stdout.text(". The coordinates are referred to cell axes")
         end
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush
         end

         ! Table headings
         table.create(7)
         table(1).set_heading("ID")
         table(2).set_heading("Z")
         table(2).set_subhead("/au")
         table(2).set_real_precision(1)
         table(3).set_heading("Group")
         table(3).set_subhead("#")
         table(4).set_heading("Site")
         table(4).set_subhead("occupancy")
         table(5).set_heading("- x -")
         table(6).set_heading("- y -")
         table(7).set_heading("- z -")
         if (cartesian) then
         table(6).set_subhead("/A")
         end

         ! Set table column data
         table(1).set_values(lab)
         table(2).set_values(Z)
         table(3).set_values(grp)
         table(4).set_values(occ)
         table(5).set_values(xyz(:,1))
         table(6).set_values(xyz(:,2))
         table(7).set_values(xyz(:,3))

      else ! Not unique labels

         if (header) then
         if (NOT cartesian) then
         stdout.flush
         stdout.text(". The coordinates are referred to cell axes")
         end
         stdout.flush
         stdout.text(". Unique atom labels were not set for each atom.")
         stdout.text("  Therefore, unique ID tags are provided.")
         if (la/=0) then
         stdout.flush
         stdout.text(". First repeated labels are for atoms "//trim(la.to_str)//" and "//trim(lb.to_str)//".")
         end
         if (ka/=0) then
         stdout.flush
         stdout.text(". First repeated xtal kinds are for atoms "//trim(ka.to_str)//" and "//trim(kb.to_str)//".")
         end
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush
         end

         ! Table headings
         table.create(8)
         table(1).set_heading("Label")
         table(2).set_heading("ID")
         table(2).set_subhead("tag")
         table(3).set_heading("Z")
         table(3).set_subhead("/au")
         table(4).set_real_precision(1)
         table(4).set_heading("Group")
         table(4).set_subhead("#")
         table(5).set_heading("Site")
         table(5).set_subhead("occupancy")
         table(6).set_heading("- x -")
         table(7).set_heading("- y -")
         table(8).set_heading("- z -")
         if (cartesian) then
         table(7).set_subhead("/A")
         end

         ! Set table column data
         table(1).set_values(lab)
         table(2).set_values(ID)
         table(3).set_values(Z)
         table(4).set_values(grp)
         table(5).set_values(occ)
         table(6).set_values(xyz(:,1))
         table(7).set_values(xyz(:,2))
         table(8).set_values(xyz(:,3))

      end

      ! Make the table
      table.put

      ! Clean
      table.destroy
      xyz.destroy
      occ.destroy
      grp.destroy
      Z.destroy
      ID.destroy
      lab.destroy

   end

   put_coords_groups_y(no_header) ::: private
   ! Output the atom coordinates with groups (no disorder)
      self :: IN
      no_header :: BIN, IN, optional

      fac :: REAL
      xyz :: MAT{REAL}*
      Z,occ  :: VEC{REAL}*
      lab,ID :: VEC{STR}*
      grp :: VEC{INT}*
      table :: VEC{TABLE_COLUMN}*
      la,lb,ka,kb :: INT
      cartesian,header,has_unique_labels :: BIN

      header = TRUE
      if (present(no_header)) header = NOT no_header

      ! Axis system
      cartesian = self(1).pos_axis_system=="cartesian"

      ! Use angstroms
      if (cartesian) then
         fac = STR:conversion_factor("angstrom")
      else
         fac = ONE
      end

      ! Title
      if (header) then
      stdout.flush
      stdout.flush
      stdout.text("================")
      stdout.text("Atom coordinates")
      stdout.text("================")
      end

      ! Table column data
      lab.create(.dim)
      ID.create(.dim)
      Z.create(.dim)
      grp.create(.dim)
      occ.create(.dim)
      xyz.create(.dim,3)

      ! Get table column data
      lab = self.label
      ID  = self.tag
      Z   = self.nuclear_charge
      grp = self.group
      occ = self.site_occupancy
      .put_coordinates_to(xyz,positions_as_rows=TRUE)
      xyz = xyz * fac

      ! Has unique labels?
      .get_1st_repeated_labels(la,lb)
      .get_1st_repeated_xtal_kinds(ka,kb)
      has_unique_labels = (la==0 AND ka==0) OR .dim==1

      ! Unique labels?
      if (has_unique_labels) then

         if (header) then
         if (NOT cartesian) then
         stdout.flush
         stdout.text(". The coordinates are referred to cell axes")
         end
         stdout.flush
         stdout.text(". This molecule has non trivial group indices, assigned")
         stdout.text("  explicitly or by CCDC connectivity criteria")
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush
         end

         ! Table headings
         table.create(6)
         table(1).set_heading("ID")
         table(2).set_heading("Z")
         table(2).set_subhead("/au")
         table(2).set_real_precision(1)
         table(3).set_heading("Grp")
         table(3).set_subhead("#")
         table(4).set_heading("- x -")
         table(5).set_heading("- y -")
         table(6).set_heading("- z -")
         if (cartesian) then
         table(5).set_subhead("/A")
         end

         ! Set table column data
         table(1).set_values(lab)
         table(2).set_values(Z)
         table(3).set_values(grp)
         table(4).set_values(xyz(:,1))
         table(5).set_values(xyz(:,2))
         table(6).set_values(xyz(:,3))

      else ! Not unique labels

         if (header) then
         if (NOT cartesian) then
         stdout.flush
         stdout.text(". The coordinates are referred to cell axes")
         end
         stdout.flush
         stdout.text(". This molecule has non trivial group indices, assigned")
         stdout.text("  explicity, or by CCDC connectivity criteria")
         stdout.flush
         stdout.text(". Unique atom labels were not set for each atom.")
         stdout.text("  Therefore, unique ID tags are provided.")
         if (la/=0) then
         stdout.flush
         stdout.text(". First repeated labels are for atoms "//trim(la.to_str)//" and "//trim(lb.to_str)//".")
         end
         if (ka/=0) then
         stdout.flush
         stdout.text(". First repeated xtal kinds are for atoms "//trim(ka.to_str)//" and "//trim(kb.to_str)//".")
         end
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush
         end

         ! Table headings
         table.create(7)
         table(1).set_heading("Label")
         table(2).set_heading("ID")
         table(2).set_subhead("tag")
         table(3).set_heading("Z")
         table(3).set_subhead("/au")
         table(4).set_real_precision(1)
         table(4).set_heading("Group")
         table(4).set_subhead("#")
         table(5).set_heading("- x -")
         table(6).set_heading("- y -")
         table(7).set_heading("- z -")
         if (cartesian) then
         table(6).set_subhead("/A")
         end

         ! Set table column data
         table(1).set_values(lab)
         table(2).set_values(ID)
         table(3).set_values(Z)
         table(4).set_values(grp)
         table(5).set_values(xyz(:,1))
         table(6).set_values(xyz(:,2))
         table(7).set_values(xyz(:,3))

      end

      ! Make the table
      table.put

      ! Clean
      table.destroy
      xyz.destroy
      occ.destroy
      grp.destroy
      Z.destroy
      ID.destroy
      lab.destroy

   end

   put_xyz_file(name, units)
   ! Output the coordinates in XYZ file format with "name" header
      self :: IN
      name :: STR, optional, IN
      units :: STR, optional, IN

      n,a :: INT
      filename, u :: STR
      pos :: VEC{REAL}(3)

      ! Filename
      filename = "geometry"
      if (present(name)) filename = name
      u = "angstroms"
      if (present(units)) u = units

      ! Redirect
      stdout.redirect(trim(filename)//".xyz")

      ! No. pf atoms
      n = .dim
      stdout.put(trim(n.to_str),width=3)
      stdout.flush

      ! Header
      stdout.put(trim(name),width=len_trim(name))
      stdout.flush

      ! Labels & coordinates
      do a = 1,n

         stdout.put(trim(self(a).chemical_symbol),width=3)
         pos = self(a).position
         stdout.put(pos(1).to_units(u),width=10,precision=5)
         stdout.put(pos(2).to_units(u),width=10,precision=5)
         stdout.put(pos(3).to_units(u),width=10,precision=5)
         stdout.flush

      end

      ! Revert
      stdout.revert

   end


   put_g09_input(name, units)
   ! Output the coordinates in XYZ file format with "name" header
      self :: IN
      name :: STR, optional, IN
      units :: STR, optional, IN

      n,a :: INT
      filename, u :: STR
      pos :: VEC{REAL}(3)

      ! Filename
      filename = "input"
      if (present(name)) filename = name
      u = "angstroms"
      if (present(units)) u = units

      ! Redirect
      stdout.redirect(trim(filename)//".gjf")

      ! No. pf atoms
      n = .dim
      stdout.text("#P B3LYP/6-31G(d,p) 6d 10f NoSymm FChk")
      stdout.flush
      ! Header
      stdout.text(trim(name))
      stdout.flush


      ! Labels & coordinates
      stdout.text("0 1")
      do a = 1,n

         stdout.put(trim(self(a).chemical_symbol),width=3)
         pos = self(a).position
         stdout.put(pos(1).to_units(u),width=10,precision=5)
         stdout.put(pos(2).to_units(u),width=10,precision=5)
         stdout.put(pos(3).to_units(u),width=10,precision=5)
         stdout.flush

      end

      stdout.flush
      ! Revert
      stdout.revert

   end



   put_pdb(pdbfile)
   ! Output the atoms in pdb file format to "pdbfile" (blame Birger)
      pdbfile :: TEXTFILE*

      i,in,ic,ip,len_code,len_pnum,element_len :: INT
      label,element_name,residue_number,code,three_letter_code,position_symbol,position_number :: STR

      ! Save PDB settings for later
      pdbfile.save

      ! Loop over atoms
      do i = 1,.dim

         ! The ATOM number
         pdbfile.put("ATOM",width=4)
         pdbfile.put(i,width=7)

         ! Start to analyze the atom label
         label = self(i).label
       ! print *,"label =",trim(label)

         ! Get start of atom index, hence the element name
         label.replace_all("(",'')
         label.replace_all(")",'')
         in = label.index_of_digit
         DIE_IF(in==0,"no atom index in atom label: "//trim(label))
         ! Get rid of left bracket
         element_name = label(1:in-1)
       ! print *,"in =",in
       ! print *,"element_name =",trim(element_name)

         ! Get start of residue code, hence the residue number
         ic = label(in:).index_of_nondigit
         DIE_IF(ic==0,"no residue code in atom label: "//trim(label))
         ic = ic + in - 1
         residue_number = label(in:ic-1)
       ! print *,"ic =",ic
       ! print *,"residue_number =",trim(residue_number)

         ! Get start of position symbol, hence residue code, position
         ! symbol and position number (could be blank)
         ! position symbols are alpha (a)
         ! position symbols are beta (b)
         ! position symbols are gamma (c,g)
         ! position symbols are delta (d)
         ! position symbols are epsilon (e)
         ! position symbols are nu (n)
         ! position symbols are terminal (t)
         ! position symbols are zeta (z)
         ! position symbols are peptide bond (')

         ip = label(ic:).index_of_character_in("'abcgdentz")
         if (ip/=0) then
            ip = ip + ic - 1
            code = label(ic:ip-1)
            position_symbol = label(ip:ip)
            position_number = label(ip+1:)
         else
            code = label(ic:)
            position_symbol = " "
            position_number = " "
         end
       ! print *,"ip =",ip
       ! print *,"code =",trim(code)
       ! print *,"position_symbol =",trim(position_symbol)
       ! print *,"position_number =",trim(position_number)

         ! Do some checks ...
         len_code = len_trim(code)
         DIE_IF(NOT (len_code==1 OR len_code==3),"residue code must be 1 or 3 characters: "//trim(label))
         len_pnum = len_trim(position_number)
         DIE_IF(len_pnum>1,"position number code cannot exceed 1 character: "//trim(label))
         if (position_number/=" ") then
         DIE_IF(NOT position_number.is_included_in("123456789"),"unknown position number: "//trim(label))
         end

         ! If the code is a one letter code, convert it
         if (len_code == 3) then
            select case (code)
               case ("UNK","AIB","IVA","WAT","EOH","TER","DLE","DVA","FOR","ETA")
               case ("ALA","ARG","GLN","GLY","VAL","LEU","ILE","SER","THR","CYS")
               case ("MET","PRO","HIS","ASN","GLU","ASP","PHE","TRP","TYR","LYS")
               case ("ACD","HSE","ACE","HYP","HYL","ALB","ALI","ABU","ARO","ORN")
               case ("ASX","PCA","BAS","SAR","BET","TAU","THY","GLX","HET")
               case default; DIE("unknown three letter residue code: "//trim(code))
            end
            three_letter_code = code
         else if (len_code == 1) then
            select case (code)
               case ("X"); three_letter_code = "UNK"
               case ("~"); three_letter_code = "WAT"
               case ("_"); three_letter_code = "EOH"
               case ("B"); three_letter_code = "DLE"
               case ("O"); three_letter_code = "DVA"
               case ("U"); three_letter_code = "AIB"
               case ("A"); three_letter_code = "ALA"
               case ("R"); three_letter_code = "ARG"
               case ("Q"); three_letter_code = "GLN"
               case ("G"); three_letter_code = "GLY"
               case ("V"); three_letter_code = "VAL"
               case ("L"); three_letter_code = "LEU"
               case ("I"); three_letter_code = "ILE"
               case ("J"); three_letter_code = "IVA"
               case ("S"); three_letter_code = "SER"
               case ("T"); three_letter_code = "THR"
               case ("C"); three_letter_code = "CYS"
               case ("M"); three_letter_code = "MET"
               case ("P"); three_letter_code = "PRO"
               case ("H"); three_letter_code = "HIS"
               case ("N"); three_letter_code = "ASN"
               case ("E"); three_letter_code = "GLU"
               case ("D"); three_letter_code = "ASP"
               case ("F"); three_letter_code = "PHE"
               case ("W"); three_letter_code = "TRP"
               case ("Y"); three_letter_code = "TYR"
               case ("K"); three_letter_code = "LYS"
               case ("Z"); three_letter_code = "TER"
               case default; DIE("unknown one letter residue code: "//trim(code))
            end
         else
            DIE("code must be one or three characters")
         end

         ! Print the new atom label from one read in
         pdbfile.tab(width=1)
         if (position_number==" ") then
         pdbfile.tab(width=1)
         else
         pdbfile.put(position_number,width=1,left=TRUE)
         end
         pdbfile.put(element_name,width=len_trim(element_name),left=TRUE)
         if (position_symbol.is_included_in("'abcgdentz")) then
         position_symbol.to_upper_case
         pdbfile.put(position_symbol,width=1,left=TRUE)
         pdbfile.tab(width=1)
         else
         pdbfile.tab(width=2)
         end
         element_len = len_trim(element_name)
         if (element_len == 1) then
         pdbfile.tab(width=1)
         end
         pdbfile.put(three_letter_code,width=3,left=TRUE)
         pdbfile.tab(width=2)
         pdbfile.put(residue_number,width=4)
         pdbfile.tab(width=4)
         pdbfile.set_real_precision(3)
         pdbfile.set_real_width(8)
         pdbfile.put(self(i).position(1).to_units("angstrom"))
         pdbfile.put(self(i).position(2).to_units("angstrom"))
         pdbfile.put(self(i).position(3).to_units("angstrom"))
         pdbfile.set_real_precision(2)
         pdbfile.set_real_width(6)
         pdbfile.put(self(i).site_occupancy)
         pdbfile.put(8*PI*PI*self(i).U_iso)
         pdbfile.put(self(i).chemical_symbol,width=12)
         pdbfile.flush

         ! Print Anisotropic U's if non-hydrogen
         if (self(i).atomic_number==1) cycle

         pdbfile.put("ANISOU",width=6)
         pdbfile.put(i,width=5)
         pdbfile.tab(width=1)
         if (position_number==" ") then
         pdbfile.tab(width=1)
         else
         pdbfile.put(position_number,width=1,left=TRUE)
         end
         pdbfile.put(element_name,width=len_trim(element_name),left=TRUE)
         if (position_symbol.is_included_in("'ABCGDENTZ")) then
         position_symbol.to_upper_case
         pdbfile.put(position_symbol,width=1,left=TRUE)
         pdbfile.tab(width=1)
         else
         pdbfile.tab(width=2)
         end
         element_len = len_trim(element_name)
         if (element_len == 1) then
         pdbfile.tab(width=1)
         end
         pdbfile.put(three_letter_code,width=3,left=TRUE)
         pdbfile.tab(width=2)
         pdbfile.put(residue_number,width=4)
         pdbfile.tab(width=2)
         pdbfile.set_int_width(7)

         ! Order for the ADP's .......
         ! u11 u22 u33 u12 u13 u23 XD-format
         ! u11 u22 u33 u12 u23 u13 SHELX
         ! u11 u22 u33 u13 u23 u12 PDB-format
         pdbfile.put(nint(self(i).ADP_tensor(1,1).to_units("angstrom^2")*10000))
         pdbfile.put(nint(self(i).ADP_tensor(2,2).to_units("angstrom^2")*10000))
         pdbfile.put(nint(self(i).ADP_tensor(3,3).to_units("angstrom^2")*10000))
         pdbfile.put(nint(self(i).ADP_tensor(1,3).to_units("angstrom^2")*10000))
         pdbfile.put(nint(self(i).ADP_tensor(2,3).to_units("angstrom^2")*10000))
         pdbfile.put(nint(self(i).ADP_tensor(1,2).to_units("angstrom^2")*10000))

         ! Last thing on line, chemical symbol
         pdbfile.put(self(i).chemical_symbol,width=8)

         ! Flush the line
         pdbfile.flush

      end
      pdbfile.unsave
   end


   put_coordinates_and_charges
   ! Output the atom coordinate information
      .put_coords_and_charges
      .put_coords_and_charges(angstrom=TRUE)
   end

   put_coords_and_charges(angstrom) ::: private
   ! Output the atom coordinates and charges
      angstrom :: BIN, optional
      i :: INT
      in_angstrom :: BIN
      in_angstrom = FALSE
      if (present(angstrom)) in_angstrom = angstrom
      stdout.flush
      if (NOT in_angstrom) then
      stdout.text("Atom list information:")
      else
      stdout.text("Atom list information (in angstrom):")
      end
      stdout.dash(int_fields=3,real_fields=4)
      stdout.put("#",int_width=TRUE)
      stdout.put("ID",int_width=TRUE)
      stdout.put("Z",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.put("charge")
      stdout.flush
      stdout.dash(int_fields=3,real_fields=4)
      do i = 1,.dim
         stdout.put(i)
         stdout.put(self(i).label,int_width=TRUE)
         stdout.put(self(i).nuclear_charge,int_width=TRUE)
         if (NOT in_angstrom) then
         stdout.put(self(i).position(1))
         stdout.put(self(i).position(2))
         stdout.put(self(i).position(3))
         else
         stdout.put(self(i).position(1).to_units("angstrom"))
         stdout.put(self(i).position(2).to_units("angstrom"))
         stdout.put(self(i).position(3).to_units("angstrom"))
         end
         stdout.put(self(i).charge)
         stdout.flush
      end
      stdout.dash(int_fields=3,real_fields=4)
   end


   put_kinds_and_groups
   ! Output the atom kinds and groups
      self :: IN

      lab,ID :: VEC{STR}*
      table :: VEC{TABLE_COLUMN}*
      Z,kd,mg,dg :: VEC{INT}*
      un :: VEC{BIN}*
      la,lb,ka,kb :: INT
      has_unique_labels :: BIN

      ! Table column data
      lab.create(.dim)
      ID.create(.dim)
      Z.create(.dim)
      kd.create(.dim)
      un.create(.dim)
      mg.create(.dim)
      dg.create(.dim)

      ! Get table column data
      lab = self.label
      ID  = self.tag
      Z   = self.atomic_number
      kd  = self.kind
      un  = self.is_unique_kind
      mg  = self.group
      dg  = self.site_disorder_group

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("=====================")
      stdout.text("Atom kinds and groups")
      stdout.text("=====================")

      ! Has unique labels?
      .get_1st_repeated_labels(la,lb)
      .get_1st_repeated_xtal_kinds(ka,kb)
      has_unique_labels = (la==0 AND ka==0) OR .dim==1

      ! Unique labels?
      if (has_unique_labels) then

         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush

         ! Table headings
         table.create(6)
         table(1).set_heading("ID")
         table(2).set_heading("Z")
         table(3).set_heading("Atom")
         table(3).set_subhead("kind")
         table(4).set_heading("Unique")
         table(4).set_subhead("kind?")
         table(5).set_heading("Molecule")
         table(5).set_subhead("group")
         table(6).set_heading("Disorder")
         table(6).set_subhead("group")

         ! Set table column data
         table(1).set_values(lab)
         table(2).set_values(Z)
         table(3).set_values(kd)
         table(4).set_values(un)
         table(5).set_values(mg)
         table(6).set_values(dg)

      else ! Not unique labels

         stdout.flush
         stdout.text(". Unique atom labels were not set for each atom.")
         stdout.text("  Therefore, unique symbol-number ID tags are used.")
         if (la/=0) then
         stdout.flush
         stdout.text(". First repeated labels are for atoms "//trim(la.to_str)//" and "//trim(lb.to_str)//".")
         end
         if (ka/=0) then
         stdout.flush
         stdout.text(". First repeated xtal kinds are for atoms "//trim(ka.to_str)//" and "//trim(kb.to_str)//".")
         end
         stdout.flush
         stdout.show("No. of atoms =",.dim)
         stdout.flush

         ! Table headings
         table.create(7)
         table(1).set_heading("Label")
         table(2).set_heading("ID")
         table(2).set_subhead("tag")
         table(3).set_heading("Z")
         table(4).set_heading("Atom")
         table(4).set_subhead("kind")
         table(5).set_heading("Unique")
         table(5).set_subhead("kind?")
         table(6).set_heading("Molecule")
         table(6).set_subhead("group")
         table(7).set_heading("Disorder")
         table(7).set_subhead("group")

         ! Set table column data
         table(1).set_values(lab)
         table(2).set_values(ID)
         table(3).set_values(Z)
         table(4).set_values(kd)
         table(5).set_values(un)
         table(6).set_values(mg)
         table(7).set_values(dg)

      end

      ! Make the table
      table.put

      ! Clean
      table.destroy
      dg.destroy
      mg.destroy
      un.destroy
      kd.destroy
      Z.destroy
      ID.destroy
      lab.destroy

   end

!  =====
!  ADP's
!  =====

   put_ADPs(no_header)
   ! Output the ADP information
   ! Output position and ADP errors if there.
   ! Always use Angstrom units for display.
      self :: IN
      no_header :: BIN, IN, optional

      .put_ADP2s(no_header)

      ! Plot ADP3's and ADP4's if present
      if (.has_any_ADP3s_and_errors) .put_ADP3s
      if (.has_any_ADP4s_and_errors) .put_ADP4s

   end

   put_ADP2s(no_header)
   ! Output the ADP information
   ! Output position and ADP errors if there.
   ! Always use Angstrom units for display.
      self :: IN
      no_header :: BIN, IN, optional

      ID,Uc :: VEC{STR}*
      U,dU :: MAT{REAL}*
      is_flat,is_npd :: VEC{BIN}*
      ratio :: VEC{REAL}*
      table :: VEC{TABLE_COLUMN}*
      fac :: REAL
      i :: INT
      cartesian,header :: BIN

      header = TRUE
      if (present(no_header)) header = NOT no_header

      ! Axis system
      cartesian = self(1).pos_axis_system=="cartesian"

      ! Use angstroms/angstrom^2
      if (cartesian) then
         fac = STR:conversion_factor("angstrom")
      else
         fac = ONE
      end

      ! Create columns
      ID.create(.dim)
      Uc.create(6)
      U.create(.dim,6)
      dU.create(.dim,6)
      is_flat.create(.dim)
      is_npd.create(.dim)
      ratio.create(.dim)

      ! Get columns
      ID  = .tag
      ATOM:put_ADP2_labels_to(Uc)
      .put_ADP2_vector_to(U,fac)
      is_flat = .has_flat_ADP
      is_npd  = .has_NPD_ADP
      ratio   = .ADP_principal_axis_ratio

      ! Title
      if (header) then
      stdout.flush
      stdout.text("=====================================")
      stdout.text("Atomic displacement parameters (ADPs)")
      stdout.text("=====================================")
      stdout.flush
      if (cartesian) then
      stdout.text(". The ADPs are referred to cartesian axes.")
      else
      stdout.text(". The ADPs are referred to unit cell axes.")
      end
      stdout.text(". The length units are in Angstrom.")
      stdout.text(". An ADP is deemed bad if the max-on-min axis ratio")
      stdout.text("  - is greater than 4 (i.e. flat)")
      stdout.text("  - or is non-positive-definite (i.e. NPD)")
      stdout.flush
      stdout.show("No. of NPD  ADPs =",.no_of_NPD_ADPs)
      stdout.show("No. of Flat ADPs =",.no_of_flat_ADPs)
      stdout.flush
      end

      ! Set table headings & data
      table.create(10)
      table.set_spacing(2)

      if (NOT .has_nonzero_pADP2_errors) then

         ! Set table
         table(1).set_heading("ID")
         table(1).set_values(ID)
         do i = 1,6
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values(U(:,i))
         end

      else ! have position/ADP errors

         ! Get error column data
         .put_ADP2_errors_to(dU,fac)

         ! Set table
         table(1).set_heading("ID")
         table(1).set_values(ID)
         do i = 1,6
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values_and_errors(U(:,i),dU(:,i))
         end

      end

      ! Units headings
      table(4).set_subhead(trim("/A^2"))

      ! ADP diagonistics
      table( 8).set_heading("NPD")
      table( 8).set_subhead("  ?")
      table( 8).set_values(is_npd)
      table( 9).set_heading("Flat")
      table( 9).set_subhead("   ?")
      table( 9).set_values(is_flat)
      table(10).set_heading(" Axis")
      table(10).set_subhead("ratio")
      table(10).set_values(ratio)

      ! Make the table
      table.put

      ! Clean
      table.clear_columns
      table.destroy

      ratio.destroy
      is_npd.destroy
      is_flat.destroy
      dU.destroy
      U.destroy
      Uc.destroy
      ID.destroy

   end

   put_ADP3s ::: private
   ! Output the ADP3 information. Always comes after the ADP
   ! information. Use Angstroms.

      U,dU :: MAT{REAL}*
      Uc :: VEC{STR}*
      ID :: VEC{STR}*
      list :: VEC{INT}*
      table :: VEC{TABLE_COLUMN}*
      fac,sfac :: REAL
      i,n :: INT

      if (NOT .has_any_ADP3s_and_errors) return

      ! Use angstroms/angstrom^2
      fac  = STR:conversion_factor("angstrom")

      ! Scale factor
      sfac = CIF_GC3_SCALE_FACTOR
      stdout.flush
      stdout.text(". The cartesian ADP3s below have been scaled")
      stdout.show("  scale factor =",sfac)

      ! No. of atoms with ADP3s
      n = .no_of_ADP3_atoms

      ! Create columns
      list.create(n)
      ID.create(n)
      Uc.create(10)
      U.create(n,10)
      dU.create(n,10)

      ! Get columns
      .put_ADP3_atom_list_to(list)
      ID = self(list).tag
      ATOM:put_ADP3_labels_to(Uc)
      .put_ADP3_vector_to(U,fac)
      U = sfac*U

      ! Set table headings & data
      table.create(11)
      table.set_spacing(2)

      if (NOT .has_nonzero_ADP3_errors) then

         ! Set table
         table(1).set_heading("ID")
         table(1).set_values(ID)
         do i = 1,10
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values(U(:,i))
         end

      else ! have position/ADP errors

         ! Get error column data
         .put_ADP3_errors_to(dU,fac)
         dU = sfac*dU

         ! Set table
         table(1).set_heading("ID")
         table(1).set_values(ID)
         do i = 1,10
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values_and_errors(U(:,i),dU(:,i))
         end

      end

      ! Units headings
      table(6).set_subhead(trim("/A^3"))

      ! Make the table
      table.put

      ! Clean
      table.clear_columns
      table.destroy
      dU.destroy
      U.destroy
      Uc.destroy
      ID.destroy
      list.destroy

   end

   put_ADP4s ::: private
   ! Output the ADP4 information. Always comes after the ADP
   ! information. Use Angstroms.

      U,dU :: MAT{REAL}*
      Uc :: VEC{STR}*
      ID :: VEC{STR}*
      list :: VEC{INT}*
      table :: VEC{TABLE_COLUMN}*
      fac,sfac :: REAL
      i,n :: INT

      if (NOT .has_any_ADP4s_and_errors) return

      ! Use angstroms/angstrom^2
      fac  = STR:conversion_factor("angstrom")

      ! Scale factor
      sfac = CIF_GC4_SCALE_FACTOR
      stdout.flush
      stdout.text(". The cartesian ADP4s below have been scaled")
      stdout.show("  scale factor =",sfac)

      ! No. of atoms with ADP4
      n = .no_of_ADP4_atoms

      ! Create columns
      list.create(n)
      ID.create(n)
      Uc.create(15)
      U.create(n,15)
      dU.create(n,15)

      ! Get columns
      .put_ADP4_atom_list_to(list)
      ID = self(list).tag
      ATOM:put_ADP4_labels_to(Uc)
      .put_ADP4_vector_to(U,fac)
      U = sfac*U

      ! Set table headings & data
      table.create(16)
      table.set_spacing(2)

      if (NOT .has_nonzero_ADP4_errors) then

         ! Set table
         table(1).set_heading("ID")
         table(1).set_values(ID)
         do i = 1,15
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values(U(:,i))
         end

      else ! have position/ADP errors

         ! Get error column data
         .put_ADP4_errors_to(dU,fac)
         dU = sfac*dU

         ! Set table
         table(1).set_heading("ID")
         table(1).set_values(ID)
         do i = 1,15
         table(i+1).set_heading(Uc(i))
         table(i+1).set_values_and_errors(U(:,i),dU(:,i))
         end

      end

      ! Units headings
      table(8).set_subhead(trim("/A^4"))

      ! Make the table
      table.put

      ! Clean
      table.clear_columns
      table.destroy
      dU.destroy
      U.destroy
      Uc.destroy
      ID.destroy
      list.destroy

   end

   put_pADPs
   ! Output the pADP vector information
   ! Genrally used for debugging only.

      mx :: MAT{REAL}*
      n :: INT
      fac :: REAL

      ! Use angstroms/angstrom^2
      fac = STR:conversion_factor("angstrom")

      ! No. of ADP's.
      n = .no_of_pADPs

      ! Get then
      mx.create(n,2)
      .put_pADP_vector_to(mx(:,1),fac)
      .put_pADP_errors_to(mx(:,2),fac)

      ! Title
      stdout.flush
      stdout.text("===================")
      stdout.text("Position/ADP vector")
      stdout.text("===================")
      stdout.flush
      stdout.text(". Column 1 is the pADP vector")
      stdout.text(". Column 2 are the corresponding errors")
      stdout.text(". The length unit is Angstrom")
      stdout.flush
      stdout.show("No. of pADPs =",n)
      stdout.flush

      ! Put
      stdout.put(mx)

      ! Clean
      mx.destroy

   end


   put_dispersion_factors
   ! Output the anamalous dispersion coefficients for every element in
   ! the molecule. 
      self :: IN

      ID :: VEC{STR}*
      fr,fi :: VEC{REAL}*
      ulist :: VEC{INT}*
      table :: VEC{TABLE_COLUMN}*
      n_kind :: INT

      ! Unique atom list
      n_kind = maxval(self(:).kind)
      ulist.create(n_kind)
      .make_unique_atom_list(ulist)

      ! Table column data
      ID.create(n_kind)
      fr.create(n_kind)
      fi.create(n_kind)

      ! Get table column data
      ID = self(ulist).chemical_symbol
    ! fr = RE(ATOM:dispersion_correction(self(ulist)))
    ! fi = IM(ATOM:dispersion_correction(self(ulist)))
      fr = self(ulist).f_r
      fi = self(ulist).f_i

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("======================================")
      stdout.text("Anomalous dispersion f' and f'' values")
      stdout.text("======================================")

      stdout.flush
      stdout.show("No. of elements =",n_kind)
      stdout.flush
      stdout.text("WARNING: it is up to you to ensure these dispersion")
      stdout.text("coefficients below correspond to the wavelength used. ")
      stdout.flush

      ! Table headings
      table.create(3)
      table(1).set_heading("ID")
      table(2).set_heading("f'")
      table(3).set_heading("f''")

      ! Set table column data
      table(1).set_values(ID)
      table(2).set_values(fr)
      table(3).set_values(fi)

      ! Print the table
      table.put

      ! Clean
      table.destroy
      fi.destroy
      fr.destroy
      ID.destroy
      ulist.destroy

   end

!  ============
!  Bond lengths
!  ============

   put_bond_length_table
   ! Output the bond length table.
      self :: IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}*
      Z_list :: VEC{VEC_{INT}}*
      no_of_bonds, n_kind,k1,k2,n_bonds :: INT
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      dist :: VEC{REAL}*
      pair :: MAT{INT}*
      has_unique_labels :: BIN

      ! Anything to do?
      if (.dim<2) return

      no_of_bonds = .no_of_bonds
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("============")
      stdout.text("Bond lengths")
      stdout.text("============")
      stdout.flush
      stdout.text(". The bond-detection criteria is the same as used")
      stdout.text("  by the Cambridge Structural Database (CSD).")
      if (NOT has_unique_labels) then
      stdout.flush
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number tags are used.")
      end
      stdout.flush
      stdout.show("No. of bonds =",no_of_bonds)
      if (no_of_bonds>VEC_ATOM_MAX_BONDS_IN_TABLE) then
      stdout.flush
      stdout.text("There are too many bonds to display in a table.")
      return
      end
      stdout.flush

      ! Get Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(7)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self.chemical_symbols)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_heading("B")
      table(3).set_width(table(1).width)
      table(3).set_left_justify(TRUE)

      table(4).set_heading("A")
      table(4).set_width_from(self.tag)

      table(5).set_spacing(0)
      table(5).set_heading("--")
      table(5).set_width(2)

      table(6).set_heading("B")
      table(6).set_width(table(4).width)
      table(6).set_left_justify(TRUE)

      table(7).set_heading("R(A--B)")
      table(7).set_subheading("/A")
      table(7).set_width_from(ONE)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_atoms(pair,dist,Z_list,k1,k2)
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_bonds,2)
         symbols = " "
         symbols(1,1) = self(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = self(Z_list(k2)[1]).chemical_symbol

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = self(pair(:,1)).tag
         labels(:,2) = self(pair(:,2)).tag

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table(1).set_values(symbols(:,1))
         table(2).set_values(dsh1)
         table(3).set_values(symbols(:,2))
         table(4).set_values(labels(:,1))
         table(5).set_values(dash)
         table(6).set_values(labels(:,2))
         table(7).set_values(dist)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.clear_columns
      table.destroy
      Z_list.destroy

   end

   put_bond_length_table(covariance,parentheses)
   ! Output the bond length table with errors, given the "covariance"
   ! matrix between all atomic positions. Set "paretheses" FALSE if
   ! you want errors without them.
      self :: IN
      covariance :: MAT{REAL}, IN
      parentheses :: BIN, optional, IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}*
      Z_list :: VEC{VEC_{INT}}*
      no_of_bonds, n_kind,k1,k2,n_bonds :: INT
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      dist,esds :: VEC{REAL}*
      pair :: MAT{INT}*
      use_brackets,has_unique_labels :: BIN

      ! Anything to do?
      if (.dim<2) return

      no_of_bonds = .no_of_bonds
      if (no_of_bonds<1) return

      ! Parentheses
      use_brackets = TRUE
      if (present(parentheses)) use_brackets = parentheses

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("============")
      stdout.text("Bond lengths")
      stdout.text("============")
      stdout.flush
      stdout.text(". The bond-detection criteria is the same as used")
      stdout.text("  by the Cambridge Structural Database (CSD).")
      if (NOT has_unique_labels) then
      stdout.flush
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number ID tags are used.")
      end
      stdout.flush
      stdout.show("No. of bonds =",no_of_bonds)
      stdout.flush

      ! Get Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      if (use_brackets) then; table.create(7)
      else;                   table.create(8)
      end

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self.chemical_symbols)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_heading("B")
      table(3).set_width(table(1).width)
      table(3).set_left_justify(TRUE)

      table(4).set_heading("A")
      table(4).set_width_from(self.tag)

      table(5).set_spacing(0)
      table(5).set_heading("--")
      table(5).set_width(2)

      table(6).set_heading("B")
      table(6).set_width(table(4).width)
      table(6).set_left_justify(TRUE)

      table(7).set_heading("R(A--B)")
      table(7).set_subheading("/A")
      table(7).set_width_from(ONE)

      if (NOT use_brackets) then
      table(8).set_heading("Error")
      table(8).set_width_from(ONE)
      end

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom Z classes, Z(k1) >= Z(k2)
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_atoms(pair,dist,esds,Z_list,k1,k2,covariance) ! leaky
         dist = dist*ANGSTROM_PER_BOHR
         esds = esds*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            esds.destroy
            dist.destroy
            pair.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_bonds,2)
         symbols = " "
         symbols(1,1) = self(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = self(Z_list(k2)[1]).chemical_symbol

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = self(pair(:,1)).tag
         labels(:,2) = self(pair(:,2)).tag

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table(1).set_values(symbols(:,1))
         table(2).set_values(dsh1)
         table(3).set_values(symbols(:,2))
         table(4).set_values(labels(:,1))
         table(5).set_values(dash)
         table(6).set_values(labels(:,2))
         if (use_brackets) then
         table(7).set_real_precision(stdout.real_precision) ! Must do, for every block
         table(7).set_values_and_errors(dist,esds)
         else
         table(7).set_values(dist)
         table(8).set_values(esds)
         end

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         esds.destroy
         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.clear_columns
      table.destroy
      Z_list.destroy

   end

   get_bonded(pair,dist,Z_list,k1,k2,range_factor) ::: template, leaky
   ! Get the Nx2 bonded-atom "pair"s, and the distances "dist" between
   ! them. The pair have "Z_list" groups "k1" and "k2", respectively.
      self :: IN
      pair :: MAT{INT}*
      dist :: VEC{REAL}*
      Z_list :: VEC{VEC_{INT}}, IN
      k1,k2 :: INT, IN
      range_factor :: REAL, IN, optional

   ENSURE(k1<=k2,"k2 is smaller than k1")

      i1,i2,a1,a2, n :: INT

      ! How many pairs, n, are there?
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (k1==k2 AND a2<=a1) cycle
            if (NOT .BONDED?(a1,a2,range_factor)) cycle

            ! Count
            n = n + 1

         end
      end

      ! Allocate
      pair.create(n,2)
      dist.create(n)

      ! Make the list
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (k1==k2 AND a2<=a1) cycle
            if (NOT .BONDED?(a1,a2,range_factor)) cycle

            ! Add the data
            n = n + 1
            pair(n,1) = a1
            pair(n,2) = a2
            dist(n)   = .bond_distance(a1,a2)

         end
      end

   end

   get_bonded_atoms(pair,dist,Z_list,k1,k2,range_factor) ::: get_from(VEC{ATOM}:get_bonded, BONDED?=>bonded), leaky
   ! Get the Nx2 bonded-atom "pair"s, and the distances "dist" between
   ! them. The pair have "Z_list" groups "k1" and "k2", respectively.
   end

   get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,range_factor) ::: get_from(VEC{ATOM}:get_bonded, BONDED?=>vdw_bonded), leaky
   ! Get the Nx2 bonded-atom "pair"s, and the distances "dist" between
   ! them. The pair have "Z_list" groups "k1" and "k2", respectively.
   end

   get_bonded_atoms(pair,dist,esds,Z_list,k1,k2,covariance,H_bonded) ::: leaky
   ! Get the Nx2 bonded-atom "pair"s, and the distances "dist" between
   ! them, and the associated "esds". The pair have "Z_list" groups of
   ! "k1" and "k2", respectively. The "covariance" matrix for *all*
   ! atom coordinates is also given.
      self :: IN

      pair :: MAT{INT}*
      dist,esds :: VEC{REAL}*
      Z_list :: VEC{VEC_{INT}}, IN
      k1,k2 :: INT, IN
      covariance :: MAT{REAL}
      H_bonded :: BIN, IN, optional

   ENSURE(k1<=k2,"k2 is smaller than k1")
   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      i1,i2,a1,a2, n :: INT
      err :: REAL
      der :: VEC{REAL}(6)
      cov :: MAT{REAL}(6,6)

      ! How many pairs, n, are there?
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (k1==k2 AND a2<=a1) cycle
            if (NOT .bonded(a1,a2,H_bonded=H_bonded)) cycle

            ! Count
            n = n + 1

         end
      end

      ! Allocate
      pair.create(n,2)
      dist.create(n)
      esds.create(n)

      ! Make the list
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (k1==k2 AND a2<=a1) cycle
            if (NOT .bonded(a1,a2,H_bonded=H_bonded)) cycle

            ! Extract covariances for atom a, b positions
            covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2])

            ! Make error
            .bond_distance_deriv(a1,a2,der)
            err = cov.dot(der,der)
            err = sqrt(err)

            ! Add the data
            n = n + 1
            pair(n,1) = a1
            pair(n,2) = a2
            dist(n)   = .bond_distance(a1,a2)
            esds(n)   = err

         end
      end

   end

   put_bond_length_with_error(a1,a2,covariance) ::: leaky
   ! Put the bond length with error between atoms "a1" and "a2".
   ! The "covariance" matrix is for *all* atomn.
      self :: IN
      a1,a2 :: INT, IN
      covariance :: MAT{REAL}

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")
   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      err,dist :: REAL
      der :: VEC{REAL}(6)
      cov :: MAT{REAL}(6,6)

      ! Extract position covariances for atom a1, a2
      covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2])

      ! Make error
      .bond_distance_deriv(a1,a2,der)
      err = cov.dot(der,der)
      err = sqrt(err)
      err.convert_to("angstrom")

      ! Add the data
      dist   = .bond_distance(a1,a2)
      dist.convert_to("angstrom")

      ! Output
      stdout.flush
      stdout.text("======================")
      stdout.text("Bond length with error")
      stdout.text("======================")
      stdout.show("Atom 1        =",self(a1).tag)
      stdout.show("Atom 2        =",self(a2).tag)
      stdout.show("Bond length   =",dist)
      stdout.show("Error         =",err)

   end

!  ===========
!  Bond angles
!  ===========

   put_bond_angle_table
   ! Output the bond angle table.
      self :: IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}*
      Z_list :: VEC{VEC_{INT}}*
      no_of_angles, n_kind,k1,k2,k3,n_angles,w :: INT
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      triple :: MAT{INT}*
      angle :: VEC{REAL}*
      val :: STR
      has_unique_labels :: BIN

      if (.dim<3) return

      no_of_angles = .no_of_angles
      if (no_of_angles<1) return

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("===========")
      stdout.text("Bond Angles")
      stdout.text("===========")
      stdout.flush
      stdout.text(". Atom B of Angle(A--B--C) is the middle atom.")
      stdout.flush
      if (NOT has_unique_labels) then
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number ID tags are used.")
      end
      stdout.flush
      stdout.show("No. of bond angles =",no_of_angles)
      if (no_of_angles>VEC_ATOM_MAX_ANGLES_IN_TABLE) then
      stdout.flush
      stdout.text("There are too many angles to display in a table.")
      return
      end
      stdout.flush

      ! Get Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(11)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.chemical_symbols)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_spacing(0)
      table(3).set_heading("B")
      table(3).set_width_from(.chemical_symbols)

      table(4).set_spacing(0)
      table(4).set_heading("--")
      table(4).set_width(2)

      table(5).set_spacing(0)
      table(5).set_heading("C")
      table(5).set_width(table(2).width)
      table(5).set_left_justify(TRUE)

      table(6).set_heading("A")
      table(6).set_width_from(self(.angle_outer_atoms).tag)

      table(7).set_spacing(0)
      table(7).set_heading("--")
      table(7).set_width(2)

      table(8).set_spacing(0)
      table(8).set_heading("B")
      table(8).set_width_from(self(.angle_center_atoms).tag)
      w = table(8).width
      val = "B"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(8).set_heading(val(1:w))

      table(9).set_spacing(0)
      table(9).set_heading("--")
      table(9).set_width(2)

      table(10).set_spacing(0)
      table(10).set_heading("C")
      table(10).set_width_from(self(.angle_outer_atoms).tag)
      table(10).set_left_justify(TRUE)

      table(11).set_heading("Angle(A--B--C)")
      table(11).set_subheading("/degree")
      table(11).set_width_from(-180d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_angles(triple,angle,Z_list,k1,k2,k3)
         angle = angle*DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            angle.destroy
            triple.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,3)
         symbols = " "
         symbols(1,1) = self(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = self(Z_list(k2)[1]).chemical_symbol
         symbols(1,3) = self(Z_list(k3)[1]).chemical_symbol

         ! Labels
         labels.create(n_angles,3)
         labels(:,1) = self(triple(:,1)).tag
         labels(:,2) = self(triple(:,2)).tag
         labels(:,3) = self(triple(:,3)).tag

         labels(:,2).pad_with("-",width=w,prepad=TRUE)

         ! Dashes
         dash.create(n_angles)
         dsh1.create(n_angles)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(dsh1)
         table( 5).set_values(symbols(:,3))
         table( 6).set_values(labels(:,1))
         table( 7).set_values(dash)
         table( 8).set_values(labels(:,2))
         table( 9).set_values(dash)
         table(10).set_values(labels(:,3))
         table(11).set_values(angle)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         angle.destroy
         triple.destroy

      end
      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      Z_list.destroy

   end

   put_bond_angle_table(covariance,parentheses)
   ! Output the bond angle table with errors given the "covariance"
   ! matrix between all atomic positions. Set "parentheses" FALSE if
   ! you don't want them for errors.
      self :: IN
      covariance :: MAT{REAL}, IN
      parentheses :: BIN, optional, IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}*
      Z_list :: VEC{VEC_{INT}}*
      no_of_angles, n_kind,k1,k2,k3,n_angles,w :: INT
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      angle,esds :: VEC{REAL}*
      triple :: MAT{INT}*
      val :: STR
      use_brackets,has_unique_labels :: BIN

      if (.dim<3) return

      no_of_angles = .no_of_angles
      if (no_of_angles<1) return

      ! Parentheses
      use_brackets = TRUE
      if (present(parentheses)) use_brackets = parentheses

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("===========")
      stdout.text("Bond Angles")
      stdout.text("===========")
      stdout.flush
      stdout.text("Atom B of Angle(A--B--C) is the middle atom.")
      stdout.flush
      if (NOT has_unique_labels) then
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number ID tags are used.")
      end
      stdout.flush
      stdout.show("No. of bond angles =",.no_of_angles)
      if (no_of_angles>VEC_ATOM_MAX_ANGLES_IN_TABLE) then
      stdout.flush
      stdout.text("There are too many angles to display in a table.")
      return
      end
      stdout.flush

      ! Get Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      if (use_brackets) then; table.create(11)
      else;                   table.create(12)
      end

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.chemical_symbols)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_spacing(0)
      table(3).set_heading("B")
      table(3).set_width_from(.chemical_symbols)

      table(4).set_spacing(0)
      table(4).set_heading("--")
      table(4).set_width(2)

      table(5).set_spacing(0)
      table(5).set_heading("C")
      table(5).set_width(table(2).width)
      table(5).set_left_justify(TRUE)

      table(6).set_heading("A")
      table(6).set_width_from(self(.angle_outer_atoms).tag)

      table(7).set_spacing(0)
      table(7).set_heading("--")
      table(7).set_width(2)

      table(8).set_spacing(0)
      table(8).set_heading("B")
      table(8).set_width_from(self(.angle_center_atoms).tag)
      w = table(8).width
      val = "B"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(8).set_heading(val(1:w))

      table(9).set_spacing(0)
      table(9).set_heading("--")
      table(9).set_width(2)

      table(10).set_spacing(0)
      table(10).set_heading("C")
      table(10).set_width_from(self(.angle_outer_atoms).tag)
      table(10).set_left_justify(TRUE)

      table(11).set_heading("Angle(A--B--C)")
      table(11).set_subheading("/degree")
      table(11).set_width_from(ONE)

      if (NOT use_brackets) then
      table(12).set_heading("Error")
      table(12).set_width_from(ONE)
      end

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_angles(triple,angle,esds,Z_list,k1,k2,k3,covariance)
         angle = angle*DEGREE_PER_RADIAN
         esds  = esds *DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            esds.destroy
            angle.destroy
            triple.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,3)
         symbols = " "
         symbols(1,1) = self(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = self(Z_list(k2)[1]).chemical_symbol
         symbols(1,3) = self(Z_list(k3)[1]).chemical_symbol

         ! Labels
         labels.create(n_angles,3)
         labels(:,1) = self(triple(:,1)).tag
         labels(:,2) = self(triple(:,2)).tag
         labels(:,3) = self(triple(:,3)).tag

         labels(:,2).pad_with("-",width=w,prepad=TRUE)

         ! Dashes
         dash.create(n_angles)
         dsh1.create(n_angles)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(dsh1)
         table( 5).set_values(symbols(:,3))
         table( 6).set_values(labels(:,1))
         table( 7).set_values(dash)
         table( 8).set_values(labels(:,2))
         table( 9).set_values(dash)
         table(10).set_values(labels(:,3))
         if (use_brackets) then
         table(11).set_real_precision(stdout.real_precision) ! Must do, for every block
         table(11).set_values_and_errors(angle,esds)
         else
         table(11).set_values(angle)
         table(12).set_values(esds)
         end

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         esds.destroy
         angle.destroy
         triple.destroy

      end
      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      Z_list.destroy

   end

   get_bonded_angles(triple,angle,Z_list,k1,k2,k3) ::: leaky, private
   ! Get the Nx3 bonded-atom "triple"s, and the "angles" between them.
   ! The triple has "Z_list" groups of "k1", "k2", and "k3", resp.
      self :: IN
      triple :: MAT{INT}*
      angle :: VEC{REAL}*
      Z_list :: VEC{VEC_{INT}}, IN
      k1,k2,k3 :: INT, IN

   ENSURE(k1<=k3,"k3 is smaller than k1")

      i1,i2,i3,a1,a2,a3, n :: INT

      ! How many triples, n, are there?
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,Z_list(k3).element.dim
               a3 = Z_list(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle
               if (k1==k3 AND a3<a1) cycle

               ! Count
               n = n + 1

            end
         end
      end

      ! Allocate
      triple.create(n,3)
      angle.create(n)

      ! Make the list
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,Z_list(k3).element.dim
               a3 = Z_list(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle
               if (k1==k3 AND a3<a1) cycle

               ! Add data
               n = n + 1
               triple(n,1) = a1
               triple(n,2) = a2
               triple(n,3) = a3
               angle(n) = .bond_angle(a1,a2,a3)

            end
         end
      end

   end

   get_bonded_angles(triple,angle,esds,Z_list,k1,k2,k3,covariance) ::: leaky, private
   ! Get the bonded-atom "triple"s, and the "angles" between them, and
   ! the associated "esds". The triple has "Z_list" groups of "k1",
   ! "k2", and "k3", respectively. The "covariance" matrix is between
   ! *all* atom coordinates.
      self :: IN
      triple :: MAT{INT}*
      angle,esds :: VEC{REAL}*
      Z_list :: VEC{VEC_{INT}}, IN
      k1,k2,k3 :: INT, IN
      covariance :: MAT{REAL}, IN

   ENSURE(k1<=k3,"k3 is smaller than k1")
   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      i1,i2,i3,a1,a2,a3, n :: INT
      err :: REAL
      der :: VEC{REAL}(9)
      cov :: MAT{REAL}(9,9)

      ! How many triples, n, are there?
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,Z_list(k3).element.dim
               a3 = Z_list(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle
               if (k1==k3 AND a3<a1) cycle

               ! Count
               n = n + 1

            end
         end
      end

      ! Allocate
      triple.create(n,3)
      angle.create(n)
      esds.create(n)

      ! Make the list
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,Z_list(k3).element.dim
               a3 = Z_list(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle
               if (k1==k3 AND a3<a1) cycle

               ! Extract covariances for atoms a, b, c
               covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2,a3])

               ! Make error
               .bond_angle_deriv(a1,a2,a3,der)
               err = cov.dot(der,der)
               if (err<ZERO) then
                  err = ZERO
               end
               err = sqrt(err)

               ! Add data
               n = n + 1
               triple(n,1) = a1
               triple(n,2) = a2
               triple(n,3) = a3
               angle(n)    = .bond_angle(a1,a2,a3)
               esds(n)     = err

            end
         end
      end

   end

   put_bond_angle_with_error(a1,a2,a3,covariance) ::: leaky
   ! Put the bond angle between atoms "a1" ... "a3" with error.  The
   ! "covariance" matrix is for *all* atom coordinates.
      self :: IN
      a1,a2,a3 :: INT, IN
      covariance :: MAT{REAL}, IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")
   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      err,ang :: REAL
      der :: VEC{REAL}(9)
      cov :: MAT{REAL}(9,9)

      ! Extract covariances for atom a, b, c positions
      covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2,a3])

      ! Make error
      .bond_angle_deriv(a1,a2,a3,der)
      err = cov.dot(der,der)
      err = sqrt(err)
      err.convert_to("degree")

      ! Add the data
      ang   = .bond_angle(a1,a2,a3)
      ang.convert_to("degree")

      ! Output
      stdout.flush
      stdout.text("=====================")
      stdout.text("Bond angle with error")
      stdout.text("=====================")
      stdout.show("Atom 1        =",self(a1).tag)
      stdout.show("Atom 2        =",self(a2).tag)
      stdout.show("Atom 3        =",self(a3).tag)
      stdout.show("Bond angle    =",ang)
      stdout.show("Error         =",err)

   end

!  ================
!  Torsions angles
!  ================

   put_torsion_angle_table
   ! Output the torsion angle table.
      self :: IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}*
      Z_list :: VEC{VEC_{INT}}*
      no_of_torsions, n_kind,k1,k2,k3,k4,n_angles,w :: INT
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      quad :: MAT{INT}*
      angle :: VEC{REAL}*
      val :: STR
      has_unique_labels :: BIN

      if (.dim<4) return

      no_of_torsions = .no_of_torsion_angles
      if (no_of_torsions<1) return

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("==============")
      stdout.text("Torsion angles")
      stdout.text("==============")
      stdout.flush
      stdout.text(". The angle shown is the one that looking down B->C")
      stdout.text("  i.e. it's the one between r(A)-r(B) and r(D)-r(C)")
      stdout.flush
      stdout.text(". The angle is +ve if r(D)-r(C) is clockwise of r(A)-r(B)")
      stdout.flush
      if (NOT has_unique_labels) then
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number ID tags are used.")
      end
      stdout.flush
      stdout.show("No. of torsion angles =",no_of_torsions)
      if (no_of_torsions>VEC_ATOM_MAX_TORSIONS_IN_TABLE) then
      stdout.flush
      stdout.text("There are too many angles to display in a table.")
      return
      end
      stdout.flush

      ! Get atom Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(15)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.chemical_symbols)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_spacing(0)
      table(3).set_heading("B")
      table(3).set_width_from(.chemical_symbols)

      table(4).set_spacing(0)
      table(4).set_heading("--")
      table(4).set_width(2)

      table(5).set_spacing(0)
      table(5).set_heading("C")
      table(5).set_width_from(.chemical_symbols)

      table(6).set_spacing(0)
      table(6).set_heading("--")
      table(6).set_width(2)

      table(7).set_spacing(0)
      table(7).set_heading("D")
      table(7).set_width(table(2).width)
      table(7).set_left_justify(TRUE)

      table(8).set_heading("A")
      table(8).set_width_from(self(.torsion_angle_1st_atoms).tag)

      table(9).set_spacing(0)
      table(9).set_heading("--")
      table(9).set_width(2)

      table(10).set_spacing(0)
      table(10).set_heading("B")
      table(10).set_width_from(self(.torsion_angle_2nd_atoms).tag)
      w = table(10).width
      val = "B"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(10).set_heading(val(1:w))

      table(11).set_spacing(0)
      table(11).set_heading("--")
      table(11).set_width(2)

      table(12).set_spacing(0)
      table(12).set_heading("C")
      table(12).set_width_from(self(.torsion_angle_3rd_atoms).tag)
      w = table(12).width
      val = "C"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(12).set_heading(val(1:w))

      table(13).set_spacing(0)
      table(13).set_heading("--")
      table(13).set_width(2)

      table(14).set_spacing(0)
      table(14).set_heading("D")
      table(14).set_width_from(self(.torsion_angle_4th_atoms).tag)
      table(14).set_left_justify(TRUE)

      table(15).set_heading("Angle(A--B--C--D)")
      table(15).set_subheading("/degree")
      table(15).set_width_from(-180d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = 1,n_kind
      do k4 = 1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_torsions(quad,angle,Z_list,k1,k2,k3,k4)
         angle = angle*DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            angle.destroy
            quad.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,4)
         symbols = " "
         symbols(1,1) = self(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = self(Z_list(k2)[1]).chemical_symbol
         symbols(1,3) = self(Z_list(k3)[1]).chemical_symbol
         symbols(1,4) = self(Z_list(k4)[1]).chemical_symbol

         ! Labels
         labels.create(n_angles,4)
         labels(:,1) = self(quad(:,1)).tag
         labels(:,2) = self(quad(:,2)).tag
         labels(:,3) = self(quad(:,3)).tag
         labels(:,4) = self(quad(:,4)).tag

         labels(:,2).pad_with("-",width=w,prepad=TRUE)
         labels(:,3).pad_with("-",width=w,prepad=TRUE)

         ! Dashes
         dash.create(n_angles)
         dsh1.create(n_angles)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(dsh1)
         table( 5).set_values(symbols(:,3))
         table( 6).set_values(dsh1)
         table( 7).set_values(symbols(:,4))

         table( 8).set_values(labels(:,1))
         table( 9).set_values(dash)
         table(10).set_values(labels(:,2))
         table(11).set_values(dash)
         table(12).set_values(labels(:,3))
         table(13).set_values(dash)
         table(14).set_values(labels(:,4))

         table(15).set_values(angle)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         angle.destroy
         quad.destroy

      end
      end
      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      Z_list.destroy

   end

   put_torsion_angle_table(covariance,parentheses)
   ! Output the torsion angle table with errors given the "covariance"
   ! matrix between all atomic positions. Set "parentheses" FALSE if
   ! ypou don't want them for errors.
      self :: IN
      covariance :: MAT{REAL}, IN
      parentheses :: BIN, optional, IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}*
      Z_list :: VEC{VEC_{INT}}*
      no_of_torsions, n_kind,k1,k2,k3,k4,n_angles,w :: INT
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      angle,esds :: VEC{REAL}*
      quad :: MAT{INT}*
      val :: STR
      use_brackets,has_unique_labels :: BIN

      if (.dim<4) return

      no_of_torsions = .no_of_torsion_angles
      if (no_of_torsions<1) return

      ! Parentheses
      use_brackets = TRUE
      if (present(parentheses)) use_brackets = parentheses

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("==============")
      stdout.text("Torsion angles")
      stdout.text("==============")
      stdout.flush
      stdout.text("The angle shown is the one that looking down B->C")
      stdout.text("i.e. it's the one between r(A)-r(B) and r(D)-r(C).")
      stdout.flush
      stdout.text("The angle is +ve if r(D)-r(C) is clockwise of r(A)-r(B).")
      stdout.flush
      if (NOT has_unique_labels) then
      stdout.text(". Unique atom labels were not set for each atom.")
      stdout.text("  Therefore, unique symbol-number ID tags are used.")
      end
      stdout.flush
      stdout.show("No. of torsion angles =",no_of_torsions)
      if (no_of_torsions>VEC_ATOM_MAX_TORSIONS_IN_TABLE) then
      stdout.flush
      stdout.text("There are too many angles to display in a table.")
      return
      end
      stdout.flush

      ! Get Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      if (use_brackets) then; table.create(15)
      else;                   table.create(16)
      end

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.chemical_symbols)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_spacing(0)
      table(3).set_heading("B")
      table(3).set_width_from(.chemical_symbols)

      table(4).set_spacing(0)
      table(4).set_heading("--")
      table(4).set_width(2)

      table(5).set_spacing(0)
      table(5).set_heading("C")
      table(5).set_width_from(.chemical_symbols)

      table(6).set_spacing(0)
      table(6).set_heading("--")
      table(6).set_width(2)

      table(7).set_spacing(0)
      table(7).set_heading("D")
      table(7).set_width(table(2).width)
      table(7).set_left_justify(TRUE)

      table(8).set_heading("A")
      table(8).set_width_from(self(.torsion_angle_1st_atoms).tag)

      table(9).set_spacing(0)
      table(9).set_heading("--")
      table(9).set_width(2)

      table(10).set_spacing(0)
      table(10).set_heading("B")
      table(10).set_width_from(self(.torsion_angle_2nd_atoms).tag)
      w = table(10).width
      val = "B"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(10).set_heading(val(1:w))

      table(11).set_spacing(0)
      table(11).set_heading("--")
      table(11).set_width(2)

      table(12).set_spacing(0)
      table(12).set_heading("C")
      table(12).set_width_from(self(.torsion_angle_3rd_atoms).tag)
      w = table(12).width
      val = "C"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(12).set_heading(val(1:w))

      table(13).set_spacing(0)
      table(13).set_heading("--")
      table(13).set_width(2)

      table(14).set_spacing(0)
      table(14).set_heading("D")
      table(14).set_width_from(self(.torsion_angle_4th_atoms).tag)
      table(14).set_left_justify(TRUE)

      table(15).set_heading("Angle(A--B--C--D)")
      table(15).set_subheading("/degree")
      table(15).set_width_from(ONE)

      if (NOT use_brackets) then
      table(16).set_heading("Error")
      table(16).set_width_from(ONE)
      end

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = 1,n_kind
      do k4 = 1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_torsions(quad,angle,esds,Z_list,k1,k2,k3,k4,covariance)
         angle = angle*DEGREE_PER_RADIAN
         esds  =  esds*DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            esds.destroy
            angle.destroy
            quad.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,4)
         symbols = " "
         symbols(1,1) = self(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = self(Z_list(k2)[1]).chemical_symbol
         symbols(1,3) = self(Z_list(k3)[1]).chemical_symbol
         symbols(1,4) = self(Z_list(k4)[1]).chemical_symbol

         ! Labels
         labels.create(n_angles,4)
         labels(:,1) = self(quad(:,1)).tag
         labels(:,2) = self(quad(:,2)).tag
         labels(:,3) = self(quad(:,3)).tag
         labels(:,4) = self(quad(:,4)).tag

         labels(:,2).pad_with("-",width=w,prepad=TRUE)
         labels(:,3).pad_with("-",width=w,prepad=TRUE)

         ! Dashes
         dash.create(n_angles)
         dsh1.create(n_angles)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(dsh1)
         table( 5).set_values(symbols(:,3))
         table( 6).set_values(dsh1)
         table( 7).set_values(symbols(:,4))

         table( 8).set_values(labels(:,1))
         table( 9).set_values(dash)
         table(10).set_values(labels(:,2))
         table(11).set_values(dash)
         table(12).set_values(labels(:,3))
         table(13).set_values(dash)
         table(14).set_values(labels(:,4))

         if (use_brackets) then
         table(15).set_real_precision(stdout.real_precision) ! Must do, for every block
         table(15).set_values_and_errors(angle,esds)
         else
         table(15).set_values(angle)
         table(16).set_values(esds)
         end

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Put spacer if not last block
         if (NOT (k1==n_kind AND k2==n_kind AND k3==n_kind AND k4==n_kind)) stdout.flush

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         esds.destroy
         angle.destroy
         quad.destroy

      end
      end
      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      Z_list.destroy

   end

   get_bonded_torsions(quad,angle,Z_list,k1,k2,k3,k4) ::: leaky, private
   ! Get the bonded-atom "quad"ruples, and the "angles" between them.
   ! The quadruple has "Z_list" groups of "k1" ... "k4", respectively.
      quad :: MAT{INT}*
      angle :: VEC{REAL}*
      Z_list :: VEC{VEC_{INT}}, IN
      k1,k2,k3,k4 :: INT, IN

      i1,i2,i3,i4,a1,a2,a3,a4, n :: INT

      ! How many quadruples, n, are there?
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,Z_list(k3).element.dim
               a3 = Z_list(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle

               do i4 = 1,Z_list(k4).element.dim
                  a4 = Z_list(k4)[i4]

                  if (a4==a1 OR a4==a2 OR a4==a3) cycle
                  if (NOT .bonded(a3,a4)) cycle
                  if (a4<a1) cycle

                  ! Count
                  n = n + 1

               end
            end
         end
      end

      ! Allocate
      quad.create(n,4)
      angle.create(n)

      ! Make the list
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,Z_list(k3).element.dim
               a3 = Z_list(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle

               do i4 = 1,Z_list(k4).element.dim
                  a4 = Z_list(k4)[i4]

                  if (a4==a1 OR a4==a2 OR a4==a3) cycle
                  if (NOT .bonded(a3,a4)) cycle
                  if (a4<a1) cycle

                  ! Add data
                  n = n + 1
                  quad(n,1) = a1
                  quad(n,2) = a2
                  quad(n,3) = a3
                  quad(n,4) = a4
                  angle(n)  = .torsion_angle(a1,a2,a3,a4)

               end
            end
         end
      end

   end

   get_bonded_torsions(quad,angle,esds,Z_list,k1,k2,k3,k4,covariance) ::: leaky, private
   ! Get the bonded-atom "quad"ruples, and the "angles" between them.
   ! The quadruple has "Z_list" groups of "k1" ... "k4", respectively.
      quad :: MAT{INT}*
      angle,esds :: VEC{REAL}*
      Z_list :: VEC{VEC_{INT}}, IN
      k1,k2,k3,k4 :: INT, IN
      covariance :: MAT{REAL}, IN

   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      i1,i2,i3,i4,a1,a2,a3,a4, n :: INT
      err :: REAL
      der :: VEC{REAL}(12)
      cov :: MAT{REAL}(12,12)

      ! How many quadruples, n, are there?
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,Z_list(k3).element.dim
               a3 = Z_list(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle

               do i4 = 1,Z_list(k4).element.dim
                  a4 = Z_list(k4)[i4]

                  if (a4==a1 OR a4==a2 OR a4==a3) cycle
                  if (NOT .bonded(a3,a4)) cycle
                  if (a4<a1) cycle

                  ! Count
                  n = n + 1

               end
            end
         end
      end

      ! Allocate
      quad.create(n,4)
      angle.create(n)
      esds.create(n)

      ! Make the list
      n = 0
      do i1 = 1,Z_list(k1).element.dim
         a1 = Z_list(k1)[i1]

         do i2 = 1,Z_list(k2).element.dim
            a2 = Z_list(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,Z_list(k3).element.dim
               a3 = Z_list(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle

               do i4 = 1,Z_list(k4).element.dim
                  a4 = Z_list(k4)[i4]

                  if (a4==a1 OR a4==a2 OR a4==a3) cycle
                  if (NOT .bonded(a3,a4)) cycle
                  if (a4<a1) cycle

                  ! Extract covariances for atoms a, b, c
                  covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2,a3,a4])

                  ! Make error
                  .torsion_angle_deriv(a1,a2,a3,a4,der)
                  err = cov.dot(der,der)
                  if (err<ZERO) then
                     err = ZERO
                  end
                  err = sqrt(err)

                  ! Add data
                  n = n + 1
                  quad(n,1) = a1
                  quad(n,2) = a2
                  quad(n,3) = a3
                  quad(n,4) = a4
                  angle(n)  = .torsion_angle(a1,a2,a3,a4)
                  esds(n)   = err

               end
            end
         end
      end

   end

   put_torsion_angle_with_error(a1,a2,a3,a4,covariance) ::: leaky
   ! Get the bonded-atom "pair"s, and the distances "dist" between
   ! them, and the associated "esds". The pair has "atom_kind" of "k1"
   ! and "k2", respectively. The "covariance" matrix for *all* atom
   ! coordinates is also given.
      self :: IN
      a1,a2,a3,a4 :: INT, IN
      covariance :: MAT{REAL}, IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")
   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      err,tor :: REAL
      der :: VEC{REAL}(12)
      cov :: MAT{REAL}(12,12)

      ! Extract covariances for atom a, b positions
      covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2,a3,a4])

      ! Make error
      .torsion_angle_deriv(a1,a2,a3,a4,der)
      err = cov.dot(der,der)
      err = sqrt(err)
      err.convert_to("degree")

      ! Add the data
      tor   = .torsion_angle(a1,a2,a3,a4)
      tor.convert_to("degree")

      ! Output
      stdout.flush
      stdout.text("========================")
      stdout.text("Torsion angle with error")
      stdout.text("========================")
      stdout.show("Atom 1        =",self(a1).tag)
      stdout.show("Atom 2        =",self(a2).tag)
      stdout.show("Atom 3        =",self(a3).tag)
      stdout.show("Atom 4        =",self(a4).tag)
      stdout.show("Torsion angle =",tor)
      stdout.show("Error         =",err)

   end

!  ==============
!  Principal axes
!  ==============

   put_principal_axes
   ! Put out the principal axis information

      pm,pn :: VEC{REAL}(3)
      pa :: MAT{REAL}(3,3)
      reorder :: BIN

      .make_principal_moments(pm,pa,reorder)

      pn = pm/maxval(pm) ! normalised moments

      stdout.flush
      stdout.text("Principal moments and axes:")
      stdout.flush
      stdout.show("Center of mass    =",.center_of_mass)
      stdout.show("Principal moments =",pm)
      stdout.show("Spherical top?    =",.is_spherical_top(pn))
      stdout.show("Symmetric top?    =",.is_symmetric_top(pn))
      stdout.show("Prolate top?      =",.is_prolate_top(pn))
      stdout.show("Oblate top?       =",.is_oblate_top(pn))
      stdout.flush
      stdout.text("Principal axes:")
      stdout.put(pa)

   end

!  ==
!  MM
!  ==

   put_mm_info ::: private
   ! Output a table of the residue names, sequence numbers, charges, but
   ! no basis sets. This is in PDB input format.
      i :: INT
      stdout.flush
      stdout.text("Residue information:")
      stdout.flush
      stdout.dash(width=42)
      stdout.put(" ",width=4)
      stdout.put("#",width=7)
      stdout.put("Name",width=4)
      stdout.put("Residue",width=5)
      stdout.put("Sequence",width=6)
      stdout.put("x",width=3)
      stdout.put("y",width=3)
      stdout.put("z",width=3)
      stdout.put("Charge",width=3)
      stdout.put("Element",width=4)
      stdout.flush
      stdout.dash(width=42)
      stdout.dash(int_fields=6,real_fields=5)
      do i = 1,size(self)
         stdout.put("ATOM",width=4)
         stdout.put(i,width=7)
         stdout.put(self(i).residue_atom_code,width=4)
         stdout.put(self(i).residue_code,width=5)
         stdout.put(self(i).residue_sequence_number,width=6)
         stdout.put(self(i).position(1),width=8,precision=3)
         stdout.put(self(i).position(2),width=8,precision=3)
         stdout.put(self(i).position(3),width=8,precision=3)
         stdout.put(self(i).mm_charge,width=7,precision=3)
         stdout.put(self(i).label,width=4)
         stdout.flush
      end
      stdout.dash(width=42)
   end

   put_restraint_atoms ::: private
   ! Output a table of the atom names, residue names and restraint atom
   ! information
      i :: INT
      stdout.text("Restraint atoms:")
      stdout.save
      stdout.set_int_width(9)
      stdout.set_real_width(9)
      stdout.set_real_precision(3)
      stdout.dash(int_fields=5,real_fields=3)
      stdout.put(" ",int_width=TRUE)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Residue",int_width=TRUE)
      stdout.put("Sequence")
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.put("Force",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=5,real_fields=3)
      do i = 1,size(self)
         if (self(i).restraining_force_constant.is_zero) cycle
         stdout.put(" ",int_width=TRUE)
         stdout.put(self(i).residue_atom_code,int_width=TRUE)
         stdout.put(self(i).residue_code,int_width=TRUE)
         stdout.put(self(i).residue_sequence_number)
         stdout.put(self(i).restraining_position(1))
         stdout.put(self(i).restraining_position(2))
         stdout.put(self(i).restraining_position(3))
         stdout.put(self(i).restraining_force_constant)
         stdout.flush
      end
      stdout.dash(int_fields=5,real_fields=3)
      stdout.unsave
   end

!  ====
!  VRML
!  ====

   put_vrml(out)
   ! Put vrml version of the atomvec to the file in object "out".
      out :: TEXTFILE

      out.set_real_precision(5)
      out.set_real_width(12)

      stdout.text("Generating VRML atoms...")
      VEC{ATOM}::put_vrml_header(out)
      .put_vrml_atoms(out)
      .put_vrml_bonds(out)
      stdout.text("done VRML atoms")
      stdout.flush

   end

   put_vrml_header(out) ::: selfless, private
   ! Put vrml header, and prototype bond and spheres, to the file.
      out :: TEXTFILE

      out.text("PROTO Atom " // achar(91))
      out.text("   field SFColor col 1 0 0")
      out.text("   field SFFloat rad 1")
      out.text("   field SFVec3f pos 0 0 0")
      out.text(achar(93))
      out.text("{")
      out.text("   Transform {")
      out.text("      translation IS pos")
      out.text("      children " // achar(91))
      out.text("         Shape {")
      out.text("            appearance Appearance {")
      out.text("               material Material {")
      out.text("                  diffuseColor IS col")
      out.text("               }")
      out.text("            }")
      out.text("            geometry Sphere {")
      out.text("              radius IS rad")
      out.text("            }")
      out.text("         }")
      out.text("      " // achar(93))
      out.text("   }")
      out.text("}")

      out.flush

      out.text("PROTO Bond " // achar(91))
      out.text("   field SFColor col 1 0 0")
      out.text("   field SFFloat hgt 1")
      out.text("   field SFVec3f pos 0 0 0")
      out.text("   field SFRotation rot 1 0 0 0")
      out.text(achar(93))
      out.text("{")
      out.text("   Transform {")
      out.text("      translation IS pos")
      out.text("      rotation IS rot")
      out.text("      children " // achar(91))
      out.text("         Shape {")
      out.text("            appearance Appearance {")
      out.text("               material Material {")
      out.text("                 diffuseColor IS col")
      out.text("               }")
      out.text("            }")
      out.text("            geometry Cylinder {")
      out.text("               radius 0.304245979")
      out.text("               height IS hgt")
      out.text("               top    FALSE")
      out.text("               bottom FALSE")
      out.text("            }")
      out.text("         }")
      out.text("      " // achar(93))
      out.text("   }")
      out.text("}")

      out.flush

   end

   put_vrml_atoms(out) ::: private
   ! Put spheres for the atoms to view as vrml.
      out :: TEXTFILE

      colour :: VEC{REAL}(3)
      label :: STR(len=2)
      radius :: REAL
      n,Z :: INT

      do n = 1,.dim

         Z = self(n).atomic_number
         label = self(n).chemical_symbol

         select case (label)
            case ("H ","D ","T ");           colour = (/191,196,192/)
            case ("He","Rn");                colour = (/88,196,160/)
            case ("Li","Be","Na","Mg");      colour = (/144,149,145/)
            case ("B ");                     colour = (/187,4,187/)
            case ("C ");                     colour = (/160,80,17/)
            case ("N ","Al");                colour = (/126,169,176/)
            case ("Si");                     colour = (/192,172,137/)
            case ("S ");                     colour = (/192,165,0/)
            case ("Cl");                     colour = (/0,165,0/)
            case ("O ","Ca","Ge","As");      colour = (/192,12,8/)
            case ("Se","Br","Sr","I ");      colour = (/192,12,8/)
            case default;                    colour = (/192,148,25/)
         end

         select case (Z)
            case (1:54);     radius = self(n).bragg_slater_radius
            case default;    radius = 1.30d0
         end

         colour = colour / 256
         out.text("Atom {")
         out.text(" col " // trim(colour.to_concatenated_str("f15.8",separator=", ")))
         out.text(" pos " // trim(self(n).position.to_concatenated_str("f15.8",separator=", ")))
         out.text(" rad " // trim(radius.to_str("f15.8")))
         out.text("}")

      end

   end

   put_vrml_bonds(out) ::: private
   ! Put bonds for the atoms to view as vrml.
      out :: TEXTFILE

      col_a,col_b,posa,posb,pos1,pos2,AB,center :: VEC{REAL}(3)
      rot :: VEC{REAL}(4)
      hgta,hgtb,rada,radb :: REAL
      a,b :: INT

      do a = 1,.dim
      do b = 1,a-1

         if (.bonded(a,b)) then

            posa = self(a).position
            posb = self(b).position
            AB = posb-posa
            AB.normalise

            rada = self(a).bragg_slater_radius
            radb = self(b).bragg_slater_radius
            center = HALF*(posa+rada*AB + posb-radb*AB)

            hgta = (center - posa).norm
            hgtb = (posb - center).norm

            pos1 = HALF*(center + posa)
            pos2 = HALF*(center + posb)

            rot(4) = PI
            rot(1:3) = AB + (/ZERO,ONE,ZERO/)
            rot(1:3).normalise

            select case (self(a).chemical_symbol)
               case ("H ","D ","T ");           col_a = (/191,196,192/)
               case ("He","Rn");                col_a = (/88,196,160/)
               case ("Li","Be","Na","Mg");      col_a = (/144,149,145/)
               case ("B ");                     col_a = (/187,4,187/)
               case ("C ");                     col_a = (/160,80,17/)
               case ("N ","Al");                col_a = (/126,169,176/)
               case ("Si");                     col_a = (/192,172,137/)
               case ("S ");                     col_a = (/192,165,0/)
               case ("Cl");                     col_a = (/0,165,0/)
               case ("O ","Ca","Ge","As");      col_a = (/192,12,8/)
               case ("Se","Br","Sr","I ");      col_a = (/192,12,8/)
               case default;                    col_a = (/192,148,25/)
            end

            select case (self(b).chemical_symbol)
               case ("H ");                     col_b = (/191,196,192/)
               case ("He","Rn");                col_b = (/88,196,160/)
               case ("Li","Be","Na","Mg");      col_b = (/144,149,145/)
               case ("B ");                     col_b = (/187,4,187/)
               case ("C ");                     col_b = (/160,80,17/)
               case ("N ","Al");                col_b = (/126,169,176/)
               case ("Si");                     col_b = (/192,172,137/)
               case ("S ");                     col_b = (/192,165,0/)
               case ("Cl");                     col_b = (/0,165,0/)
               case ("O ","Ca","Ge","As");      col_b = (/192,12,8/)
               case ("Se","Br","Sr","I ");      col_b = (/192,12,8/)
               case default;                    col_b = (/192,148,25/)
            end

            col_a = col_a / 256
            col_b = col_b / 256
            out.text("Bond {")
            out.text(" col " //  trim(col_a.to_concatenated_str("f15.8",separator=", ")))
            out.text(" pos " //  trim(pos1.to_concatenated_str("f15.8",separator=", ")))
            out.text(" rot " //  trim(rot.to_concatenated_str("f15.8",separator=", ")))
            out.text(" hgt " //  trim(hgta.to_str("f15.8")))
            out.text("}")
            out.text("Bond {")
            out.text(" col " //  trim(col_b.to_concatenated_str("f15.8",separator=", ")))
            out.text(" pos " //  trim(pos2.to_concatenated_str("f15.8",separator=", ")))
            out.text(" rot " //  trim(rot.to_concatenated_str("f15.8",separator=", ")))
            out.text(" hgt " //  trim(hgtb.to_str("f15.8")))
            out.text("}")

         end

      end
      end

   end

   put_atom_groups
   ! Put out the atom group information
      self :: IN

   ENSURE(.has_groups,"no atom group information")

      n,i :: INT
      list :: VEC{VEC_{INT}}*

      .make_atom_group_list(list)

      stdout.save
      stdout.set_int_width(3)
      stdout.set_no_of_fields_per_line(25)
      stdout.set_using_array_labels(FALSE)

      stdout.flush
      stdout.text("Atom group information")
      stdout.flush
      stdout.show("n_groups =",list.dim)

      do n = 1,list.dim
         stdout.put("group "// trim(n.to_str) //"  =")
         do i = 1,list(n).element.dim
            stdout.put(list(n).element(i))
         end
         stdout.flush
      end

      stdout.unsave
      list.destroy

   end

   put_CX(label,angstrom)
   ! Outputs some information for the Crystal Explorer program
      label :: STR
      angstrom :: BIN, optional

      a :: INT
      pos :: VEC{REAL}(3)
      angst :: BIN

      angst = FALSE
      if (present(angstrom)) angst = angstrom

      ! Print atom_coords
      stdout.flush
      stdout.text("begin atom_coords " // label.trim)

      do a = 1,.dim

         stdout.put(self(a).label)
         stdout.put(self(a).chemical_symbol)

         pos = self(a).position
         if (angst) pos = ANGSTROM_PER_BOHR*pos
         stdout.put(pos(1))
         stdout.put(pos(2))
         stdout.put(pos(3))

         stdout.put(" IN")

         stdout.put(self(a).site_disorder_group)
         stdout.put(self(a).site_occupancy)

         stdout.flush

      end

      stdout.text("end atom_coords")

   end

!  ================
!  Put CIF routines
!  ================

   put_CIF_coords(refine_H_U_iso)
   ! Output the atoms and ADP's in CIF format to "stdout" in an
   ! axis system.
      self :: IN
      refine_H_U_iso :: BIN, IN

      is_cartn :: BIN

      is_cartn = self(1).pos_axis_system=="cartesian"

      if (is_cartn) then; .put_CIF_coords_cartn(refine_H_U_iso)
      else;               .put_CIF_coords_cryst(refine_H_U_iso)
      end

   end

   put_CIF_coords(refine_H_U_iso,esd)
   ! Output the atoms and ADP's in CIF format to "stdout" in an
   ! axis system, with errors "esd" provided externally.
      self :: IN
      refine_H_U_iso :: BIN, IN
      esd :: VEC{REAL}, IN

      is_cartn :: BIN

      is_cartn = self(1).pos_axis_system=="cartesian"

      if (is_cartn) then; .put_CIF_coords_cartn(refine_H_U_iso,esd)
      else;               .put_CIF_coords_cryst(refine_H_U_iso,esd)
      end

   end


   put_CIF_coords_cartn(refine_H_U_iso) ::: private
   ! Output the atoms and ADP's in CIF format to "stdout" in the
   ! cartesian axis system. This version does override existing esd's.
      self :: IN
      refine_H_U_iso :: BIN, IN

   ENSURE(self(1).pos_axis_system=="cartesian","not cartesian axis system!")

      ID,blnk,ADP_type :: VEC{STR}*
      Uiso,Uerr,occ :: VEC{REAL}*
      grp :: VEC{INT}*
      xyz,err :: MAT{REAL}*
      fac,fac2 :: REAL
      tabl1,tabl2 :: VEC{TABLE_COLUMN}*

      ! Unit conversion
      fac  = ANGSTROM_PER_BOHR
      fac2 = fac*fac

      ! CIF coordinate header
      stdout.flush
      stdout.text("# =====================")
      stdout.text("# Cartesian coordinates")
      stdout.text("# =====================")
      stdout.flush
      stdout.text("# . These precise data use non-standard CIF tags")
      stdout.text("# . Please keep for a better refinement restart")
      stdout.text("# . Units are in Angstrom")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_Cartn_label")
      stdout.text("_atom_site_Cartn_x")
      stdout.text("_atom_site_Cartn_y")
      stdout.text("_atom_site_Cartn_z")
      stdout.text("_atom_site_Cartn_U_iso_or_equiv")
      stdout.text("_atom_site_Cartn_adp_type")
      stdout.text("_atom_site_Cartn_occupancy")
      stdout.text("_atom_site_Cartn_disorder_group")
      stdout.text("_atom_site_Cartn_x_esu")
      stdout.text("_atom_site_Cartn_y_esu")
      stdout.text("_atom_site_Cartn_z_esu")
      stdout.text("_atom_site_Cartn_U_iso_or_equiv_esu")

      ! Table column data
      ID.create(.dim)
      blnk.create(.dim)
      xyz.create(.dim,3)
      err.create(.dim,3)
      Uiso.create(.dim)
      Uerr.create(.dim)
      ADP_type.create(.dim)
      occ.create(.dim)
      grp.create(.dim)

      ! Get table column data
      ID       = self.tag
      blnk     = " "
      .put_pos_vector_to(xyz,fac)
      .put_pos_errors_to(err,fac)
      Uiso     = self.U_iso      *fac2
      Uerr     = self.U_iso_error*fac2
      ADP_type = .ADP_type(refine_H_U_iso)
      occ      = self.site_occupancy
      grp      = self.site_disorder_group

      ! Table 1
      tabl1.create(8)
      tabl1(1).set_values(ID)
      tabl1(2).set_values(xyz(:,1))
      tabl1(3).set_values(xyz(:,2))
      tabl1(4).set_values(xyz(:,3))
      tabl1(5).set_values(Uiso)
      tabl1(6).set_values(ADP_type)
      tabl1(7).set_values(occ)
      tabl1(8).set_values(grp)

      ! Table 2
      tabl2.create(5)
      tabl2(1).set_values(blnk)
      tabl2(2).set_values(err(:,1))
      tabl2(3).set_values(err(:,2))
      tabl2(4).set_values(err(:,3))
      tabl2(5).set_values(Uerr)

      tabl2(1).set_width(tabl1(1).width)
      tabl2(2).set_width(tabl1(2).width)
      tabl2(3).set_width(tabl1(3).width)
      tabl2(4).set_width(tabl1(4).width)
      tabl2(5).set_width(tabl1(5).width)

      ! Put tables
      tabl1.put_body(tabl2)

      ! Clean
      tabl2.destroy
      tabl1.destroy
      grp.destroy
      occ.destroy
      ADP_type.destroy
      Uerr.destroy
      Uiso.destroy
      err.destroy
      xyz.destroy
      blnk.destroy
      ID.destroy

   end

   put_CIF_coords_cartn(refine_H_U_iso,esd) ::: private
   ! Output the atoms and ADP's in CIF format to "stdout" in an
   ! axis system, with errors "esd" provided externally.
      self :: IN
      refine_H_U_iso :: BIN, IN
      esd :: VEC{REAL}, IN

   ENSURE(esd.dim==.no_of_pADPS,"wrong size, esd")
   ENSURE(self(1).pos_axis_system=="cartesian","not cartesian axis system!")

      ID,blnk,ADP_type :: VEC{STR}*
      Uiso,Uerr,occ :: VEC{REAL}*
      grp :: VEC{INT}*
      xyz,err :: MAT{REAL}*
      fac,fac2 :: REAL
      tabl1,tabl2 :: VEC{TABLE_COLUMN}*

      ! Unit conversion
      fac  = ANGSTROM_PER_BOHR
      fac2 = fac*fac

      ! CIF coordinate header
      stdout.flush
      stdout.text("# =====================")
      stdout.text("# Cartesian coordinates")
      stdout.text("# =====================")
      stdout.flush
      stdout.text("# . These precise data use non-standard CIF tags")
      stdout.text("# . Please keep for a better refinement restart")
      stdout.text("# . Units are in Angstrom")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_Cartn_label")
      stdout.text("_atom_site_Cartn_x")
      stdout.text("_atom_site_Cartn_y")
      stdout.text("_atom_site_Cartn_z")
      stdout.text("_atom_site_Cartn_U_iso_or_equiv")
      stdout.text("_atom_site_Cartn_adp_type")
      stdout.text("_atom_site_Cartn_occupancy")
      stdout.text("_atom_site_Cartn_disorder_group")
      stdout.text("_atom_site_Cartn_x_esu")
      stdout.text("_atom_site_Cartn_y_esu")
      stdout.text("_atom_site_Cartn_z_esu")
      stdout.text("_atom_site_Cartn_U_iso_or_equiv_esu")

      ! Table column data
      ID.create(.dim)
      blnk.create(.dim)
      xyz.create(.dim,3)
      err.create(.dim,3)
      Uiso.create(.dim)
      Uerr.create(.dim)
      ADP_type.create(.dim)
      occ.create(.dim)
      grp.create(.dim)

      ! Get table column data
      ID       = self.tag
      blnk     = " "
      .put_pos_vector_to(xyz,fac)
      .put_pos_errors_to(err,esd,fac)     ! Note esd
      Uiso     = self.U_iso      *fac2
      Uerr     = self.U_iso_error*fac2
      ADP_type = .ADP_type(refine_H_U_iso)
      occ      = self.site_occupancy
      grp      = self.site_disorder_group

      ! Table 1
      tabl1.create(8)
      tabl1(1).set_values(ID)
      tabl1(2).set_values(xyz(:,1))
      tabl1(3).set_values(xyz(:,2))
      tabl1(4).set_values(xyz(:,3))
      tabl1(5).set_values(Uiso)
      tabl1(6).set_values(ADP_type)
      tabl1(7).set_values(occ)
      tabl1(8).set_values(grp)

      ! Table 2
      tabl2.create(5)
      tabl2(1).set_values(blnk)
      tabl2(2).set_values(err(:,1))
      tabl2(3).set_values(err(:,2))
      tabl2(4).set_values(err(:,3))
      tabl2(5).set_values(Uerr)

      tabl2(1).set_width(tabl1(1).width)
      tabl2(2).set_width(tabl1(2).width)
      tabl2(3).set_width(tabl1(3).width)
      tabl2(4).set_width(tabl1(4).width)
      tabl2(5).set_width(tabl1(5).width)

      ! Put tables
      tabl1.put_body(tabl2)

      ! Clean
      tabl2.destroy
      tabl1.destroy
      grp.destroy
      occ.destroy
      ADP_type.destroy
      Uerr.destroy
      Uiso.destroy
      err.destroy
      xyz.destroy
      blnk.destroy
      ID.destroy

   end


   put_CIF_coords_cryst(refine_H_U_iso) ::: private
   ! Output the atoms and ADP's in CIF format to "stdout" in the
   ! crystal/fractional axis system. This version does not override
   ! existing esd's.
      self :: IN
      refine_H_U_iso :: BIN, IN

      ID,ADP_type :: VEC{STR}*
      Uiso,occ :: VEC{REAL}*
      grp :: VEC{INT}*
      xyz :: MAT{REAL}*
      err :: MAT{REAL}*
      table :: VEC{TABLE_COLUMN}*
      fac,fac2 :: REAL

      ! Table column data
      ID.create(.dim)
      xyz.create(.dim,3)
      err.create(.dim,3)
      Uiso.create(.dim)
      ADP_type.create(.dim)
      occ.create(.dim)
      grp.create(.dim)

      ! Unit conversion
      fac  = ANGSTROM_PER_BOHR
      fac2 = fac*fac

      ! Get table column data
      ID       = self.tag
      Uiso     = self.U_iso*fac2
      ADP_type = .ADP_type(refine_H_U_iso)
      occ      = self.site_occupancy
      grp      = self.site_disorder_group

      ! CIF coordinate header
      stdout.flush
      stdout.text("# ======================")
      stdout.text("# Fractional coordinates")
      stdout.text("# ======================")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_label")
      stdout.text("_atom_site_fract_x")
      stdout.text("_atom_site_fract_y")
      stdout.text("_atom_site_fract_z")
      stdout.text("_atom_site_U_iso_or_equiv")
      stdout.text("_atom_site_adp_type")
      stdout.text("_atom_site_occupancy")
      stdout.text("_atom_site_disorder_group")

      ! Get table column data
      .put_pos_vector_to(xyz)
      .put_pos_errors_to(err)

      ! Table 1
      table.create(8)
      table(1).set_values(ID)
      table(2).set_values_and_errors(xyz(:,1),err(:,1))
      table(3).set_values_and_errors(xyz(:,2),err(:,2))
      table(4).set_values_and_errors(xyz(:,3),err(:,3))
      table(5).set_values(Uiso)
      table(6).set_values(ADP_type)
      table(7).set_values(occ)
      table(8).set_values(grp)

      ! Put tables
      table.put_body

      ! Clean
      table.destroy
      grp.destroy
      occ.destroy
      ADP_type.destroy
      Uiso.destroy
      err.destroy
      xyz.destroy
      ID.destroy

   end

   put_CIF_coords_cryst(refine_H_U_iso,esd) ::: private
   ! Output the atoms and ADP's in CIF format to "stdout" in an
   ! axis system, with errors "esd" provided externally.
      self :: IN
      refine_H_U_iso :: BIN, IN
      esd :: VEC{REAL}, IN

   ENSURE(esd.dim==.no_of_pADPS,"wrong size, esd")
   ENSURE(self(1).pos_axis_system=="crystal","not crystal axis system!")

      ID,blnk,ADP_type :: VEC{STR}*
      Uiso,Uerr,occ :: VEC{REAL}*
      grp :: VEC{INT}*
      xyz,err :: MAT{REAL}*
      fac,fac2 :: REAL
      tabl1 :: VEC{TABLE_COLUMN}*
      tabl2 :: VEC{TABLE_COLUMN}*

      ! Unit conversion
      fac  = ANGSTROM_PER_BOHR
      fac2 = fac*fac

      ! CIF coordinate header
      stdout.flush
      stdout.text("# =====================================")
      stdout.text("# Precise fractional system coordinates")
      stdout.text("# =====================================")
      stdout.flush
      stdout.text("# . These precise data use non-standard CIF tags")
      stdout.text("# . Non-standard tags shadow standard tags to avoid duplication")
      stdout.text("# . Please keep for a better refinement restart")
      stdout.text("# . Better yet, use the refined cartesian parameters")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_Cryst_label")
      stdout.text("_atom_site_Cryst_x")
      stdout.text("_atom_site_Cryst_y")
      stdout.text("_atom_site_Cryst_z")
      stdout.text("_atom_site_Cryst_U_iso_or_equiv")
      stdout.text("_atom_site_Cryst_adp_type")
      stdout.text("_atom_site_Cryst_occupancy")
      stdout.text("_atom_site_Cryst_disorder_group")
      stdout.text("_atom_site_Cryst_x_esu")
      stdout.text("_atom_site_Cryst_y_esu")
      stdout.text("_atom_site_Cryst_z_esu")
      stdout.text("_atom_site_Cryst_U_iso_or_equiv_esu")

      ! Table column data
      ID.create(.dim)
      blnk.create(.dim)
      xyz.create(.dim,3)
      err.create(.dim,3)
      Uiso.create(.dim)
      Uerr.create(.dim)
      ADP_type.create(.dim)
      occ.create(.dim)
      grp.create(.dim)

      ! Get table column data
      ID       = self.tag
      blnk     = " "
      .put_pos_vector_to(xyz)
      .put_pos_errors_to(err,esd)         ! Note esd
      Uiso     = self.U_iso      *fac2
      Uerr     = self.U_iso_error*fac2
      ADP_type = .ADP_type(refine_H_U_iso)
      occ      = self.site_occupancy
      grp      = self.site_disorder_group

      ! Table 1
      tabl1.create(8)
      tabl1(1).set_values(ID)
      tabl1(2).set_values(xyz(:,1))
      tabl1(3).set_values(xyz(:,2))
      tabl1(4).set_values(xyz(:,3))
      tabl1(5).set_values(Uiso)
      tabl1(6).set_values(ADP_type)
      tabl1(7).set_values(occ)
      tabl1(8).set_values(grp)

      ! Table 2
      tabl2.create(5)
      tabl2(1).set_values(blnk)
      tabl2(2).set_values(err(:,1))
      tabl2(3).set_values(err(:,2))
      tabl2(4).set_values(err(:,3))
      tabl2(5).set_values(Uerr)

      tabl2(1).set_width(tabl1(1).width)
      tabl2(2).set_width(tabl1(2).width)
      tabl2(3).set_width(tabl1(3).width)
      tabl2(4).set_width(tabl1(4).width)
      tabl2(5).set_width(tabl1(5).width)

      ! Put tables
      tabl1.put_body(tabl2)

      ! Clean
      tabl2.destroy
      tabl1.destroy

      ! CIF coordinate header
      stdout.flush
      stdout.text("# ======================")
      stdout.text("# Fractional coordinates")
      stdout.text("# ======================")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_label")
      stdout.text("_atom_site_fract_x")
      stdout.text("_atom_site_fract_y")
      stdout.text("_atom_site_fract_z")
      stdout.text("_atom_site_U_iso_or_equiv")
      stdout.text("_atom_site_adp_type")
      stdout.text("_atom_site_occupancy")
      stdout.text("_atom_site_disorder_group")

      ! Set table column data
      tabl1.create(8)
      tabl1(1).set_values(ID)
      tabl1(2).set_values_and_errors(xyz(:,1),err(:,1))
      tabl1(3).set_values_and_errors(xyz(:,2),err(:,2))
      tabl1(4).set_values_and_errors(xyz(:,3),err(:,3))
      tabl1(5).set_values_and_errors(Uiso,Uerr)
      tabl1(6).set_values(ADP_type)
      tabl1(7).set_values(occ)
      tabl1(8).set_values(grp)

      ! Put table
      tabl1.put_body

      ! Clean
      tabl1.destroy
      grp.destroy
      occ.destroy
      ADP_type.destroy
      Uerr.destroy
      Uiso.destroy
      err.destroy
      xyz.destroy
      blnk.destroy
      ID.destroy

   end


   put_CIF_ADP2(refine_H_U_iso,esd)
   ! Output the ADP2's in CIF format to "stdout" in an axis system.
   ! This version uses inputted refinement "esd" errors.
      self :: IN
      refine_H_U_iso :: BIN, optional, IN
      esd :: VEC{REAL}, optional, IN

      is_cartn :: BIN

      is_cartn = self(1).ADP_axis_system=="cartesian"

      if (is_cartn) then; .put_CIF_ADP2_cartn(refine_H_U_iso,esd)
      else;               .put_CIF_ADP2_cryst(refine_H_U_iso,esd)
      end

   end

   put_CIF_ADP2_cartn(refine_H_U_iso,esd) ::: private
   ! Output the ADP2's in CIF format to "stdout" in cartesian axis system.
   ! If present and TRUE "refine_H_U_iso" removed H ADP printing.
   ! If present and TRUE "esd" array for whole atom list overrides ! errors.
      self :: IN
      refine_H_U_iso :: BIN, optional, IN
      esd :: VEC{REAL}, optional, IN

   ENSURE(all(self(:).ADP_axis_system=="cartesian"),"ADP axis system must be cartesian")

      list :: VEC{INT}*
      ID,blnk :: VEC{STR}*
      ADPv,ADPe :: MAT{REAL}*
      tabl1,tabl2 :: VEC{TABLE_COLUMN}*
      lab :: STR
      fac :: REAL
      i,dim :: INT
      H_U_iso :: BIN

      H_U_iso = FALSE
      if (present(refine_H_U_iso)) H_U_iso = refine_H_U_iso

      ! Unit conversion for ADP's
      fac = ANGSTROM_PER_BOHR

      ! CIF ADP header
      stdout.flush
      stdout.text("# ==============")
      stdout.text("# Cartesian ADPs")
      stdout.text("# ==============")
      stdout.flush
      stdout.text("# . These precise data use non-standard CIF tags")
      stdout.text("# . Please keep for a better refinement restart")
      stdout.text("# . Units are in Angstrom^2")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_Cartn_ADP2_U_label")
      do i = 1,6
      lab = ATOM:ADP2_index_label(i,form="underscore-123-repeated")
      stdout.text("_atom_site_Cartn_ADP2_U_"//trim(lab))
      end
      do i = 1,6
      lab = ATOM:ADP2_index_label(i,form="underscore-123-repeated")
      stdout.text("_atom_site_Cartn_ADP2_U_"//trim(lab)//"_esu")
      end

      ! Size of table
      dim = .dim
      if (H_U_iso) dim = .no_of_non_H_atoms

      ! Allocate column data
        ID.create(dim)
      blnk.create(dim)
      ADPv.create(dim,6)
      ADPe.create(dim,6)

      ! Get column data
      if (NOT H_U_iso) then
         ID =  self.tag
         blnk = " "
         self.put_ADP2_vector_to(ADPv,fac)
         if (NOT present(esd)) then; self.put_ADP2_errors_to(ADPe,fac)
         else;                       self.put_ADP2_errors_to(ADPe,fac,esd)
         end
      else
         list => .list_of_non_H_atoms
         ID =  self(list).tag
         blnk = " "
         self(list).put_ADP2_vector_to(ADPv,fac)
         if (NOT present(esd)) then; self(list).put_ADP2_errors_to(ADPe,fac)
         else;                             self.put_ADP2_errors_to(ADPe,list,fac,esd)
         end
      end

      ! Table 1
      tabl1.create(7)
      tabl1(1).set_values(ID)
      tabl1(2).set_values(ADPv(:,1))
      tabl1(3).set_values(ADPv(:,2))
      tabl1(4).set_values(ADPv(:,3))
      tabl1(5).set_values(ADPv(:,4))
      tabl1(6).set_values(ADPv(:,5))
      tabl1(7).set_values(ADPv(:,6))

      ! Table 2
      tabl2.create(7)
      tabl2(1).set_values(blnk)
      tabl2(2).set_values(ADPe(:,1))
      tabl2(3).set_values(ADPe(:,2))
      tabl2(4).set_values(ADPe(:,3))
      tabl2(5).set_values(ADPe(:,4))
      tabl2(6).set_values(ADPe(:,5))
      tabl2(7).set_values(ADPe(:,6))

      tabl2(1).set_width(tabl1(1).width)
      tabl2(2).set_width(tabl1(2).width)
      tabl2(3).set_width(tabl1(3).width)
      tabl2(4).set_width(tabl1(4).width)
      tabl2(5).set_width(tabl1(5).width)
      tabl2(6).set_width(tabl1(6).width)
      tabl2(7).set_width(tabl1(7).width)

      ! Put tables
      tabl1.put_body(tabl2)

      ! Clean
      tabl2.destroy
      tabl1.destroy
      if (H_U_iso) list.destroy
      ADPe.destroy
      ADPv.destroy
      blnk.destroy
      ID.destroy

   end

   put_CIF_ADP2_cryst(refine_H_U_iso,esd) ::: private
   ! Output the ADP2's in CIF format to "stdout" in crystal system.
   ! If present and TRUE "refine_H_U_iso" removed H ADP printing.
   ! If present and TRUE "esd" array for whole atom list overrides ! errors.
      self :: IN
      refine_H_U_iso :: BIN, optional, IN
      esd :: VEC{REAL}, optional, IN

   ENSURE(all(self(:).ADP_axis_system=="crystal"),"ADP axis system must be crystal")

      list :: VEC{INT}*
      ID,blnk :: VEC{STR}*
      ADPv,ADPe :: MAT{REAL}*
      tabl1 :: VEC{TABLE_COLUMN}*
      tabl2 :: VEC{TABLE_COLUMN}*
      lab :: STR
      fac :: REAL
      i,dim :: INT
      H_U_iso :: BIN

      H_U_iso = FALSE
      if (present(refine_H_U_iso)) H_U_iso = refine_H_U_iso

      ! Unit conversion for ADP's
      fac = ANGSTROM_PER_BOHR

      ! CIF ADP header
      stdout.flush
      stdout.text("# ==================================")
      stdout.text("# Precise cartesian axis system ADPs")
      stdout.text("# ==================================")
      stdout.flush
      stdout.text("# . These precise data use non-standard CIF tags")
      stdout.text("# . Non-standard tags shadow standard tags to avoid duplication")
      stdout.text("# . Keep these for a refinement restart")
      stdout.text("# . Better yet, use the refined cartesian parameters")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_Cryst_ADP2_U_label")
      do i = 1,6
      lab = ATOM:ADP2_index_label(i,form="underscore-123-repeated")
      stdout.text("_atom_site_Cryst_ADP2_U_"//trim(lab))
      end
      do i = 1,6
      lab = ATOM:ADP2_index_label(i,form="underscore-123-repeated")
      stdout.text("_atom_site_Cryst_ADP2_U_"//trim(lab)//"_esu")
      end

      ! Size of table
      dim = .dim
      if (H_U_iso) dim = .no_of_non_H_atoms

      ! Allocate column data
        ID.create(dim)
      blnk.create(dim)
      ADPv.create(dim,6)
      ADPe.create(dim,6)

      ! Get column data
      if (NOT H_U_iso) then
         ID =  self.tag
         blnk = " "
         self.put_ADP2_vector_to(ADPv,fac)
         if (NOT present(esd)) then; self.put_ADP2_errors_to(ADPe,fac)
         else;                       self.put_ADP2_errors_to(ADPe,fac,esd)
         end
      else
         list => .list_of_non_H_atoms
         ID =  self(list).tag
         blnk = " "
         self(list).put_ADP2_vector_to(ADPv,fac)
         if (NOT present(esd)) then; self(list).put_ADP2_errors_to(ADPe,fac)
         else;                             self.put_ADP2_errors_to(ADPe,list,fac,esd)
         end
      end

      ! Table 1
      tabl1.create(7)
      tabl1(1).set_values(ID)
      tabl1(2).set_values(ADPv(:,1))
      tabl1(3).set_values(ADPv(:,2))
      tabl1(4).set_values(ADPv(:,3))
      tabl1(5).set_values(ADPv(:,4))
      tabl1(6).set_values(ADPv(:,5))
      tabl1(7).set_values(ADPv(:,6))

      ! Table 2
      tabl2.create(7)
      tabl2(1).set_values(blnk)
      tabl2(2).set_values(ADPe(:,1))
      tabl2(3).set_values(ADPe(:,2))
      tabl2(4).set_values(ADPe(:,3))
      tabl2(5).set_values(ADPe(:,4))
      tabl2(6).set_values(ADPe(:,5))
      tabl2(7).set_values(ADPe(:,6))

      tabl2(1).set_width(tabl1(1).width)
      tabl2(2).set_width(tabl1(2).width)
      tabl2(3).set_width(tabl1(3).width)
      tabl2(4).set_width(tabl1(4).width)
      tabl2(5).set_width(tabl1(5).width)
      tabl2(6).set_width(tabl1(6).width)
      tabl2(7).set_width(tabl1(7).width)

      ! Put tables
      tabl1.put_body(tabl2)

      ! Clean
      tabl2.destroy
      tabl1.destroy

      ! CIF ADP header
      stdout.flush
      stdout.text("# ====")
      stdout.text("# ADPs")
      stdout.text("# ====")
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_aniso_label")
      do i = 1,6
      lab = ATOM:ADP_label(i,form="underscore-123-repeated")
      stdout.text("_atom_site_aniso_"//trim(lab))
      end

      ! Table
      tabl1.create(7)
      tabl1(1).set_values(ID)
      tabl1(2).set_values_and_errors(ADPv(:,1),ADPe(:,1))
      tabl1(3).set_values_and_errors(ADPv(:,2),ADPe(:,2))
      tabl1(4).set_values_and_errors(ADPv(:,3),ADPe(:,3))
      tabl1(5).set_values_and_errors(ADPv(:,4),ADPe(:,4))
      tabl1(6).set_values_and_errors(ADPv(:,5),ADPe(:,5))
      tabl1(7).set_values_and_errors(ADPv(:,6),ADPe(:,6))

      ! Put tables
      tabl1.put_body

      ! Clean
      tabl1.destroy
      if (H_U_iso) list.destroy
      ADPe.destroy
      ADPv.destroy
      blnk.destroy
      ID.destroy

   end


   put_CIF_ADPn(cif)
   ! Output anharmonic ADPs in CIF format to "stdout".
   ! This version does not produce errors. See below.
   ! Can handle any .ADP_axis_system.
      self :: IN
      cif :: CIF, IN

      is_cartn :: BIN

      is_cartn = self(1).ADP_axis_system=="cartesian"

      if (is_cartn) then; .put_CIF_ADPn_cartn(cif)
      else;               .put_CIF_ADPn_cryst(cif)
      end

   end

   put_CIF_ADPn(cif,esd)
   ! Output anharmonic ADPs in CIF format to "stdout".
   ! This version produces errors, stored in "esd".
   ! Can handle any .ADP_axis_system.
      self :: IN
      cif :: CIF, IN
      esd :: VEC{REAL}, IN

      is_cartn :: BIN

      is_cartn = self(1).ADP_axis_system=="cartesian"

      if (is_cartn) then; .put_CIF_ADPn_cartn(cif,esd)
      else;               .put_CIF_ADPn_cryst(cif,esd)
      end

   end


   put_CIF_ADPn_cartn(cif) ::: private
   ! Output cartesian anharmonic ADPs in CIF format to "stdout".
   ! This version does not produce errors. See below.
      self :: IN
      cif :: CIF, IN

      i :: INT
      lab,ADPn_label :: STR
      ADP3v :: VEC{REAL}(10)
      ADP4v :: VEC{REAL}(15)
      fac1,fac2 :: REAL
      fac3,fac4 :: REAL

      ! Unit conversion for ADP's
      fac1 = ANGSTROM_PER_BOHR
      fac2 = fac1*fac1
      fac3 = fac2*fac1
      fac4 = fac2*fac2

      ! ==========
      ! Put ADP3's
      ! ==========
      if (.has_any_ADP3s_and_errors) then

         ADPn_label = "_atom_site_Cartn_ADP3_U_"

         stdout.flush
         stdout.text("# ===============")
         stdout.text("# Cartesian ADP3s")
         stdout.text("# ===============")
         stdout.flush
         stdout.text("# . These precise data use non-standard CIF tags")
         stdout.text("# . Please keep for a better refinement restart")
         stdout.text("# . Units are in Angstrom^3 but are scaled")

         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC3_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,10
         lab = ATOM:ADP3_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
       
         do i = 1,.dim
       
            if (NOT self(i).has_ADP3s_and_errors) cycle
       
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
       
            ! Get values
            self(i).put_ADP3_vector_to(ADP3v)

            ! Units !!!!!!!!!!!!
            ADP3v = fac3 * ADP3v

            ! Scale factor
            ADP3v = cif.GC3_scale_factor*ADP3v
       
            ! Print ADP3
            stdout.put(ADP3v( 1))
            stdout.put(ADP3v( 2))
            stdout.put(ADP3v( 3))
            stdout.flush

            stdout.put(ADP3v( 4))
            stdout.put(ADP3v( 5))
            stdout.flush

            stdout.put(ADP3v( 6))
            stdout.put(ADP3v( 7))
            stdout.flush

            stdout.put(ADP3v( 8))
            stdout.put(ADP3v( 9))
            stdout.flush

            stdout.put(ADP3v(10))
            stdout.flush
       
         end

      end

      ! ==========
      ! Put ADP4's
      ! ==========
      if (.has_any_ADP4s_and_errors) then

         ADPn_label = "_atom_site_Cartn_ADP4_U_"

         stdout.flush
         stdout.text("# ===============")
         stdout.text("# Cartesian ADP4s")
         stdout.text("# ===============")
         stdout.flush
         stdout.text("# . These precise data use non-standard CIF tags")
         stdout.text("# . Please keep for a better refinement restart")
         stdout.text("# . Units are in Angstrom^4 but may be scaled")

         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC4_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,15
         lab = ATOM:ADP4_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
        
         do i = 1,.dim
        
            if (NOT self(i).has_ADP4s_and_errors) cycle
        
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
        
            ! Get values
            self(i).put_ADP4_vector_to(ADP4v)

            ! Units !!!!!!!!!!
            ADP4v = fac4*ADP4v

            ! Scale factor
            ADP4v = cif.GC4_scale_factor*ADP4v
        
            ! Print ADP4
            stdout.put(ADP4v( 1))
            stdout.put(ADP4v( 2))
            stdout.put(ADP4v( 3))
            stdout.flush

            stdout.put(ADP4v( 4))
            stdout.put(ADP4v( 5))
            stdout.flush

            stdout.put(ADP4v( 6))
            stdout.put(ADP4v( 7))
            stdout.flush

            stdout.put(ADP4v( 8))
            stdout.put(ADP4v( 9))
            stdout.flush

            stdout.put(ADP4v(10))
            stdout.put(ADP4v(11))
            stdout.put(ADP4v(12))
            stdout.flush

            stdout.put(ADP4v(13))
            stdout.put(ADP4v(14))
            stdout.put(ADP4v(15))
            stdout.flush
        
         end

      end

   end

   put_CIF_ADPn_cartn(cif,esd) ::: private
   ! Output cartesian anharmonic ADPs in CIF format to "stdout".
   ! This version produces errors, stored in "esd".
      self :: IN
      cif :: CIF, IN
      esd :: VEC{REAL}, IN

   ENSURE(esd.dim==.no_of_pADPS,"wrong sizem esd")

      ADP :: VEC{REAL}(15)
      err :: VEC{REAL}(15)
      lab,ADPn_label :: STR
      i,k :: INT
      fac1,fac2 :: REAL
      fac3,fac4 :: REAL

      ! Unit conversion for ADP's
      fac1 = ANGSTROM_PER_BOHR
      fac2 = fac1*fac1
      fac3 = fac2*fac1
      fac4 = fac2*fac2

      ! ==========
      ! Put ADP3's 
      ! ==========
      if (.has_any_ADP3s_and_errors) then

         ADPn_label = "_atom_site_Cartn_ADP3_U_"

         stdout.flush
         stdout.text("# ===============")
         stdout.text("# Cartesian ADP3s")
         stdout.text("# ===============")
         stdout.flush
         stdout.text("# . These precise data use non-standard CIF tags")
         stdout.text("# . Please keep for a better refinement restart")
         stdout.text("# . Units are in Angstrom^3 but may be scaled")
        
         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC3_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,3
         lab = ATOM:ADP3_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 1,3
         lab = ATOM:ADP3_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         do i = 4,5
         lab = ATOM:ADP3_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 4,5
         lab = ATOM:ADP3_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         do i = 6,7
         lab = ATOM:ADP3_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 6,7
         lab = ATOM:ADP3_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         do i = 8,9
         lab = ATOM:ADP3_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 8,9
         lab = ATOM:ADP3_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         do i = 10,10
         lab = ATOM:ADP3_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end
        
         k = 0
         do i = 1,.dim
        
            if (NOT self(i).has_ADP3s_and_errors) cycle
        
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
        
            ! Get values and errors
            self(i).put_ADP3_vector_to(ADP(1:10))
            err(1:10) = esd(k+10:k+19)

            ! Units !!!!!!!!!!!!!!!!!!
            ADP(1:10) = ADP(1:10)*fac3
            err(1:10) = err(1:10)*fac3

            ! Scale by scale factor
            ADP(1:10) = ADP(1:10)*cif.GC3_scale_factor
            err(1:10) = err(1:10)*cif.GC3_scale_factor
        
            ! Put quantity q with full error.
            stdout.put(ADP( 1))
            stdout.put(ADP( 2))
            stdout.put(ADP( 3))
            stdout.flush
            stdout.put(err( 1))
            stdout.put(err( 2))
            stdout.put(err( 3))
            stdout.flush

            stdout.put(ADP( 4))
            stdout.put(ADP( 5))
            stdout.flush
            stdout.put(err( 4))
            stdout.put(err( 5))
            stdout.flush

            stdout.put(ADP( 6))
            stdout.put(ADP( 7))
            stdout.flush
            stdout.put(err( 6))
            stdout.put(err( 7))
            stdout.flush

            stdout.put(ADP( 8))
            stdout.put(ADP( 9))
            stdout.flush
            stdout.put(err( 8))
            stdout.put(err( 9))
            stdout.flush

            stdout.put(ADP(10))
            stdout.flush
            stdout.put(err(10))
            stdout.flush
        
            k = k + self(i).no_of_pADPs
        
         end

      end

      ! ==========
      ! Put ADP4's
      ! ==========
      if (.has_any_ADP4s_and_errors) then

         ADPn_label = "_atom_site_Cartn_ADP4_U_"

         stdout.flush
         stdout.text("# ===============")
         stdout.text("# Cartesian ADP4s")
         stdout.text("# ===============")
         stdout.flush
         stdout.text("# . These precise data use non-standard CIF tags")
         stdout.text("# . Please keep for a better refinement restart")
         stdout.text("# . Units are in Angstrom^4")
        
         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC4_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,3
         lab = ATOM:ADP4_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 1,3
         lab = ATOM:ADP4_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         do i = 4,5
         lab = ATOM:ADP4_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 4,5
         lab = ATOM:ADP4_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         do i = 6,7
         lab = ATOM:ADP4_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 6,7
         lab = ATOM:ADP4_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         do i = 8,9
         lab = ATOM:ADP4_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 8,9
         lab = ATOM:ADP4_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         do i = 10,12
         lab = ATOM:ADP4_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 10,12
         lab = ATOM:ADP4_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         do i = 13,15
         lab = ATOM:ADP4_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         do i = 13,15
         lab = ATOM:ADP4_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end
        
         k = 0
         do i = 1,.dim
        
            if (NOT self(i).has_ADP4s_and_errors) cycle
        
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
        
            ! Get values and errors (dimensionless)
            self(i).put_ADP4_vector_to(ADP(1:15))
            err(1:15) = esd(k+20:k+34)

            ! Units !!!!!!!!!!!!!!!!!!
            ADP(1:15) = ADP(1:15)*fac4
            err(1:15) = err(1:15)*fac4

            ! Scale by scale factor
            ADP(1:15) = ADP(1:15)*cif.GC4_scale_factor
            err(1:15) = err(1:15)*cif.GC4_scale_factor
        
            ! Put quantity q with full error.
            stdout.put(ADP( 1))
            stdout.put(ADP( 2))
            stdout.put(ADP( 3))
            stdout.flush
            stdout.put(err( 1))
            stdout.put(err( 2))
            stdout.put(err( 3))
            stdout.flush

            stdout.put(ADP( 4))
            stdout.put(ADP( 5))
            stdout.flush
            stdout.put(err( 4))
            stdout.put(err( 5))
            stdout.flush

            stdout.put(ADP( 6))
            stdout.put(ADP( 7))
            stdout.flush
            stdout.put(err( 6))
            stdout.put(err( 7))
            stdout.flush

            stdout.put(ADP( 8))
            stdout.put(ADP( 9))
            stdout.flush
            stdout.put(err( 8))
            stdout.put(err( 9))
            stdout.flush

            stdout.put(ADP(10))
            stdout.put(ADP(11))
            stdout.put(ADP(12))
            stdout.flush
            stdout.put(err(10))
            stdout.put(err(11))
            stdout.put(err(12))
            stdout.flush

            stdout.put(ADP(13))
            stdout.put(ADP(14))
            stdout.put(ADP(15))
            stdout.flush
            stdout.put(err(13))
            stdout.put(err(14))
            stdout.put(err(15))
            stdout.flush
        
            k = k + self(i).no_of_pADPs
        
         end

      end ! =========

   end


   put_CIF_ADPn_cryst(cif) ::: private
   ! Output anharmonic ADPs in CIF format to "stdout".
   ! This version does not produce errors. See below.
   ! Can handle any .ADP_axis_system.
      self :: IN
      cif :: CIF, IN

      i :: INT
      lab,ADPn_label :: STR
      ADP3v :: VEC{REAL}(10)
      ADP4v :: VEC{REAL}(15)

      ! ==========
      ! Put ADP3's
      ! ==========
      if (.has_any_ADP3s_and_errors) then

         ADPn_label = "_atom_site_anharm_GC_C_"

         stdout.flush
         stdout.text("# ======================================")
         stdout.text("# Third order Gram-Charlier coefficients")
         stdout.text("# ======================================")
         stdout.flush
         stdout.text("# . These data are in standard presentation")
         stdout.text("# . They are dimensionless but are scaled")

         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC3_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,10
         lab = ATOM:ADP3_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
       
         do i = 1,.dim
       
            if (NOT self(i).has_ADP3s_and_errors) cycle
       
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
       
            ! Get values
            self(i).put_ADP3_vector_to(ADP3v)

            ! Scale factor
            ADP3v = cif.GC3_scale_factor*ADP3v
       
            ! Print ADP3
            stdout.put(ADP3v( 1))
            stdout.put(ADP3v( 2))
            stdout.put(ADP3v( 3))
            stdout.flush

            stdout.put(ADP3v( 4))
            stdout.put(ADP3v( 5))
            stdout.flush

            stdout.put(ADP3v( 6))
            stdout.put(ADP3v( 7))
            stdout.flush

            stdout.put(ADP3v( 8))
            stdout.put(ADP3v( 9))
            stdout.flush

            stdout.put(ADP3v(10))
            stdout.flush
       
         end

      end

      ! ==========
      ! Put ADP4's
      ! ==========
      if (.has_any_ADP4s_and_errors) then

         ADPn_label = "_atom_site_anharm_GC_D_"

         stdout.flush
         stdout.text("# =======================================")
         stdout.text("# Fourth order Gram-Charlier coefficients")
         stdout.text("# =======================================")
         stdout.flush
         stdout.text("# . These data are in standard presentation")
         stdout.text("# . They are dimensionless but may be scaled")

         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC4_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,15
         lab = ATOM:ADP4_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
        
         do i = 1,.dim
        
            if (NOT self(i).has_ADP4s_and_errors) cycle
        
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
        
            ! Get values
            self(i).put_ADP4_vector_to(ADP4v)

            ! Scale factor
            ADP4v = cif.GC4_scale_factor*ADP4v
        
            ! Print ADP4
            stdout.put(ADP4v( 1))
            stdout.put(ADP4v( 2))
            stdout.put(ADP4v( 3))
            stdout.flush

            stdout.put(ADP4v( 4))
            stdout.put(ADP4v( 5))
            stdout.flush

            stdout.put(ADP4v( 6))
            stdout.put(ADP4v( 7))
            stdout.flush

            stdout.put(ADP4v( 8))
            stdout.put(ADP4v( 9))
            stdout.flush

            stdout.put(ADP4v(10))
            stdout.put(ADP4v(11))
            stdout.put(ADP4v(12))
            stdout.flush

            stdout.put(ADP4v(13))
            stdout.put(ADP4v(14))
            stdout.put(ADP4v(15))
            stdout.flush
        
         end

      end

   end

   put_CIF_ADPn_cryst(cif,esd) ::: private
   ! Output fractional/GC anharmonic ADPs in CIF format to "stdout".
   ! This version produces errors, stored in "esd".
      self :: IN
      cif :: CIF, IN
      esd :: VEC{REAL}, IN

   ENSURE(esd.dim==.no_of_pADPS,"wrong sizem esd")

      ADP :: VEC{REAL}(15)
      err :: VEC{REAL}(15)
      lab,ADPn_label :: STR
      i,k :: INT

      ! ==========
      ! Put ADP3's 
      ! ==========
      if (.has_any_ADP3s_and_errors) then

         ADPn_label = "_atom_site_anharm_GC_C_"

         stdout.flush
         stdout.text("# ============================================")
         stdout.text("# Precise 3rd order Gram-Charlier coefficients")
         stdout.text("# ============================================")
         stdout.flush
         stdout.text("# . These are precise parameters and ESDs")
         stdout.text("# . Keep these for a refinement restart")
         stdout.text("# . Better yet, use the refined cartesian parameters")
        
         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC3_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,10
         lab = ATOM:ADP3_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end
        
         k = 0
         do i = 1,.dim
        
            if (NOT self(i).has_ADP3s_and_errors) cycle
        
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
        
            ! Get values and errors (dimensionless)
            self(i).put_ADP3_vector_to(ADP(1:10))
            err(1:10) = esd(k+10:k+19)

            ! Scale by scale_factor
            ADP(1:10) = ADP(1:10)*cif.GC3_scale_factor
            err(1:10) = err(1:10)*cif.GC3_scale_factor
        
            ! Put quantity q with full error.
            stdout.put(ADP( 1)); stdout.flush
            stdout.put(err( 1)); stdout.flush
            stdout.put(ADP( 2)); stdout.flush
            stdout.put(err( 2)); stdout.flush
            stdout.put(ADP( 3)); stdout.flush
            stdout.put(err( 3)); stdout.flush
            stdout.put(ADP( 4)); stdout.flush
            stdout.put(err( 4)); stdout.flush
            stdout.put(ADP( 5)); stdout.flush
            stdout.put(err( 5)); stdout.flush
            stdout.put(ADP( 6)); stdout.flush
            stdout.put(err( 6)); stdout.flush
            stdout.put(ADP( 7)); stdout.flush
            stdout.put(err( 7)); stdout.flush
            stdout.put(ADP( 8)); stdout.flush
            stdout.put(err( 8)); stdout.flush
            stdout.put(ADP( 9)); stdout.flush
            stdout.put(err( 9)); stdout.flush
            stdout.put(ADP(10)); stdout.flush
            stdout.put(err(10)); stdout.flush
        
            k = k + self(i).no_of_pADPs
        
         end

         ! Reset precision for errors
         stdout.save
         stdout.set_real_width(stdout.saved.real_width+3)
         stdout.set_real_precision(stdout.saved.real_precision+3)
         
         ! CIF ADP header
         stdout.flush
         stdout.text("# ======================================")
         stdout.text("# Third order Gram-Charlier coefficients")
         stdout.text("# ======================================")
         stdout.flush
         stdout.text("# . These data are in standard presentation")

         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC3_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")
         do i = 1,10
         lab = ATOM:ADP3_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         
         ! Put ADP's
         k = 0
         do i = 1,.dim
        
            if (NOT self(i).has_ADP3s_and_errors) cycle
         
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
        
            ! Get values and errors
            self(i).put_ADP3_vector_to(ADP(1:10))
            err(1:10) = esd(k+10:k+19)

            ! Scale by scale_factor
            ADP(1:10) = ADP(1:10)*cif.GC3_scale_factor
            err(1:10) = err(1:10)*cif.GC3_scale_factor
         
            ! Put quantity q with error e in format q(e)
            stdout.put(ADP( 1),err( 1))
            stdout.put(ADP( 2),err( 2))
            stdout.put(ADP( 3),err( 3))
            stdout.flush

            stdout.put(ADP( 4),err( 4))
            stdout.put(ADP( 5),err( 5))
            stdout.flush

            stdout.put(ADP( 6),err( 6))
            stdout.put(ADP( 7),err( 7))
            stdout.flush

            stdout.put(ADP( 8),err( 8))
            stdout.put(ADP( 9),err( 9))
            stdout.flush

            stdout.put(ADP(10),err(10))
            stdout.flush
         
            k = k + self(i).no_of_pADPs
         
         end
         
         ! Revert
         stdout.unsave
   
      end

      ! ==========
      ! Put ADP4's
      ! ==========
      if (.has_any_ADP4s_and_errors) then

         ADPn_label = "_atom_site_anharm_GC_D_"

         stdout.flush
         stdout.text("# ============================================")
         stdout.text("# Precise 4th order Gram-Charlier coefficients")
         stdout.text("# ============================================")
         stdout.flush
         stdout.text("# . These are precise parameters and ESDs")
         stdout.text("# . Keep these for a refinement restart")
         stdout.text("# . Better yet, use the refined cartesian parameters")
        
         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC4_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")
         do i = 1,15
         lab = ATOM:ADP4_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end
        
         k = 0
         do i = 1,.dim
        
            if (NOT self(i).has_ADP4s_and_errors) cycle
        
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
        
            ! Get values and errors (dimensionless)
            self(i).put_ADP4_vector_to(ADP(1:15))
            err(1:15) = esd(k+20:k+34)

            ! Scale by scale factor
            ADP(1:15) = ADP(1:15)*cif.GC4_scale_factor
            err(1:15) = err(1:15)*cif.GC4_scale_factor
        
            ! Put quantity q with full error.
            stdout.put(ADP( 1)); stdout.flush
            stdout.put(err( 1)); stdout.flush
            stdout.put(ADP( 2)); stdout.flush
            stdout.put(err( 2)); stdout.flush
            stdout.put(ADP( 3)); stdout.flush
            stdout.put(err( 3)); stdout.flush
            stdout.put(ADP( 4)); stdout.flush
            stdout.put(err( 4)); stdout.flush
            stdout.put(ADP( 5)); stdout.flush
            stdout.put(err( 5)); stdout.flush
            stdout.put(ADP( 6)); stdout.flush
            stdout.put(err( 6)); stdout.flush
            stdout.put(ADP( 7)); stdout.flush
            stdout.put(err( 7)); stdout.flush
            stdout.put(ADP( 8)); stdout.flush
            stdout.put(err( 8)); stdout.flush
            stdout.put(ADP( 9)); stdout.flush
            stdout.put(err( 9)); stdout.flush
            stdout.put(ADP(10)); stdout.flush
            stdout.put(err(10)); stdout.flush
            stdout.put(ADP(11)); stdout.flush
            stdout.put(err(11)); stdout.flush
            stdout.put(ADP(12)); stdout.flush
            stdout.put(err(12)); stdout.flush
            stdout.put(ADP(13)); stdout.flush
            stdout.put(err(13)); stdout.flush
            stdout.put(ADP(14)); stdout.flush
            stdout.put(err(14)); stdout.flush
            stdout.put(ADP(15)); stdout.flush
            stdout.put(err(15)); stdout.flush
        
            k = k + self(i).no_of_pADPs
        
         end

         ! Reset precision for errors
         stdout.save
         stdout.set_real_width(stdout.saved.real_width+3)
         stdout.set_real_precision(stdout.saved.real_precision+3)
         
         ! CIF ADP header
         stdout.flush
         stdout.text("# =======================================")
         stdout.text("# Fourth order Gram-Charlier coefficients")
         stdout.text("# =======================================")
         stdout.flush
         stdout.text("# . These data are in standard presentation")

         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC4_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")
         do i = 1,15
         lab = ATOM:ADP4_index_label(i,form="underscore-123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         end
         
         ! Put ADP's
         k = 0
         do i = 1,.dim
        
            if (NOT self(i).has_ADP4s_and_errors) cycle
         
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
        
            ! Get values and errors
            self(i).put_ADP4_vector_to(ADP(1:15))
            err(1:15) = esd(k+20:k+34)

            ! Scale by scale_factor
            ADP(1:15) = ADP(1:15)*cif.GC4_scale_factor
            err(1:15) = err(1:15)*cif.GC4_scale_factor
         
            ! Put quantity q with error e in format q(e)
            stdout.put(ADP( 1),err( 1))
            stdout.put(ADP( 2),err( 2))
            stdout.put(ADP( 3),err( 3))
            stdout.flush

            stdout.put(ADP( 4),err( 4))
            stdout.put(ADP( 5),err( 5))
            stdout.flush

            stdout.put(ADP( 6),err( 6))
            stdout.put(ADP( 7),err( 7))
            stdout.flush

            stdout.put(ADP( 8),err( 8))
            stdout.put(ADP( 9),err( 9))
            stdout.flush

            stdout.put(ADP(10),err(10))
            stdout.put(ADP(11),err(11))
            stdout.put(ADP(12),err(12))
            stdout.flush

            stdout.put(ADP(13),err(13))
            stdout.put(ADP(14),err(14))
            stdout.put(ADP(15),err(15))
            stdout.flush
         
            k = k + self(i).no_of_pADPs
         
         end
         
         ! Revert
         stdout.unsave
   
      end ! =========

   end


   put_CIF_bond_length_table(covariance)
   ! Output the CIF bond length table with errors, given the "covariance"
   ! matrix between all atomic positions. 
      self :: IN
      covariance :: MAT{REAL}, IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}*
      Z_list :: VEC{VEC_{INT}}*
      n_kind,k1,k2,n_bonds :: INT
      labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      dist,esds :: VEC{REAL}*
      pair :: MAT{INT}*

      ! Header
      stdout.flush
      stdout.text("# ============")
      stdout.text("# Bond lengths")
      stdout.text("# ============")

      ! Loop 
      stdout.flush
      stdout.text("loop_")
      stdout.text(" _geom_bond_atom_site_label_1")
      stdout.text(" _geom_bond_site_symmetry_1")
      stdout.text(" _geom_bond_atom_site_label_2")
      stdout.text(" _geom_bond_site_symmetry_2")
      stdout.text(" _geom_bond_distance")
      stdout.text(" _geom_bond_publ_flag")

      ! Get Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(6)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self.tag)
      table(2).set_heading(".")
      table(2).set_width(1)
      table(3).set_heading("B")
      table(3).set_width(table(1).width)
      table(4).set_heading(".")
      table(4).set_width(1)
      table(5).set_heading("R(A--B)")
      table(5).set_width_from(ONE)
      table(6).set_heading("yes")
      table(6).set_width(3)


      ! Loop over atom Z classes, Z(k1) >= Z(k2)
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_atoms(pair,dist,esds,Z_list,k1,k2,covariance) ! leaky
         dist = dist*ANGSTROM_PER_BOHR
         esds = esds*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            esds.destroy
            dist.destroy
            pair.destroy
            cycle
         end

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = self(pair(:,1)).tag
         labels(:,2) = self(pair(:,2)).tag

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "."
         dsh1    = "yes"

         ! Set table data
         table(1).set_values(labels(:,1))
         table(2).set_values(dash)
         table(3).set_values(labels(:,2))
         table(4).set_values(dash)
         table(5).set_values_and_errors(dist,esds)
         table(6).set_values(dsh1)

         ! Put body
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         esds.destroy
         dist.destroy
         pair.destroy

      end
      end


      ! Clean
      table.clear_columns
      table.destroy
      Z_list.destroy

   end

   put_CIF_bond_angle_table(covariance)
   ! Output the CIF bond angle table with errors given the "covariance"
   ! matrix between all atomic positions. 
      self :: IN
      covariance :: MAT{REAL}, IN

   ENSURE(self(1).pos_axis_system=="cartesian","axis system must be cartesian")

      table :: VEC{TABLE_COLUMN}*
      Z_list :: VEC{VEC_{INT}}*
      n_kind,k1,k2,k3,n_angles :: INT
      symbols   :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      angle,esds :: VEC{REAL}*
      triple :: MAT{INT}*

      ! Title
      stdout.flush
      stdout.text("# ===========")
      stdout.text("# Bond Angles")
      stdout.text("# ===========")

      ! Loop 
      stdout.flush
      stdout.text("loop_")
      stdout.text(" _geom_angle_atom_site_label_1")
      stdout.text(" _geom_angle_site_symmetry_1")
      stdout.text(" _geom_angle_atom_site_label_2")
      stdout.text(" _geom_angle_site_symmetry_2")
      stdout.text(" _geom_angle_atom_site_label_3")
      stdout.text(" _geom_angle_site_symmetry_3")
      stdout.text(" _geom_angle")
      stdout.text(" _geom_angle_publ_flag")

      ! Get Z list
      .make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (self(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(8)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self(.angle_outer_atoms).tag)
      table(2).set_heading(".")
      table(2).set_width(1)
      table(3).set_heading("B")
      table(3).set_width_from(self(.angle_center_atoms).tag)
      table(4).set_heading(".")
      table(4).set_width(1)
      table(5).set_heading("C")
      table(5).set_width_from(self(.angle_outer_atoms).tag)
      table(6).set_heading(".")
      table(6).set_width(1)
      table(7).set_heading("Angle(A--B--C)")
      table(7).set_width_from(ONE)
      table(8).set_heading("yes")
      table(8).set_width(3)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_angles(triple,angle,esds,Z_list,k1,k2,k3,covariance)
         angle = angle*DEGREE_PER_RADIAN
         esds  = esds *DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            esds.destroy
            angle.destroy
            triple.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,3)
         symbols = " "
         symbols(:,1) = self(triple(:,1)).tag
         symbols(:,2) = self(triple(:,2)).tag
         symbols(:,3) = self(triple(:,3)).tag

         ! Dashes
         dash.create(n_angles)
         dsh1.create(n_angles)
         dash    = "."
         dsh1    = "yes"

         ! Set table data
         table(1).set_values(symbols(:,1))
         table(2).set_values(dash)
         table(3).set_values(symbols(:,2))
         table(4).set_values(dash)
         table(5).set_values(symbols(:,3))
         table(6).set_values(dash)
         table(7).set_values_and_errors(angle,esds)
         table(8).set_values(dsh1)

         ! Put body
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         symbols.destroy
         esds.destroy
         angle.destroy
         triple.destroy

      end
      end
      end

      ! Clean
      table.destroy
      Z_list.destroy

   end



   put_NKA_with_errors(T_sequence_no)
   ! Output the atom positions, ADP's, ADP sigmas in NKA file format
   ! to "stdout".
      T_sequence_no :: INT

      i,k :: INT
      fac :: REAL
      ADP :: MAT{REAL}(3,3)
      pos :: VEC{REAL}(3)
      err :: VEC{REAL}(6)

      ! Unit conversion for ADP's
      fac =  ANGSTROM_PER_BOHR*ANGSTROM_PER_BOHR

      ! Coordinates and ADP's in A^2
      stdout.flush
      do i = 1,.dim

         stdout.put(self(i).chemical_symbol,width=3)

         ! Coordinates in crystal or cartesian system
         pos = ANGSTROM_PER_BOHR * self(i).position
         stdout.put(pos(1))
         stdout.put(pos(2))
         stdout.put(pos(3))
         stdout.put(1,width=2)
         stdout.put(T_sequence_no,width=3)
         stdout.flush

         ! Get values and errors
         ADP =  fac * self(i).ADP_tensor

         ! ADP's always in cartesians and A^2
         stdout.put(ADP(1,1))
         stdout.put(ADP(2,2))
         stdout.put(ADP(3,3))
         stdout.put(ADP(1,2))
         stdout.put(ADP(1,3))
         stdout.put(ADP(2,3))

         stdout.flush

      end

      ! Now the ADP errors
      stdout.flush
      k = -9
      do i = 1,.dim

         k = k + 9

         stdout.put("SIG",width=3)
         stdout.put(self(i).chemical_symbol,width=3)
         stdout.put(T_sequence_no,width=3)

         ! Get values and errors
         err = fac * self(i).pADP_errors(4:9)

         ! Print ADPs
         stdout.put(err(1))
         stdout.put(err(2))
         stdout.put(err(3))
         stdout.put(err(4))
         stdout.put(err(5))
         stdout.put(err(6))

         stdout.flush

      end

   end

   put_excel_with_errors(esd,temperature)
   ! Output the atoms in Excel file format to "stdout"
   ! This should be in the crystal coordinate system.
      esd :: VEC{REAL}
      temperature :: REAL

   ENSURE(self(1).pos_axis_system=="crystal","must be in crystal axis system")

      i,k :: INT
      fac :: REAL
      ADP :: MAT{REAL}(3,3)
      err :: VEC{REAL}(6)
      lab :: STR

      ! Unit conversion for ADP's
      fac =  ANGSTROM_PER_BOHR*ANGSTROM_PER_BOHR

      ! Coordinates in crystal axis system
      stdout.show("Coordinates refined at T =",temperature)
      stdout.flush
      k = 0
      do i = 1,.dim

         stdout.put("x")
         stdout.put(self(i).position(1))
         stdout.put(esd(k+1))
         stdout.put(self(i).tag)
         stdout.flush

         stdout.put("y")
         stdout.put(self(i).position(2))
         stdout.put(esd(k+2))
         stdout.put(self(i).tag)
         stdout.flush

         stdout.put("z")
         stdout.put(self(i).position(3))
         stdout.put(esd(k+3))
         stdout.put(self(i).tag)
         stdout.flush

         k = k + 9

      end

      ! ADP's in crystal (CIF) axis system, angstrom^2 units
      stdout.show("ADP's refined at T =",temperature)
      stdout.flush
      k = 0
      do i = 1,.dim

         ! Get values and errors
         ADP = fac * self(i).ADP_tensor
         err = fac * esd(k+4:k+9)
         lab = self(i).tag

         ! Print
         stdout.put("U11"); stdout.put(ADP(1,1)); stdout.put(err(1)); stdout.put(lab); stdout.flush
         stdout.put("U22"); stdout.put(ADP(2,2)); stdout.put(err(2)); stdout.put(lab); stdout.flush
         stdout.put("U33"); stdout.put(ADP(3,3)); stdout.put(err(3)); stdout.put(lab); stdout.flush
         stdout.put("U12"); stdout.put(ADP(1,2)); stdout.put(err(4)); stdout.put(lab); stdout.flush
         stdout.put("U13"); stdout.put(ADP(1,3)); stdout.put(err(5)); stdout.put(lab); stdout.flush
         stdout.put("U23"); stdout.put(ADP(2,3)); stdout.put(err(6)); stdout.put(lab); stdout.flush

         k = k + 9

      end

   end

!  ============
!  Put orbitals
!  ============

   put_orbitals(orb,pair)
   ! Output the orbitals "orb" in a table with basis function labels.
      self :: IN
      orb :: MAT{REAL}, IN
      pair :: BIN, optional, IN

   ENSURE(.has_all_gaussian_bases,"no gaussian bases")
   ENSURE(orb.dim2==.no_of_basis_functions,"wrong dim2, orb: "//trim(INT:to_str(orb.dim2)))

      table :: VEC{TABLE_COLUMN}*
      labels :: VEC{STR}*
      is_pair :: BIN
      c :: INT

      ! Bond/antibond pair?
      is_pair = FALSE
      if (present(pair)) then
      if (orb.dim2==2) then
         is_pair = pair
      end
      end

      ! Basis-fn tags
      labels.create(.no_of_basis_functions)
      labels = .tag_xyz_basis_fn_part

      ! Create table
      table.create(orb.dim2+1)

      ! Set table headings
      table(1).set_heading("Basis")
      table(1).set_subhead("func.")

      if (is_pair) then
         table(2).set_heading("Bond")
         table(2).set_subhead("Orb.")
         table(3).set_heading("Anti")
         table(3).set_subhead("bond")
      else
         do c = 1,orb.dim2
         table(c+1).set_heading("Orb")
         table(c+1).set_subhead(trim(c.to_str))
         end
      end

      ! Set data
      table(1).set_values(labels)
      do c = 1,orb.dim2
         table(c+1).set_values(orb(:,c))
      end


      ! Put
      table.put(label_rows=FALSE)

      ! Clean
      table.clear_columns
      table.destroy
      labels.destroy

   end

end
