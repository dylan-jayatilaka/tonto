!==================================================================
!
! MOLECULE.CP: Coupled-perturbed (CP) procedures
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!==================================================================


module MOLECULE.CP

   implicit none

contains

!  ================================
!  Very bad dipole polarisabilities
!  ================================

   put_Sylvain_Csizmadia_tensors 
   ! Put out the Sylvain-Csizmadia polarisability tensors.  This
   ! routine will read the value of the Unsold denominator.
      self :: INOUT

   ENSURE(.density_mx.allocated,"no density matrix")
   ENSURE(.MOs.allocated,"no molecular orbitals")
   ENSURE(.MOs.r.allocated,"no restricted MO'ss")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated, "no atom info")

      P, Dx,Dy,Dz :: MAT{REAL}@
      Qxx,Qyy,Qzz :: MAT{REAL}@
      Qxy,Qxz,Qyz :: MAT{REAL}@
      Oxxx,Oyyy,Ozzz :: MAT{REAL}@
      Oxxy,Oxxz,Oyyx :: MAT{REAL}@
      Oyyz,Ozzx,Ozzy,Oxyz :: MAT{REAL}@
      alpha,evec, mu2 :: MAT{REAL}(3,3)
      beta,       mu3 :: MAT3{REAL}(3,3,3)
      bvec, eval, mu1 :: VEC{REAL}(3)
      b10vec :: VEC{REAL}(10)
      n,x,y,z, i, u,v,w :: INT
      delta,dm1 :: REAL
      fac1,fac2 :: REAL
      fnm1,fnm2 :: REAL
      val1,val2,val3 :: REAL

      stdout.flush
      stdout.text("========================================")
      stdout.text("Sylvian-Csizmadia polarisability tensors")
      stdout.text("========================================")

      ! Input Unsold denominator
    ! stdin.read(delta)

      ! 1/N factors ...
      fnm1  = (ONE/.n_a)
      fnm2  = fnm1*fnm1

      ! Calculate Unsold denominator
      dm1 = ZERO
      do i = 1,.n_a
         dm1 = dm1 + ONE/.MO_energies.r(i)
      end
      dm1  = -fnm1*dm1
      fac1 =  FOUR*dm1
      fac2 =  TWELVE*dm1*dm1

      ! Print Unsold denominator
      delta = ONE/dm1
      stdout.flush
      stdout.show("Unsold denominator/a.u. =",delta)

      ! Allocate space for moment matrix elements, and get them
      n = .n_bf
        Dx.create(n,n);   Dy.create(n,n);   Dz.create(n,n)
       Qxx.create(n,n);  Qyy.create(n,n);  Qzz.create(n,n)
       Qxy.create(n,n);  Qxz.create(n,n);  Qyz.create(n,n)
      Oxxx.create(n,n); Oyyy.create(n,n); Ozzz.create(n,n)
      Oxxy.create(n,n); Oxxz.create(n,n)
      Oyyx.create(n,n); Oyyz.create(n,n)
      Ozzx.create(n,n); Ozzy.create(n,n)
      Oxyz.create(n,n)
      .INTS:make_dipole_matrices(Dx,Dy,Dz)
      .INTS:make_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
      .INTS:make_octupole_matrices(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz)

      ! Get the half-occupied density matrix
      .BASE:make_r_density_mx
      P.create(.n_bf,.n_bf)
      P = HALF*.density_mx.r

      ! Set the component indices
      x = 1
      y = 2
      z = 3

      ! Moments
      mu1(x) = P.trace_product_with(Dx)
      mu1(y) = P.trace_product_with(Dy)
      mu1(z) = P.trace_product_with(Dz)

      mu2(x,x) = P.trace_product_with(Qxx)
      mu2(y,y) = P.trace_product_with(Qyy)
      mu2(z,z) = P.trace_product_with(Qzz)
      mu2(y,x) = P.trace_product_with(Qxy)
      mu2(z,x) = P.trace_product_with(Qxz)
      mu2(z,y) = P.trace_product_with(Qyz)
      mu2(x,y) = mu2(y,x)
      mu2(x,z) = mu2(z,x)
      mu2(y,z) = mu2(z,y)

      mu3(x,x,x) = P.trace_product_with(Oxxx)
      mu3(y,y,y) = P.trace_product_with(Oyyy)
      mu3(z,z,z) = P.trace_product_with(Ozzz)
      mu3(y,x,x) = P.trace_product_with(Oxxy)
      mu3(z,x,x) = P.trace_product_with(Oxxz)
      mu3(y,y,x) = P.trace_product_with(Oyyx)
      mu3(z,y,x) = P.trace_product_with(Oxyz)
      mu3(z,z,x) = P.trace_product_with(Ozzx)
      mu3(z,y,y) = P.trace_product_with(Oyyz)
      mu3(z,z,y) = P.trace_product_with(Ozzy)
      mu3.make_symmetric

      ! Evaluate the polarisability
      alpha(x,x) = mu2(x,x) - P.trace_product_with(Dx,P,Dx)
      alpha(y,y) = mu2(y,y) - P.trace_product_with(Dy,P,Dy)
      alpha(z,z) = mu2(z,z) - P.trace_product_with(Dz,P,Dz)
      alpha(y,x) = mu2(x,y) - P.trace_product_with(Dy,P,Dx)
      alpha(z,x) = mu2(x,z) - P.trace_product_with(Dz,P,Dx)
      alpha(z,y) = mu2(y,z) - P.trace_product_with(Dz,P,Dy)
      alpha.symmetric_reflect
      alpha = fac1*alpha

      stdout.flush
      stdout.text("================================")
      stdout.text("Sylvain-Csizmadia polarisability")
      stdout.text("================================")

      stdout.flush
      stdout.put(alpha)
      stdout.flush
      stdout.show("Mean polarisability =",THIRD*(alpha(x,x)+alpha(y,y)+alpha(z,z)))

      stdout.flush
      stdout.text("Principal values (au) :")
      stdout.flush
      alpha.solve_symmetric_eigenproblem(eval,evec)
      stdout.put(eval)

      stdout.flush
      stdout.text("Principal directions :")
      stdout.flush
      stdout.put(evec)

!      ! Whitten-Spackman-Jayatilaka polarisability
!      alpha1.create(3,3,.n_a);      alpha1 = ZERO
!      alpha2.create(3,3,.n_a,.n_a); alpha2 = ZERO
!      Pi.create(.n_bf,.n_bf)
!      Tx.create(.n_bf,.n_bf,.n_a)
!      Ty.create(.n_bf,.n_bf,.n_a)
!      Tz.create(.n_bf,.n_bf,.n_a)
!      do i = 1,.n_a
!         MOi => .MOs.r(:,i:i)
!         Pi.to_product_of(MOi,MOi,transpose_b=TRUE)
!         Tx(:,:,i).to_product_of(Pi,Dx)
!         Ty(:,:,i).to_product_of(Pi,Dy)
!         Tz(:,:,i).to_product_of(Pi,Dz)
!      end
!      do i = 1,.n_a
!         MOi => .MOs.r(:,i:i)
!         Pi.to_product_of(MOi,MOi,transpose_b=TRUE)
!         alpha1(x,x,i) = Pi.trace_product_with(Qxx) - Tx(:,:,i).trace_product_with(Tx(:,:,i))
!         alpha1(y,y,i) = Pi.trace_product_with(Qyy) - Ty(:,:,i).trace_product_with(Ty(:,:,i))
!         alpha1(z,z,i) = Pi.trace_product_with(Qzz) - Tz(:,:,i).trace_product_with(Tz(:,:,i))
!         alpha1(y,x,i) = Pi.trace_product_with(Qxy) - Ty(:,:,i).trace_product_with(Tx(:,:,i))
!         alpha1(z,x,i) = Pi.trace_product_with(Qxz) - Tz(:,:,i).trace_product_with(Tx(:,:,i))
!         alpha1(z,y,i) = Pi.trace_product_with(Qyz) - Tz(:,:,i).trace_product_with(Ty(:,:,i))
!         alpha1(:,:,i) = -FOUR*alpha1(:,:,i)/(.MO_energies.r(i))
!         do j = 1,(i-1)
!             alpha2(x,x,i,j) = -Tx(:,:,i).trace_product_with(Tx(:,:,j)) - Tx(:,:,j).trace_product_with(Tx(:,:,i))
!             alpha2(y,y,i,j) = -Ty(:,:,i).trace_product_with(Ty(:,:,j)) - Ty(:,:,j).trace_product_with(Ty(:,:,i))
!             alpha2(z,z,i,j) = -Tz(:,:,i).trace_product_with(Tz(:,:,j)) - Tz(:,:,j).trace_product_with(Tz(:,:,i))
!             alpha2(y,x,i,j) = -Ty(:,:,i).trace_product_with(Tx(:,:,j)) - Ty(:,:,j).trace_product_with(Tx(:,:,i))
!             alpha2(z,x,i,j) = -Tz(:,:,i).trace_product_with(Tx(:,:,j)) - Tz(:,:,j).trace_product_with(Tx(:,:,i))
!             alpha2(z,y,i,j) = -Tz(:,:,i).trace_product_with(Ty(:,:,j)) - Tz(:,:,j).trace_product_with(Ty(:,:,i))
!             alpha2(:,:,i,j) = -TWO*alpha2(:,:,i,j)*(ONE/.MO_energies.r(i) + ONE/.MO_energies.r(j))
!         end
!      end
!      Tz.destroy; Ty.destroy; Tx.destroy
!      Pi.destroy
!
!      stdout.flush
!      alpha = ZERO
!      do i = 1,.n_a
!         alpha = alpha + alpha1(:,:,i)
!         do j = 1,(i-1)
!            alpha = alpha + alpha2(:,:,i,j)
!         end
!      end
!      alpha.symmetric_reflect
!
!      stdout.flush
!      stdout.text("==========================================")
!      stdout.text("Whitten-Spackman-Jayatilaka polarisability")
!      stdout.text("==========================================")
!      stdout.flush
!      stdout.put(alpha)
!      stdout.flush
!      stdout.show("Mean polarisability =",THIRD*(alpha(x,x)+alpha(y,y)+alpha(z,z)))
!
!      stdout.flush
!      stdout.text("Principal values (au) :")
!      stdout.flush
!      alpha.solve_symmetric_eigenproblem(eigenvalues,eigenvectors)
!      stdout.put(eigenvalues)
!      stdout.flush
!      stdout.text("Principal directions :")
!      stdout.flush
!      stdout.put(eigenvectors)
!
!      stdout.flush
!      stdout.text("WSJ first polarisability (au):")
!      stdout.flush
!      stdout.put(alpha)
!      stdout.flush
!      stdout.show("Mean polarisability =",THIRD*(alpha(x,x)+alpha(y,y)+alpha(z,z)))
!
!      alpha2.destroy
!      alpha1.destroy
!
!      beta(x,x,x) = P.trace_product_with(Oxxx) - THREE*P.trace_product_with(Dx,P,Qxx) &
!                  + P.trace_product_with(Dx,P,Dx,P,Dx)
!      beta(y,y,y) = P.trace_product_with(Oyyy) - THREE*P.trace_product_with(Dy,P,Qyy) &
!                  + P.trace_product_with(Dy,P,Dy,P,Dy)
!      beta(z,z,z) = P.trace_product_with(Ozzz) - THREE*P.trace_product_with(Dz,P,Qzz) &
!                  + P.trace_product_with(Dz,P,Dz,P,Dz)
!      beta(y,x,x) = P.trace_product_with(Oxxy) - TWO*P.trace_product_with(Dx,P,Qxy) &
!                  - P.trace_product_with(Dy,P,Qxx) + P.trace_product_with(Dy,P,Dx,P,Dx)
!      beta(z,x,x) = P.trace_product_with(Oxxz) - TWO*P.trace_product_with(Dx,P,Qxz) &
!                  - P.trace_product_with(Dz,P,Qxx) + P.trace_product_with(Dz,P,Dx,P,Dx)
!      beta(y,y,x) = P.trace_product_with(Oyyx) - TWO*P.trace_product_with(Dy,P,Qxy) &
!                  - P.trace_product_with(Dx,P,Qyy) + P.trace_product_with(Dy,P,Dy,P,Dx)
!      beta(z,y,x) = P.trace_product_with(Oxyz) - P.trace_product_with(Dz,P,Qxy) &
!                  - P.trace_product_with(Dy,P,Qxz) - P.trace_product_with(Dx,P,Qyz) &
!                  + P.trace_product_with(Dz,P,Dy,P,Dx)
!      beta(z,z,x) = P.trace_product_with(Ozzx) - TWO*P.trace_product_with(Dz,P,Qxz) &
!                  - P.trace_product_with(Dx,P,Qzz) + P.trace_product_with(Dz,P,Dz,P,Dx)
!      beta(z,y,y) = P.trace_product_with(Oyyz) - TWO*P.trace_product_with(Dy,P,Qyz) &
!                  - P.trace_product_with(Dz,P,Qyy) + P.trace_product_with(Dz,P,Dy,P,Dy)
!      beta(z,z,y) = P.trace_product_with(Ozzy) - TWO*P.trace_product_with(Dz,P,Qyz) &
!                  - P.trace_product_with(Dy,P,Qzz) + P.trace_product_with(Dz,P,Dz,P,Dy)
!      beta.make_symmetric
!
!      fac = 12.0d0/(delta*delta)
!      beta = fac*beta
!
!      stdout.flush
!      stdout.text("WSJ Dipole hyperpolarisability (au):")
!      stdout.flush
!      stdout.put(beta)
!
!      stdout.flush
!      stdout.text("Dipole hyperpolarisability - unique values (au):")
!      stdout.flush
!      stdout.text("The order is xxx,xxy,xyy,yyy,xxz,xyz,yyz,xzz,yzz,zzz")
!      stdout.flush
!
!      b10vec( 1) = beta(1,1,1)
!      b10vec( 2) = beta(1,1,2)
!      b10vec( 3) = beta(1,2,2)
!      b10vec( 4) = beta(2,2,2)
!      b10vec( 5) = beta(1,1,3)
!      b10vec( 6) = beta(1,2,3)
!      b10vec( 7) = beta(2,2,3)
!      b10vec( 8) = beta(1,3,3)
!      b10vec( 9) = beta(2,3,3)
!      b10vec(10) = beta(3,3,3)
!
!      stdout.put(b10vec)
!
!      stdout.flush
!      stdout.text("Vector dipole hyperpolarisability (au):")
!      stdout.flush
!      beta.set_vector_hyperpolarisability(bvec)
!
!      stdout.put(bvec)

      ! =====================
      ! Jayatilaka-Jha-Munshi
      ! =====================

      do u = 1,3
      do v = 1,3
         alpha(u,v) = mu2(u,v) - fnm1*mu1(u)*mu1(v)
      end
      end
      alpha = fac1*alpha

      do u = 1,3
      do v = 1,3
      do w = 1,3
         val1 = mu3(u,v,w)
         val2 = mu1(u)*mu2(v,w) + mu1(v)*mu2(w,u) + mu1(w)*mu2(u,v)
         val3 = mu1(u)*mu1(v)*mu1(w)
         beta(u,v,w) =  val1 - fnm1*val2 + TWO*fnm2*val3
      end
      end
      end
      beta = fac2*beta

      stdout.flush
      stdout.text("==========================================")
      stdout.text("Jayatilaka-Jha-Munshi (JJM) polarisability")
      stdout.text("==========================================")

      stdout.flush
      stdout.text("mu1:")
      stdout.put(mu1)

      stdout.flush
      stdout.text("mu2:")
      stdout.put(mu2)

      stdout.flush
      stdout.text("JJM first polarisability:")
      stdout.flush
      stdout.flush
      stdout.put(alpha)
      stdout.flush
      stdout.show("JJM mean polarisability =",THIRD*(alpha(x,x)+alpha(y,y)+alpha(z,z)))

      stdout.flush
      stdout.text("JJM Dipole hyperpolarisability (JJM):")
      stdout.flush
      stdout.put(beta)

      stdout.flush
      stdout.text("JJM Dipole hyperpolarisability - unique values:")
      stdout.flush
      stdout.text("The order is xxx,xxy,xyy,yyy,xxz,xyz,yyz,xzz,yzz,zzz")
      stdout.flush

      b10vec( 1) = beta(1,1,1)
      b10vec( 2) = beta(1,1,2)
      b10vec( 3) = beta(1,2,2)
      b10vec( 4) = beta(2,2,2)
      b10vec( 5) = beta(1,1,3)
      b10vec( 6) = beta(1,2,3)
      b10vec( 7) = beta(2,2,3)
      b10vec( 8) = beta(1,3,3)
      b10vec( 9) = beta(2,3,3)
      b10vec(10) = beta(3,3,3)

      stdout.put(b10vec)

      stdout.flush
      stdout.text("JJM Vector dipole hyperpolarisability:")
      stdout.flush
      beta.set_vector_hyperpolarisability(bvec)

      stdout.put(bvec)
      stdout.flush
      stdout.show("JJM |beta| =",bvec.norm)


      P.destroy
      Oxyz.destroy
      Ozzy.destroy; Ozzx.destroy
      Oyyz.destroy; Oyyx.destroy
      Oxxz.destroy; Oxxy.destroy
      Ozzz.destroy; Oyyy.destroy; Oxxx.destroy
      Qyz.destroy; Qxz.destroy; Qxy.destroy
      Qzz.destroy; Qyy.destroy; Qxx.destroy
      Dz.destroy; Dy.destroy; Dx.destroy

   end

   put_sos_dipole_polarisability ::: leaky
   ! Calculate the dipole polarisability using the sum-over-states
   ! (SOS) formula.
      self :: INOUT

   ENSURE(.MOs.allocated,"no MO's")
   ENSURE(.MOs.r.allocated,"no restricted MO's")
   ENSURE(.scfdata.allocated,"no scf data")
   ENSURE(.scfdata.SCF_kind=="rhf","SOS polarisability only for RHF case")
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom info")

      D :: MAT3{REAL}@
      e :: VEC{REAL}@
      eval :: VEC{REAL}(3)
      alpha,evec :: MAT{REAL}(3,3)
      l,m,a,i :: INT
      val :: REAL

      e = .MO_energies.r

      ! Get the dipole moment matrices in the AO basis.
      D.create(.n_bf,.n_bf,3)
      .INTS:make_dipole_matrices(D(:,:,1),D(:,:,2),D(:,:,3))

      ! Change dipole matrices from AO -> MO basis
      D(:,:,1).change_basis_using(.MOs.r)
      D(:,:,2).change_basis_using(.MOs.r)
      D(:,:,3).change_basis_using(.MOs.r)

      ! Do the calculation
      alpha = ZERO
      do l = 1,3
      do m = 1,l
         val = ZERO
         do a = .n_a+1,.n_bf
         do i =      1,.n_a
            val = val + (D(a,i,l)*D(a,i,m))/(e(a)-e(i))
         end
         end
         alpha(l,m) = val
      end
      end
      D.destroy
      alpha = FOUR*alpha
      alpha.symmetric_reflect

      .dipole_polarisability.destroy
      .dipole_polarisability.create(3,3) ! leaky here
      .dipole_polarisability = alpha

      stdout.flush
      stdout.text("=====================================")
      stdout.text("Sum-over-states dipole polarisability")
      stdout.text("=====================================")
      stdout.flush
      stdout.text(". In atomic units")
      stdout.flush
      stdout.put(alpha)
      stdout.flush
      stdout.show("Mean polarisability =",THIRD*(alpha(1,1)+alpha(2,2)+alpha(3,3)))

      stdout.flush
      stdout.text("Principal values:")
      stdout.flush
      alpha.solve_symmetric_eigenproblem(eval,evec)
      stdout.put(eval)
      stdout.flush
      stdout.text("Principal directions:")
      stdout.flush
      stdout.put(evec)

   end

!  =================================
!  Unit-cell dipole polarizabilities
!  =================================

   put_UC_dipole_polarisability ::: leaky
   ! Calculate the unit cell dipole polarisability using Coupled
   ! Perturbed Hartree-Fock theory. It assumes that the crystal data
   ! is present, and that the polarisabilities for each molecules can
   ! be added up.
      self :: INOUT

   ENSURE(.dipole_polarisability.allocated,"no dipole_polarisability")
   ENSURE(.atom.allocated,"no atom data")
   ENSURE(.crystal.allocated,"no crystal data")

      alpha :: MAT{REAL}(3,3)

      ! Make it
      .:make_UC_dipole_polarisability(alpha)

      ! Print the polarisability
      stdout.flush
      stdout.text("===============================")
      stdout.text("Unit cell dipole polarisability")
      stdout.text("===============================")

      .:put_dipole_polarisability(alpha)

   end

   make_UC_dipole_polarisability(uc_alpha) ::: leaky
   ! Calculate the unit cell dipole polarisability using Coupled
   ! Perturbed Hartree-Fock theory. It assumes that the crystal data
   ! is present, and that the polarisabilities for each molecules can
   ! be added up.
      self :: INOUT
      uc_alpha :: MAT{REAL}(3,3), OUT

   ENSURE(.dipole_polarisability.allocated,"no dipole_polarisability")
   ENSURE(.atom.allocated,"no atom data")
   ENSURE(.crystal.allocated,"no crystal data")
   ENSURE(all(.crystal.frag_atom_for_asym_atom/=0),"some asym atoms not found")

      ! Molecular polarisability
      uc_alpha = .dipole_polarisability

      ! Make the unit cell cluster
      .cluster.destroy
      .cluster.create
      .cluster.set_defaults(.crystal)
      .cluster.set_generation_method("unit_cell")
      .cluster.set_defragment(FALSE)
      .cluster.set_radius(ZERO)
      .cluster.update_info ! NOT PURE

      .cluster.add_UC_tensors(uc_alpha)

   end

   put_UC_dipole_hyperpolar ::: leaky
   ! Calculate the unit cell dipole hyperpolarisability using Coupled
   ! Perturbed Hartree-Fock theory. It assumes that the crystal data
   ! is present, and that the polarisabilities for each molecules can
   ! be added up.
      self :: INOUT

   ENSURE(.dipole_hyperpolarisability.allocated,"no dipole_hyperpolarisability")
   ENSURE(.atom.allocated,"no atom data")
   ENSURE(.crystal.allocated,"no crystal data")
   ENSURE(all(.crystal.frag_atom_for_asym_atom/=0),"some asym atoms not found")

      beta :: MAT3{REAL}(3,3,3)
      bvec :: VEC{REAL}(3)

      beta = .dipole_hyperpolarisability

      .cluster.destroy
      .crystal.update_fragment_info(.atom)
      .cluster.create
      .cluster.set_defaults(.crystal)
      .cluster.set_generation_method("unit_cell")
      .cluster.set_defragment(FALSE)
      .cluster.set_radius(ZERO)
      .cluster.update_info
      .cluster.add_UC_tensors(beta)

      stdout.flush
      stdout.text("====================================")
      stdout.text("Unit cell dipole hyperpolarisability")
      stdout.text("====================================")
      stdout.flush
      stdout.text(". In atomic units")
      stdout.flush
      stdout.put(beta)

      beta.set_vector_hyperpolarisability(bvec)
      stdout.flush
      stdout.text("Vector dipole hyperpolarisability:")
      stdout.flush
      stdout.put(bvec)

   end

!  ============================
!  Unit-cell refractive indices
!  ============================

   put_UC_refractive_index ::: leaky
   ! Calculate the unit cell refractive index from the atomic charge
   ! and dipole polarisabilities.
      self :: INOUT

   ENSURE(.dipole_polarisability.allocated,"no dipole_polarisability")
   ENSURE(.atom.allocated,"no atom data")
   ENSURE(.crystal.allocated,"no crystal data")
   ENSURE(.crystal.fragment_info_made,"no crystal fragment info")
   ENSURE(all(.crystal.frag_atom_for_asym_atom/=0),"some asym atoms not found")

      chi1 :: MAT{REAL}(3,3)
      chi2 :: MAT3{REAL}(3,3,3)

      ! Make sure asymmetric unit is generated from the fragment
      ! (Also it assigns atomic charges, polarisabilities to asymmetric unit)
      .crystal.destroy_asymmetric_unit
      .crystal.update_fragment_info(.atom)
      DIE_IF(.crystal.asymmetric_unit_atom.deallocated,"missing asym atoms")

      ! Make the cluster
      .cluster.destroy
      .cluster.create
      .cluster.set_defaults(.crystal)
      .cluster.update_info ! leaky here

      stdout.flush
      stdout.text("=================================================")
      stdout.text("Unit cell susceptibilities and refractive indices")
      stdout.text("=================================================")

      stdout.flush
      stdout.text("=== Naive method (no local field effects) ===")
      .cluster.make_chi1_naive(chi1,.dipole_polarisability)
      .:put_refractive_indices(chi1)

      stdout.flush
      stdout.text("=== ALFFA method (single site per molecule, at COM) ===")
      .cluster.make_chi1_ALFFA(chi1,.dipole_polarisability)
      .:put_refractive_indices(chi1)

      stdout.flush
      stdout.text("=== RLFTn method (multiple sites per molecule) ===")
      .cluster.make_chi1_RLFTn(chi1,.dipole_polarisability)
      .:put_refractive_indices(chi1)

      stdout.flush
      stdout.text("=== Spackman's RLFTn method (L tensor averaged over sites) ===")
      .cluster.make_chi1_RLFTn_av_L(chi1,.dipole_polarisability)
      .:put_refractive_indices(chi1)

      stdout.flush
      stdout.text("======================================")
      stdout.text("Unit cell second susceptibility chi(2)")
      stdout.text("======================================")

      .cluster.make_chi2_RLFTn_av_L(chi2,.dipole_hyperpolarisability,.dipole_polarisability)
      ::put_chi2(chi2,chi1)

   end

   put_UC_chi2 ::: leaky
   ! This code was ressurected and modified from the svn repository
   !  extracted at {2007-07-01} ... It is supposed to represent
   ! Munshi's results
      self :: INOUT

   ENSURE(.HA_info_made,"no Hirshfeld atom properties")
   ENSURE(.atomic_polarisabilities_made,"no atomic polarisabilities")
   ENSURE(.dipole_polarisability.allocated,"no dipole_polarisability")
   ENSURE(.dipole_hyperpolarisability.allocated,"no dipole_hyperpolarisability")
   ENSURE(.atom.allocated,"no atom data")
   ENSURE(.crystal.allocated,"no crystal data")
   ENSURE(.crystal.fragment_info_made,"no crystal fragment info")
   ENSURE(all(.crystal.frag_atom_for_asym_atom/=0),"some asym atoms not found")

      alpha      :: MAT{REAL}(3,3)
      uc_alpha   :: MAT{REAL}(3,3)
      chi1       :: MAT{REAL}(3,3)
      chi1_naive :: MAT{REAL}(3,3)
      chi1_com   :: MAT{REAL}(3,3)
      chi1_nonH  :: MAT{REAL}(3,3)
      chi1_nc    :: MAT{REAL}(3,3)
      chi1_do    :: MAT{REAL}(3,3)
      beta       :: MAT3{REAL}(3,3,3)
      chi2_nonH  :: MAT3{REAL}(3,3,3)

      ! Get molecular alpha and beta
      alpha = .dipole_polarisability
      beta  = .dipole_hyperpolarisability

      ! Make the susceptibilities
      .cluster.destroy
      .cluster.create
      .cluster.set_defaults(.crystal)
      .cluster.update_info ! leaky here
      .cluster.make_susceptibility2( &
         alpha,beta,uc_alpha, &
         chi1_naive,chi1_com,chi1_nonH, &
         chi2_nonH,chi1_nc,chi1_do,chi1)


      stdout.flush
      stdout.text("===========================================")
      stdout.text("Unit cell first and second susceptibilities")
      stdout.text("===========================================")
      stdout.flush
      stdout.text(". This code uses a distrubted polarizability formalism")
      stdout.text(". It was used to produce unlublished results by P. Munshi in 2007")

      stdout.flush
      stdout.text("== Unit cell alpha==")
      stdout.flush
      stdout.put(uc_alpha)
      stdout.flush

      stdout.flush
      stdout.text("=== Naive method (no local field effects) ===")
      .:put_refractive_indices(chi1_naive)

      stdout.flush
      stdout.text("=== ALFFA method (single site per molecule, at COM) ===")
      .:put_refractive_indices(chi1_com)

      stdout.flush
      stdout.text("=== RLFTn method (multiple sites per molecule) ===")
      .:put_refractive_indices(chi1_nonH)

      stdout.flush
      stdout.text("=== chi2 RLFTn method (multiple sites per molecule) ===")
      ::put_chi2(chi2_nonH,chi1_nonH)

!      stdout.flush
!      stdout.text("Unit cell distributed no charge susceptibility ====(DAP-q)====")
!      .MAIN:put_refractive_indices(chi1_nc)
!
!      stdout.flush
!      stdout.text("Unit cell distributed dipole only susceptibility ====(DAD)======")
!      .MAIN:put_refractive_indices(chi1_do)
!
!      stdout.flush
!      stdout.text("Unit cell distributed susceptibility ====(DAP)======")
!      .MAIN:put_refractive_indices(chi1)

   end

   put_refractive_indices(chi1) ::: private
   ! Put out the permittivity and unit cell refractive index
      self :: INOUT
      chi1 :: MAT{REAL}(3,3), OUT

      eval :: VEC{REAL}(3)
      eps,evec :: MAT{REAL}(3,3)

      ! Print out the susceptibility
      stdout.flush
      stdout.text("chi1:")
      stdout.flush
      stdout.put(chi1)
      stdout.flush

      ! Work out the permittivity
      eps.to_unit_mx
      eps = eps + chi1

      ! Get the optic axes
      eps.solve_symmetric_eigenproblem(eval,evec)

      ! Print out the refractive indices
      stdout.flush
      stdout.text("Refractive indices")
      stdout.flush
      stdout.put(sqrt(eval))

      ! Optic axes ...
      stdout.flush
      stdout.text("Principal directions (columns):")
      stdout.flush
      stdout.put(evec)

      if (.crystal.allocated) then
      stdout.flush
      stdout.text("Principal directions in crystal axis system:")
      stdout.flush
      evec.change_basis_using(.crystal.unit_cell.inverse_mx,.crystal.unit_cell.direct_mx)
      stdout.put(evec)
      end

   end

   put_chi2(chi2,chi1) ::: selfless, private
   ! Put out the chi2
      self :: INOUT
      chi2 :: MAT3{REAL}(3,3,3), OUT
      chi1 :: MAT{REAL}(3,3), OUT

      v10  :: VEC{REAL}(10)
      v3   :: VEC{REAL}(3)
      eval :: VEC{REAL}(3)
      evec :: MAT{REAL}(3,3)
      eps  :: MAT{REAL}(3,3)
      beta :: MAT3{REAL}(3,3,3)

      ! Print out the 2nd susceptibility
      stdout.flush
      stdout.text("== chi2 in the xyz frame ==")
      stdout.flush
      stdout.text(". Atomic units are used")
      stdout.text(". Element order is: xxx,yxx,yyx,yyy,zxx,zyx,zyy,zzx,zzy,zzz")
      stdout.flush
      stdout.put(chi2)

      chi2.compress_to_pyramid(v10)
      stdout.flush
      stdout.text("Independent chi2 elements:")
      stdout.put(v10)

      chi2.set_vector_hyperpolarisability(v3)
      stdout.flush
      stdout.text("Vector componenets of chi2:")
      stdout.flush
      stdout.put(v3)
      stdout.flush
      stdout.show("|chi2| = ",v3.norm)

      ! Work out the permittivity
      eps.to_unit_mx
      eps = eps + chi1

      ! Get the optic axes
      eps.solve_symmetric_eigenproblem(eval,evec)

      ! Beta in the optic axis frame
      beta = chi2
      beta.change_basis_using(evec)

      ! chi2 in the optic axis frame
      stdout.flush
      stdout.text("== chi2 in the optic axis frame ==")
      stdout.flush
      stdout.put(chi2)

      chi2.compress_to_pyramid(v10)
      stdout.flush
      stdout.text("Independent chi2 elements:")
      stdout.text("The order of elements is: xxx,yxx,yyx,yyy,zxx,zyx,zyy,zzx,zzy,zzz")
      stdout.put(v10)

      chi2.compress_to_pyramid(v10)
      stdout.flush
      stdout.text("chi2 in the optic axis frame - as vector:")
      stdout.put(v10)

      chi2.set_vector_hyperpolarisability(v3)
      stdout.flush
      stdout.text("Vector componenets of chi2:")
      stdout.flush
      stdout.put(v3)
      stdout.flush
      stdout.show("|chi2| = ",v3.norm)

   end

!  =======================
!  Dipole polarizabilities
!  =======================

   make_SCF_dipole_polarisability ::: leaky, PURE
   ! Make the SCF electric dipole polarisability
      self :: INOUT

      alpha  :: MAT{REAL}(3,3)
      U,D_mo :: MAT3{REAL}@
      nv,no,l,m,a,i :: INT
      val :: REAL

      ! Make the U matrices if needed
      if (.U_electric_dipole.deallocated) .:make_U_electric_dipole
      U = .U_electric_dipole

      ! Get the dipole moment matrices in the AO basis.
      no = .n_a
      nv = .n_bf - .n_a
      D_mo.create(nv,no,3)
      .:get_VO_MO_dipole_matrices(D_mo)
      D_mo = -D_mo

      ! Calculate polarisability using U and D ...
      alpha = ZERO
      do l = 1,3
      do m = 1,l
         val = ZERO
         do a = 1,nv
         do i = 1,no
            val = val + D_mo(a,i,l)*U(a,i,m)
         end
         end
         alpha(l,m) = val
      end
      end
      alpha = FOUR*alpha
      alpha.symmetric_reflect

      ! Assign
      .dipole_polarisability = alpha

      ! Clean
      D_mo.destroy

   end

   put_sSCFdipole_polarisability ::: leaky
   ! Put the SCF polarisability
      self :: INOUT

      ! Make the polarisability .....
      .:make_SCF_dipole_polarisability ! INOUT

      ! Print out the answer
      stdout.flush
      stdout.text("=========================")
      stdout.text("SCF dipole polarizability")
      stdout.text("=========================")
      .:put_dipole_polarisability(.dipole_polarisability)

      ! Biggest contributions
      .:put_big_alpha_terms

   end

   put_big_alpha_terms ::: leaky, private
   ! Put the main contributions to the SCF polarisability
   ! Tidied from mjt === dylan
      self :: INOUT

      U,D_mo :: MAT3{REAL}@
      alpha_bar,alpha_abs :: VEC{REAL}@
      indices :: VEC{INT}@
      a,i,ai,l,nv,no :: INT
      val :: REAL

      ! Make the U matrices/dipole integrals if needed
      if (.U_electric_dipole.deallocated) .:make_U_electric_dipole
      U = .U_electric_dipole

      ! Get the virtual-occupied MO dipole moment matrices
      no = .n_a
      nv = .n_bf - no
      D_mo.create(nv,no,3)
      .:get_VO_MO_dipole_matrices(D_mo)
      D_mo = -D_mo

      ! Get the individual orbital contributions to the
      ! mean polarisabilitity
      alpha_bar.create(nv*no)
      ai = 0
      do i = 1,no
      do a = 1,nv
         val = ZERO
         do l = 1,3
            val = val + D_mo(a,i,l)*U(a,i,l)
         end
         ai = ai + 1
         alpha_bar(ai) = val
      end
      end
      alpha_bar = THIRD*FOUR * alpha_bar
      D_mo.destroy

      ! Get largest contributions in "indices"
      indices.create(nv*no)
      alpha_abs.create(nv*no)
      alpha_abs = abs(alpha_bar)
      alpha_abs.quick_sort(indices,decreasing_order=TRUE)

      ! Print out the largest contributions
      stdout.flush
      stdout.text("Mean dipole polarisability, top orbital-pair contributions:")
      stdout.flush
      stdout.show("Check: mean polarisability =",alpha_bar.sum_elements)
      stdout.flush
      stdout.dash(int_fields=3,real_fields=1)
      stdout.put("Rank",int_width=TRUE)
      stdout.put("a",int_width=TRUE)
      stdout.put("i",int_width=TRUE)
      stdout.put("alpha_ai")
      stdout.flush
      stdout.dash(int_fields=3,real_fields=1)
      do l = 1,5 ! take the top 5 results
         ai = indices(l) ! get the index
         a  = mod(ai,nv)
         i  = (ai-1)/nv + 1
         stdout.put(l)
         stdout.put(a)
         stdout.put(i)
         stdout.put(alpha_bar(ai))
         stdout.flush
      end
      stdout.dash(int_fields=3,real_fields=1)

      alpha_abs.destroy
      indices.destroy
      alpha_bar.destroy

   end

   put_dipole_polarisability(alpha) ::: leaky
   ! Put the dipole polarisability
      self :: IN
      alpha :: MAT{REAL}(3,3), IN

      eval :: VEC{REAL}(3)
      evec :: MAT{REAL}(3,3)
      mean :: REAL

      ! Print out the answer
      stdout.flush
      stdout.text(". In atomic units")
      stdout.put(alpha)
      stdout.flush
      mean = THIRD*(alpha(1,1)+alpha(2,2)+alpha(3,3))
      stdout.show("Mean polarisability =",mean)

      ! Get principal axes
      alpha.solve_symmetric_eigenproblem(eval,evec)

      ! Put in descending order
      eval.reverse_order
      evec.reverse_column_order

      ! Put eigenvalues
      stdout.flush
      stdout.text("Principal values (au) :")
      stdout.flush
      stdout.put(eval)

      ! Optic axes ...
      stdout.flush
      stdout.text("Principal directions (columns):")
      stdout.flush
      stdout.put(evec)

      if (.crystal.allocated) then
      stdout.flush
      stdout.text("Principal directions in crystal axis system :")
      stdout.flush
      evec.change_basis_using(.crystal.unit_cell.inverse_mx,.crystal.unit_cell.direct_mx)
      stdout.put(evec)
      end

   end

!  ============================
!  Dipole hyperpolarizabilities
!  ============================

   make_SCF_dipole_hyperpol ::: leaky
   ! Calculate scf dipole hyperpolarisability
   ! Taken from Colwell et al, CPL 210, p. 261 (1993)
      self :: INOUT

      beta :: MAT3{REAL}(3,3,3)
      U,F :: MAT3{REAL}@
      xi_vv,xi_oo :: MAT{REAL}@
      no,nv,l,m,n :: INT
      val,val1,val2 :: REAL

      ! Make the U matrices/dipole integrals if needed
      if (.U_electric_dipole.deallocated) .:make_U_electric_dipole
      U = .U_electric_dipole

      ! Make F(k). We don't need the U term in eqn (29)
      ! See Colwell et al, CPL 210, p. 261 (1993)
      F.create(.n_bf,.n_bf,3)
      .:get_MO_dipole_matrices(F)
      .:add_A_times_U(F,U)

      ! Make beta
      no = .n_a
      nv = .n_bf - no

      xi_oo.create(no,no)
      xi_vv.create(nv,nv)

      beta = ZERO
      do m = 1,3
      do n = 1,3

         xi_vv.to_product_of(  U(:,:,m),U(:,:,n),transpose_b=TRUE)
         xi_vv.plus_product_of(U(:,:,n),U(:,:,m),transpose_b=TRUE)

         xi_oo.to_product_of(  U(:,:,m),U(:,:,n),transpose_a=TRUE)
         xi_oo.plus_product_of(U(:,:,n),U(:,:,m),transpose_a=TRUE)

         do l = 1,3
            val1 =  TWO*F(1 :no,1 :no,l).trace_product_with(xi_oo)
            val2 = -TWO*F(no+1:,no+1:,l).trace_product_with(xi_vv)
            val  = val1 + val2
            .dipole_hyperpolarisability = ZERO
            beta(l,m,n) = beta(l,m,n) + val
            beta(m,n,l) = beta(m,n,l) + val
            beta(n,l,m) = beta(n,l,m) + val
         end

      end
      end

      ! Create dipole hyperpolarisability
      .dipole_hyperpolarisability.destroy
      .dipole_hyperpolarisability.create(3,3,3) ! leaky here
      .dipole_hyperpolarisability = beta

      ! Clean
      xi_vv.destroy
      xi_oo.destroy
      F.destroy

   end

   put_SCF_dipole_hyperpolarisa ::: leaky
   ! Calculate the polarisability using Coupled Perturbed 
   ! Hartree-Fock theory.
      self :: INOUT

      beta :: MAT3{REAL}(3,3,3)
      bvec :: VEC{REAL}(3)

      ! Do it .....
      .:make_SCF_dipole_hyperpol
      beta = .dipole_hyperpolarisability
      beta.set_vector_hyperpolarisability(bvec)

      ! Print the results

      stdout.flush
      stdout.text("==========================")
      stdout.text("Dipole hyperpolarisability")
      stdout.text("==========================")
      stdout.flush
      stdout.text(". In atomic units")
      stdout.put(beta)

      stdout.flush
      stdout.text("Vector dipole hyperpolarisability (au):")
      stdout.flush
      stdout.put(bvec)
      stdout.flush
      stdout.show(" |beta| = ",bvec.norm)

   end

!  =======================
!  Atomic polarizabilities
!  =======================

   make_SCF_atomic_polarisability
   ! Calculate the polarisability using Coupled Perturbed
   ! Hartree-Fock theory.
      self :: INOUT

   ENSURE(.MOs.allocated,"no MO's")
   ENSURE(.MOs.r.allocated,"no restricted MO's")

      D :: MAT3{REAL}@
      U :: MAT3{REAL}@
      pt,NO :: MAT{REAL}@
      wt,Wai,rhoi,occ :: VEC{REAL}@
      pos :: VEC{REAL}(3)
      n_pt,i,a :: INT

      ! Make the U matrices/dipole integrals if needed
      if (.U_electric_dipole.deallocated) .:make_U_electric_dipole
      U = .U_electric_dipole

      ! Make the AO perturbed density matrices
      D.create(.n_bf,.n_bf,3)
      .:make_perturbed_densities(D,U,.MOs.r,.n_a)

      ! Ensure ANO's and becke_grid made (leaky)
      .SCF:make_HA_inputs

      ! Make the becke grid integration grid (pt,wt)
      .becke_grid.make_grid(pt,wt) ! <<<<<<<< leaky

      ! Integrate the polarisabilities
      n_pt = pt.dim1
      NO.create(.n_bf,.n_bf)
      occ.create(.n_bf)
      Wai.create(n_pt)
      rhoi.create(n_pt)

      ! Make overlap matrix (for NO's)
      .INTS:make_overlap_mx ! NOT PURE

      do i = 1,3

         .BASE:make_r_NOs(NO,occ,D(:,:,i)) ! NOT PURE
         .GRID:make_ED_grid_r(rhoi,pt,NO,occ)

         rhoi = rhoi*wt

         do a = 1,.n_atom
            .GRID:make_stockholder_atom_grid(Wai,a,pt,.overlapping_atoms_for_atom(a).element)
            Wai = -rhoi*Wai
            pos = .atom(a).position
            .atom(a).charge_polarisability(i)   = sum(Wai)
            .atom(a).dipole_polarisability(1,i) = sum(Wai*(pt(:,1)-pos(1)))
            .atom(a).dipole_polarisability(2,i) = sum(Wai*(pt(:,2)-pos(2)))
            .atom(a).dipole_polarisability(3,i) = sum(Wai*(pt(:,3)-pos(3)))
         end

      end

      ! Clean
      rhoi.destroy; Wai.destroy
      occ.destroy; NO.destroy
      wt.destroy; pt.destroy
      D.destroy

      .atomic_polarisabilities_made = TRUE

   end

   put_SCF_atomic_polarisability
   ! Calculate the polarisability using Coupled Perturbed 
   ! Hartree-Fock theory.
      self :: INOUT

   ENSURE(.MOs.allocated,"no MO's")
   ENSURE(.MOs.r.allocated,"no restricted MO's")

      dpol,alpha,alpha_q,alpha_m  :: MAT{REAL}(3,3)
      qpol :: VEC{REAL}(3)
      a :: INT
      asym :: REAL

      ! Make it
      if (NOT .atomic_polarisabilities_made) then
         .:make_SCF_atomic_polarisability
      end

      ! Write results in au
      alpha_q = ZERO
      stdout.flush
      stdout.text("=================================")
      stdout.text("Hirshfeld atomic polarisabilities")
      stdout.text("=================================")
      stdout.flush
      stdout.text(". In atomic units")
      stdout.flush
      stdout.text("Monopole polarisabiities:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=3)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("q_x")
      stdout.put("q_y")
      stdout.put("q_z")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=3)
      do a = 1,.n_atom
         stdout.put(.atom(a).label,int_width=TRUE)
         qpol = .atom(a).charge_polarisability
         stdout.put(qpol(1))
         stdout.put(qpol(2))
         stdout.put(qpol(3))
         stdout.flush
         alpha_q(:,1) = alpha_q(:,1) + .atom(a).position * qpol(1)
         alpha_q(:,2) = alpha_q(:,2) + .atom(a).position * qpol(2)
         alpha_q(:,3) = alpha_q(:,3) + .atom(a).position * qpol(3)
      end
      stdout.dash(int_fields=1,real_fields=3)
      stdout.flush

      ! Write results in au
      alpha_m = ZERO
      asym = ZERO
      stdout.flush
      stdout.text("Dipole polarisabiities:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=3)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("a_:x")
      stdout.put("a_:y")
      stdout.put("a_:z")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=3)
      do a = 1,.n_atom
         stdout.put(.atom(a).label,int_width=TRUE)
         dpol = .atom(a).dipole_polarisability
         stdout.put(dpol(1,1))
         stdout.put(dpol(1,2))
         stdout.put(dpol(1,3))
         stdout.flush
         stdout.tab(int_fields=1)
         stdout.put(dpol(2,1))
         stdout.put(dpol(2,2))
         stdout.put(dpol(2,3))
         stdout.flush
         stdout.tab(int_fields=1)
         stdout.put(dpol(3,1))
         stdout.put(dpol(3,2))
         stdout.put(dpol(3,3))
         asym = max(asym,abs(dpol(1,2)-dpol(2,1)))
         asym = max(asym,abs(dpol(1,3)-dpol(3,1)))
         asym = max(asym,abs(dpol(2,3)-dpol(3,2)))
         stdout.flush
         alpha_m = alpha_m + dpol
      end
      stdout.dash(int_fields=1,real_fields=3)
      stdout.flush
      stdout.show("Maximum asymmetry in polarisabilities =",asym)
      stdout.flush
      stdout.text("Contribution to molecular polarisability from atomic charges (au):")
      stdout.put(alpha_q)
      stdout.flush
      stdout.text("Contribution to molecular polarisability from atomic dipoles (au):")
      stdout.put(alpha_m)
      stdout.flush
      stdout.text("Molecular polarisability (au):")
      alpha = alpha_q + alpha_m
      stdout.put(alpha)

   end

!  ====
!  CPHF
!  ====

   make_U_electric_dipole ::: leaky
   ! Calculate U matrices for electric dipole perturbations using
   ! Coupled Perturbed Hartree-Fock theory. 
   ! NOTE: restricted case only so far.
      self :: INOUT

   ENSURE(.overlap_mx.allocated,"no overlap_mx")

      U,D_mo :: MAT3{REAL}@
      no, nv :: INT

      ! Dimensions
      no = .n_a
      nv = .n_bf - no

      ! U matrices. Leaky
      U.create(nv,no,3)

      ! Virtual-occupied dipole moment matrices 
      ! - in the MO basis
      D_mo.create(nv,no,3)
      .:get_VO_MO_dipole_matrices(D_mo)
      D_mo = -D_mo

      ! Solve the CPHF equations
      .:set_CPHF_DIIS
      .:solve_CPHF_equations(U,D_mo) ! NOT PURE
      D_mo.destroy

      ! Assign U matrices
      .U_electric_dipole = U

   end

   make_U2_electric_dipole ::: leaky
   ! Calculate the second order U matrices for electric dipole
   ! perturbations using Coupled Perturbed Hartree-Fock theory. 
   ! NOTE: restricted case only so far.
      self :: INOUT

   ENSURE(.U_electric_dipole.allocated,"no first order U matrices!")
   ENSURE(.overlap_mx.allocated,"no overlap_mx")

      U,U2, rhs,Doo,Dvv :: MAT3{REAL}@
      xi,D,W,J,K, MOv   :: MAT{REAL}@
      no,nv, l,m,p :: INT

      ! Dimensions
      no = .n_a
      nv = .n_bf - no

      ! U2 matrices. Leaky
      U2.create(nv,no,3)

      ! Assign U matrices, MO's
      U = .U_electric_dipole

      ! RHS of CPHF equations
      rhs.create(nv,no,6)

      ! Get the virtual-occupied dipole moment matrices in the MO basis
      Doo.create(no,no,3)
      Dvv.create(nv,nv,3)
      .:get_OO_VV_MO_dipole_matrices(Doo,Dvv)

      ! Virtual MOs
      MOv = .MOs.r(:,no+1:)
      D.create(.n_bf,.n_bf)
      W.create(.n_bf,.n_bf)
      J.create(.n_bf,.n_bf)
      K.create(.n_bf,.n_bf)

      ! Make the second-order RHS
      p = 0
      do l = 1,3
      do m = 1,l

         p = p + 1

         ! xi-oo -> AO basis
         xi.create(no,no)
           xi.to_product_of(U(:,:,l),U(:,:,m),transpose_a=TRUE)
         xi.plus_product_of(U(:,:,m),U(:,:,l),transpose_a=TRUE)
         xi.back_transform_to(W,MOv)
         xi.destroy

         ! xi-vv -> AO basis
         xi.create(nv,nv)
           xi.to_product_of(U(:,:,l),U(:,:,m),transpose_b=TRUE)
         xi.plus_product_of(U(:,:,m),U(:,:,l),transpose_b=TRUE)
         xi.back_transform_to(D,MOv)
         xi.destroy

         D = HALF*(D - W)
         D.symmetrize

         ! A times xi -> AO basis -> MO basis -> W
         .FOCK:make_r_JK_engine(J,K,D)
         D = FOUR*J - TWO*K

         ! Assemble rhs
         D.change_basis_to(rhs(:,:,p),MOv,MOv)
         rhs(:,:,p).plus_scaled_product_of(U(:,:,l),Doo(:,:,m),fac=-ONE)
         rhs(:,:,p).plus_scaled_product_of(U(:,:,m),Doo(:,:,l),fac=-ONE)
         rhs(:,:,p).plus_scaled_product_of(Dvv(:,:,l),U(:,:,m),fac=-ONE)
         rhs(:,:,p).plus_scaled_product_of(Dvv(:,:,m),U(:,:,l),fac=-ONE)

      end
      end

      ! Clean
      K.destroy
      J.destroy
      W.destroy
      D.destroy
      Dvv.destroy
      Doo.destroy

      ! Solve the CPHF equations
      .:set_CPHF_DIIS
      .:solve_CPHF_equations(U2,rhs) ! NOT PURE

      ! Assign U matrices
      .U2_electric_dipole = U2

   end

   make_perturbed_densities(D,U,MO,no) ::: leaky. PURE
   ! Make the perturbed densities "D" from the "U" matrices by back
   ! transforming with the "MO" from occupied orbital "no".
      self :: IN
      D :: MAT3{REAL}, OUT
      U :: MAT3{REAL}, IN
      MO :: MAT{REAL}, IN
      no :: INT, optional, IN

   ENSURE(D.dim3==U.dim3,"incompatible D and U")
   ENSURE(D.dim1==.n_bf AND D.dim2==.n_bf,"wrong size, D")
   ENSURE(MO.is_square AND MO.dim1==.n_bf,"wrong size, MO")

      i :: INT

      if (present(no)) then

         ENSURE(no>0,"n_occ must be positive")
         ENSURE(no<=.n_bf,"n_occ must not exceed n_bf")
         do i = 1,U.dim3
            U(:,:,i).back_transform_to(D(:,:,i),MO(:,no+1:),MO(:,1:no))
            D(:,:,i).symmetrize
         end

      else

         do i = 1,U.dim3
            U(:,:,i).back_transform_to(D(:,:,i),MO)
            D(:,:,i).symmetrize
         end

      end

      D = FOUR*D

   end

   get_MO_dipole_matrices(D_mo) ::: private, PURE
   ! Get the MO dipole matrices
      self :: IN
      D_mo :: MAT3{REAL}, OUT

   ENSURE(all(shape(D_mo)==[.n_bf,.n_bf,3]),"wrong shape, D_mo")
   ENSURE(.MOs.allocated,"no MO's")
   ENSURE(.MOs.r.allocated,"no restricted MO's")

      ! Get the dipole moment matrices in the AO basis.
      .INTS:make_dipole_matrices(D_mo(:,:,1),D_mo(:,:,2),D_mo(:,:,3))

      ! Change dipole matrices from AO -> MO basis
      D_mo(:,:,1).change_basis_using(.MOs.r)
      D_mo(:,:,2).change_basis_using(.MOs.r)
      D_mo(:,:,3).change_basis_using(.MOs.r)

   end

   get_VO_MO_dipole_matrices(D_mo) ::: private, PURE
   ! Get the virtual-occupied MO dipole matrices
      self :: IN
      D_mo :: MAT3{REAL}, OUT

   ENSURE(all(shape(D_mo)==[(.n_bf-.n_a),.n_a,3]),"wrong shape, D_mo")
   ENSURE(.MOs.allocated,"no MO's")
   ENSURE(.MOs.r.allocated,"no restricted MO's")

      D_ao :: MAT3{REAL}@
      MOv,MOo :: MAT{REAL}@
      no :: INT

      ! Get the dipole moment matrices in the AO basis.
      D_ao.create(.n_bf,.n_bf,3)
      .INTS:make_dipole_matrices(D_ao(:,:,1),D_ao(:,:,2),D_ao(:,:,3))

      ! MO's
      no = .n_a
      MOv = .MOs.r(:,no+1:  )
      MOo = .MOs.r(:,   1:no) 

      ! Change dipole matrices from AO -> MO basis
      D_ao(:,:,1).change_basis_to(D_mo(:,:,1),MOv,MOo)
      D_ao(:,:,2).change_basis_to(D_mo(:,:,2),MOv,MOo)
      D_ao(:,:,3).change_basis_to(D_mo(:,:,3),MOv,MOo)
      D_ao.destroy

   end

   get_OO_VV_MO_dipole_matrices(Doo,Dvv) ::: private, PURE
   ! Get the virtual-occupied MO dipole matrices
      self :: INOUT
      Doo :: MAT3{REAL}, OUT
      Dvv :: MAT3{REAL}, OUT

   ENSURE(.MOs.allocated,"no MO's")
   ENSURE(.MOs.r.allocated,"no restricted MO's")

      D_ao :: MAT3{REAL}@
      MOv,MOo :: MAT{REAL}@
      no :: INT

      ! Get the dipole moment matrices in the AO basis.
      D_ao.create(.n_bf,.n_bf,3)
      .INTS:make_dipole_matrices(D_ao(:,:,1),D_ao(:,:,2),D_ao(:,:,3))

      ! Change dipole matrices from AO -> MO basis
      no = .n_a
      MOv = .MOs.r(:,no+1:  )
      MOo = .MOs.r(:,   1:no) 

      D_ao(:,:,1).change_basis_to(Doo(:,:,1),MOo)
      D_ao(:,:,2).change_basis_to(Doo(:,:,2),MOo)
      D_ao(:,:,3).change_basis_to(Doo(:,:,3),MOo)

      D_ao(:,:,1).change_basis_to(Dvv(:,:,1),MOv)
      D_ao(:,:,2).change_basis_to(Dvv(:,:,2),MOv)
      D_ao(:,:,3).change_basis_to(Dvv(:,:,3),MOv)

      D_ao.destroy

   end

   set_CPHF_DIIS ::: leaky, PURE
   ! Set up the DIIS archives for a CPHF calculations.
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scf data")

      tol :: REAL

      ! Set up DIIS
      tol = .scfdata.SCF_DIIS.convergence_tolerance
      .scfdata.SCF_DIIS.set_defaults
      .scfdata.SCF_DIIS.set_save_iteration(0)
      .scfdata.SCF_DIIS.set_start_iteration(2)
      .scfdata.SCF_DIIS.set_convergence_tolerance(tol)

   end

   solve_CPHF_equations(U,rhs) ::: private
   ! Solve the coupled-perturbed Hartree-Fock (CPHF) equations. The
   ! result is the derivative MO coefficients "U" (virtual-occupied
   ! block) and "rhs" is the right hand side of the CPHF equations
   ! (virtual-occupied block). The convergence tolerance and the
   ! number of iterations are controlled via the scfdata block, since
   ! this is a self consistent procedure.
      self :: INOUT
      U    :: MAT3{REAL}, INOUT
      rhs  :: MAT3{REAL}, IN

   ENSURE(.scfdata.allocated,"no scf data")
   ENSURE(.MOs.allocated,"no MOs")
   ENSURE(.MOs.r.allocated,"no restricted MOs")
   ENSURE(U.dim1==(.n_bf-.n_a),  "wrong size, U, dimension 1")
   ENSURE(U.dim2==.n_a,          "wrong size, U, dimension 2")
   ENSURE(rhs.dim1==(.n_bf-.n_a),"wrong size, rhs, dimension 1")
   ENSURE(rhs.dim2==.n_a,        "wrong size, rhs dimension 2")
   ENSURE(U.dim3==rhs.dim3,"incompatible sizes, U and rhs")

      Ev, Eo  :: VEC{REAL}@
      par,err :: VEC{REAL}@
      U_vo :: MAT3{REAL}@
      U_ao,AU,J,K,W :: MAT{REAL}@
      MOv,MOo :: MAT{REAL}@
      no,nv,n_pert,n_vo, n :: INT
      tol0,test,delta :: REAL
      use_DIIS :: BIN
      arch :: ARCHIVE

      ! Dimensions
      no = .n_a
      nv = .n_bf - .n_a
      n_vo   = nv*no
      n_pert = U.dim3
      tol0   = TOL(6)

      ! Assign MO's, orbital ranges
      MOv = .MOs.r(:,no+1:  )
      MOo = .MOs.r(:,   1:no) 
      Ev  = .MO_energies.r(no+1:  )
      Eo  = .MO_energies.r(   1:no)

      ! Read/initialize U's
      .:initialize_Us(U,rhs,Ev,Eo,tol0)

      ! Allocate temporaries
      U_vo.create(nv,no,n_pert)
      U_ao.create(.n_bf,.n_bf)
      W.create(nv,no)
      J.create(.n_bf,.n_bf)
      K.create(.n_bf,.n_bf)
      par.create(n_vo)
      err.create(n_vo)

      ! Use DIIS?
      use_DIIS = .scfdata.using_CP_DIIS

      ! Set initial convergence data/DIIS
      .scfdata.update_CP_difference(ZERO)
      .scfdata.set_DIIS_error(ZERO)
      if (use_DIIS) .scfdata.reset_CP(n_pert)

      ! Banner & tabular output
      .scfdata.put_CP_banner
      .scfdata.put_CP_options
      .scfdata.set_CP_table
      .scfdata.put_CP_table_head
      .scfdata.put_CP_table_body_and_footer

      ! Begin iterations
      do

         U_vo  = U
         test  = ZERO
         delta = ZERO

         ! For each perturbation, update U(:,:,n)
         do n = 1,n_pert

            ! U(MO) -> U(AO)
            U(:,:,n).back_transform_to(U_ao,MOv,Moo)
            U_ao.symmetrize

            ! Make A.U (AO) -> A.U (MO) = W
            .FOCK:make_r_JK_engine(J,K,U_ao)
            U_ao = FOUR*J - TWO*K
            .BASE:remove_dependence_from_r(U_ao)
            U_ao.change_basis_to(W,MOv,Moo)

            ! DIIS extrapolation on AU (MO)
            if (use_DIIS) then
               par = reshape(W,[n_vo])
               W.plus_difference_product_with(U(:,:,n),Ev,Eo,tol0) ! W <- H
               err = reshape(W-rhs(:,:,n),[n_vo])                  ! H - rhs
               .scfdata.CP_DIIS(n).extrapolate(par,err,n_vo)
               W   = reshape(par,[nv,no])                          ! W <- AU
               test = max(test,.scfdata.CP_DIIS(n).error_length)
            end

            ! Update U, U <- (rhs - W)/D
            W = rhs(:,:,n) - W
            U(:,:,n) = ZERO
            U(:,:,n).plus_difference_divisor_with(W,Ev,Eo,tol0)    ! W <- H

         end
           
         ! Delta is max |diff|
         delta = max(delta,maxval(abs(U-U_vo)))

         ! Update data
         .scfdata.update_iteration
         .scfdata.update_DIIS_from_CP_DIIS
         .scfdata.update_CP_difference(delta)
         .scfdata.SCF_DIIS.set_error_length(test)
         .scfdata.set_DIIS_error(test)

         ! Put table
         .scfdata.put_CP_table_body_and_footer(flush=TRUE)

         ! Write archive for restart
         arch.set(.name,"U_electric_dipole",genre="restricted")
         arch.write(U)

         if (.scfdata.SCF_done) exit

      end ! iterative cycle

      ! Clean-up
      .scfdata.SCF_DIIS.destroy_ptr_part
      .scfdata.CP_DIIS.destroy
      err.destroy
      par.destroy
      K.destroy
      J.destroy
      W.destroy
      U_ao.destroy
      U_vo.destroy

   end

   initialize_Us(U,rhs,Ev,Eo,tol0) ::: private
   ! Initialize the U matrices
      self :: INOUT
      U    :: MAT3{REAL}, OUT
      rhs  :: MAT3{REAL}, IN
      Ev   :: VEC{REAL}, IN
      Eo   :: VEC{REAL}, IN
      tol0 :: REAL, IN

      arch :: ARCHIVE
      n :: INT

      if (.scfdata.initial_Us=="restricted") then

         ! Read or calculate initial approximation for U
         stdout.flush
         stdout.text("As requested from scfdata, reading U's from disk ...")
         arch.set(.name,"U_electric_dipole",genre="restricted")
         arch.read(U)

      else

         ! Set SOS initial guess
         U = ZERO
         do n = 1,U.dim3
            U(:,:,n).plus_difference_divisor_with(rhs(:,:,n),Ev,Eo,tol0)
         end

      end

   end

!  ========
!  A matrix
!  ========

   make_A_times_U(AU,U) ::: private
   ! Make the full A times U matrix in the MO basis
      self :: INOUT
      AU :: MAT3{REAL}, OUT
      U  :: MAT3{REAL}, IN

   ENSURE(.scfdata.allocated,"no scf data")
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom info")
   ENSURE(U.dim1==(.n_bf-.n_a),"wrong size, U, dimension 1")
   ENSURE(U.dim2==.n_a,"wrong size, rhs, dimension 2")
   ENSURE(AU.dim1==.n_bf,"wrong size, AU")
   ENSURE(AU.dim2==.n_bf,"wrong size, AU")
   ENSURE(U.dim3==AU.dim3,"incompatible sizes, U and AU")

      U_ao,J,K :: MAT{REAL}@
      MOv, MOo :: MAT{REAL}@
      n :: INT

      U_ao.create(.n_bf,.n_bf)
      J.create(.n_bf,.n_bf)
      K.create(.n_bf,.n_bf)

      MOv = .MOs.r(:,.n_a+1:)
      MOo = .MOs.r(:,:.n_a) 

      do n = 1,U.dim3
         U(:,:,n).back_transform_to(U_ao,Mov,MOo)
         U_ao.symmetrize                   ! U -> AO basis
         .FOCK:make_r_JK_direct(J,K,U_ao)  ! A times U (INOUT)
         AU(:,:,n) = FOUR*J - TWO*K
         AU(:,:,n).change_basis_using(.MOs.r)
      end

      ! Clean
      K.destroy
      J.destroy
      U_ao.destroy

   end

   add_A_times_U(AU,U) ::: private
   ! Add the full A matrix times the full U matrix to "AU". "U" is the
   ! virtual-occupied block of the full U matrix.
      self :: INOUT
      AU :: MAT3{REAL}, OUT
      U  :: MAT3{REAL}, IN

   ENSURE(.scfdata.allocated,"no scf data")
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom info")
   ENSURE(U.dim1==(.n_bf-.n_a),"wrong size, U, dimension 1")
   ENSURE(U.dim2==.n_a,"wrong size, rhs, dimension 2")
   ENSURE(AU.dim1==.n_bf,"wrong size, AU")
   ENSURE(AU.dim2==.n_bf,"wrong size, AU")
   ENSURE(U.dim3==AU.dim3,"incompatible sizes, U and AU")

      J,K,W :: MAT{REAL}@
      MOv, MOo :: MAT{REAL}@
      n :: INT


      J.create(.n_bf,.n_bf)
      K.create(.n_bf,.n_bf)
      W.create(.n_bf,.n_bf)

      MOv = .MOs.r(:,.n_a+1:)
      MOo = .MOs.r(:,:.n_a) 

      do n = 1,U.dim3
         U(:,:,n).back_transform_to(W,MOv,MOo)
         W.symmetrize                  ! U -> AO basis
         .FOCK:make_r_JK_direct(J,K,W) ! INOUT
         W = FOUR*J - TWO*K            ! W = A times U
         W.change_basis_using(.MOs.r)
         AU(:,:,n) = AU(:,:,n) + W
      end

      ! Clean
      W.destroy
      K.destroy
      J.destroy

   end

!  ====================
!  Hirshfeld properties
!  ====================

!   make_H_polarisabilities ::: leaky
!   ! Make Hirshfeld polarisabilities
!
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.allocated,  "no atom list")
!
!      pt,E :: MAT{REAL}*
!      wt,r1,r2,r3 :: VEC{REAL}*
!      c1,c2,c3 :: REAL
!      n_pt,c :: INT
!
!      ! Make Becke grid if missing (leaky)
!      .GRID:set_up_becke_grid
!
!      ! Loop over atoms "c"
!      do c = 1,.n_atom
!
!         if (.atom(c).atomic_number<1) cycle
!
!         ! Get the Becke grid for atom "c"
!         .becke_grid.make_grid(pt,wt,c)
!         n_pt = pt.dim1
!
!         ! Apply stockholder weight for atom "c" to "wt".
!         ! NOTE: interpolatators may be used if set by user
!         .GRID:apply_stockholder_atom_weight(wt,c,pt)
!
!         ! Prune the grid with new "wt", get saved bf grid gridc0,
!         ! and new no of points, n_pt -- leaky
!         .becke_grid.prune_grid(pt,wt)
!         n_pt = pt.dim1
!
!         ! Make the field-derivative density grid
!         E.create(n_pt,3)
!         .GRID:make_e_polarization_vgrid(E,pt)
!
!         ! Multiply by the weights
!         E(:,1) = E(:,1)*wt
!         E(:,2) = E(:,2)*wt
!         E(:,3) = E(:,3)*wt
!
!         ! Integration points
!         r1 => pt(:,1)
!         r2 => pt(:,2)
!         r3 => pt(:,3)
!
!         ! Atom c position
!         c1 = .atom(c).position(1)
!         c2 = .atom(c).position(2)
!         c3 = .atom(c).position(3)
!
!         ! Make moments
!         .atom(c).charge_polarisability(1)   = -VEC{REAL}:sum_elements(E(:,1))
!         .atom(c).charge_polarisability(2)   = -VEC{REAL}:sum_elements(E(:,2))
!         .atom(c).charge_polarisability(3)   = -VEC{REAL}:sum_elements(E(:,3))
!         .atom(c).dipole_polarisability(1,1) = -VEC{REAL}:sum_elements(E(:,1)*(r1-c1))
!         .atom(c).dipole_polarisability(1,2) = -VEC{REAL}:sum_elements(E(:,2)*(r1-c1))
!         .atom(c).dipole_polarisability(1,3) = -VEC{REAL}:sum_elements(E(:,3)*(r1-c1))
!         .atom(c).dipole_polarisability(2,1) = -VEC{REAL}:sum_elements(E(:,1)*(r2-c2))
!         .atom(c).dipole_polarisability(2,2) = -VEC{REAL}:sum_elements(E(:,2)*(r2-c2))
!         .atom(c).dipole_polarisability(2,3) = -VEC{REAL}:sum_elements(E(:,3)*(r2-c2))
!         .atom(c).dipole_polarisability(3,1) = -VEC{REAL}:sum_elements(E(:,1)*(r3-c3))
!         .atom(c).dipole_polarisability(3,2) = -VEC{REAL}:sum_elements(E(:,2)*(r3-c3))
!         .atom(c).dipole_polarisability(3,3) = -VEC{REAL}:sum_elements(E(:,3)*(r3-c3))
!
!         ! Clean up
!         E.destroy
!         wt.destroy; pt.destroy
!
!      end ! -- integration atom c
!
!      ! Put charges to asymmetric unit
!      if (.crystal.allocated) then
!         .crystal.destroy_asymmetric_unit
!         .crystal.update_fragment_info(.atom,assign_atom=TRUE,warnings=FALSE)
!      end
!
!   end

!   put_H_polarisabilities ::: leaky
!   ! Put the Hirshfeld polarizabilities
!   ENSURE(.basis_info_made,"no basis info")
!   ENSURE(.atom.allocated,"no atom list")
!
!      ID :: VEC{STR}*
!      dim :: INT
!      qx,qy,qz    :: VEC{REAL}*
!      a1x,a1y,a1z :: VEC{REAL}*
!      a2x,a2y,a2z :: VEC{REAL}*
!      a3x,a3y,a3z :: VEC{REAL}*
!      table :: VEC{TABLE_COLUMN}*
!
!      ! Make and set the atom properties first ...
!      .:make_H_polarisabilities
!
!      ! Title
!      stdout.flush
!      stdout.flush
!      stdout.text("==========================")
!      stdout.text("Hirshfeld polarizabilities")
!      stdout.text("==========================")
!      stdout.flush
!      stdout.text(". The results are presented in au")
!      stdout.text(". The indices 1..3 label the moment wrt the atom center")
!      stdout.text(". The indices x..z label the electric field component")
!
!      ! Monpoles
!      stdout.flush
!      stdout.text("Monopole polarisabiities:")
!      stdout.flush
!
!      ! Get data
!      dim = .atom.dim
!      ID.create(dim);  ID  = .atom.tag
!      qx.create(dim);  qx  = .atom.charge_polarisability(1)
!      qy.create(dim);  qy  = .atom.charge_polarisability(2)
!      qz.create(dim);  qz  = .atom.charge_polarisability(3)
!
!      ! Make table
!      table.create(4)
!      table(1).set_heading("ID");         table(1).set_values(ID)
!      table(2).set_heading("q(x)");       table(2).set_values(qx)
!      table(3).set_heading("q(y)");       table(3).set_values(qy)
!      table(4).set_heading("q(z)");       table(4).set_values(qz)
!      table.put
!
!      ! Clean
!      table.destroy
!      qz.destroy
!      qy.destroy
!      qx.destroy
!
!      ! Dipoles
!      stdout.flush
!      stdout.text("Dipole polarisabiities:")
!      stdout.flush
!
!      ! Get data
!      a1x.create(dim); a1x = .atom.dipole_polarisability(1,1)
!      a1y.create(dim); a1y = .atom.dipole_polarisability(1,2)
!      a1z.create(dim); a1z = .atom.dipole_polarisability(1,3)
!      a2x.create(dim); a2x = .atom.dipole_polarisability(2,1)
!      a2y.create(dim); a2y = .atom.dipole_polarisability(2,2)
!      a2z.create(dim); a2z = .atom.dipole_polarisability(2,3)
!      a3x.create(dim); a3x = .atom.dipole_polarisability(3,1)
!      a3y.create(dim); a3y = .atom.dipole_polarisability(3,2)
!      a3z.create(dim); a3z = .atom.dipole_polarisability(3,3)
!
!      ! Make table
!      table.create(10)
!      table( 1).set_heading("ID");         table( 1).set_values(ID)
!      table( 2).set_heading("alpha(1x)");  table( 2).set_values(a1x)
!      table( 3).set_heading("alpha(1y)");  table( 3).set_values(a1y)
!      table( 4).set_heading("alpha(1z)");  table( 4).set_values(a1z)
!      table( 5).set_heading("alpha(2x)");  table( 5).set_values(a2x)
!      table( 6).set_heading("alpha(2y)");  table( 6).set_values(a2y)
!      table( 7).set_heading("alpha(2z)");  table( 7).set_values(a2z)
!      table( 8).set_heading("alpha(3x)");  table( 8).set_values(a3x)
!      table( 9).set_heading("alpha(3y)");  table( 9).set_values(a3y)
!      table(10).set_heading("alpha(3z)");  table(10).set_values(a3z)
!      table.put
!
!      ! Clean
!      table.destroy
!      a3z.destroy
!      a3y.destroy
!      a3x.destroy
!      a2z.destroy
!      a2y.destroy
!      a2x.destroy
!      a1z.destroy
!      a1y.destroy
!      a1x.destroy
!      ID.destroy
!
!   end

end
