!===============================================================================
!
! SHELL1QUARTET : Group of 4 SHELL1s, used for two-electron integrals.  This
! module is designed for speed, but still try to keep it readable.
!
! I improved the readability and added cleaner code which can always be used in
! the general case. In addition optimal code was generated by a program. Some use
! of assumed size arrays was done for efficiency. -- dylan
!
! Copyright (C) Daniel Grimwood, 2002
! Copyright (C) Dylan Jayatilaka, 2006
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: shell1quartet.foo 4035 2013-05-28 14:04:59Z dylan_ $

module SHELL1QUARTET

   implicit none

   ! List of cartesian powers for gaussian functions in a certain angular
   ! momentum range
!  nx, ny, nz :: VEC{INT}*, private  DEFAULT_NULL
!  gaussian_indices :: MAT{GAUSSIAN_INDICES}*, private  DEFAULT_NULL

   ! These are indexing arrays used for the horizontal recursion relation.
   ! They are set using the set_hrr_indexing_arrays routine.

!  l_max_hrr :: INT, private = -1
!  first_nonzero :: VEC{INT}*, private  DEFAULT_NULL
!  index_m1 :: VEC{INT}*, private  DEFAULT_NULL
!  index_p1 :: MAT{INT}*, private  DEFAULT_NULL

   ! The minimum number of contractions of the ab shellpair for which to
   ! precalculate the cd shellpair data.

!  n_contraction_cutoff :: INT = 0

   ! The minimum value of l angular momentum for a shellpair to perform the
   ! reduced multiplication scheme.

!  ERI_rms_min_l :: INT = 4

   ! When a factor controlling the size of a primitive pair integral is smaller
   ! than this cutoff, its contribution to the ERI is ignored.

   pair_cutoff :: REAL, private = SHELL1QUARTET_ERI_PAIR_CUTOFF

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Destroy an object
   end

   nullify_ptr_part ::: pure
   ! Nullify the pointer parts of self
      self :: INOUT

      .a.nullify_ptr_part
      .b.nullify_ptr_part
      .c.nullify_ptr_part
      .d.nullify_ptr_part

      nullify(.ab_exponent_sum)
      nullify(.ab_exponent_inv)
      nullify(.ab_contraction_prefactor)
      nullify(.ab_contraction_s_prefactor)
      nullify(.ab_contraction_p_prefactor)
      nullify(.ab_pair_center)
      nullify(.ab_center_diff)
      nullify(.cd_exponent_sum)
      nullify(.cd_exponent_inv)
      nullify(.cd_contraction_prefactor)
      nullify(.cd_contraction_s_prefactor)
      nullify(.cd_contraction_p_prefactor)
      nullify(.cd_pair_center)
      nullify(.cd_center_diff)

   end

   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts of self
      self :: INOUT

      .destroy_ab
      .destroy_cd

   end

   destroy_ab ::: leaky, PURE
   ! Destroy the shella and shellb pointer parts of self
      self :: INOUT

      .a.nullify_ptr_part
      .b.nullify_ptr_part

      if (.ab_nullify) then

         nullify(.ab_exponent_sum)
         nullify(.ab_exponent_inv)
         if (.ab_same_center) then
            nullify(.ab_contraction_prefactor)
            nullify(.ab_contraction_s_prefactor)
            nullify(.ab_contraction_p_prefactor)
         else
            .ab_contraction_prefactor.destroy
            .ab_contraction_s_prefactor.destroy
            .ab_contraction_p_prefactor.destroy
         end
   !     nullify(.ab_form_3dints_yz_rms_indices)

      else

         .ab_exponent_sum.destroy
         .ab_exponent_inv.destroy
         .ab_contraction_prefactor.destroy
         .ab_contraction_s_prefactor.destroy
         .ab_contraction_p_prefactor.destroy
   !     .ab_form_3dints_yz_rms_indices.destroy

      end

      .ab_pair_center.destroy
      .ab_center_diff.destroy

   end

   destroy_cd ::: leaky, PURE
   ! Destroy the shellc and shelld pointer parts of self
      self :: INOUT

      .c.nullify_ptr_part
      .d.nullify_ptr_part

      if (.cd_nullify) then
       nullify(.cd_exponent_sum)
       nullify(.cd_exponent_inv)
       if (.cd_same_center) then
          nullify(.cd_contraction_prefactor)
          nullify(.cd_contraction_s_prefactor)
          nullify(.cd_contraction_p_prefactor)
       else
          .cd_contraction_prefactor.destroy
          .cd_contraction_s_prefactor.destroy
          .cd_contraction_p_prefactor.destroy
       end
   !   nullify(.cd_form_3dints_yz_rms_indices)

      else

       .cd_exponent_sum.destroy
       .cd_exponent_inv.destroy
       .cd_contraction_prefactor.destroy
       .cd_contraction_s_prefactor.destroy
       .cd_contraction_p_prefactor.destroy
   !   .cd_form_3dints_yz_rms_indices.destroy

      end

      .cd_pair_center.destroy
      .cd_center_diff.destroy

   end

!  ===========
!  Set methods
!  ===========

   set_defaults ::: PURE
   ! Set defaults
      self :: INOUT

      .is_spherical = FALSE
      .ab_nullify  = TRUE
      .cd_nullify  = TRUE

   end

   set_spherical(val) ::: PURE
   ! Set sphericals to "val" defaults
      self :: INOUT
      val :: BIN, IN

      .is_spherical = val

   end

!  ======================
!  Miscellaneous Routines
!  ======================

   unnormalise ::: pure
   ! Unnormalise each shell in this shell quartet
      self :: INOUT

      .a.unnormalise
      .b.unnormalise
      .c.unnormalise
      .d.unnormalise

   end

!  ===================
!  Precalculated stuff
!  ===================

   set_pair_cutoff(cutoff)
   ! Set the "cutoff" for the exponential prefactor for the product of two
   ! gaussian primitives, below which that primitive pair is is ignored in
   ! the calculation of the ERI's.
      cutoff :: REAL, IN

   ENSURE(cutoff>ZERO,"cutoff must be pisitive")

      if (FALSE) self = self
      pair_cutoff = cutoff

   end

   set_ab_new(shellpr,pos_a,pos_b,same_center,skip) ::: leaky
   ! Set the a and b parts from "shellpr" but override the positions.
   ! "same_center" should be set TRUE if pos_a==pos_b.
   ! "skip" can be set TRUE if NOT same_center; it skips gaussian product
   ! pairs which are too small to worry about.
   ! NOTE: this does not create many pointer parts
      shellpr :: SHELL1PAIR, IN, target
      pos_a,pos_b :: VEC{REAL}, IN
      same_center,skip :: BIN, IN

      exponent_sum,exponent_inv :: VEC{REAL}*
      AB,At,P,PAt,b_pos_b :: VEC{REAL}(3)
      a,b,r2ab,b_r2ab,ab_inv,prefac :: REAL
      i,j,bg,ag :: INT

      .is_spherical = shellpr.a.is_spherical ! b must be the same

      .a = shellpr.a
      .b = shellpr.b
      .a.position = pos_a
      .b.position = pos_b
      .ab_same_center = same_center
      .ab_l_max = shellpr.l_max
      .ab_l_min = shellpr.l_min
      .ab_l_sum = shellpr.l_sum
      .ab_l_tri = .ab_l_max*(.ab_l_max+1)/2 + .ab_l_min + 1
      .ab_n_gaussian_pairs = shellpr.n_gaussian_pairs
      .ab_n_comp_pairs   = shellpr.n_comp_pairs
      .ab_n_sph_pairs   = shellpr.n_sph_pairs
      .ab_n_bf_pairs   = shellpr.n_bf_pairs
      .ab_first_gaussian = shellpr.first_gaussian
      .ab_last_gaussian  = shellpr.last_gaussian
      .n_ab = shellpr.n_gaussian

      .ab_pair_center.create(3,.ab_n_gaussian_pairs)
      .ab_center_diff.create(3,.ab_n_gaussian_pairs)

      if (NOT skip) then
        .ab_nullify = TRUE
        .ab_exponent_sum => shellpr.exponent_sum
        .ab_exponent_inv => shellpr.exponent_inv
        if (same_center) then
           .ab_contraction_prefactor => shellpr.contraction_prefactor
           .r2ab = ZERO
           i = 0
           do bg = 1,.b.n_cc
              do ag = 1,.a.n_cc
                 i = i + 1
               ! prefac = shellpr.contraction_prefactor(i)
               ! .ab_contraction_prefactor(i) = prefac
                 .ab_pair_center(1,i) = pos_a(1)
                 .ab_pair_center(2,i) = pos_a(2)
                 .ab_pair_center(3,i) = pos_a(3)
                 .ab_center_diff(1,i) = ZERO
                 .ab_center_diff(2,i) = ZERO
                 .ab_center_diff(3,i) = ZERO
              end
           end
        else
           .ab_contraction_prefactor.create(.ab_n_gaussian_pairs)
           ! Want position of shell1 with higher angular momentum.
           if (.a.l > .b.l) then; At = pos_a
           else;                  At = pos_b
           end
           AB = pos_a-pos_b
           r2ab = dot_product(AB,AB)
           .r2ab = r2ab
           i = 0
           do bg = 1,.b.n_cc
              b = .b.exponent(bg)
              b_pos_b = b*pos_b
              b_r2ab = b*r2ab
              do ag = 1,.a.n_cc
                 i = i + 1
                 a = .a.exponent(ag)
                 ab_inv = .ab_exponent_inv(i)
                 prefac = shellpr.contraction_prefactor(i)*exp(-a*b_r2ab*ab_inv)
                 .ab_contraction_prefactor(i) = prefac
                 P = (b_pos_b + a*pos_a) * ab_inv ! This can't be precalculated
                 PAt = P - At                     ! it could be compressed, below
                 .ab_pair_center(1,i) = P(1)
                 .ab_pair_center(2,i) = P(2)
                 .ab_pair_center(3,i) = P(3)
                 .ab_center_diff(1,i) = PAt(1)
                 .ab_center_diff(2,i) = PAt(2)
                 .ab_center_diff(3,i) = PAt(3)
              end
           end
        end
      else
        .ab_contraction_prefactor.create(.ab_n_gaussian_pairs)
        ! When skipping, centers must not be the same ....
        ! Want position of shell1 with higher angular momentum.
        if (.a.l > .b.l) then; At = pos_a
        else;                  At = pos_b
        end
        AB = pos_a-pos_b
        r2ab = dot_product(AB,AB)
        .r2ab = r2ab
        .ab_nullify = FALSE
        .ab_exponent_sum.create(.ab_n_gaussian_pairs)
        .ab_exponent_inv.create(.ab_n_gaussian_pairs)
        exponent_sum => shellpr.exponent_sum
        exponent_inv => shellpr.exponent_inv
        i = 0
        j = 0
        do bg = 1,.b.n_cc
           b = .b.exponent(bg)
           b_pos_b = b*pos_b
           b_r2ab = b*r2ab
           do ag = 1,.a.n_cc
              i = i + 1
              a = .a.exponent(ag)
              ab_inv = exponent_inv(i)
              prefac = exp(-a*b_r2ab*ab_inv)
              if (prefac<pair_cutoff) cycle  ! <<<<<<<<<<<<<
              j = j + 1
              .ab_exponent_sum(j) = exponent_sum(i)
              .ab_exponent_inv(j) = ab_inv
              .ab_contraction_prefactor(j) = prefac*shellpr.contraction_prefactor(i)
              P = (b_pos_b + a*pos_a) * ab_inv
              PAt = P - At
              .ab_pair_center(1,j) = P(1)
              .ab_pair_center(2,j) = P(2)
              .ab_pair_center(3,j) = P(3)
              .ab_center_diff(1,j) = PAt(1)
              .ab_center_diff(2,j) = PAt(2)
              .ab_center_diff(3,j) = PAt(3)
           end
        end
        .ab_n_gaussian_pairs = j
      end
   end

   set_cd_new(shellpr,pos_c,pos_d,same_center,skip) ::: leaky
   ! Set the c and d parts from "shellpr" but override the positions.
   ! "same_center" should be set TRUE if pos_a==pos_b.
   ! "skip" can be set TRUE if NOT same_center; it skips gaussian product
   ! pairs which are too small to worry about.
   ! NOTE: this does not create many pointer parts
      shellpr :: SHELL1PAIR, IN, target
      pos_c,pos_d :: VEC{REAL}, IN
      same_center,skip :: BIN, IN
      exponent_sum,exponent_inv :: VEC{REAL}*
      CD,Ct,Q,QCt,d_pos_d :: VEC{REAL}(3)
      c,d,r2cd,d_r2cd,cd_inv,prefac :: REAL
      i,j,dg,cg :: INT

      .is_spherical = shellpr.a.is_spherical ! d must be the same

      .c = shellpr.a
      .d = shellpr.b
      .c.position = pos_c
      .d.position = pos_d

      .cd_same_center = same_center
      .cd_l_max = shellpr.l_max
      .cd_l_min = shellpr.l_min
      .cd_l_sum = shellpr.l_sum
      .cd_l_tri = .cd_l_max*(.cd_l_max+1)/2 + .cd_l_min + 1
      .cd_n_gaussian_pairs = shellpr.n_gaussian_pairs
      .cd_n_comp_pairs   = shellpr.n_comp_pairs
      .cd_n_sph_pairs   = shellpr.n_sph_pairs
      .cd_n_bf_pairs   = shellpr.n_bf_pairs
      .cd_first_gaussian = shellpr.first_gaussian
      .cd_last_gaussian  = shellpr.last_gaussian
      .n_cd = shellpr.n_gaussian

      .cd_pair_center.create(3,.cd_n_gaussian_pairs)
      .cd_center_diff.create(3,.cd_n_gaussian_pairs)

      if (NOT skip) then

        .cd_nullify = TRUE
        .cd_exponent_sum => shellpr.exponent_sum
        .cd_exponent_inv => shellpr.exponent_inv

        if (same_center) then
           .cd_contraction_prefactor => shellpr.contraction_prefactor
           .r2cd = ZERO
           i = 0
           do dg = 1,.d.n_cc
              do cg = 1,.c.n_cc
                 i = i + 1
               ! prefac = shellpr.contraction_prefactor(i)
               ! .cd_contraction_prefactor(i) = prefac
                 .cd_pair_center(1,i) = pos_c(1)
                 .cd_pair_center(2,i) = pos_c(2)
                 .cd_pair_center(3,i) = pos_c(3)
                 .cd_center_diff(1,i) = ZERO
                 .cd_center_diff(2,i) = ZERO
                 .cd_center_diff(3,i) = ZERO
              end
           end

        else

           .cd_contraction_prefactor.create(.cd_n_gaussian_pairs)
           ! Want position of shell1 with higher angular momentum.
           if (.c.l > .d.l) then; Ct = pos_c
           else;                  Ct = pos_d
           end
           CD = pos_c-pos_d
           r2cd = dot_product(CD,CD)
           .r2cd = r2cd
           i = 0
           do dg = 1,.d.n_cc
              d = .d.exponent(dg)
              d_pos_d = d*pos_d
              d_r2cd = d*r2cd
              do cg = 1,.c.n_cc
                 i = i + 1
                 c = .c.exponent(cg)
                 cd_inv  = .cd_exponent_inv(i)
                 prefac = shellpr.contraction_prefactor(i)*exp(-c*d_r2cd*cd_inv)
                 .cd_contraction_prefactor(i) = prefac
                 Q = (d_pos_d + c*pos_c) * cd_inv
                 QCt = Q - Ct
                 .cd_pair_center(1,i) = Q(1)
                 .cd_pair_center(2,i) = Q(2)
                 .cd_pair_center(3,i) = Q(3)
                 .cd_center_diff(1,i) = QCt(1)
                 .cd_center_diff(2,i) = QCt(2)
                 .cd_center_diff(3,i) = QCt(3)
              end
           end

        end

      else

        .cd_contraction_prefactor.create(.cd_n_gaussian_pairs)
        ! When skipping, centers must not be the same ....
        ! Want position of shell1 with higher angular momentum.
        if (.c.l > .d.l) then; Ct = pos_c
        else;                  Ct = pos_d
        end
        CD = pos_c-pos_d
        r2cd = dot_product(CD,CD)
        .r2cd = r2cd
        .cd_nullify = FALSE
        .cd_exponent_sum.create(.cd_n_gaussian_pairs)
        .cd_exponent_inv.create(.cd_n_gaussian_pairs)
        exponent_sum => shellpr.exponent_sum
        exponent_inv => shellpr.exponent_inv
        i = 0
        j = 0
        do dg = 1,.d.n_cc
           d = .d.exponent(dg)
           d_pos_d = d*pos_d
           d_r2cd = d*r2cd
           do cg = 1,.c.n_cc
              i = i + 1
              c = .c.exponent(cg)
              cd_inv  = exponent_inv(i)
              prefac = exp(-c*d_r2cd*cd_inv)
              if (prefac<pair_cutoff) cycle
              j = j + 1
              .cd_exponent_sum(j) = exponent_sum(i)
              .cd_exponent_inv(j) = cd_inv
              .cd_contraction_prefactor(j) = prefac*shellpr.contraction_prefactor(i)
              Q = (d_pos_d + c*pos_c) * cd_inv
              QCt = Q - Ct
              .cd_pair_center(1,j) = Q(1)
              .cd_pair_center(2,j) = Q(2)
              .cd_pair_center(3,j) = Q(3)
              .cd_center_diff(1,j) = QCt(1)
              .cd_center_diff(2,j) = QCt(2)
              .cd_center_diff(3,j) = QCt(3)
           end
        end

        .cd_n_gaussian_pairs = j

      end

   end

!  ===========
!  ERI cutoffs
!  ===========

! What is this routine below doing? hasn't it been subsumed into the type? -- dylan

!   cd_kappa_max result (res) ::: pure
!   ! Return the largest kappa_cd used in the Lindh integrals.
!     self :: IN
!     res :: REAL
!     CD :: VEC{REAL}(3)
!     d,d_cc,c,cd_inv,prefac,r2_cd :: REAL
!     dg,cg :: INT
!     CD = .d.position - .c.position
!     r2_cd = dot_product(CD,CD)
!     res = ZERO
!     do dg = 1,.d.n_cc
!       d      = .d.exponent(dg)
!       d_cc   = .d.contraction(dg)
!       do cg = 1,.c.n_cc
!         c = .c.exponent(cg)
!         cd_inv = ONE/(c+d)
!         prefac = d_cc*.c.contraction(cg) * cd_inv * sqrt(cd_inv) * exp(-c*d*r2_cd*cd_inv)
!         res = max(res,prefac/(sqrt(cd_inv)*cd_inv))
!       end
!     end
!   end

!   skip_ERI result (res) ::: pure
!   ! Whether the ERI block will be less than a cutoff value.
!     self :: IN
!     res :: BIN
!     res = (.ab_kappa_max*.cd_kappa_max < SHELL4_ERI_CUTOFF)
!   end

!   skip_ERI(cutoff) result (res) ::: pure
!   ! Whether the ERI block will be less than a cutoff value.
!     self :: IN
!     cutoff :: REAL, IN
!     res :: BIN
!     res = (.ab_kappa_max*.cd_kappa_max < cutoff)
!   end

!===============================================================================
!                   Roland Lindh-style integrals
!
! Electron repulsion integrals from Lindh, Ryu and Liu,
! J. Chem. Phys 95(8) 1991, 5889-5897.
!
! See also:
! Obara and Saika, J. Chem. Phys. 84(7), 1986, 3963-3974.
! Head-Gordon and Pople, J. Chem. Phys. 89(9), 1988, 5777-5786.
!
!===============================================================================

   make_ERI(abcd) ::: public
   ! Makes the (ab|cd) integrals, summed over the primitives
   ! (uses the transfer equation to make (ab|cd) from (es|fs))
   ! ENSURE(.is_spherical,"wrong ERI routine call, sph vs cart violation")
      self :: IN
      abcd :: VEC{REAL}(*), OUT

      W :: MAT4{REAL}*

      if (NOT .is_spherical) then

         SHELL1QUARTET::make_ERI_c(self,abcd)

      elseif (max(.ab_l_max,.cd_l_max)<2) then

         SHELL1QUARTET::make_ERI_c(self,abcd)

      else

         W.create(.a.n_comp,.b.n_comp,.c.n_comp,.d.n_comp)
         SHELL1QUARTET::make_ERI_c(self,W)
         SHELL1QUARTET::change_to_spherical(self,W,abcd)

      end

   end

   make_ERI_c(abcd)
   ! Makes the (ab|cd) integrals, summed over the primitives
   ! (uses the transfer equation to make (ab|cd) from (es|fs))
      self :: IN
      abcd :: VEC{REAL}(*), OUT
 ! ENSURE(.n_ab==(.ab_last_gaussian-.ab_first_gaussian+1),"n_ab wrong")
 ! ENSURE(.n_cd==(.cd_last_gaussian-.cd_first_gaussian+1),"n_cd wrong")

      esfs,escd :: VEC{REAL}*
      ssss :: REAL

      if      (.ab_l_sum==0 AND .cd_l_sum==0) then

        .make_esfs_ss_0000(ssss)
        abcd(1) = ssss

      else if (.ab_l_sum==0) then

        esfs.create(.n_cd)
        SHELL1QUARTET::make_esfs(self,esfs)            ! Make (es|fs) integrals
        SHELL1QUARTET::transfer_cd_s(self,esfs,abcd)   ! Transfer, ab = ss
        esfs.destroy

      else if (.cd_l_sum==0) then

        esfs.create(.n_ab)
        SHELL1QUARTET::make_esfs(self,esfs)            ! Make (es|fs) integrals
        SHELL1QUARTET::transfer_ab_s(self,esfs,abcd)   ! Transfer, cd = ss
        esfs.destroy

      else

        esfs.create(.n_ab*.n_cd)
        SHELL1QUARTET::make_esfs(self,esfs)            ! Make (es|fs) integrals
        escd.create(.n_ab*.c.n_comp*.d.n_comp)
        SHELL1QUARTET::transfer_cd(self,esfs,escd)     ! Transfer relations
        SHELL1QUARTET::transfer_ab(self,escd,abcd)
        escd.destroy
        esfs.destroy

      end

   end

   change_to_spherical(C,S) ::: leaky
   ! Normalise a cartesian integral block "C" to a spherical integral
   ! block "S" . "C" is destroyed.
      self :: IN
      C :: MAT4{REAL}*
      S :: MAT4{REAL}(.a.n_sph,.b.n_sph,.c.n_sph,.d.n_sph), OUT

      UU  :: VEC{MAT_{REAL}}*
      U :: MAT{REAL}*
      W,WW :: MAT4{REAL}*

      UU => GAUSSIAN_DATA::spherical_harmonics_for

      if (max(.ab_l_max,.cd_l_max)<2) then

         S = C             ! don't use this case
         C.destroy

      else

         W => C

         if (.a.l>=2) then
            U => UU(.a.l).element
            WW.create(.a.n_sph,.b.n_comp,.c.n_comp,.d.n_comp)
            W.change_index_1_to(WW,U)
            W.destroy
            W => WW
         end

         if (.b.l>=2) then
            U => UU(.b.l).element
            WW.create(.a.n_sph,.b.n_sph,.c.n_comp,.d.n_comp)
            W.change_index_2_to(WW,U)
            W.destroy
            W => WW
         end

         if (.c.l>=2) then
            U => UU(.c.l).element
            WW.create(.a.n_sph,.b.n_sph,.c.n_sph,.d.n_comp)
            W.change_index_3_to(WW,U)
            W.destroy
            W => WW
         end

         if (.d.l>=2) then
            U => UU(.d.l).element
            WW.create(.a.n_sph,.b.n_sph,.c.n_sph,.d.n_sph)
            W.change_index_4_to(WW,U)
            W.destroy
            W => WW
         end

         S = W

         WW.destroy

      end

   end

! This is a general purpose routine which always works
! but it calls special case code

   make_esfs(esfs)
   ! Makes the (es|fs) integrals, summed over primitives.
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd)

      l_max :: INT
      l_max = max(.ab_l_sum,.cd_l_sum)
    ! if (GAUSSIAN_DATA::Ishida_ordering) then
    !    SHELL1QUARTET::make_esfs_general(self,esfs)
    !    return
    ! end
      select case (l_max)
        case (0)
                                                            SHELL1QUARTET::make_esfs_ss_ssss(self,esfs)
        case (1)
           if      (.ab_l_sum==1 AND .cd_l_sum==0) then;    SHELL1QUARTET::make_esfs_ps_psss(self,esfs)
           else if (.ab_l_sum==0 AND .cd_l_sum==1) then;    SHELL1QUARTET::make_esfs_sp_ssps(self,esfs)
           else if (.ab_l_sum==1 AND .cd_l_sum==1) then;    SHELL1QUARTET::make_esfs_pp_psps(self,esfs)
           end
        case (2)
           if      (.ab_l_sum==2 AND .cd_l_sum==0) then ! ; SHELL1QUARTET::make_esfs_ds(self,esfs)
              if   (.ab_l_min==0) then;                     SHELL1QUARTET::make_esfs_ds_dsss(self,esfs)
              else;                                         SHELL1QUARTET::make_esfs_ds_ppss(self,esfs)
              end
           else if (.ab_l_sum==0 AND .cd_l_sum==2) then ! ; SHELL1QUARTET::make_esfs_sd(self,esfs)
              if   (.cd_l_min==0) then;                     SHELL1QUARTET::make_esfs_sd_ssds(self,esfs)
              else;                                         SHELL1QUARTET::make_esfs_sd_sspp(self,esfs)
              end
           else if (.ab_l_sum==2 AND .cd_l_sum==1) then ! ; SHELL1QUARTET::make_esfs_dp(self,esfs)
              if   (.ab_l_min==0) then;                     SHELL1QUARTET::make_esfs_dp_dsps(self,esfs)
              else;                                         SHELL1QUARTET::make_esfs_dp_ppps(self,esfs)
              end
           else if (.ab_l_sum==1 AND .cd_l_sum==2) then ! ; SHELL1QUARTET::make_esfs_pd(self,esfs)
              if   (.cd_l_min==0) then;                     SHELL1QUARTET::make_esfs_pd_psds(self,esfs)
              else;                                         SHELL1QUARTET::make_esfs_pd_pspp(self,esfs)
              end
           else if (.ab_l_sum==2 AND .cd_l_sum==2) then ! ; SHELL1QUARTET::make_esfs_dd(self,esfs)
              if      (.ab_l_min==0 AND .cd_l_min==0) then; SHELL1QUARTET::make_esfs_dd_dsds(self,esfs)
              else if (.ab_l_min==0 AND .cd_l_min==1) then; SHELL1QUARTET::make_esfs_dd_dspp(self,esfs)
              else if (.ab_l_min==1 AND .cd_l_min==0) then; SHELL1QUARTET::make_esfs_dd_ppds(self,esfs)
              else;                                         SHELL1QUARTET::make_esfs_dd_pppp(self,esfs)
              end
           end
   ! else if (.ab_l_sum==3 AND .cd_l_sum==0) then ! ; SHELL1QUARTET::make_esfs_fs(self,esfs)
   !    if      (.ab_l_min==0) then;                  SHELL1QUARTET::make_esfs_fs_fsss(self,esfs)
   !    else;                                         SHELL1QUARTET::make_esfs_fs_dpss(self,esfs)
   !    end
   ! else if (.ab_l_sum==0 AND .cd_l_sum==3) then ! ; SHELL1QUARTET::make_esfs_sf(self,esfs)
   !    if      (.cd_l_min==0) then;                  SHELL1QUARTET::make_esfs_sf_ssfs(self,esfs)
   !    else;                                         SHELL1QUARTET::make_esfs_sf_ssdp(self,esfs)
   !    end
   ! else if (.ab_l_sum==3 AND .cd_l_sum==1) then ! ; SHELL1QUARTET::make_esfs_fp(self,esfs)
   !    if      (.ab_l_min==0) then;                  SHELL1QUARTET::make_esfs_fp_fsps(self,esfs)
   !    else;                                         SHELL1QUARTET::make_esfs_fp_dpps(self,esfs)
   !    end
   ! else if (.ab_l_sum==1 AND .cd_l_sum==3) then ! ; SHELL1QUARTET::make_esfs_pf(self,esfs)
   !    if      (.ab_l_min==0) then;                  SHELL1QUARTET::make_esfs_pf_psfs(self,esfs)
   !    else;                                         SHELL1QUARTET::make_esfs_pf_psdp(self,esfs)
   !    end
   ! else if (.ab_l_sum==3 AND .cd_l_sum==2) then ! ; SHELL1QUARTET::make_esfs_fd(self,esfs)
   !    if      (.ab_l_min==0 AND .cd_l_min==0) then; SHELL1QUARTET::make_esfs_fd_fsds(self,esfs)
   !    else if (.ab_l_min==0 AND .cd_l_min==1) then; SHELL1QUARTET::make_esfs_fd_fspp(self,esfs)
   !    else if (.ab_l_min==1 AND .cd_l_min==0) then; SHELL1QUARTET::make_esfs_fd_dpds(self,esfs)
   !    else;                                         SHELL1QUARTET::make_esfs_fd_dppp(self,esfs)
   !    end
   ! else if (.ab_l_sum==2 AND .cd_l_sum==3) then ! ; SHELL1QUARTET::make_esfs_df(self,esfs)
   !    if      (.ab_l_min==0 AND .cd_l_min==0) then; SHELL1QUARTET::make_esfs_df_dsfs(self,esfs)
   !    else if (.ab_l_min==1 AND .cd_l_min==0) then; SHELL1QUARTET::make_esfs_df_ppfs(self,esfs)
   !    else if (.ab_l_min==0 AND .cd_l_min==0) then; SHELL1QUARTET::make_esfs_df_dsdp(self,esfs)
   !    else;                                         SHELL1QUARTET::make_esfs_df_ppdp(self,esfs)
   !    end
   ! else if (.ab_l_sum==3 AND .cd_l_sum==3) then ! ; SHELL1QUARTET::make_esfs_ff(self,esfs)
   !    if      (.ab_l_min==0 AND .cd_l_min==0) then; SHELL1QUARTET::make_esfs_ff_fsfs(self,esfs)
   !    else if (.ab_l_min==0 AND .cd_l_min==1) then; SHELL1QUARTET::make_esfs_ff_fsdp(self,esfs)
   !    else if (.ab_l_min==1 AND .cd_l_min==0) then; SHELL1QUARTET::make_esfs_ff_dpfs(self,esfs)
   !    else;                                         SHELL1QUARTET::make_esfs_ff_dpdp(self,esfs)
   !    end
        case default
   !       if (.a.l==2 AND .b.l==2 AND .c.l==2 AND .d.l==2) then
   !                                                        SHELL1QUARTET::make_esfs_gg_dddd(self,esfs)
   !       else
           if      (                 .cd_l_sum==0) then;    SHELL1QUARTET::make_esfs_Xs(self,esfs)
           else if (.ab_l_sum==0                 ) then;    SHELL1QUARTET::make_esfs_sX(self,esfs)
           else if (                 .cd_l_sum==1) then;    SHELL1QUARTET::make_esfs_Xp(self,esfs)
           else if (.ab_l_sum==1                 ) then;    SHELL1QUARTET::make_esfs_pX(self,esfs)
           else if (                 .cd_l_sum==2) then;    SHELL1QUARTET::make_esfs_Xd(self,esfs)
           else if (.ab_l_sum==2                 ) then;    SHELL1QUARTET::make_esfs_dX(self,esfs)
           else;                                            SHELL1QUARTET::make_esfs_XX(self,esfs)
   !       else;                                            SHELL1QUARTET::make_esfs_general(self,esfs)
           end
   !       end
      end
   end

! This is a general purpose routine which always works
! but it doesn't use special case code.

!   make_esfs_general(esfs) ::: private
!   ! Makes the initial (es|fs) integrals, summed over the primitives
!      self :: IN
!      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT
!      Ixa,Iya,Iza :: MAT3{REAL}*
!      Ix,Iy,Iz :: MAT{REAL}*
!      Ix_f,Iy_f,Iz_f,Ix_1,Iy_1,Iz_1 :: VEC{REAL}*
!      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
!      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
!      t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
!      ce,cf,bb,ce1,cf1 :: REAL
!      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
!      Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
!      Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
!      Ixe, Iye, Ize, Ixf, Iyf, Izf  :: REAL
!      Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
!      n_roots,dim1,dim2 :: INT
!      e,f,fm1,ep1,fp1,n,i,j,k,n_sum :: INT
!   ! j0,j1,j2,j3,k0,k1,k2,k3 :: INT
!      rys :: RYS*
!      ss :: BIN
!      ss = .ab_l_max==0 AND .cd_l_max==0
!      dim1 = .ab_l_sum + 1                            ! Space for 2D integrals
!      dim2 = .cd_l_sum + 1
!      n_roots = (dim1+dim2)/2
!      n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
!      Ixa.create(n_sum,dim1,dim2)                     ! Allocate 2D integrals
!      Iya.create(n_sum,dim1,dim2)
!      Iza.create(n_sum,dim1,dim2)
!
!      rys.create(n_roots)
!
!      i = 0
!   ! k0 = 0
!      do k = 1,.ab_n_gaussian_pairs
!         ab_cc = .ab_contraction_prefactor(k)
!   !     if (ab_cc<pair_cutoff) cycle
!         zeta = .ab_exponent_sum(k)
!         zinv = .ab_exponent_inv(k)
!         half_zinv = HALF * zinv
!         ab_cc = ab_cc * TWOPI5ON2
!   !     k1 = k0+1; k2 = k0+2; k3 = k0+3; k0 = k3
!         Px = .ab_pair_center(1,k)
!         Py = .ab_pair_center(2,k)
!         Pz = .ab_pair_center(3,k)
!         PAx = .ab_center_diff(1,k)
!         PAy = .ab_center_diff(2,k)
!         PAz = .ab_center_diff(3,k)
!   !     j0 = 0
!         do j = 1,.cd_n_gaussian_pairs
!             cd_cc = .cd_contraction_prefactor(j)
!   !         if (cd_cc<pair_cutoff) cycle
!             eta  = .cd_exponent_sum(j)
!             einv = .cd_exponent_inv(j)
!   !         j1 = j0+1; j2 = j0+2; j3 = j0+3; j0 = j3
!             Qx = .cd_pair_center(1,j)
!             Qy = .cd_pair_center(2,j)
!             Qz = .cd_pair_center(3,j)
!             QCx = .cd_center_diff(1,j)
!             QCy = .cd_center_diff(2,j)
!             QCz = .cd_center_diff(3,j)
!             rho  = zeta * eta / (zeta + eta)
!             rho_zinv = rho * zinv
!             rho_einv = rho * einv
!             half_einv = HALF * einv
!             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
!             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
!             rys.get_weights(xx,only_weight=ss)
!             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
!
!             ! Now make the 2 dimensional integrals.
!             do n = 1,n_roots
!               i = i + 1
!               Ix => Ixa(i,:,:)
!               Iy => Iya(i,:,:)
!               Iz => Iza(i,:,:)
!               t2      = rys.root(n)
!               Ix(1,1) = ONE
!               Iy(1,1) = ONE
!               Iz(1,1) = ONE
!               if (.ab_l_sum>0) then
!                 t2_rz = t2 * rho_zinv
!                 Ix21 = PAx + t2_rz*QPx; Ix(2,1) = Ix21
!                 Iy21 = PAy + t2_rz*QPy; Iy(2,1) = Iy21
!                 Iz21 = PAz + t2_rz*QPz; Iz(2,1) = Iz21
!               end
!               if (.ab_l_sum>1) then
!                 ce  = (ONE - t2_rz) * half_zinv
!                 Ix31 = Ix21*Ix21 + ce; Ix(3,1) = Ix31
!                 Iy31 = Iy21*Iy21 + ce; Iy(3,1) = Iy31
!                 Iz31 = Iz21*Iz21 + ce; Iz(3,1) = Iz31
!               end
!               if (.ab_l_sum>2) then
!                 Ixe = Ix31; Ixm1 = Ix21
!                 Iye = Iy31; Iym1 = Iy21
!                 Ize = Iz31; Izm1 = Iz21
!                 ce1 = ce
!                 do ep1 = 4,.ab_l_sum+1
!                   ce1 = ce1 + ce
!                   Ixp1 = Ix21*Ixe + ce1*Ixm1; Ix(ep1,1) = Ixp1
!                   Iyp1 = Iy21*Iye + ce1*Iym1; Iy(ep1,1) = Iyp1
!                   Izp1 = Iz21*Ize + ce1*Izm1; Iz(ep1,1) = Izp1
!                   Ixm1 = Ixe; Ixe = Ixp1
!                   Iym1 = Iye; Iye = Iyp1
!                   Izm1 = Ize; Ize = Izp1
!                 end
!               end
!               if (.cd_l_sum>0) then
!                 t2_re = t2 * rho_einv
!                 Ix12 = QCx - t2_re*QPx; Ix(1,2) = Ix12
!                 Iy12 = QCy - t2_re*QPy; Iy(1,2) = Iy12
!                 Iz12 = QCz - t2_re*QPz; Iz(1,2) = Iz12
!               end
!               if (.cd_l_sum>1) then
!                 cf  = (ONE - t2_re) * half_einv
!                 Ix13 = Ix12*Ix12 + cf; Ix(1,3) = Ix13
!                 Iy13 = Iy12*Iy12 + cf; Iy(1,3) = Iy13
!                 Iz13 = Iz12*Iz12 + cf; Iz(1,3) = Iz13
!               end
!               if (.cd_l_sum>2) then
!                 Ixf = Ix13; Ixm1 = Ix12
!                 Iyf = Iy13; Iym1 = Iy12
!                 Izf = Iz13; Izm1 = Iz12
!                 cf1 = cf
!                 do fp1 = 4,.cd_l_sum+1
!                   cf1 = cf1 + cf
!                   Ixp1 = Ix12*Ixf + cf1*Ixm1; Ix(1,fp1) = Ixp1
!                   Iyp1 = Iy12*Iyf + cf1*Iym1; Iy(1,fp1) = Iyp1
!                   Izp1 = Iz12*Izf + cf1*Izm1; Iz(1,fp1) = Izp1
!                   Ixm1 = Ixf; Ixf = Ixp1
!                   Iym1 = Iyf; Iyf = Iyp1
!                   Izm1 = Izf; Izf = Izp1
!                 end
!               end
!               if (.ab_l_sum>0 AND .cd_l_sum>0) then
!                 bb = t2_rz * half_einv
!                 Ix22 = Ix12*Ix21 + bb; Ix(2,2) = Ix22
!                 Iy22 = Iy12*Iy21 + bb; Iy(2,2) = Iy22
!                 Iz22 = Iz12*Iz21 + bb; Iz(2,2) = Iz22
!               end
!               if (.ab_l_sum>0 AND .cd_l_sum>1) then
!                 Ix23 = Ix12*Ix22 + cf*Ix21 + bb*Ix12; Ix(2,3) = Ix23
!                 Iy23 = Iy12*Iy22 + cf*Iy21 + bb*Iy12; Iy(2,3) = Iy23
!                 Iz23 = Iz12*Iz22 + cf*Iz21 + bb*Iz12; Iz(2,3) = Iz23
!               end
!               if (.ab_l_sum>1 AND .cd_l_sum>0) then
!                 Ix32 = Ix21*Ix22 + ce*Ix12 + bb*Ix21; Ix(3,2) = Ix32
!                 Iy32 = Iy21*Iy22 + ce*Iy12 + bb*Iy21; Iy(3,2) = Iy32
!                 Iz32 = Iz21*Iz22 + ce*Iz12 + bb*Iz21; Iz(3,2) = Iz32
!               end
!               if (.ab_l_sum>0 AND .cd_l_sum>2) then
!                 Ixf = Ix23; Ixm1 = Ix22
!                 Iyf = Iy23; Iym1 = Iy22
!                 Izf = Iz23; Izm1 = Iz22
!                 cf1 = cf
!                 do f = 3,.cd_l_sum
!                   fp1 = f + 1
!                   cf1 = cf1 + cf
!                   Ixp1 = Ix12*Ixf + cf1*Ixm1 + bb*Ix(1,f); Ix(2,fp1) = Ixp1
!                   Iyp1 = Iy12*Iyf + cf1*Iym1 + bb*Iy(1,f); Iy(2,fp1) = Iyp1
!                   Izp1 = Iz12*Izf + cf1*Izm1 + bb*Iz(1,f); Iz(2,fp1) = Izp1
!                   Ixm1 = Ixf; Ixf = Ixp1
!                   Iym1 = Iyf; Iyf = Iyp1
!                   Izm1 = Izf; Izf = Izp1
!                 end
!               end
!               if (.ab_l_sum>2 AND .cd_l_sum>0) then
!                 Ixe = Ix32; Ixm1 = Ix22
!                 Iye = Iy32; Iym1 = Iy22
!                 Ize = Iz32; Izm1 = Iz22
!                 ce1 = ce
!                 do e = 3,.ab_l_sum
!                   ep1 = e + 1
!                   ce1 = ce1 + ce
!                   Ixp1 = Ix21*Ixe + ce1*Ixm1 + bb*Ix(e,1); Ix(ep1,2) = Ixp1
!                   Iyp1 = Iy21*Iye + ce1*Iym1 + bb*Iy(e,1); Iy(ep1,2) = Iyp1
!                   Izp1 = Iz21*Ize + ce1*Izm1 + bb*Iz(e,1); Iz(ep1,2) = Izp1
!                   Ixm1 = Ixe; Ixe = Ixp1
!                   Iym1 = Iye; Iye = Iyp1
!                   Izm1 = Ize; Ize = Izp1
!                 end
!               end
!               if (.ab_l_sum>1 AND .cd_l_sum>1) then
!                 f1_bb = bb
!                 do f = 3,.cd_l_sum+1
!                   fm1 = f - 1
!                   Ix_f => Ix(:,f)
!                   Iy_f => Iy(:,f)
!                   Iz_f => Iz(:,f)
!                   Ix_1 => Ix(:,fm1)
!                   Iy_1 => Iy(:,fm1)
!                   Iz_1 => Iz(:,fm1)
!                   Ixe = Ix_f(2); Ixm1 = Ix_f(1)
!                   Iye = Iy_f(2); Iym1 = Iy_f(1)
!                   Ize = Iz_f(2); Izm1 = Iz_f(1)
!                   f1_bb = f1_bb + bb
!                   ce1 = ZERO
!                   do e = 2,.ab_l_sum
!                     ep1 = e + 1
!                     ce1 = ce1 + ce
!                     Ixp1 = Ix21*Ixe + ce1*Ixm1 + f1_bb*Ix_1(e); Ix_f(ep1) = Ixp1
!                     Iyp1 = Iy21*Iye + ce1*Iym1 + f1_bb*Iy_1(e); Iy_f(ep1) = Iyp1
!                     Izp1 = Iz21*Ize + ce1*Izm1 + f1_bb*Iz_1(e); Iz_f(ep1) = Izp1
!                     Ixm1 = Ixe; Ixe = Ixp1
!                     Iym1 = Iye; Iye = Iyp1
!                     Izm1 = Ize; Ize = Izp1
!                   end
!                 end
!               end
!               Iz = Iz * rys.weight(n)
!             end
!         end     ! -- loops over c,d
!      end         ! -- loops over a,b
!
!      rys.destroy
!
!      .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
!   ! SHELL1QUARTET::form_esfs_rms2(self,esfs,Ixa,Iya,Iza,Iza(:,1,1),n_sum,dim1,dim2)
!
!      Iza.destroy
!      Iya.destroy
!      Ixa.destroy
!   end

! These are optimised routines derived from the make_esfs_general routine
! and from the code in RMS2_INDICES which generates optimal fortran source.

   make_esfs_ss_0000(v11) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      v11 :: REAL, OUT

      Qx,Qy,Qz,Px,Py,Pz,QPx,QPy,QPz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho :: REAL
      j,k :: INT
      rys :: RYS*

      rys.create(1)

      v11 = ZERO

      parallel do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             rho  = zeta * eta / (zeta + eta)
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx,only_weight=TRUE)
             ! Now make the 2 dimensional integrals.
             ! Only weights are needed for ss case
             v11 = v11 + rys.weight(1) * ab_cc * cd_cc * sqrt(rho)
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      PARALLEL_SUM(v11)

      rys.destroy

   end

   make_esfs_ss_ssss(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}, OUT

      Qx,Qy,Qz,Px,Py,Pz,QPx,QPy,QPz :: REAL
      v11,zeta,eta,xx,ab_cc,cd_cc,rho :: REAL
      j,k :: INT
      rys :: RYS*

      rys.create(1)

      esfs = ZERO

      v11 = ZERO

      parallel do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             rho  = zeta * eta / (zeta + eta)
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx,only_weight=TRUE)
             ! Now make the 2 dimensional integrals.
             ! Only weights are needed for ss case
             v11 = v11 + rys.weight(1) * ab_cc * cd_cc * sqrt(rho)
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

   ! .form_esfs(esfs,Iza,Iza,Iza,Iza(:,1,1))

      esfs(1,1) = v11

      PARALLEL_SUM(esfs)

   end

   make_esfs_ps_psss(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: VEC{REAL}(.n_ab), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,Px,Py,Pz :: REAL
      Ix21,Iy21,Iz21,v11,v21,v31 :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,rho_zinv :: REAL
      wt,t2,t2_rz :: REAL
      j,k :: INT
      rys :: RYS*

      rys.create(1)

      esfs = ZERO

      v11 = ZERO; v21 = ZERO; v31 = ZERO

      parallel do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
               t2      = rys.root(1)
               wt      = rys.weight(1)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               v11 = v11 + Ix21*wt
               v21 = v21 + Iy21*wt
               v31 = v31 + Iz21*wt
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1) = v11
      esfs(2) = v21
      esfs(3) = v31

      PARALLEL_SUM(esfs)

   end

   make_esfs_sp_ssps(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: VEC{REAL}(.n_cd), OUT

      QPx,QPy,QPz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      Ix12,Iy12,Iz12,v11,v12,v13 :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,einv,rho_einv :: REAL
      wt,t2,t2_re :: REAL
      j,k :: INT
      rys :: RYS*

      rys.create(1)

      esfs = ZERO

      v11 = ZERO; v12 = ZERO; v13 = ZERO

      parallel do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_einv = rho * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
               t2      = rys.root(1)
               wt      = rys.weight(1)

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               v11 = v11 + Ix12*wt
               v12 = v12 + Iy12*wt
               v13 = v13 + Iz12*wt
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1) = v11
      esfs(2) = v12
      esfs(3) = v13

      PARALLEL_SUM(esfs)

   end

   make_esfs_pp_psps(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,zinv,rho,einv,rho_zinv,rho_einv :: REAL
      wt,t2,t2_rz,t2_re,bb,half_einv :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      v11,v21,v31,v12,v22,v32,v13,v23,v33 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 2
      rys.create(n_roots)

      esfs = ZERO

      v11 = ZERO; v21 = ZERO; v31 = ZERO
      v12 = ZERO; v22 = ZERO; v32 = ZERO
      v13 = ZERO; v23 = ZERO; v33 = ZERO

      parallel do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             half_einv = HALF * einv
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 =  PAx + t2_rz*QPx
               Iy21 =  PAy + t2_rz*QPy
               Iz21 =  PAz + t2_rz*QPz

               t2_re = t2 * rho_einv
               Ix12 =  QCx - t2_re*QPx
               Iy12 =  QCy - t2_re*QPy
               Iz12 =  QCz - t2_re*QPz

               bb = t2_rz * half_einv
               Ix22 =  Ix12*Ix21 + bb
               Iy22 =  Iy12*Iy21 + bb
               Iz22 =  Iz12*Iz21 + bb

               Iz21 = Iz21*wt
               Iy21 = Iy21*wt
               Ix21 = Ix21*wt

               v11 = v11 + Ix22          *wt
               v21 = v21 + Ix12*Iy21
               v31 = v31 + Ix12*     Iz21
               v12 = v12 + Ix21*Iy12
               v22 = v22 +      Iy22     *wt
               v32 = v32 +      Iy12*Iz21
               v13 = v13 + Ix21*     Iz12
               v23 = v23 +      Iy21*Iz12
               v33 = v33 +           Iz22*wt
             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(2,1) = v21
      esfs(3,1) = v31
      esfs(1,2) = v12
      esfs(2,2) = v22
      esfs(3,2) = v32
      esfs(1,3) = v13
      esfs(2,3) = v23
      esfs(3,3) = v33

      PARALLEL_SUM(esfs)

   end

!   make_esfs_pp(esfs) ::: private
!   ! Makes the initial (es|fs) integrals, summed over the primitives
!     self :: IN
!     esfs :: MAT{REAL}, OUT
!     Ixa,Iya,Iza :: MAT3{REAL}*
!     Ix,Iy,Iz :: MAT{REAL}*
!     QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
!     zeta,eta,xx,ab_cc,cd_cc,zinv,rho,einv,rho_zinv,rho_einv :: REAL
!     wt,t2,t2_rz,t2_re,bb,half_einv :: REAL
!     Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
!     v11,v21,v31,v12,v22,v32,v13,v23,v33 :: REAL
!     n_roots,dim1,dim2 :: INT
!     e,f,em1,fm1,ep1,fp1,n,i,j,k,n_sum :: INT
!     rys :: RYS*
!
!     dim1 = .ab_l_sum + 1
!     dim2 = .cd_l_sum + 1
!     n_roots = (dim1+dim2)/2
!     n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
!     Ixa.create(n_sum,dim1,dim2)
!     Iya.create(n_sum,dim1,dim2)
!     Iza.create(n_sum,dim1,dim2)
!
!     rys.create(n_roots)
!
!     i = 0
!     do k = 1,.ab_n_gaussian_pairs
!         ab_cc = .ab_contraction_prefactor(k)
!         zeta = .ab_exponent_sum(k)
!         zinv = .ab_exponent_inv(k)
!         ab_cc = ab_cc * TWOPI5ON2
!         Px = .ab_pair_center(1,k)
!         Py = .ab_pair_center(2,k)
!         Pz = .ab_pair_center(3,k)
!         PAx = .ab_center_diff(1,k)
!         PAy = .ab_center_diff(2,k)
!         PAz = .ab_center_diff(3,k)
!         do j = 1,.cd_n_gaussian_pairs
!             cd_cc = .cd_contraction_prefactor(j)
!             eta  = .cd_exponent_sum(j)
!             einv = .cd_exponent_inv(j)
!             Qx = .cd_pair_center(1,j)
!             Qy = .cd_pair_center(2,j)
!             Qz = .cd_pair_center(3,j)
!             QCx = .cd_center_diff(1,j)
!             QCy = .cd_center_diff(2,j)
!             QCz = .cd_center_diff(3,j)
!             rho  = zeta * eta / (zeta + eta)
!             rho_zinv = rho * zinv
!             rho_einv = rho * einv
!             half_einv = HALF * einv
!             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
!             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
!             rys.get_weights(xx)
!             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
!             ! Now make the 2 dimensional integrals.
!             do n = 1,n_roots
!               i = i + 1
!               Ix => Ixa(i,:,:)
!               Iy => Iya(i,:,:)
!               Iz => Iza(i,:,:)
!               t2      = rys.root(n)
!               Ix(1,1) = ONE
!               Iy(1,1) = ONE
!               Iz(1,1) = wt
!
!                 t2_rz = t2 * rho_zinv
!                 Ix21 = PAx + t2_rz*QPx; Ix(2,1) = Ix21
!                 Iy21 = PAy + t2_rz*QPy; Iy(2,1) = Iy21
!                 Iz21 = PAz + t2_rz*QPz; Iz(2,1) = Iz21*wt
!
!                 t2_re = t2 * rho_einv
!                 Ix12 = QCx - t2_re*QPx; Ix(1,2) = Ix12
!                 Iy12 = QCy - t2_re*QPy; Iy(1,2) = Iy12
!                 Iz12 = QCz - t2_re*QPz; Iz(1,2) = Iz12*wt
!
!                 bb = t2_rz * half_einv
!                 Ix22 = Ix12*Ix21 + bb; Ix(2,2) = Ix22
!                 Iy22 = Iy12*Iy21 + bb; Iy(2,2) = Iy22
!                 Iz22 = Iz12*Iz21 + bb; Iz(2,2) = Iz22*wt
!             end
!         end     ! -- loops over c,d
!     end         ! -- loops over a,b
!
!     rys.destroy
!
!     .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
!
!     Iza.destroy
!     Iya.destroy
!     Ixa.destroy
!   end

   make_esfs_ds_dsss(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: VEC{REAL}(.n_ab), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,rho_zinv :: REAL
      wt,t2,t2_rz,half_zinv,ce :: REAL
      Ix21,Iy21,Iz21 :: REAL
      Ix31,Iy31,Iz31 :: REAL
      v11,v21,v31,v41,v51,v61 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 2
      rys.create(n_roots)

      esfs = ZERO

      v11 = ZERO; v21 = ZERO; v31 = ZERO
      v41 = ZERO; v51 = ZERO; v61 = ZERO

      parallel do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               ce  = (ONE - t2_rz) * half_zinv
               Ix31 = Ix21*Ix21 + ce
               Iy31 = Iy21*Iy21 + ce
               Iz31 = Iz21*Iz21 + ce

               Iz21 = Iz21*wt
               Iz31 = Iz31*wt

               v11 = v11 + Ix31*wt      ! xx
               v21 = v21 + Iy31*wt      ! yy
               v31 = v31 + Iz31         ! zz
               v41 = v41 + Ix21*Iy21*wt ! xy
               v51 = v51 + Ix21*Iz21    ! xz
               v61 = v61 + Iy21*Iz21    ! yz

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1) = v11
      esfs(2) = v21
      esfs(3) = v31
      esfs(4) = v41
      esfs(5) = v51
      esfs(6) = v61

      PARALLEL_SUM(esfs)

   end

   make_esfs_ds_ppss(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}, OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,rho_zinv :: REAL
      wt,t2,t2_rz,half_zinv,ce :: REAL
      Ix21,Iy21,Iz21 :: REAL
      Ix31,Iy31,Iz31 :: REAL
      v11,v21,v31,v41,v51,v61,v71,v81,v91,Iy21_wt :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 2
      rys.create(n_roots)

      esfs = ZERO

      v11 = ZERO; v21 = ZERO; v31 = ZERO
      v41 = ZERO; v51 = ZERO; v61 = ZERO
      v71 = ZERO; v81 = ZERO; v91 = ZERO

      parallel do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               ce  = (ONE - t2_rz) * half_zinv
               Ix31 = Ix21*Ix21 + ce
               Iy31 = Iy21*Iy21 + ce
               Iz31 = Iz21*Iz21 + ce

               Iz21 = Iz21*wt
               Iz31 = Iz31*wt

               Iy21_wt = Iy21*wt

               v11 = v11 + Ix21*wt
               v81 = v81 + Ix21*Iz21
               v21 = v21 + Iy21_wt
               v91 = v91 + Iy21*Iz21
               v31 = v31 + Iz21
               v61 = v61 + Iz31
               v41 = v41 + Ix31*wt
               v51 = v51 + Iy31*wt
               v71 = v71 + Ix21*Iy21_wt

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(8,1) = v81
      esfs(2,1) = v21
      esfs(9,1) = v91
      esfs(3,1) = v31
      esfs(6,1) = v61
      esfs(4,1) = v41
      esfs(5,1) = v51
      esfs(7,1) = v71

      PARALLEL_SUM(esfs)

   end

!   make_esfs_ds(esfs) ::: private
!   ! Makes the initial (es|fs) integrals, summed over the primitives
!     self :: IN
!     esfs :: MAT{REAL}, OUT
!     Ixa,Iya,Iza :: MAT3{REAL}*
!     Ix,Iy,Iz :: MAT{REAL}*
!     QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,Px,Py,Pz :: REAL
!     zeta,eta,xx,ab_cc,cd_cc,rho,zinv,rho_zinv :: REAL
!     wt,t2,t2_rz,t2_re,half_zinv,ce :: REAL
!     Ix21,Iy21,Iz21 :: REAL
!     Ix31,Iy31,Iz31 :: REAL
!     v11,v21,v31,v41,v51,v61 :: REAL
!     n_roots,dim1,dim2 :: INT
!     n,i,j,k,n_sum :: INT
!     rys :: RYS*
!
!     dim1 = .ab_l_sum + 1
!     dim2 = .cd_l_sum + 1
!     n_roots = (dim1+dim2)/2
!     n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
!     Ixa.create(n_sum,dim1,dim2)
!     Iya.create(n_sum,dim1,dim2)
!     Iza.create(n_sum,dim1,dim2)
!
!     rys.create(n_roots)
!
!     i = 0
!     do k = 1,.ab_n_gaussian_pairs
!         ab_cc = .ab_contraction_prefactor(k)
!         zeta = .ab_exponent_sum(k)
!         zinv = .ab_exponent_inv(k)
!         half_zinv = HALF * zinv
!         ab_cc = ab_cc * TWOPI5ON2
!         Px = .ab_pair_center(1,k)
!         Py = .ab_pair_center(2,k)
!         Pz = .ab_pair_center(3,k)
!         PAx = .ab_center_diff(1,k)
!         PAy = .ab_center_diff(2,k)
!         PAz = .ab_center_diff(3,k)
!         do j = 1,.cd_n_gaussian_pairs
!             cd_cc = .cd_contraction_prefactor(j)
!             eta  = .cd_exponent_sum(j)
!             Qx = .cd_pair_center(1,j)
!             Qy = .cd_pair_center(2,j)
!             Qz = .cd_pair_center(3,j)
!             rho  = zeta * eta / (zeta + eta)
!             rho_zinv = rho * zinv
!             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
!             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
!             rys.get_weights(xx)
!             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
!             ! Now make the 2 dimensional integrals.
!             do n = 1,n_roots
!               i = i + 1
!               Ix => Ixa(i,:,:)
!               Iy => Iya(i,:,:)
!               Iz => Iza(i,:,:)
!               t2      = rys.root(n)
!               wt      = rys.weight(n)
!               ! Ix(1,1) = ONE
!               ! Iy(1,1) = ONE
!               Iz(1,1) = wt
!                 t2_rz = t2 * rho_zinv
!                 Ix21 = PAx + t2_rz*QPx; Ix(2,1) = Ix21
!                 Iy21 = PAy + t2_rz*QPy; Iy(2,1) = Iy21
!                 Iz21 = PAz + t2_rz*QPz; Iz(2,1) = Iz21*wt
!                 ce  = (ONE - t2_rz) * half_zinv
!                 Ix31 = Ix21*Ix21 + ce; Ix(3,1) = Ix31
!                 Iy31 = Iy21*Iy21 + ce; Iy(3,1) = Iy31
!                 Iz31 = Iz21*Iz21 + ce; Iz(3,1) = Iz31*wt
!             end
!         end     ! -- loops over c,d
!     end         ! -- loops over a,b
!
!     rys.destroy
!
!     .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
!
!     Iza.destroy
!     Iya.destroy
!     Ixa.destroy
!   end

   make_esfs_sd_ssds(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: VEC{REAL}(.n_cd), OUT

      QPx,QPy,QPz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,einv,rho_einv :: REAL
      wt,t2,t2_re,half_einv,cf :: REAL
      Ix12,Iy12,Iz12 :: REAL
      Ix13,Iy13,Iz13 :: REAL
      v11,v12,v13,v14,v15,v16 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 2
      rys.create(n_roots)

      esfs = ZERO

      v11 = ZERO; v12 = ZERO; v13 = ZERO
      v14 = ZERO; v15 = ZERO; v16 = ZERO

      parallel do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               cf  = (ONE - t2_re) * half_einv
               Ix13 = Ix12*Ix12 + cf
               Iy13 = Iy12*Iy12 + cf
               Iz13 = Iz12*Iz12 + cf

               Iz12 = Iz12*wt
               Iz13 = Iz13*wt

               v11 = v11 + Ix13*wt
               v12 = v12 + Iy13*wt
               v13 = v13 + Iz13
               v14 = v14 + Ix12*Iy12*wt
               v15 = v15 + Ix12*Iz12
               v16 = v16 + Iy12*Iz12

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1) = v11
      esfs(2) = v12
      esfs(3) = v13
      esfs(4) = v14
      esfs(5) = v15
      esfs(6) = v16

      PARALLEL_SUM(esfs)

   end

   make_esfs_sd_sspp(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: VEC{REAL}(.n_cd), OUT

      QPx,QPy,QPz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,einv,rho_einv :: REAL
      wt,t2,t2_re,half_einv,cf :: REAL
      Ix12,Iy12,Iz12 :: REAL
      Ix13,Iy13,Iz13 :: REAL
      v11,v18,v12,v19,v13,v16,v14,v15,v17,Iy12_wt :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 2
      rys.create(n_roots)

      esfs = ZERO

      v11 = ZERO; v18 = ZERO; v12 = ZERO
      v19 = ZERO; v13 = ZERO; v16 = ZERO
      v14 = ZERO; v15 = ZERO; v17 = ZERO

      parallel do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               cf  = (ONE - t2_re) * half_einv
               Ix13 = Ix12*Ix12 + cf
               Iy13 = Iy12*Iy12 + cf
               Iz13 = Iz12*Iz12 + cf

               Iz12 = Iz12*wt
               Iz13 = Iz13*wt

               Iy12_wt = Iy12*wt

               v11 = v11 + Ix12*wt
               v18 = v18 + Ix12*Iz12
               v12 = v12 + Iy12_wt
               v19 = v19 + Iy12*Iz12
               v13 = v13 + Iz12
               v16 = v16 + Iz13
               v14 = v14 + Ix13*wt
               v15 = v15 + Iy13*wt
               v17 = v17 + Ix12*Iy12_wt

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1) = v11
      esfs(8) = v18
      esfs(2) = v12
      esfs(9) = v19
      esfs(3) = v13
      esfs(6) = v16
      esfs(4) = v14
      esfs(5) = v15
      esfs(7) = v17

      PARALLEL_SUM(esfs)

   end

!   make_esfs_sd(esfs) ::: private
!   ! Makes the initial (es|fs) integrals, summed over the primitives
!     self :: IN
!     esfs :: MAT{REAL}, OUT
!     Ixa,Iya,Iza :: MAT3{REAL}*
!     Ix,Iy,Iz :: MAT{REAL}*
!     QPx,QPy,QPz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
!     zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_einv :: REAL
!     wt,t2,t2_re,half_einv,cf :: REAL
!     Ix12,Iy12,Iz12 :: REAL
!     Ix13,Iy13,Iz13 :: REAL
!     n_roots,dim1,dim2 :: INT
!     n,i,j,k,n_sum :: INT
!     rys :: RYS*
!
!     dim1 = .ab_l_sum + 1
!     dim2 = .cd_l_sum + 1
!     n_roots = (dim1+dim2)/2
!     n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
!     Ixa.create(n_sum,dim1,dim2)
!     Iya.create(n_sum,dim1,dim2)
!     Iza.create(n_sum,dim1,dim2)
!
!     rys.create(n_roots)
!
!     i = 0
!     do k = 1,.ab_n_gaussian_pairs
!         ab_cc = .ab_contraction_prefactor(k)
!         zeta = .ab_exponent_sum(k)
!         ab_cc = ab_cc * TWOPI5ON2
!         Px = .ab_pair_center(1,k)
!         Py = .ab_pair_center(2,k)
!         Pz = .ab_pair_center(3,k)
!         do j = 1,.cd_n_gaussian_pairs
!             cd_cc = .cd_contraction_prefactor(j)
!             eta  = .cd_exponent_sum(j)
!             einv = .cd_exponent_inv(j)
!             Qx = .cd_pair_center(1,j)
!             Qy = .cd_pair_center(2,j)
!             Qz = .cd_pair_center(3,j)
!             QCx = .cd_center_diff(1,j)
!             QCy = .cd_center_diff(2,j)
!             QCz = .cd_center_diff(3,j)
!             rho  = zeta * eta / (zeta + eta)
!             rho_einv = rho * einv
!             half_einv = HALF * einv
!             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
!             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
!             rys.get_weights(xx)
!             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
!             ! Now make the 2 dimensional integrals.
!             do n = 1,n_roots
!               i = i + 1
!               Ix => Ixa(i,:,:)
!               Iy => Iya(i,:,:)
!               Iz => Iza(i,:,:)
!               t2      = rys.root(n)
!               wt      = rys.weight(n)
!               ! Ix(1,1) = ONE
!               ! Iy(1,1) = ONE
!               Iz(1,1) = wt
!               t2_re = t2 * rho_einv
!               Ix12 = QCx - t2_re*QPx; Ix(1,2) = Ix12
!               Iy12 = QCy - t2_re*QPy; Iy(1,2) = Iy12
!               Iz12 = QCz - t2_re*QPz; Iz(1,2) = Iz12*wt
!               cf  = (ONE - t2_re) * half_einv
!               Ix13 = Ix12*Ix12 + cf; Ix(1,3) = Ix13
!               Iy13 = Iy12*Iy12 + cf; Iy(1,3) = Iy13
!               Iz13 = Iz12*Iz12 + cf; Iz(1,3) = Iz13*wt
!             end
!         end     ! -- loops over c,d
!     end         ! -- loops over a,b
!
!     rys.destroy
!
!     .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
!
!     Iza.destroy
!     Iya.destroy
!     Ixa.destroy
!   end

   make_esfs_dp_dsps(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      wt,t2,t2_rz,t2_re,half_zinv,half_einv,ce,bb :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21 :: REAL
      Ix22,Iy22,Iz22,Ix22_bb,Iy22_bb,Iz22_bb :: REAL
      Ix31,Iy31,Iz31,Ix32,Iy32,Iz32 :: REAL
      v11,v21,v31,v41,v51,v61,v12,v22,v32 :: REAL
      v42,v52,v62,v13,v23,v33,v43,v53,v63 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 2
      rys.create(n_roots)

      esfs = ZERO

      v11 = ZERO; v21 = ZERO; v31 = ZERO; v41 = ZERO; v51 = ZERO; v61 = ZERO
      v12 = ZERO; v22 = ZERO; v32 = ZERO; v42 = ZERO; v52 = ZERO; v62 = ZERO
      v13 = ZERO; v23 = ZERO; v33 = ZERO; v43 = ZERO; v53 = ZERO; v63 = ZERO

      parallel do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             half_einv = HALF * einv
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               ce  = (ONE - t2_rz) * half_zinv
               Ix31 = Ix21*Ix21 + ce
               Iy31 = Iy21*Iy21 + ce
               Iz31 = Iz21*Iz21 + ce

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               bb = t2_rz * half_einv
               Ix22 = Ix12*Ix21 + bb
               Iy22 = Iy12*Iy21 + bb
               Iz22 = Iz12*Iz21 + bb

               Ix22_bb = Ix22 + bb
               Iy22_bb = Iy22 + bb
               Iz22_bb = Iz22 + bb

               Ix32 = Ix21*Ix22_bb + ce*Ix12
               Iy32 = Iy21*Iy22_bb + ce*Iy12
               Iz32 = Iz21*Iz22_bb + ce*Iz12

               Iz21 = Iz21*wt
               Iz31 = Iz31*wt
               Iz12 = Iz12*wt
               Iz22 = Iz22*wt
               Iz32 = Iz32*wt

               v11 = v11 + Ix32*wt
               v21 = v21 + Ix12*Iy31*wt
               v31 = v31 + Ix12*Iz31
               v41 = v41 + Ix22*Iy21*wt
               v51 = v51 + Ix22*Iz21
               v61 = v61 + Ix12*Iy21*Iz21
               v12 = v12 + Ix31*Iy12*wt
               v22 = v22 + Iy32*wt
               v32 = v32 + Iy12*Iz31
               v42 = v42 + Ix21*Iy22*wt
               v52 = v52 + Ix21*Iy12*Iz21
               v62 = v62 + Iy22*Iz21
               v13 = v13 + Ix31*Iz12
               v23 = v23 + Iy31*Iz12
               v33 = v33 + Iz32
               v43 = v43 + Ix21*Iy21*Iz12
               v53 = v53 + Ix21*Iz22
               v63 = v63 + Iy21*Iz22

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(2,1) = v21
      esfs(3,1) = v31
      esfs(4,1) = v41
      esfs(5,1) = v51
      esfs(6,1) = v61
      esfs(1,2) = v12
      esfs(2,2) = v22
      esfs(3,2) = v32
      esfs(4,2) = v42
      esfs(5,2) = v52
      esfs(6,2) = v62
      esfs(1,3) = v13
      esfs(2,3) = v23
      esfs(3,3) = v33
      esfs(4,3) = v43
      esfs(5,3) = v53
      esfs(6,3) = v63

      PARALLEL_SUM(esfs)

   end

   make_esfs_dp_ppps(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      wt,t2,t2_rz,t2_re,half_zinv,half_einv,ce,bb :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21 :: REAL
      Ix22,Iy22,Iz22,Ix22_bb,Iy22_bb,Iz22_bb  :: REAL
      Ix31,Iy31,Iz31,Ix32,Iy32,Iz32, Ixy  :: REAL
      v11,v81,v21,v91,v31,v61,v41,v51,v71 :: REAL
      v12,v82,v22,v92,v32,v62,v42,v52,v72 :: REAL
      v13,v83,v23,v93,v33,v63,v43,v53,v73 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 2
      rys.create(n_roots)

      esfs = ZERO

      v11 = ZERO; v81 = ZERO; v21 = ZERO
      v91 = ZERO; v31 = ZERO; v61 = ZERO
      v41 = ZERO; v51 = ZERO; v71 = ZERO
      v12 = ZERO; v82 = ZERO; v22 = ZERO
      v92 = ZERO; v32 = ZERO; v62 = ZERO
      v42 = ZERO; v52 = ZERO; v72 = ZERO
      v13 = ZERO; v83 = ZERO; v23 = ZERO
      v93 = ZERO; v33 = ZERO; v63 = ZERO
      v43 = ZERO; v53 = ZERO; v73 = ZERO

      parallel do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             half_einv = HALF * einv
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               ce  = (ONE - t2_rz) * half_zinv
               Ix31 = Ix21*Ix21 + ce
               Iy31 = Iy21*Iy21 + ce
               Iz31 = Iz21*Iz21 + ce

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               bb = t2_rz * half_einv
               Ix22 = Ix12*Ix21 + bb
               Iy22 = Iy12*Iy21 + bb
               Iz22 = Iz12*Iz21 + bb

               Ix22_bb = Ix22 + bb
               Iy22_bb = Iy22 + bb
               Iz22_bb = Iz22 + bb

               Ix32 = Ix21*Ix22_bb + ce*Ix12
               Iy32 = Iy21*Iy22_bb + ce*Iy12
               Iz32 = Iz21*Iz22_bb + ce*Iz12

               Iz21 = Iz21*wt
               Iz31 = Iz31*wt
               Iz12 = Iz12*wt
               Iz22 = Iz22*wt
               Iz32 = Iz32*wt

               v11 = v11 + Ix22*wt
               v81 = v81 + Ix22*Iz21
               Ixy = Ix12*Iy21
               v21 = v21 + Ixy*wt
               v91 = v91 + Ixy*Iz21
               v31 = v31 + Ix12*Iz21
               v61 = v61 + Ix12*Iz31
               v41 = v41 + Ix32*wt
               v51 = v51 + Ix12*Iy31*wt
               v71 = v71 + Ix22*Iy21*wt
               Ixy = Ix21*Iy12
               v12 = v12 + Ixy*wt
               v82 = v82 + Ixy*Iz21
               v22 = v22 + Iy22*wt
               v92 = v92 + Iy22*Iz21
               v32 = v32 + Iy12*Iz21
               v62 = v62 + Iy12*Iz31
               v42 = v42 + Ix31*Iy12*wt
               v52 = v52 + Iy32*wt
               v72 = v72 + Ix21*Iy22*wt
               v13 = v13 + Ix21*Iz12
               v83 = v83 + Ix21*Iz22
               v23 = v23 + Iy21*Iz12
               v93 = v93 + Iy21*Iz22
               v33 = v33 + Iz22
               v63 = v63 + Iz32
               v43 = v43 + Ix31*Iz12
               v53 = v53 + Iy31*Iz12
               v73 = v73 + Ix21*Iy21*Iz12

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(8,1) = v81
      esfs(2,1) = v21
      esfs(9,1) = v91
      esfs(3,1) = v31
      esfs(6,1) = v61
      esfs(4,1) = v41
      esfs(5,1) = v51
      esfs(7,1) = v71
      esfs(1,2) = v12
      esfs(8,2) = v82
      esfs(2,2) = v22
      esfs(9,2) = v92
      esfs(3,2) = v32
      esfs(6,2) = v62
      esfs(4,2) = v42
      esfs(5,2) = v52
      esfs(7,2) = v72
      esfs(1,3) = v13
      esfs(8,3) = v83
      esfs(2,3) = v23
      esfs(9,3) = v93
      esfs(3,3) = v33
      esfs(6,3) = v63
      esfs(4,3) = v43
      esfs(5,3) = v53
      esfs(7,3) = v73

      PARALLEL_SUM(esfs)

   end

!   make_esfs_dp(esfs) ::: private
!   ! Makes the initial (es|fs) integrals, summed over the primitives
!     self :: IN
!     esfs :: MAT{REAL}, OUT
!     Ixa,Iya,Iza :: MAT3{REAL}*
!     Ix,Iy,Iz :: MAT{REAL}*
!     QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
!     zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
!     wt,t2,t2_rz,t2_re,half_zinv,half_einv,ce,bb :: REAL
!     Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
!     Ix31,Iy31,Iz31,Ix32,Iy32,Iz32 :: REAL
!     n_roots,dim1,dim2 :: INT
!     n,i,j,k,n_sum :: INT
!     rys :: RYS*
!
!     dim1 = .ab_l_sum + 1
!     dim2 = .cd_l_sum + 1
!     n_roots = (dim1+dim2)/2
!     n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
!     Ixa.create(n_sum,dim1,dim2)
!     Iya.create(n_sum,dim1,dim2)
!     Iza.create(n_sum,dim1,dim2)
!
!     rys.create(n_roots)
!
!     i = 0
!     do k = 1,.ab_n_gaussian_pairs
!         ab_cc = .ab_contraction_prefactor(k)
!         zeta = .ab_exponent_sum(k)
!         zinv = .ab_exponent_inv(k)
!         half_zinv = HALF * zinv
!         ab_cc = ab_cc * TWOPI5ON2
!         Px = .ab_pair_center(1,k)
!         Py = .ab_pair_center(2,k)
!         Pz = .ab_pair_center(3,k)
!         PAx = .ab_center_diff(1,k)
!         PAy = .ab_center_diff(2,k)
!         PAz = .ab_center_diff(3,k)
!         do j = 1,.cd_n_gaussian_pairs
!             cd_cc = .cd_contraction_prefactor(j)
!             eta  = .cd_exponent_sum(j)
!             einv = .cd_exponent_inv(j)
!             half_einv = HALF * einv
!             Qx = .cd_pair_center(1,j)
!             Qy = .cd_pair_center(2,j)
!             Qz = .cd_pair_center(3,j)
!             QCx = .cd_center_diff(1,j)
!             QCy = .cd_center_diff(2,j)
!             QCz = .cd_center_diff(3,j)
!             rho  = zeta * eta / (zeta + eta)
!             rho_zinv = rho * zinv
!             rho_einv = rho * einv
!             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
!             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
!             rys.get_weights(xx)
!             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
!             ! Now make the 2 dimensional integrals.
!             do n = 1,n_roots
!               i = i + 1
!               Ix => Ixa(i,:,:)
!               Iy => Iya(i,:,:)
!               Iz => Iza(i,:,:)
!               t2      = rys.root(n)
!               wt      = rys.weight(n)
!               Ix(1,1) = ONE
!               Iy(1,1) = ONE
!               Iz(1,1) = wt
!               t2_rz = t2 * rho_zinv
!               Ix21 = PAx + t2_rz*QPx; Ix(2,1) = Ix21
!               Iy21 = PAy + t2_rz*QPy; Iy(2,1) = Iy21
!               Iz21 = PAz + t2_rz*QPz; Iz(2,1) = Iz21*wt
!               ce  = (ONE - t2_rz) * half_zinv
!               Ix31 = Ix21*Ix21 + ce; Ix(3,1) = Ix31
!               Iy31 = Iy21*Iy21 + ce; Iy(3,1) = Iy31
!               Iz31 = Iz21*Iz21 + ce; Iz(3,1) = Iz31*wt
!               t2_re = t2 * rho_einv
!               Ix12 = QCx - t2_re*QPx; Ix(1,2) = Ix12
!               Iy12 = QCy - t2_re*QPy; Iy(1,2) = Iy12
!               Iz12 = QCz - t2_re*QPz; Iz(1,2) = Iz12*wt
!               bb = t2_rz * half_einv
!               Ix22 = Ix12*Ix21 + bb; Ix(2,2) = Ix22
!               Iy22 = Iy12*Iy21 + bb; Iy(2,2) = Iy22
!               Iz22 = Iz12*Iz21 + bb; Iz(2,2) = Iz22*wt
!               Ix32 = Ix21*Ix22 + ce*Ix12 + bb*Ix21; Ix(3,2) = Ix32
!               Iy32 = Iy21*Iy22 + ce*Iy12 + bb*Iy21; Iy(3,2) = Iy32
!               Iz32 = Iz21*Iz22 + ce*Iz12 + bb*Iz21; Iz(3,2) = Iz32*wt
!             end
!         end     ! -- loops over c,d
!     end         ! -- loops over a,b
!
!     rys.destroy
!
!     .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
!
!     Iza.destroy
!     Iya.destroy
!     Ixa.destroy
!   end

   make_esfs_pd_psds(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      wt,t2,t2_rz,t2_re,half_einv,cf,bb :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21 :: REAL
      Ix22,Iy22,Iz22,Ix22_bb,Iy22_bb,Iz22_bb :: REAL
      Ix13,Iy13,Iz13,Ix23,Iy23,Iz23 :: REAL
      v11,v21,v31,v12,v22,v32,v13,v23,v33 :: REAL
      v14,v24,v34,v15,v25,v35,v16,v26,v36 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 2
      rys.create(n_roots)

      esfs = ZERO

      v11 = ZERO; v21 = ZERO; v31 = ZERO; v12 = ZERO; v22 = ZERO; v32 = ZERO
      v13 = ZERO; v23 = ZERO; v33 = ZERO; v14 = ZERO; v24 = ZERO; v34 = ZERO
      v15 = ZERO; v25 = ZERO; v35 = ZERO; v16 = ZERO; v26 = ZERO; v36 = ZERO

      parallel do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               cf  = (ONE - t2_re) * half_einv
               Ix13 = Ix12*Ix12 + cf
               Iy13 = Iy12*Iy12 + cf
               Iz13 = Iz12*Iz12 + cf

               bb = t2_rz * half_einv
               Ix22 = Ix12*Ix21 + bb
               Iy22 = Iy12*Iy21 + bb
               Iz22 = Iz12*Iz21 + bb

               Ix22_bb = Ix22 + bb
               Iy22_bb = Iy22 + bb
               Iz22_bb = Iz22 + bb

               Ix23 = Ix12*Ix22_bb + cf*Ix21
               Iy23 = Iy12*Iy22_bb + cf*Iy21
               Iz23 = Iz12*Iz22_bb + cf*Iz21

               Iz21 = Iz21*wt
               Iz12 = Iz12*wt
               Iz13 = Iz13*wt
               Iz22 = Iz22*wt
               Iz23 = Iz23*wt

               v11 = v11 + Ix23*wt
               v21 = v21 + Ix13*Iy21*wt
               v31 = v31 + Ix13*Iz21
               v12 = v12 + Ix21*Iy13*wt
               v22 = v22 + Iy23*wt
               v32 = v32 + Iy13*Iz21
               v13 = v13 + Ix21*Iz13
               v23 = v23 + Iy21*Iz13
               v33 = v33 + Iz23
               v14 = v14 + Ix22*Iy12*wt
               v24 = v24 + Ix12*Iy22*wt
               v34 = v34 + Ix12*Iy12*Iz21
               v15 = v15 + Ix22*Iz12
               v25 = v25 + Ix12*Iy21*Iz12
               v35 = v35 + Ix12*Iz22
               v16 = v16 + Ix21*Iy12*Iz12
               v26 = v26 + Iy22*Iz12
               v36 = v36 + Iy12*Iz22

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(2,1) = v21
      esfs(3,1) = v31
      esfs(1,2) = v12
      esfs(2,2) = v22
      esfs(3,2) = v32
      esfs(1,3) = v13
      esfs(2,3) = v23
      esfs(3,3) = v33
      esfs(1,4) = v14
      esfs(2,4) = v24
      esfs(3,4) = v34
      esfs(1,5) = v15
      esfs(2,5) = v25
      esfs(3,5) = v35
      esfs(1,6) = v16
      esfs(2,6) = v26
      esfs(3,6) = v36

      PARALLEL_SUM(esfs)

   end

   make_esfs_pd_pspp(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      wt,t2,t2_rz,t2_re,half_einv,cf,bb :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21 :: REAL
      Ix22,Iy22,Iz22,Ix22_bb,Iy22_bb,Iz22_bb :: REAL
      Ix13,Iy13,Iz13,Ix23,Iy23,Iz23, Ixy  :: REAL
      v11,v18,v21,v28,v31,v38,v12,v19,v22 :: REAL
      v29,v32,v39,v13,v16,v23,v26,v33,v36 :: REAL
      v14,v24,v34,v15,v25,v35,v17,v27,v37 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 2
      rys.create(n_roots)

      esfs = ZERO

      v11 = ZERO; v18 = ZERO; v21 = ZERO
      v28 = ZERO; v31 = ZERO; v38 = ZERO
      v12 = ZERO; v19 = ZERO; v22 = ZERO
      v29 = ZERO; v32 = ZERO; v39 = ZERO
      v13 = ZERO; v16 = ZERO; v23 = ZERO
      v26 = ZERO; v33 = ZERO; v36 = ZERO
      v14 = ZERO; v24 = ZERO; v34 = ZERO
      v15 = ZERO; v25 = ZERO; v35 = ZERO
      v17 = ZERO; v27 = ZERO; v37 = ZERO

      parallel do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               cf  = (ONE - t2_re) * half_einv
               Ix13 = Ix12*Ix12 + cf
               Iy13 = Iy12*Iy12 + cf
               Iz13 = Iz12*Iz12 + cf

               bb = t2_rz * half_einv
               Ix22 = Ix12*Ix21 + bb
               Iy22 = Iy12*Iy21 + bb
               Iz22 = Iz12*Iz21 + bb

               Ix22_bb = Ix22 + bb
               Iy22_bb = Iy22 + bb
               Iz22_bb = Iz22 + bb

               Ix23 = Ix12*Ix22_bb + cf*Ix21
               Iy23 = Iy12*Iy22_bb + cf*Iy21
               Iz23 = Iz12*Iz22_bb + cf*Iz21

               Iz21 = Iz21*wt
               Iz12 = Iz12*wt
               Iz13 = Iz13*wt
               Iz22 = Iz22*wt
               Iz23 = Iz23*wt

               v11 = v11 + Ix22*wt
               v18 = v18 + Ix22*Iz12
               Ixy = Ix12*Iy21
               v21 = v21 + Ixy*wt
               v28 = v28 + Ixy*Iz12
               v31 = v31 + Ix12*Iz21
               v38 = v38 + Ix12*Iz22
               Ixy = Ix21*Iy12
               v12 = v12 + Ixy*wt
               v19 = v19 + Ixy*Iz12
               v22 = v22 + Iy22*wt
               v29 = v29 + Iy22*Iz12
               v32 = v32 + Iy12*Iz21
               v39 = v39 + Iy12*Iz22
               v13 = v13 + Ix21*Iz12
               v16 = v16 + Ix21*Iz13
               v23 = v23 + Iy21*Iz12
               v26 = v26 + Iy21*Iz13
               v33 = v33 + Iz22
               v36 = v36 + Iz23
               v14 = v14 + Ix23*wt
               v24 = v24 + Ix13*Iy21*wt
               v34 = v34 + Ix13*Iz21
               v15 = v15 + Ix21*Iy13*wt
               v25 = v25 + Iy23*wt
               v35 = v35 + Iy13*Iz21
               v17 = v17 + Ix22*Iy12*wt
               v27 = v27 + Ix12*Iy22*wt
               v37 = v37 + Ix12*Iy12*Iz21

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(1,8) = v18
      esfs(2,1) = v21
      esfs(2,8) = v28
      esfs(3,1) = v31
      esfs(3,8) = v38
      esfs(1,2) = v12
      esfs(1,9) = v19
      esfs(2,2) = v22
      esfs(2,9) = v29
      esfs(3,2) = v32
      esfs(3,9) = v39
      esfs(1,3) = v13
      esfs(1,6) = v16
      esfs(2,3) = v23
      esfs(2,6) = v26
      esfs(3,3) = v33
      esfs(3,6) = v36
      esfs(1,4) = v14
      esfs(2,4) = v24
      esfs(3,4) = v34
      esfs(1,5) = v15
      esfs(2,5) = v25
      esfs(3,5) = v35
      esfs(1,7) = v17
      esfs(2,7) = v27
      esfs(3,7) = v37

      PARALLEL_SUM(esfs)

   end

!   make_esfs_pd(esfs) ::: private
!   ! Makes the initial (es|fs) integrals, summed over the primitives
!     self :: IN
!     esfs :: MAT{REAL}, OUT
!     Ixa,Iya,Iza :: MAT3{REAL}*
!     Ix,Iy,Iz :: MAT{REAL}*
!     QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
!     zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
!     wt,t2,t2_rz,t2_re,half_einv,cf,bb :: REAL
!     Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
!     Ix13,Iy13,Iz13,Ix23,Iy23,Iz23 :: REAL
!     n_roots,dim1,dim2 :: INT
!     n,i,j,k,n_sum :: INT
!     rys :: RYS*
!
!     dim1 = .ab_l_sum + 1
!     dim2 = .cd_l_sum + 1
!     n_roots = (dim1+dim2)/2
!     n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
!     Ixa.create(n_sum,dim1,dim2)
!     Iya.create(n_sum,dim1,dim2)
!     Iza.create(n_sum,dim1,dim2)
!
!     rys.create(n_roots)
!
!     i = 0
!     do k = 1,.ab_n_gaussian_pairs
!         ab_cc = .ab_contraction_prefactor(k)
!         zeta = .ab_exponent_sum(k)
!         zinv = .ab_exponent_inv(k)
!         ab_cc = ab_cc * TWOPI5ON2
!         Px = .ab_pair_center(1,k)
!         Py = .ab_pair_center(2,k)
!         Pz = .ab_pair_center(3,k)
!         PAx = .ab_center_diff(1,k)
!         PAy = .ab_center_diff(2,k)
!         PAz = .ab_center_diff(3,k)
!         do j = 1,.cd_n_gaussian_pairs
!             cd_cc = .cd_contraction_prefactor(j)
!             eta  = .cd_exponent_sum(j)
!             einv = .cd_exponent_inv(j)
!             Qx = .cd_pair_center(1,j)
!             Qy = .cd_pair_center(2,j)
!             Qz = .cd_pair_center(3,j)
!             QCx = .cd_center_diff(1,j)
!             QCy = .cd_center_diff(2,j)
!             QCz = .cd_center_diff(3,j)
!             rho  = zeta * eta / (zeta + eta)
!             rho_zinv = rho * zinv
!             rho_einv = rho * einv
!             half_einv = HALF * einv
!             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
!             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
!             rys.get_weights(xx)
!             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
!             ! Now make the 2 dimensional integrals.
!             do n = 1,n_roots
!               i = i + 1
!               Ix => Ixa(i,:,:)
!               Iy => Iya(i,:,:)
!               Iz => Iza(i,:,:)
!               t2      = rys.root(n)
!               wt      = rys.weight(n)
!               Ix(1,1) = ONE
!               Iy(1,1) = ONE
!               Iz(1,1) = wt
!               t2_rz = t2 * rho_zinv
!               Ix21 = PAx + t2_rz*QPx; Ix(2,1) = Ix21
!               Iy21 = PAy + t2_rz*QPy; Iy(2,1) = Iy21
!               Iz21 = PAz + t2_rz*QPz; Iz(2,1) = Iz21*wt
!               t2_re = t2 * rho_einv
!               Ix12 = QCx - t2_re*QPx; Ix(1,2) = Ix12
!               Iy12 = QCy - t2_re*QPy; Iy(1,2) = Iy12
!               Iz12 = QCz - t2_re*QPz; Iz(1,2) = Iz12*wt
!               cf  = (ONE - t2_re) * half_einv
!               Ix13 = Ix12*Ix12 + cf; Ix(1,3) = Ix13
!               Iy13 = Iy12*Iy12 + cf; Iy(1,3) = Iy13
!               Iz13 = Iz12*Iz12 + cf; Iz(1,3) = Iz13*wt
!               bb = t2_rz * half_einv
!               Ix22 = Ix12*Ix21 + bb; Ix(2,2) = Ix22
!               Iy22 = Iy12*Iy21 + bb; Iy(2,2) = Iy22
!               Iz22 = Iz12*Iz21 + bb; Iz(2,2) = Iz22*wt
!               Ix23 = Ix12*Ix22 + cf*Ix21 + bb*Ix12; Ix(2,3) = Ix23
!               Iy23 = Iy12*Iy22 + cf*Iy21 + bb*Iy12; Iy(2,3) = Iy23
!               Iz23 = Iz12*Iz22 + cf*Iz21 + bb*Iz12; Iz(2,3) = Iz23*wt
!             end
!         end     ! -- loops over c,d
!     end         ! -- loops over a,b
!
!     rys.destroy
!
!     .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
!
!     Iza.destroy
!     Iya.destroy
!     Ixa.destroy
!   end

   make_esfs_dd_dsds(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      wt,t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
      ce,cf,bb :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
      Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
      Ix33,Iy33,Iz33,Ix22_bb,Iy22_bb,Iz22_bb :: REAL
      v11,v21,v31,v41,v51,v61,v12,v22,v32 :: REAL
      v42,v52,v62,v13,v23,v33,v43,v53,v63 :: REAL
      v14,v24,v34,v44,v54,v64,v15,v25,v35 :: REAL
      v45,v55,v65,v16,v26,v36,v46,v56,v66 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 3
      rys.create(n_roots)

      esfs = ZERO

      v11 = ZERO; v21 = ZERO; v31 = ZERO; v41 = ZERO; v51 = ZERO; v61 = ZERO
      v12 = ZERO; v22 = ZERO; v32 = ZERO; v42 = ZERO; v52 = ZERO; v62 = ZERO
      v13 = ZERO; v23 = ZERO; v33 = ZERO; v43 = ZERO; v53 = ZERO; v63 = ZERO
      v14 = ZERO; v24 = ZERO; v34 = ZERO; v44 = ZERO; v54 = ZERO; v64 = ZERO
      v15 = ZERO; v25 = ZERO; v35 = ZERO; v45 = ZERO; v55 = ZERO; v65 = ZERO
      v16 = ZERO; v26 = ZERO; v36 = ZERO; v46 = ZERO; v56 = ZERO; v66 = ZERO

      parallel do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             half_einv = HALF * einv
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               ce  = (ONE - t2_rz) * half_zinv
               Ix31 = Ix21*Ix21 + ce
               Iy31 = Iy21*Iy21 + ce
               Iz31 = Iz21*Iz21 + ce

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               cf  = (ONE - t2_re) * half_einv
               Ix13 = Ix12*Ix12 + cf
               Iy13 = Iy12*Iy12 + cf
               Iz13 = Iz12*Iz12 + cf

               bb = t2_rz * half_einv
               Ix22 = Ix12*Ix21 + bb
               Iy22 = Iy12*Iy21 + bb
               Iz22 = Iz12*Iz21 + bb

               Ix22_bb = Ix22 + bb
               Iy22_bb = Iy22 + bb
               Iz22_bb = Iz22 + bb

               Ix23 = Ix12*Ix22_bb + cf*Ix21
               Iy23 = Iy12*Iy22_bb + cf*Iy21
               Iz23 = Iz12*Iz22_bb + cf*Iz21

               Ix32 = Ix21*Ix22_bb + ce*Ix12
               Iy32 = Iy21*Iy22_bb + ce*Iy12
               Iz32 = Iz21*Iz22_bb + ce*Iz12

               f1_bb = bb + bb
               Ix33 = Ix21*Ix23 + ce*Ix13 + f1_bb*Ix22
               Iy33 = Iy21*Iy23 + ce*Iy13 + f1_bb*Iy22
               Iz33 = Iz21*Iz23 + ce*Iz13 + f1_bb*Iz22

               Iz21 = Iz21*wt
               Iz31 = Iz31*wt
               Iz12 = Iz12*wt
               Iz13 = Iz13*wt
               Iz22 = Iz22*wt
               Iz23 = Iz23*wt
               Iz32 = Iz32*wt
               Iz33 = Iz33*wt

               v11 = v11 + Ix33*wt
               v21 = v21 + Ix13*Iy31*wt
               v31 = v31 + Ix13*Iz31
               v41 = v41 + Ix23*Iy21*wt
               v51 = v51 + Ix23*Iz21
               v61 = v61 + Ix13*Iy21*Iz21
               v12 = v12 + Ix31*Iy13*wt
               v22 = v22 + Iy33*wt
               v32 = v32 + Iy13*Iz31
               v42 = v42 + Ix21*Iy23*wt
               v52 = v52 + Ix21*Iy13*Iz21
               v62 = v62 + Iy23*Iz21
               v13 = v13 + Ix31*Iz13
               v23 = v23 + Iy31*Iz13
               v33 = v33 + Iz33
               v43 = v43 + Ix21*Iy21*Iz13
               v53 = v53 + Ix21*Iz23
               v63 = v63 + Iy21*Iz23
               v14 = v14 + Ix32*Iy12*wt
               v24 = v24 + Ix12*Iy32*wt
               v34 = v34 + Ix12*Iy12*Iz31
               v44 = v44 + Ix22*Iy22*wt
               v54 = v54 + Ix22*Iy12*Iz21
               v64 = v64 + Ix12*Iy22*Iz21
               v15 = v15 + Ix32*Iz12
               v25 = v25 + Ix12*Iy31*Iz12
               v35 = v35 + Ix12*Iz32
               v45 = v45 + Ix22*Iy21*Iz12
               v55 = v55 + Ix22*Iz22
               v65 = v65 + Ix12*Iy21*Iz22
               v16 = v16 + Ix31*Iy12*Iz12
               v26 = v26 + Iy32*Iz12
               v36 = v36 + Iy12*Iz32
               v46 = v46 + Ix21*Iy22*Iz12
               v56 = v56 + Ix21*Iy12*Iz22
               v66 = v66 + Iy22*Iz22

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(2,1) = v21
      esfs(3,1) = v31
      esfs(4,1) = v41
      esfs(5,1) = v51
      esfs(6,1) = v61
      esfs(1,2) = v12
      esfs(2,2) = v22
      esfs(3,2) = v32
      esfs(4,2) = v42
      esfs(5,2) = v52
      esfs(6,2) = v62
      esfs(1,3) = v13
      esfs(2,3) = v23
      esfs(3,3) = v33
      esfs(4,3) = v43
      esfs(5,3) = v53
      esfs(6,3) = v63
      esfs(1,4) = v14
      esfs(2,4) = v24
      esfs(3,4) = v34
      esfs(4,4) = v44
      esfs(5,4) = v54
      esfs(6,4) = v64
      esfs(1,5) = v15
      esfs(2,5) = v25
      esfs(3,5) = v35
      esfs(4,5) = v45
      esfs(5,5) = v55
      esfs(6,5) = v65
      esfs(1,6) = v16
      esfs(2,6) = v26
      esfs(3,6) = v36
      esfs(4,6) = v46
      esfs(5,6) = v56
      esfs(6,6) = v66

      PARALLEL_SUM(esfs)

   end

   make_esfs_dd_dspp(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      wt,t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
      ce,cf,bb :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
      Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
      Ix33,Iy33,Iz33,Ix22_bb,Iy22_bb,Iz22_bb, Ixy :: REAL
      v11,v18,v21,v28,v31,v38 :: REAL
      v41,v48,v51,v58,v61,v68 :: REAL
      v12,v19,v22,v29,v32,v39 :: REAL
      v42,v49,v52,v59,v62,v69 :: REAL
      v13,v16,v23,v26,v33,v36 :: REAL
      v43,v46,v53,v56,v63,v66 :: REAL
      v14,v24,v34,v44,v54,v64 :: REAL
      v15,v25,v35,v45,v55,v65 :: REAL
      v17,v27,v37,v47,v57,v67 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 3
      rys.create(n_roots)

      esfs = ZERO

      v11 = ZERO; v18 = ZERO; v21 = ZERO; v28 = ZERO; v31 = ZERO; v38 = ZERO
      v41 = ZERO; v48 = ZERO; v51 = ZERO; v58 = ZERO; v61 = ZERO; v68 = ZERO
      v12 = ZERO; v19 = ZERO; v22 = ZERO; v29 = ZERO; v32 = ZERO; v39 = ZERO
      v42 = ZERO; v49 = ZERO; v52 = ZERO; v59 = ZERO; v62 = ZERO; v69 = ZERO
      v13 = ZERO; v16 = ZERO; v23 = ZERO; v26 = ZERO; v33 = ZERO; v36 = ZERO
      v43 = ZERO; v46 = ZERO; v53 = ZERO; v56 = ZERO; v63 = ZERO; v66 = ZERO
      v14 = ZERO; v24 = ZERO; v34 = ZERO; v44 = ZERO; v54 = ZERO; v64 = ZERO
      v15 = ZERO; v25 = ZERO; v35 = ZERO; v45 = ZERO; v55 = ZERO; v65 = ZERO
      v17 = ZERO; v27 = ZERO; v37 = ZERO; v47 = ZERO; v57 = ZERO; v67 = ZERO

      parallel do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             half_einv = HALF * einv
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               ce  = (ONE - t2_rz) * half_zinv
               Ix31 = Ix21*Ix21 + ce
               Iy31 = Iy21*Iy21 + ce
               Iz31 = Iz21*Iz21 + ce

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               cf  = (ONE - t2_re) * half_einv
               Ix13 = Ix12*Ix12 + cf
               Iy13 = Iy12*Iy12 + cf
               Iz13 = Iz12*Iz12 + cf

               bb = t2_rz * half_einv
               Ix22 = Ix12*Ix21 + bb
               Iy22 = Iy12*Iy21 + bb
               Iz22 = Iz12*Iz21 + bb

               Ix22_bb = Ix22 + bb
               Iy22_bb = Iy22 + bb
               Iz22_bb = Iz22 + bb

               Ix23 = Ix12*Ix22_bb + cf*Ix21
               Iy23 = Iy12*Iy22_bb + cf*Iy21
               Iz23 = Iz12*Iz22_bb + cf*Iz21

               Ix32 = Ix21*Ix22_bb + ce*Ix12
               Iy32 = Iy21*Iy22_bb + ce*Iy12
               Iz32 = Iz21*Iz22_bb + ce*Iz12

               f1_bb = bb + bb
               Ix33 = Ix21*Ix23 + ce*Ix13 + f1_bb*Ix22
               Iy33 = Iy21*Iy23 + ce*Iy13 + f1_bb*Iy22
               Iz33 = Iz21*Iz23 + ce*Iz13 + f1_bb*Iz22

               Iz21 = Iz21*wt
               Iz31 = Iz31*wt
               Iz12 = Iz12*wt
               Iz13 = Iz13*wt
               Iz22 = Iz22*wt
               Iz23 = Iz23*wt
               Iz32 = Iz32*wt
               Iz33 = Iz33*wt

               v11 = v11 + Ix32*wt
               v18 = v18 + Ix32*Iz12
               Ixy = Ix12*Iy31
               v21 = v21 + Ixy*wt
               v28 = v28 + Ixy*Iz12
               v31 = v31 + Ix12*Iz31
               v38 = v38 + Ix12*Iz32
               Ixy = Ix22*Iy21
               v41 = v41 + Ixy*wt
               v48 = v48 + Ixy*Iz12
               v51 = v51 + Ix22*Iz21
               v58 = v58 + Ix22*Iz22
               Ixy = Ix12*Iy21
               v61 = v61 + Ixy*Iz21
               v68 = v68 + Ixy*Iz22
               Ixy = Ix31*Iy12
               v12 = v12 + Ixy*wt
               v19 = v19 + Ixy*Iz12
               v22 = v22 + Iy32*wt
               v29 = v29 + Iy32*Iz12
               v32 = v32 + Iy12*Iz31
               v39 = v39 + Iy12*Iz32
               Ixy = Ix21*Iy22
               v42 = v42 + Ixy*wt
               v49 = v49 + Ixy*Iz12
               Ixy = Ix21*Iy12
               v52 = v52 + Ixy*Iz21
               v59 = v59 + Ixy*Iz22
               v62 = v62 + Iy22*Iz21
               v69 = v69 + Iy22*Iz22
               v13 = v13 + Ix31*Iz12
               v16 = v16 + Ix31*Iz13
               v23 = v23 + Iy31*Iz12
               v26 = v26 + Iy31*Iz13
               v33 = v33 + Iz32
               v36 = v36 + Iz33
               Ixy = Ix21*Iy21
               v43 = v43 + Ixy*Iz12
               v46 = v46 + Ixy*Iz13
               v53 = v53 + Ix21*Iz22
               v56 = v56 + Ix21*Iz23
               v63 = v63 + Iy21*Iz22
               v66 = v66 + Iy21*Iz23
               v14 = v14 + Ix33*wt
               v24 = v24 + Ix13*Iy31*wt
               v34 = v34 + Ix13*Iz31
               v44 = v44 + Ix23*Iy21*wt
               v54 = v54 + Ix23*Iz21
               v64 = v64 + Ix13*Iy21*Iz21
               v15 = v15 + Ix31*Iy13*wt
               v25 = v25 + Iy33*wt
               v35 = v35 + Iy13*Iz31
               v45 = v45 + Ix21*Iy23*wt
               v55 = v55 + Ix21*Iy13*Iz21
               v65 = v65 + Iy23*Iz21
               v17 = v17 + Ix32*Iy12*wt
               v27 = v27 + Ix12*Iy32*wt
               v37 = v37 + Ix12*Iy12*Iz31
               v47 = v47 + Ix22*Iy22*wt
               v57 = v57 + Ix22*Iy12*Iz21
               v67 = v67 + Ix12*Iy22*Iz21

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(1,8) = v18
      esfs(2,1) = v21
      esfs(2,8) = v28
      esfs(3,1) = v31
      esfs(3,8) = v38
      esfs(4,1) = v41
      esfs(4,8) = v48
      esfs(5,1) = v51
      esfs(5,8) = v58
      esfs(6,1) = v61
      esfs(6,8) = v68
      esfs(1,2) = v12
      esfs(1,9) = v19
      esfs(2,2) = v22
      esfs(2,9) = v29
      esfs(3,2) = v32
      esfs(3,9) = v39
      esfs(4,2) = v42
      esfs(4,9) = v49
      esfs(5,2) = v52
      esfs(5,9) = v59
      esfs(6,2) = v62
      esfs(6,9) = v69
      esfs(1,3) = v13
      esfs(1,6) = v16
      esfs(2,3) = v23
      esfs(2,6) = v26
      esfs(3,3) = v33
      esfs(3,6) = v36
      esfs(4,3) = v43
      esfs(4,6) = v46
      esfs(5,3) = v53
      esfs(5,6) = v56
      esfs(6,3) = v63
      esfs(6,6) = v66
      esfs(1,4) = v14
      esfs(2,4) = v24
      esfs(3,4) = v34
      esfs(4,4) = v44
      esfs(5,4) = v54
      esfs(6,4) = v64
      esfs(1,5) = v15
      esfs(2,5) = v25
      esfs(3,5) = v35
      esfs(4,5) = v45
      esfs(5,5) = v55
      esfs(6,5) = v65
      esfs(1,7) = v17
      esfs(2,7) = v27
      esfs(3,7) = v37
      esfs(4,7) = v47
      esfs(5,7) = v57
      esfs(6,7) = v67

      PARALLEL_SUM(esfs)

   end

   make_esfs_dd_ppds(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      wt,t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
      ce,cf,bb :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
      Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
      Ix33,Iy33,Iz33,Ix22_bb,Iy22_bb,Iz22_bb, Ixy :: REAL
      v11,v81,v21,v91,v31,v61 :: REAL
      v41,v51,v71,v12,v82,v22 :: REAL
      v92,v32,v62,v42,v52,v72 :: REAL
      v13,v83,v23,v93,v33,v63 :: REAL
      v43,v53,v73,v14,v84,v24 :: REAL
      v94,v34,v64,v44,v54,v74 :: REAL
      v15,v85,v25,v95,v35,v65 :: REAL
      v45,v55,v75,v16,v86,v26 :: REAL
      v96,v36,v66,v46,v56,v76 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 3
      rys.create(n_roots)

      esfs = ZERO

      v11 = ZERO; v81 = ZERO; v21 = ZERO; v91 = ZERO; v31 = ZERO; v61 = ZERO
      v41 = ZERO; v51 = ZERO; v71 = ZERO; v12 = ZERO; v82 = ZERO; v22 = ZERO
      v92 = ZERO; v32 = ZERO; v62 = ZERO; v42 = ZERO; v52 = ZERO; v72 = ZERO
      v13 = ZERO; v83 = ZERO; v23 = ZERO; v93 = ZERO; v33 = ZERO; v63 = ZERO
      v43 = ZERO; v53 = ZERO; v73 = ZERO; v14 = ZERO; v84 = ZERO; v24 = ZERO
      v94 = ZERO; v34 = ZERO; v64 = ZERO; v44 = ZERO; v54 = ZERO; v74 = ZERO
      v15 = ZERO; v85 = ZERO; v25 = ZERO; v95 = ZERO; v35 = ZERO; v65 = ZERO
      v45 = ZERO; v55 = ZERO; v75 = ZERO; v16 = ZERO; v86 = ZERO; v26 = ZERO
      v96 = ZERO; v36 = ZERO; v66 = ZERO; v46 = ZERO; v56 = ZERO; v76 = ZERO

      parallel do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             half_einv = HALF * einv
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               ce  = (ONE - t2_rz) * half_zinv
               Ix31 = Ix21*Ix21 + ce
               Iy31 = Iy21*Iy21 + ce
               Iz31 = Iz21*Iz21 + ce

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               cf  = (ONE - t2_re) * half_einv
               Ix13 = Ix12*Ix12 + cf
               Iy13 = Iy12*Iy12 + cf
               Iz13 = Iz12*Iz12 + cf

               bb = t2_rz * half_einv
               Ix22 = Ix12*Ix21 + bb
               Iy22 = Iy12*Iy21 + bb
               Iz22 = Iz12*Iz21 + bb

               Ix22_bb = Ix22 + bb
               Iy22_bb = Iy22 + bb
               Iz22_bb = Iz22 + bb

               Ix23 = Ix12*Ix22_bb + cf*Ix21
               Iy23 = Iy12*Iy22_bb + cf*Iy21
               Iz23 = Iz12*Iz22_bb + cf*Iz21

               Ix32 = Ix21*Ix22_bb + ce*Ix12
               Iy32 = Iy21*Iy22_bb + ce*Iy12
               Iz32 = Iz21*Iz22_bb + ce*Iz12

               f1_bb = bb + bb
               Ix33 = Ix21*Ix23 + ce*Ix13 + f1_bb*Ix22
               Iy33 = Iy21*Iy23 + ce*Iy13 + f1_bb*Iy22
               Iz33 = Iz21*Iz23 + ce*Iz13 + f1_bb*Iz22

               Iz21 = Iz21*wt
               Iz31 = Iz31*wt
               Iz12 = Iz12*wt
               Iz13 = Iz13*wt
               Iz22 = Iz22*wt
               Iz23 = Iz23*wt
               Iz32 = Iz32*wt
               Iz33 = Iz33*wt

               v11 = v11 + Ix23*wt
               v81 = v81 + Ix23*Iz21
               Ixy = Ix13*Iy21
               v21 = v21 + Ixy*wt
               v91 = v91 + Ixy*Iz21
               v31 = v31 + Ix13*Iz21
               v61 = v61 + Ix13*Iz31
               v41 = v41 + Ix33*wt
               v51 = v51 + Ix13*Iy31*wt
               v71 = v71 + Ix23*Iy21*wt
               Ixy = Ix21*Iy13
               v12 = v12 + Ixy*wt
               v82 = v82 + Ixy*Iz21
               v22 = v22 + Iy23*wt
               v92 = v92 + Iy23*Iz21
               v32 = v32 + Iy13*Iz21
               v62 = v62 + Iy13*Iz31
               v42 = v42 + Ix31*Iy13*wt
               v52 = v52 + Iy33*wt
               v72 = v72 + Ix21*Iy23*wt
               v13 = v13 + Ix21*Iz13
               v83 = v83 + Ix21*Iz23
               v23 = v23 + Iy21*Iz13
               v93 = v93 + Iy21*Iz23
               v33 = v33 + Iz23
               v63 = v63 + Iz33
               v43 = v43 + Ix31*Iz13
               v53 = v53 + Iy31*Iz13
               v73 = v73 + Ix21*Iy21*Iz13
               Ixy = Ix22*Iy12
               v14 = v14 + Ixy*wt
               v84 = v84 + Ixy*Iz21
               Ixy = Ix12*Iy22
               v24 = v24 + Ixy*wt
               v94 = v94 + Ixy*Iz21
               Ixy = Ix12*Iy12
               v34 = v34 + Ixy*Iz21
               v64 = v64 + Ixy*Iz31
               v44 = v44 + Ix32*Iy12*wt
               v54 = v54 + Ix12*Iy32*wt
               v74 = v74 + Ix22*Iy22*wt
               v15 = v15 + Ix22*Iz12
               v85 = v85 + Ix22*Iz22
               Ixy = Ix12*Iy21
               v25 = v25 + Ixy*Iz12
               v95 = v95 + Ixy*Iz22
               v35 = v35 + Ix12*Iz22
               v65 = v65 + Ix12*Iz32
               v45 = v45 + Ix32*Iz12
               v55 = v55 + Ix12*Iy31*Iz12
               v75 = v75 + Ix22*Iy21*Iz12
               Ixy = Ix21*Iy12
               v16 = v16 + Ixy*Iz12
               v86 = v86 + Ixy*Iz22
               v26 = v26 + Iy22*Iz12
               v96 = v96 + Iy22*Iz22
               v36 = v36 + Iy12*Iz22
               v66 = v66 + Iy12*Iz32
               v46 = v46 + Ix31*Iy12*Iz12
               v56 = v56 + Iy32*Iz12
               v76 = v76 + Ix21*Iy22*Iz12

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(8,1) = v81
      esfs(2,1) = v21
      esfs(9,1) = v91
      esfs(3,1) = v31
      esfs(6,1) = v61
      esfs(4,1) = v41
      esfs(5,1) = v51
      esfs(7,1) = v71
      esfs(1,2) = v12
      esfs(8,2) = v82
      esfs(2,2) = v22
      esfs(9,2) = v92
      esfs(3,2) = v32
      esfs(6,2) = v62
      esfs(4,2) = v42
      esfs(5,2) = v52
      esfs(7,2) = v72
      esfs(1,3) = v13
      esfs(8,3) = v83
      esfs(2,3) = v23
      esfs(9,3) = v93
      esfs(3,3) = v33
      esfs(6,3) = v63
      esfs(4,3) = v43
      esfs(5,3) = v53
      esfs(7,3) = v73
      esfs(1,4) = v14
      esfs(8,4) = v84
      esfs(2,4) = v24
      esfs(9,4) = v94
      esfs(3,4) = v34
      esfs(6,4) = v64
      esfs(4,4) = v44
      esfs(5,4) = v54
      esfs(7,4) = v74
      esfs(1,5) = v15
      esfs(8,5) = v85
      esfs(2,5) = v25
      esfs(9,5) = v95
      esfs(3,5) = v35
      esfs(6,5) = v65
      esfs(4,5) = v45
      esfs(5,5) = v55
      esfs(7,5) = v75
      esfs(1,6) = v16
      esfs(8,6) = v86
      esfs(2,6) = v26
      esfs(9,6) = v96
      esfs(3,6) = v36
      esfs(6,6) = v66
      esfs(4,6) = v46
      esfs(5,6) = v56
      esfs(7,6) = v76

      PARALLEL_SUM(esfs)

   end

   make_esfs_dd_pppp(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      wt,t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
      ce,cf,bb :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
      Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
      Ix33,Iy33,Iz33,Ix22_bb,Iy22_bb,Iz22_bb, Ixy :: REAL
      v11,v81,v18,v88,v21,v91,v28,v98,v31 :: REAL
      v61,v38,v68,v41,v48,v51,v58,v71,v78 :: REAL
      v12,v82,v19,v89,v22,v92,v29,v99,v32 :: REAL
      v62,v39,v69,v42,v49,v52,v59,v72,v79 :: REAL
      v13,v83,v16,v86,v23,v93,v26,v96,v33 :: REAL
      v63,v36,v66,v43,v46,v53,v56,v73,v76 :: REAL
      v14,v84,v24,v94,v34,v64,v44,v54,v74 :: REAL
      v15,v85,v25,v95,v35,v65,v45,v55,v75 :: REAL
      v17,v87,v27,v97,v37,v67,v47,v57,v77 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 3
      rys.create(n_roots)

      esfs = ZERO

      v11 = ZERO; v81 = ZERO; v18 = ZERO; v88 = ZERO; v21 = ZERO; v91 = ZERO
      v28 = ZERO; v98 = ZERO; v31 = ZERO; v61 = ZERO; v38 = ZERO; v68 = ZERO
      v41 = ZERO; v48 = ZERO; v51 = ZERO; v58 = ZERO; v71 = ZERO; v78 = ZERO
      v12 = ZERO; v82 = ZERO; v19 = ZERO; v89 = ZERO; v22 = ZERO; v92 = ZERO
      v29 = ZERO; v99 = ZERO; v32 = ZERO; v62 = ZERO; v39 = ZERO; v69 = ZERO
      v42 = ZERO; v49 = ZERO; v52 = ZERO; v59 = ZERO; v72 = ZERO; v79 = ZERO
      v13 = ZERO; v83 = ZERO; v16 = ZERO; v86 = ZERO; v23 = ZERO; v93 = ZERO
      v26 = ZERO; v96 = ZERO; v33 = ZERO; v63 = ZERO; v36 = ZERO; v66 = ZERO
      v43 = ZERO; v46 = ZERO; v53 = ZERO; v56 = ZERO; v73 = ZERO; v76 = ZERO
      v14 = ZERO; v84 = ZERO; v24 = ZERO; v94 = ZERO; v34 = ZERO; v64 = ZERO
      v44 = ZERO; v54 = ZERO; v74 = ZERO; v15 = ZERO; v85 = ZERO; v25 = ZERO
      v95 = ZERO; v35 = ZERO; v65 = ZERO; v45 = ZERO; v55 = ZERO; v75 = ZERO
      v17 = ZERO; v87 = ZERO; v27 = ZERO; v97 = ZERO; v37 = ZERO; v67 = ZERO
      v47 = ZERO; v57 = ZERO; v77 = ZERO

      parallel do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             half_einv = HALF * einv
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               ce  = (ONE - t2_rz) * half_zinv
               Ix31 = Ix21*Ix21 + ce
               Iy31 = Iy21*Iy21 + ce
               Iz31 = Iz21*Iz21 + ce

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               cf  = (ONE - t2_re) * half_einv
               Ix13 = Ix12*Ix12 + cf
               Iy13 = Iy12*Iy12 + cf
               Iz13 = Iz12*Iz12 + cf

               bb = t2_rz * half_einv
               Ix22 = Ix12*Ix21 + bb
               Iy22 = Iy12*Iy21 + bb
               Iz22 = Iz12*Iz21 + bb

               Ix22_bb = Ix22 + bb
               Iy22_bb = Iy22 + bb
               Iz22_bb = Iz22 + bb

               Ix23 = Ix12*Ix22_bb + cf*Ix21
               Iy23 = Iy12*Iy22_bb + cf*Iy21
               Iz23 = Iz12*Iz22_bb + cf*Iz21

               Ix32 = Ix21*Ix22_bb + ce*Ix12
               Iy32 = Iy21*Iy22_bb + ce*Iy12
               Iz32 = Iz21*Iz22_bb + ce*Iz12

               f1_bb = bb + bb
               Ix33 = Ix21*Ix23 + ce*Ix13 + f1_bb*Ix22
               Iy33 = Iy21*Iy23 + ce*Iy13 + f1_bb*Iy22
               Iz33 = Iz21*Iz23 + ce*Iz13 + f1_bb*Iz22

               Iz21 = Iz21*wt
               Iz31 = Iz31*wt
               Iz12 = Iz12*wt
               Iz13 = Iz13*wt
               Iz22 = Iz22*wt
               Iz23 = Iz23*wt
               Iz32 = Iz32*wt
               Iz33 = Iz33*wt

               v11 = v11 + Ix22*wt
               v81 = v81 + Ix22*Iz21
               v18 = v18 + Ix22*Iz12
               v88 = v88 + Ix22*Iz22
               Ixy = Ix12*Iy21
               v21 = v21 + Ixy*wt
               v91 = v91 + Ixy*Iz21
               v28 = v28 + Ixy*Iz12
               v98 = v98 + Ixy*Iz22
               v31 = v31 + Ix12*Iz21
               v61 = v61 + Ix12*Iz31
               v38 = v38 + Ix12*Iz22
               v68 = v68 + Ix12*Iz32
               v41 = v41 + Ix32*wt
               v48 = v48 + Ix32*Iz12
               Ixy = Ix12*Iy31
               v51 = v51 + Ixy*wt
               v58 = v58 + Ixy*Iz12
               Ixy = Ix22*Iy21
               v71 = v71 + Ixy*wt
               v78 = v78 + Ixy*Iz12
               Ixy = Ix21*Iy12
               v12 = v12 + Ixy*wt
               v82 = v82 + Ixy*Iz21
               v19 = v19 + Ixy*Iz12
               v89 = v89 + Ixy*Iz22
               v22 = v22 + Iy22*wt
               v92 = v92 + Iy22*Iz21
               v29 = v29 + Iy22*Iz12
               v99 = v99 + Iy22*Iz22
               v32 = v32 + Iy12*Iz21
               v62 = v62 + Iy12*Iz31
               v39 = v39 + Iy12*Iz22
               v69 = v69 + Iy12*Iz32
               Ixy = Ix31*Iy12
               v42 = v42 + Ixy*wt
               v49 = v49 + Ixy*Iz12
               v52 = v52 + Iy32*wt
               v59 = v59 + Iy32*Iz12
               Ixy = Ix21*Iy22
               v72 = v72 + Ixy*wt
               v79 = v79 + Ixy*Iz12
               v13 = v13 + Ix21*Iz12
               v83 = v83 + Ix21*Iz22
               v16 = v16 + Ix21*Iz13
               v86 = v86 + Ix21*Iz23
               v23 = v23 + Iy21*Iz12
               v93 = v93 + Iy21*Iz22
               v26 = v26 + Iy21*Iz13
               v96 = v96 + Iy21*Iz23
               v33 = v33 + Iz22
               v63 = v63 + Iz32
               v36 = v36 + Iz23
               v66 = v66 + Iz33
               v43 = v43 + Ix31*Iz12
               v46 = v46 + Ix31*Iz13
               v53 = v53 + Iy31*Iz12
               v56 = v56 + Iy31*Iz13
               Ixy = Ix21*Iy21
               v73 = v73 + Ixy*Iz12
               v76 = v76 + Ixy*Iz13
               v14 = v14 + Ix23*wt
               v84 = v84 + Ix23*Iz21
               Ixy = Ix13*Iy21
               v24 = v24 + Ixy*wt
               v94 = v94 + Ixy*Iz21
               v34 = v34 + Ix13*Iz21
               v64 = v64 + Ix13*Iz31
               v44 = v44 + Ix33*wt
               v54 = v54 + Ix13*Iy31*wt
               v74 = v74 + Ix23*Iy21*wt
               Ixy = Ix21*Iy13
               v15 = v15 + Ixy*wt
               v85 = v85 + Ixy*Iz21
               v25 = v25 + Iy23*wt
               v95 = v95 + Iy23*Iz21
               v35 = v35 + Iy13*Iz21
               v65 = v65 + Iy13*Iz31
               v45 = v45 + Ix31*Iy13*wt
               v55 = v55 + Iy33*wt
               v75 = v75 + Ix21*Iy23*wt
               Ixy = Ix22*Iy12
               v17 = v17 + Ixy*wt
               v87 = v87 + Ixy*Iz21
               Ixy = Ix12*Iy22
               v27 = v27 + Ixy*wt
               v97 = v97 + Ixy*Iz21
               Ixy = Ix12*Iy12
               v37 = v37 + Ixy*Iz21
               v67 = v67 + Ixy*Iz31
               v47 = v47 + Ix32*Iy12*wt
               v57 = v57 + Ix12*Iy32*wt
               v77 = v77 + Ix22*Iy22*wt

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(8,1) = v81
      esfs(1,8) = v18
      esfs(8,8) = v88
      esfs(2,1) = v21
      esfs(9,1) = v91
      esfs(2,8) = v28
      esfs(9,8) = v98
      esfs(3,1) = v31
      esfs(6,1) = v61
      esfs(3,8) = v38
      esfs(6,8) = v68
      esfs(4,1) = v41
      esfs(4,8) = v48
      esfs(5,1) = v51
      esfs(5,8) = v58
      esfs(7,1) = v71
      esfs(7,8) = v78
      esfs(1,2) = v12
      esfs(8,2) = v82
      esfs(1,9) = v19
      esfs(8,9) = v89
      esfs(2,2) = v22
      esfs(9,2) = v92
      esfs(2,9) = v29
      esfs(9,9) = v99
      esfs(3,2) = v32
      esfs(6,2) = v62
      esfs(3,9) = v39
      esfs(6,9) = v69
      esfs(4,2) = v42
      esfs(4,9) = v49
      esfs(5,2) = v52
      esfs(5,9) = v59
      esfs(7,2) = v72
      esfs(7,9) = v79
      esfs(1,3) = v13
      esfs(8,3) = v83
      esfs(1,6) = v16
      esfs(8,6) = v86
      esfs(2,3) = v23
      esfs(9,3) = v93
      esfs(2,6) = v26
      esfs(9,6) = v96
      esfs(3,3) = v33
      esfs(6,3) = v63
      esfs(3,6) = v36
      esfs(6,6) = v66
      esfs(4,3) = v43
      esfs(4,6) = v46
      esfs(5,3) = v53
      esfs(5,6) = v56
      esfs(7,3) = v73
      esfs(7,6) = v76
      esfs(1,4) = v14
      esfs(8,4) = v84
      esfs(2,4) = v24
      esfs(9,4) = v94
      esfs(3,4) = v34
      esfs(6,4) = v64
      esfs(4,4) = v44
      esfs(5,4) = v54
      esfs(7,4) = v74
      esfs(1,5) = v15
      esfs(8,5) = v85
      esfs(2,5) = v25
      esfs(9,5) = v95
      esfs(3,5) = v35
      esfs(6,5) = v65
      esfs(4,5) = v45
      esfs(5,5) = v55
      esfs(7,5) = v75
      esfs(1,7) = v17
      esfs(8,7) = v87
      esfs(2,7) = v27
      esfs(9,7) = v97
      esfs(3,7) = v37
      esfs(6,7) = v67
      esfs(4,7) = v47
      esfs(5,7) = v57
      esfs(7,7) = v77

      PARALLEL_SUM(esfs)

   end

!   make_esfs_gg_dddd(esfs) ::: private
!   ! Makes the initial (es|fs) integrals, summed over the primitives
!     self :: IN
!     esfs :: MAT{REAL}, OUT
!     QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
!     zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
!     wt,t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
!     ce,cf,bb,ce1,cf1, Ixy :: REAL
!     Ix21,Iy21,Iz21,Ix12,Iy12,Iz12 :: REAL
!     Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
!     Ix41,Iy41,Iz41,Ix14,Iy14,Iz14 :: REAL
!     Ix51,Iy51,Iz51,Ix15,Iy15,Iz15 :: REAL
!     Ix22,Iy22,Iz22                :: REAL
!     Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
!     Ix42,Iy42,Iz42,Ix24,Iy24,Iz24 :: REAL
!     Ix52,Iy52,Iz52,Ix25,Iy25,Iz25 :: REAL
!     Ix23,Iy23,Iz23,Ix32,Iy32,Iz32 :: REAL
!     Ix33,Iy33,Iz33                :: REAL
!     Ix43,Iy43,Iz43,Ix34,Iy34,Iz34 :: REAL
!     Ix53,Iy53,Iz53,Ix35,Iy35,Iz35 :: REAL
!     Ix24,Iy24,Iz24,Ix42,Iy42,Iz42 :: REAL
!     Ix34,Iy34,Iz34,Ix43,Iy43,Iz43 :: REAL
!     Ix44,Iy44,Iz44                :: REAL
!     Ix54,Iy54,Iz54,Ix45,Iy45,Iz45 :: REAL
!     Ix25,Iy25,Iz25,Ix52,Iy52,Iz52 :: REAL
!     Ix35,Iy35,Iz35,Ix53,Iy53,Iz53 :: REAL
!     Ix45,Iy45,Iz45,Ix54,Iy54,Iz54 :: REAL
!     Ix55,Iy55,Iz55                :: REAL
!     n_roots,dim1,dim2 :: INT
!     n,j,k :: INT
!     rys :: RYS*
!
!     v__1__1,v_11__1,v_27__1,v__1_11,v_11_11,v_27_11,v__1_27,v_11_27,v_27_27,v__2__1 :: REAL
!     v_13__1,v_28__1,v__2_11,v_13_11,v_28_11,v__2_27,v_13_27,v_28_27,v__3__1,v__9__1 :: REAL
!     v_19__1,v__3_11,v__9_11,v_19_11,v__3_27,v__9_27,v_19_27,v__4__1,v__4_11,v__4_27 :: REAL
!     v__5__1,v_14__1,v_24__1,v__5_11,v_14_11,v_24_11,v__5_27,v_14_27,v_24_27,v__6__1 :: REAL
!     v_15__1,v_25__1,v__6_11,v_15_11,v_25_11,v__6_27,v_15_27,v_25_27,v__7__1,v_21__1 :: REAL
!     v__7_11,v_21_11,v__7_27,v_21_27,v__8__1,v_23__1,v__8_11,v_23_11,v__8_27,v_23_27 :: REAL
!     v_10__1,v_10_11,v_10_27,v_12__1,v_12_11,v_12_27,v_17__1,v_17_11,v_17_27,v_18__1 :: REAL
!     v_18_11,v_18_27,v_20__1,v_20_11,v_20_27,v_22__1,v_22_11,v_22_27,v_26__1,v_26_11 :: REAL
!     v_26_27,v__1__2,v_11__2,v_27__2,v__1_13,v_11_13,v_27_13,v__1_28,v_11_28,v_27_28 :: REAL
!     v__2__2,v_13__2,v_28__2,v__2_13,v_13_13,v_28_13,v__2_28,v_13_28,v_28_28,v__3__2 :: REAL
!     v__9__2,v_19__2,v__3_13,v__9_13,v_19_13,v__3_28,v__9_28,v_19_28,v__4__2,v__4_13 :: REAL
!     v__4_28,v__5__2,v_14__2,v_24__2,v__5_13,v_14_13,v_24_13,v__5_28,v_14_28,v_24_28 :: REAL
!     v__6__2,v_15__2,v_25__2,v__6_13,v_15_13,v_25_13,v__6_28,v_15_28,v_25_28,v__7__2 :: REAL
!     v_21__2,v__7_13,v_21_13,v__7_28,v_21_28,v__8__2,v_23__2,v__8_13,v_23_13,v__8_28 :: REAL
!     v_23_28,v_10__2,v_10_13,v_10_28,v_12__2,v_12_13,v_12_28,v_17__2,v_17_13,v_17_28 :: REAL
!     v_18__2,v_18_13,v_18_28,v_20__2,v_20_13,v_20_28,v_22__2,v_22_13,v_22_28,v_26__2 :: REAL
!     v_26_13,v_26_28,v__1__3,v_11__3,v_27__3,v__1__9,v_11__9,v_27__9,v__1_19,v_11_19 :: REAL
!     v_27_19,v__2__3,v_13__3,v_28__3,v__2__9,v_13__9,v_28__9,v__2_19,v_13_19,v_28_19 :: REAL
!     v__3__3,v__9__3,v_19__3,v__3__9,v__9__9,v_19__9,v__3_19,v__9_19,v_19_19,v__4__3 :: REAL
!     v__4__9,v__4_19,v__5__3,v_14__3,v_24__3,v__5__9,v_14__9,v_24__9,v__5_19,v_14_19 :: REAL
!     v_24_19,v__6__3,v_15__3,v_25__3,v__6__9,v_15__9,v_25__9,v__6_19,v_15_19,v_25_19 :: REAL
!     v__7__3,v_21__3,v__7__9,v_21__9,v__7_19,v_21_19,v__8__3,v_23__3,v__8__9,v_23__9 :: REAL
!     v__8_19,v_23_19,v_10__3,v_10__9,v_10_19,v_12__3,v_12__9,v_12_19,v_17__3,v_17__9 :: REAL
!     v_17_19,v_18__3,v_18__9,v_18_19,v_20__3,v_20__9,v_20_19,v_22__3,v_22__9,v_22_19 :: REAL
!     v_26__3,v_26__9,v_26_19,v__1__4,v_11__4,v_27__4,v__2__4,v_13__4,v_28__4,v__3__4 :: REAL
!     v__9__4,v_19__4,v__4__4,v__5__4,v_14__4,v_24__4,v__6__4,v_15__4,v_25__4,v__7__4 :: REAL
!     v_21__4,v__8__4,v_23__4,v_10__4,v_12__4,v_17__4,v_18__4,v_20__4,v_22__4,v_26__4 :: REAL
!     v__1__5,v_11__5,v_27__5,v__1_14,v_11_14,v_27_14,v__1_24,v_11_24,v_27_24,v__2__5 :: REAL
!     v_13__5,v_28__5,v__2_14,v_13_14,v_28_14,v__2_24,v_13_24,v_28_24,v__3__5,v__9__5 :: REAL
!     v_19__5,v__3_14,v__9_14,v_19_14,v__3_24,v__9_24,v_19_24,v__4__5,v__4_14,v__4_24 :: REAL
!     v__5__5,v_14__5,v_24__5,v__5_14,v_14_14,v_24_14,v__5_24,v_14_24,v_24_24,v__6__5 :: REAL
!     v_15__5,v_25__5,v__6_14,v_15_14,v_25_14,v__6_24,v_15_24,v_25_24,v__7__5,v_21__5 :: REAL
!     v__7_14,v_21_14,v__7_24,v_21_24,v__8__5,v_23__5,v__8_14,v_23_14,v__8_24,v_23_24 :: REAL
!     v_10__5,v_10_14,v_10_24,v_12__5,v_12_14,v_12_24,v_17__5,v_17_14,v_17_24,v_18__5 :: REAL
!     v_18_14,v_18_24,v_20__5,v_20_14,v_20_24,v_22__5,v_22_14,v_22_24,v_26__5,v_26_14 :: REAL
!     v_26_24,v__1__6,v_11__6,v_27__6,v__1_15,v_11_15,v_27_15,v__1_25,v_11_25,v_27_25 :: REAL
!     v__2__6,v_13__6,v_28__6,v__2_15,v_13_15,v_28_15,v__2_25,v_13_25,v_28_25,v__3__6 :: REAL
!     v__9__6,v_19__6,v__3_15,v__9_15,v_19_15,v__3_25,v__9_25,v_19_25,v__4__6,v__4_15 :: REAL
!     v__4_25,v__5__6,v_14__6,v_24__6,v__5_15,v_14_15,v_24_15,v__5_25,v_14_25,v_24_25 :: REAL
!     v__6__6,v_15__6,v_25__6,v__6_15,v_15_15,v_25_15,v__6_25,v_15_25,v_25_25,v__7__6 :: REAL
!     v_21__6,v__7_15,v_21_15,v__7_25,v_21_25,v__8__6,v_23__6,v__8_15,v_23_15,v__8_25 :: REAL
!     v_23_25,v_10__6,v_10_15,v_10_25,v_12__6,v_12_15,v_12_25,v_17__6,v_17_15,v_17_25 :: REAL
!     v_18__6,v_18_15,v_18_25,v_20__6,v_20_15,v_20_25,v_22__6,v_22_15,v_22_25,v_26__6 :: REAL
!     v_26_15,v_26_25,v__1__7,v_11__7,v_27__7,v__1_21,v_11_21,v_27_21,v__2__7,v_13__7 :: REAL
!     v_28__7,v__2_21,v_13_21,v_28_21,v__3__7,v__9__7,v_19__7,v__3_21,v__9_21,v_19_21 :: REAL
!     v__4__7,v__4_21,v__5__7,v_14__7,v_24__7,v__5_21,v_14_21,v_24_21,v__6__7,v_15__7 :: REAL
!     v_25__7,v__6_21,v_15_21,v_25_21,v__7__7,v_21__7,v__7_21,v_21_21,v__8__7,v_23__7 :: REAL
!     v__8_21,v_23_21,v_10__7,v_10_21,v_12__7,v_12_21,v_17__7,v_17_21,v_18__7,v_18_21 :: REAL
!     v_20__7,v_20_21,v_22__7,v_22_21,v_26__7,v_26_21,v__1__8,v_11__8,v_27__8,v__1_23 :: REAL
!     v_11_23,v_27_23,v__2__8,v_13__8,v_28__8,v__2_23,v_13_23,v_28_23,v__3__8,v__9__8 :: REAL
!     v_19__8,v__3_23,v__9_23,v_19_23,v__4__8,v__4_23,v__5__8,v_14__8,v_24__8,v__5_23 :: REAL
!     v_14_23,v_24_23,v__6__8,v_15__8,v_25__8,v__6_23,v_15_23,v_25_23,v__7__8,v_21__8 :: REAL
!     v__7_23,v_21_23,v__8__8,v_23__8,v__8_23,v_23_23,v_10__8,v_10_23,v_12__8,v_12_23 :: REAL
!     v_17__8,v_17_23,v_18__8,v_18_23,v_20__8,v_20_23,v_22__8,v_22_23,v_26__8,v_26_23 :: REAL
!     v__1_10,v_11_10,v_27_10,v__2_10,v_13_10,v_28_10,v__3_10,v__9_10,v_19_10,v__4_10 :: REAL
!     v__5_10,v_14_10,v_24_10,v__6_10,v_15_10,v_25_10,v__7_10,v_21_10,v__8_10,v_23_10 :: REAL
!     v_10_10,v_12_10,v_17_10,v_18_10,v_20_10,v_22_10,v_26_10,v__1_12,v_11_12,v_27_12 :: REAL
!     v__2_12,v_13_12,v_28_12,v__3_12,v__9_12,v_19_12,v__4_12,v__5_12,v_14_12,v_24_12 :: REAL
!     v__6_12,v_15_12,v_25_12,v__7_12,v_21_12,v__8_12,v_23_12,v_10_12,v_12_12,v_17_12 :: REAL
!     v_18_12,v_20_12,v_22_12,v_26_12,v__1_17,v_11_17,v_27_17,v__2_17,v_13_17,v_28_17 :: REAL
!     v__3_17,v__9_17,v_19_17,v__4_17,v__5_17,v_14_17,v_24_17,v__6_17,v_15_17,v_25_17 :: REAL
!     v__7_17,v_21_17,v__8_17,v_23_17,v_10_17,v_12_17,v_17_17,v_18_17,v_20_17,v_22_17 :: REAL
!     v_26_17,v__1_18,v_11_18,v_27_18,v__2_18,v_13_18,v_28_18,v__3_18,v__9_18,v_19_18 :: REAL
!     v__4_18,v__5_18,v_14_18,v_24_18,v__6_18,v_15_18,v_25_18,v__7_18,v_21_18,v__8_18 :: REAL
!     v_23_18,v_10_18,v_12_18,v_17_18,v_18_18,v_20_18,v_22_18,v_26_18,v__1_20,v_11_20 :: REAL
!     v_27_20,v__2_20,v_13_20,v_28_20,v__3_20,v__9_20,v_19_20,v__4_20,v__5_20,v_14_20 :: REAL
!     v_24_20,v__6_20,v_15_20,v_25_20,v__7_20,v_21_20,v__8_20,v_23_20,v_10_20,v_12_20 :: REAL
!     v_17_20,v_18_20,v_20_20,v_22_20,v_26_20,v__1_22,v_11_22,v_27_22,v__2_22,v_13_22 :: REAL
!     v_28_22,v__3_22,v__9_22,v_19_22,v__4_22,v__5_22,v_14_22,v_24_22,v__6_22,v_15_22 :: REAL
!     v_25_22,v__7_22,v_21_22,v__8_22,v_23_22,v_10_22,v_12_22,v_17_22,v_18_22,v_20_22 :: REAL
!     v_22_22,v_26_22,v__1_26,v_11_26,v_27_26,v__2_26,v_13_26,v_28_26,v__3_26,v__9_26 :: REAL
!     v_19_26,v__4_26,v__5_26,v_14_26,v_24_26,v__6_26,v_15_26,v_25_26,v__7_26,v_21_26 :: REAL
!     v__8_26,v_23_26,v_10_26,v_12_26,v_17_26,v_18_26,v_20_26,v_22_26,v_26_26,v_16_16 :: REAL
!     v_31_16,v_16_31,v_31_31,v_29_16,v_29_31,v_30_16,v_30_31,v_16_29,v_31_29,v_29_29 :: REAL
!     v_30_29,v_16_30,v_31_30,v_29_30,v_30_30,v_16__1,v_31__1,v_16_11,v_31_11,v_16_27 :: REAL
!     v_31_27,v_29__1,v_29_11,v_29_27,v_30__1,v_30_11,v_30_27,v_16__2,v_31__2,v_16_13 :: REAL
!     v_31_13,v_16_28,v_31_28,v_29__2,v_29_13,v_29_28,v_30__2,v_30_13,v_30_28,v_16__3 :: REAL
!     v_31__3,v_16__9,v_31__9,v_16_19,v_31_19,v_29__3,v_29__9,v_29_19,v_30__3,v_30__9 :: REAL
!     v_30_19,v_16__4,v_31__4,v_29__4,v_30__4,v_16__5,v_31__5,v_16_14,v_31_14,v_16_24 :: REAL
!     v_31_24,v_29__5,v_29_14,v_29_24,v_30__5,v_30_14,v_30_24,v_16__6,v_31__6,v_16_15 :: REAL
!     v_31_15,v_16_25,v_31_25,v_29__6,v_29_15,v_29_25,v_30__6,v_30_15,v_30_25,v_16__7 :: REAL
!     v_31__7,v_16_21,v_31_21,v_29__7,v_29_21,v_30__7,v_30_21,v_16__8,v_31__8,v_16_23 :: REAL
!     v_31_23,v_29__8,v_29_23,v_30__8,v_30_23,v_16_10,v_31_10,v_29_10,v_30_10,v_16_12 :: REAL
!     v_31_12,v_29_12,v_30_12,v_16_17,v_31_17,v_29_17,v_30_17,v_16_18,v_31_18,v_29_18 :: REAL
!     v_30_18,v_16_20,v_31_20,v_29_20,v_30_20,v_16_22,v_31_22,v_29_22,v_30_22,v_16_26 :: REAL
!     v_31_26,v_29_26,v_30_26,v__1_16,v_11_16,v_27_16,v__1_31,v_11_31,v_27_31,v__2_16 :: REAL
!     v_13_16,v_28_16,v__2_31,v_13_31,v_28_31,v__3_16,v__9_16,v_19_16,v__3_31,v__9_31 :: REAL
!     v_19_31,v__4_16,v__4_31,v__5_16,v_14_16,v_24_16,v__5_31,v_14_31,v_24_31,v__6_16 :: REAL
!     v_15_16,v_25_16,v__6_31,v_15_31,v_25_31,v__7_16,v_21_16,v__7_31,v_21_31,v__8_16 :: REAL
!     v_23_16,v__8_31,v_23_31,v_10_16,v_10_31,v_12_16,v_12_31,v_17_16,v_17_31,v_18_16 :: REAL
!     v_18_31,v_20_16,v_20_31,v_22_16,v_22_31,v_26_16,v_26_31,v__1_29,v_11_29,v_27_29 :: REAL
!     v__2_29,v_13_29,v_28_29,v__3_29,v__9_29,v_19_29,v__4_29,v__5_29,v_14_29,v_24_29 :: REAL
!     v__6_29,v_15_29,v_25_29,v__7_29,v_21_29,v__8_29,v_23_29,v_10_29,v_12_29,v_17_29 :: REAL
!     v_18_29,v_20_29,v_22_29,v_26_29,v__1_30,v_11_30,v_27_30,v__2_30,v_13_30,v_28_30 :: REAL
!     v__3_30,v__9_30,v_19_30,v__4_30,v__5_30,v_14_30,v_24_30,v__6_30,v_15_30,v_25_30 :: REAL
!     v__7_30,v_21_30,v__8_30,v_23_30,v_10_30,v_12_30,v_17_30,v_18_30,v_20_30,v_22_30 :: REAL
!     v_26_30 :: REAL
!
!     dim1 = .ab_l_sum + 1
!     dim2 = .cd_l_sum + 1
!     n_roots = (dim1+dim2)/2
!     rys.create(n_roots)
!
!     v__1__1 = ZERO; v_11__1 = ZERO; v_27__1 = ZERO; v__1_11 = ZERO; v_11_11 = ZERO; v_27_11 = ZERO
!     v__1_27 = ZERO; v_11_27 = ZERO; v_27_27 = ZERO; v__2__1 = ZERO; v_13__1 = ZERO; v_28__1 = ZERO
!     v__2_11 = ZERO; v_13_11 = ZERO; v_28_11 = ZERO; v__2_27 = ZERO; v_13_27 = ZERO; v_28_27 = ZERO
!     v__3__1 = ZERO; v__9__1 = ZERO; v_19__1 = ZERO; v__3_11 = ZERO; v__9_11 = ZERO; v_19_11 = ZERO
!     v__3_27 = ZERO; v__9_27 = ZERO; v_19_27 = ZERO; v__4__1 = ZERO; v__4_11 = ZERO; v__4_27 = ZERO
!     v__5__1 = ZERO; v_14__1 = ZERO; v_24__1 = ZERO; v__5_11 = ZERO; v_14_11 = ZERO; v_24_11 = ZERO
!     v__5_27 = ZERO; v_14_27 = ZERO; v_24_27 = ZERO; v__6__1 = ZERO; v_15__1 = ZERO; v_25__1 = ZERO
!     v__6_11 = ZERO; v_15_11 = ZERO; v_25_11 = ZERO; v__6_27 = ZERO; v_15_27 = ZERO; v_25_27 = ZERO
!     v__7__1 = ZERO; v_21__1 = ZERO; v__7_11 = ZERO; v_21_11 = ZERO; v__7_27 = ZERO; v_21_27 = ZERO
!     v__8__1 = ZERO; v_23__1 = ZERO; v__8_11 = ZERO; v_23_11 = ZERO; v__8_27 = ZERO; v_23_27 = ZERO
!     v_10__1 = ZERO; v_10_11 = ZERO; v_10_27 = ZERO; v_12__1 = ZERO; v_12_11 = ZERO; v_12_27 = ZERO
!     v_17__1 = ZERO; v_17_11 = ZERO; v_17_27 = ZERO; v_18__1 = ZERO; v_18_11 = ZERO; v_18_27 = ZERO
!     v_20__1 = ZERO; v_20_11 = ZERO; v_20_27 = ZERO; v_22__1 = ZERO; v_22_11 = ZERO; v_22_27 = ZERO
!     v_26__1 = ZERO; v_26_11 = ZERO; v_26_27 = ZERO; v__1__2 = ZERO; v_11__2 = ZERO; v_27__2 = ZERO
!     v__1_13 = ZERO; v_11_13 = ZERO; v_27_13 = ZERO; v__1_28 = ZERO; v_11_28 = ZERO; v_27_28 = ZERO
!     v__2__2 = ZERO; v_13__2 = ZERO; v_28__2 = ZERO; v__2_13 = ZERO; v_13_13 = ZERO; v_28_13 = ZERO
!     v__2_28 = ZERO; v_13_28 = ZERO; v_28_28 = ZERO; v__3__2 = ZERO; v__9__2 = ZERO; v_19__2 = ZERO
!     v__3_13 = ZERO; v__9_13 = ZERO; v_19_13 = ZERO; v__3_28 = ZERO; v__9_28 = ZERO; v_19_28 = ZERO
!     v__4__2 = ZERO; v__4_13 = ZERO; v__4_28 = ZERO; v__5__2 = ZERO; v_14__2 = ZERO; v_24__2 = ZERO
!     v__5_13 = ZERO; v_14_13 = ZERO; v_24_13 = ZERO; v__5_28 = ZERO; v_14_28 = ZERO; v_24_28 = ZERO
!     v__6__2 = ZERO; v_15__2 = ZERO; v_25__2 = ZERO; v__6_13 = ZERO; v_15_13 = ZERO; v_25_13 = ZERO
!     v__6_28 = ZERO; v_15_28 = ZERO; v_25_28 = ZERO; v__7__2 = ZERO; v_21__2 = ZERO; v__7_13 = ZERO
!     v_21_13 = ZERO; v__7_28 = ZERO; v_21_28 = ZERO; v__8__2 = ZERO; v_23__2 = ZERO; v__8_13 = ZERO
!     v_23_13 = ZERO; v__8_28 = ZERO; v_23_28 = ZERO; v_10__2 = ZERO; v_10_13 = ZERO; v_10_28 = ZERO
!     v_12__2 = ZERO; v_12_13 = ZERO; v_12_28 = ZERO; v_17__2 = ZERO; v_17_13 = ZERO; v_17_28 = ZERO
!     v_18__2 = ZERO; v_18_13 = ZERO; v_18_28 = ZERO; v_20__2 = ZERO; v_20_13 = ZERO; v_20_28 = ZERO
!     v_22__2 = ZERO; v_22_13 = ZERO; v_22_28 = ZERO; v_26__2 = ZERO; v_26_13 = ZERO; v_26_28 = ZERO
!     v__1__3 = ZERO; v_11__3 = ZERO; v_27__3 = ZERO; v__1__9 = ZERO; v_11__9 = ZERO; v_27__9 = ZERO
!     v__1_19 = ZERO; v_11_19 = ZERO; v_27_19 = ZERO; v__2__3 = ZERO; v_13__3 = ZERO; v_28__3 = ZERO
!     v__2__9 = ZERO; v_13__9 = ZERO; v_28__9 = ZERO; v__2_19 = ZERO; v_13_19 = ZERO; v_28_19 = ZERO
!     v__3__3 = ZERO; v__9__3 = ZERO; v_19__3 = ZERO; v__3__9 = ZERO; v__9__9 = ZERO; v_19__9 = ZERO
!     v__3_19 = ZERO; v__9_19 = ZERO; v_19_19 = ZERO; v__4__3 = ZERO; v__4__9 = ZERO; v__4_19 = ZERO
!     v__5__3 = ZERO; v_14__3 = ZERO; v_24__3 = ZERO; v__5__9 = ZERO; v_14__9 = ZERO; v_24__9 = ZERO
!     v__5_19 = ZERO; v_14_19 = ZERO; v_24_19 = ZERO; v__6__3 = ZERO; v_15__3 = ZERO; v_25__3 = ZERO
!     v__6__9 = ZERO; v_15__9 = ZERO; v_25__9 = ZERO; v__6_19 = ZERO; v_15_19 = ZERO; v_25_19 = ZERO
!     v__7__3 = ZERO; v_21__3 = ZERO; v__7__9 = ZERO; v_21__9 = ZERO; v__7_19 = ZERO; v_21_19 = ZERO
!     v__8__3 = ZERO; v_23__3 = ZERO; v__8__9 = ZERO; v_23__9 = ZERO; v__8_19 = ZERO; v_23_19 = ZERO
!     v_10__3 = ZERO; v_10__9 = ZERO; v_10_19 = ZERO; v_12__3 = ZERO; v_12__9 = ZERO; v_12_19 = ZERO
!     v_17__3 = ZERO; v_17__9 = ZERO; v_17_19 = ZERO; v_18__3 = ZERO; v_18__9 = ZERO; v_18_19 = ZERO
!     v_20__3 = ZERO; v_20__9 = ZERO; v_20_19 = ZERO; v_22__3 = ZERO; v_22__9 = ZERO; v_22_19 = ZERO
!     v_26__3 = ZERO; v_26__9 = ZERO; v_26_19 = ZERO; v__1__4 = ZERO; v_11__4 = ZERO; v_27__4 = ZERO
!     v__2__4 = ZERO; v_13__4 = ZERO; v_28__4 = ZERO; v__3__4 = ZERO; v__9__4 = ZERO; v_19__4 = ZERO
!     v__4__4 = ZERO; v__5__4 = ZERO; v_14__4 = ZERO; v_24__4 = ZERO; v__6__4 = ZERO; v_15__4 = ZERO
!     v_25__4 = ZERO; v__7__4 = ZERO; v_21__4 = ZERO; v__8__4 = ZERO; v_23__4 = ZERO; v_10__4 = ZERO
!     v_12__4 = ZERO; v_17__4 = ZERO; v_18__4 = ZERO; v_20__4 = ZERO; v_22__4 = ZERO; v_26__4 = ZERO
!     v__1__5 = ZERO; v_11__5 = ZERO; v_27__5 = ZERO; v__1_14 = ZERO; v_11_14 = ZERO; v_27_14 = ZERO
!     v__1_24 = ZERO; v_11_24 = ZERO; v_27_24 = ZERO; v__2__5 = ZERO; v_13__5 = ZERO; v_28__5 = ZERO
!     v__2_14 = ZERO; v_13_14 = ZERO; v_28_14 = ZERO; v__2_24 = ZERO; v_13_24 = ZERO; v_28_24 = ZERO
!     v__3__5 = ZERO; v__9__5 = ZERO; v_19__5 = ZERO; v__3_14 = ZERO; v__9_14 = ZERO; v_19_14 = ZERO
!     v__3_24 = ZERO; v__9_24 = ZERO; v_19_24 = ZERO; v__4__5 = ZERO; v__4_14 = ZERO; v__4_24 = ZERO
!     v__5__5 = ZERO; v_14__5 = ZERO; v_24__5 = ZERO; v__5_14 = ZERO; v_14_14 = ZERO; v_24_14 = ZERO
!     v__5_24 = ZERO; v_14_24 = ZERO; v_24_24 = ZERO; v__6__5 = ZERO; v_15__5 = ZERO; v_25__5 = ZERO
!     v__6_14 = ZERO; v_15_14 = ZERO; v_25_14 = ZERO; v__6_24 = ZERO; v_15_24 = ZERO; v_25_24 = ZERO
!     v__7__5 = ZERO; v_21__5 = ZERO; v__7_14 = ZERO; v_21_14 = ZERO; v__7_24 = ZERO; v_21_24 = ZERO
!     v__8__5 = ZERO; v_23__5 = ZERO; v__8_14 = ZERO; v_23_14 = ZERO; v__8_24 = ZERO; v_23_24 = ZERO
!     v_10__5 = ZERO; v_10_14 = ZERO; v_10_24 = ZERO; v_12__5 = ZERO; v_12_14 = ZERO; v_12_24 = ZERO
!     v_17__5 = ZERO; v_17_14 = ZERO; v_17_24 = ZERO; v_18__5 = ZERO; v_18_14 = ZERO; v_18_24 = ZERO
!     v_20__5 = ZERO; v_20_14 = ZERO; v_20_24 = ZERO; v_22__5 = ZERO; v_22_14 = ZERO; v_22_24 = ZERO
!     v_26__5 = ZERO; v_26_14 = ZERO; v_26_24 = ZERO; v__1__6 = ZERO; v_11__6 = ZERO; v_27__6 = ZERO
!     v__1_15 = ZERO; v_11_15 = ZERO; v_27_15 = ZERO; v__1_25 = ZERO; v_11_25 = ZERO; v_27_25 = ZERO
!     v__2__6 = ZERO; v_13__6 = ZERO; v_28__6 = ZERO; v__2_15 = ZERO; v_13_15 = ZERO; v_28_15 = ZERO
!     v__2_25 = ZERO; v_13_25 = ZERO; v_28_25 = ZERO; v__3__6 = ZERO; v__9__6 = ZERO; v_19__6 = ZERO
!     v__3_15 = ZERO; v__9_15 = ZERO; v_19_15 = ZERO; v__3_25 = ZERO; v__9_25 = ZERO; v_19_25 = ZERO
!     v__4__6 = ZERO; v__4_15 = ZERO; v__4_25 = ZERO; v__5__6 = ZERO; v_14__6 = ZERO; v_24__6 = ZERO
!     v__5_15 = ZERO; v_14_15 = ZERO; v_24_15 = ZERO; v__5_25 = ZERO; v_14_25 = ZERO; v_24_25 = ZERO
!     v__6__6 = ZERO; v_15__6 = ZERO; v_25__6 = ZERO; v__6_15 = ZERO; v_15_15 = ZERO; v_25_15 = ZERO
!     v__6_25 = ZERO; v_15_25 = ZERO; v_25_25 = ZERO; v__7__6 = ZERO; v_21__6 = ZERO; v__7_15 = ZERO
!     v_21_15 = ZERO; v__7_25 = ZERO; v_21_25 = ZERO; v__8__6 = ZERO; v_23__6 = ZERO; v__8_15 = ZERO
!     v_23_15 = ZERO; v__8_25 = ZERO; v_23_25 = ZERO; v_10__6 = ZERO; v_10_15 = ZERO; v_10_25 = ZERO
!     v_12__6 = ZERO; v_12_15 = ZERO; v_12_25 = ZERO; v_17__6 = ZERO; v_17_15 = ZERO; v_17_25 = ZERO
!     v_18__6 = ZERO; v_18_15 = ZERO; v_18_25 = ZERO; v_20__6 = ZERO; v_20_15 = ZERO; v_20_25 = ZERO
!     v_22__6 = ZERO; v_22_15 = ZERO; v_22_25 = ZERO; v_26__6 = ZERO; v_26_15 = ZERO; v_26_25 = ZERO
!     v__1__7 = ZERO; v_11__7 = ZERO; v_27__7 = ZERO; v__1_21 = ZERO; v_11_21 = ZERO; v_27_21 = ZERO
!     v__2__7 = ZERO; v_13__7 = ZERO; v_28__7 = ZERO; v__2_21 = ZERO; v_13_21 = ZERO; v_28_21 = ZERO
!     v__3__7 = ZERO; v__9__7 = ZERO; v_19__7 = ZERO; v__3_21 = ZERO; v__9_21 = ZERO; v_19_21 = ZERO
!     v__4__7 = ZERO; v__4_21 = ZERO; v__5__7 = ZERO; v_14__7 = ZERO; v_24__7 = ZERO; v__5_21 = ZERO
!     v_14_21 = ZERO; v_24_21 = ZERO; v__6__7 = ZERO; v_15__7 = ZERO; v_25__7 = ZERO; v__6_21 = ZERO
!     v_15_21 = ZERO; v_25_21 = ZERO; v__7__7 = ZERO; v_21__7 = ZERO; v__7_21 = ZERO; v_21_21 = ZERO
!     v__8__7 = ZERO; v_23__7 = ZERO; v__8_21 = ZERO; v_23_21 = ZERO; v_10__7 = ZERO; v_10_21 = ZERO
!     v_12__7 = ZERO; v_12_21 = ZERO; v_17__7 = ZERO; v_17_21 = ZERO; v_18__7 = ZERO; v_18_21 = ZERO
!     v_20__7 = ZERO; v_20_21 = ZERO; v_22__7 = ZERO; v_22_21 = ZERO; v_26__7 = ZERO; v_26_21 = ZERO
!     v__1__8 = ZERO; v_11__8 = ZERO; v_27__8 = ZERO; v__1_23 = ZERO; v_11_23 = ZERO; v_27_23 = ZERO
!     v__2__8 = ZERO; v_13__8 = ZERO; v_28__8 = ZERO; v__2_23 = ZERO; v_13_23 = ZERO; v_28_23 = ZERO
!     v__3__8 = ZERO; v__9__8 = ZERO; v_19__8 = ZERO; v__3_23 = ZERO; v__9_23 = ZERO; v_19_23 = ZERO
!     v__4__8 = ZERO; v__4_23 = ZERO; v__5__8 = ZERO; v_14__8 = ZERO; v_24__8 = ZERO; v__5_23 = ZERO
!     v_14_23 = ZERO; v_24_23 = ZERO; v__6__8 = ZERO; v_15__8 = ZERO; v_25__8 = ZERO; v__6_23 = ZERO
!     v_15_23 = ZERO; v_25_23 = ZERO; v__7__8 = ZERO; v_21__8 = ZERO; v__7_23 = ZERO; v_21_23 = ZERO
!     v__8__8 = ZERO; v_23__8 = ZERO; v__8_23 = ZERO; v_23_23 = ZERO; v_10__8 = ZERO; v_10_23 = ZERO
!     v_12__8 = ZERO; v_12_23 = ZERO; v_17__8 = ZERO; v_17_23 = ZERO; v_18__8 = ZERO; v_18_23 = ZERO
!     v_20__8 = ZERO; v_20_23 = ZERO; v_22__8 = ZERO; v_22_23 = ZERO; v_26__8 = ZERO; v_26_23 = ZERO
!     v__1_10 = ZERO; v_11_10 = ZERO; v_27_10 = ZERO; v__2_10 = ZERO; v_13_10 = ZERO; v_28_10 = ZERO
!     v__3_10 = ZERO; v__9_10 = ZERO; v_19_10 = ZERO; v__4_10 = ZERO; v__5_10 = ZERO; v_14_10 = ZERO
!     v_24_10 = ZERO; v__6_10 = ZERO; v_15_10 = ZERO; v_25_10 = ZERO; v__7_10 = ZERO; v_21_10 = ZERO
!     v__8_10 = ZERO; v_23_10 = ZERO; v_10_10 = ZERO; v_12_10 = ZERO; v_17_10 = ZERO; v_18_10 = ZERO
!     v_20_10 = ZERO; v_22_10 = ZERO; v_26_10 = ZERO; v__1_12 = ZERO; v_11_12 = ZERO; v_27_12 = ZERO
!     v__2_12 = ZERO; v_13_12 = ZERO; v_28_12 = ZERO; v__3_12 = ZERO; v__9_12 = ZERO; v_19_12 = ZERO
!     v__4_12 = ZERO; v__5_12 = ZERO; v_14_12 = ZERO; v_24_12 = ZERO; v__6_12 = ZERO; v_15_12 = ZERO
!     v_25_12 = ZERO; v__7_12 = ZERO; v_21_12 = ZERO; v__8_12 = ZERO; v_23_12 = ZERO; v_10_12 = ZERO
!     v_12_12 = ZERO; v_17_12 = ZERO; v_18_12 = ZERO; v_20_12 = ZERO; v_22_12 = ZERO; v_26_12 = ZERO
!     v__1_17 = ZERO; v_11_17 = ZERO; v_27_17 = ZERO; v__2_17 = ZERO; v_13_17 = ZERO; v_28_17 = ZERO
!     v__3_17 = ZERO; v__9_17 = ZERO; v_19_17 = ZERO; v__4_17 = ZERO; v__5_17 = ZERO; v_14_17 = ZERO
!     v_24_17 = ZERO; v__6_17 = ZERO; v_15_17 = ZERO; v_25_17 = ZERO; v__7_17 = ZERO; v_21_17 = ZERO
!     v__8_17 = ZERO; v_23_17 = ZERO; v_10_17 = ZERO; v_12_17 = ZERO; v_17_17 = ZERO; v_18_17 = ZERO
!     v_20_17 = ZERO; v_22_17 = ZERO; v_26_17 = ZERO; v__1_18 = ZERO; v_11_18 = ZERO; v_27_18 = ZERO
!     v__2_18 = ZERO; v_13_18 = ZERO; v_28_18 = ZERO; v__3_18 = ZERO; v__9_18 = ZERO; v_19_18 = ZERO
!     v__4_18 = ZERO; v__5_18 = ZERO; v_14_18 = ZERO; v_24_18 = ZERO; v__6_18 = ZERO; v_15_18 = ZERO
!     v_25_18 = ZERO; v__7_18 = ZERO; v_21_18 = ZERO; v__8_18 = ZERO; v_23_18 = ZERO; v_10_18 = ZERO
!     v_12_18 = ZERO; v_17_18 = ZERO; v_18_18 = ZERO; v_20_18 = ZERO; v_22_18 = ZERO; v_26_18 = ZERO
!     v__1_20 = ZERO; v_11_20 = ZERO; v_27_20 = ZERO; v__2_20 = ZERO; v_13_20 = ZERO; v_28_20 = ZERO
!     v__3_20 = ZERO; v__9_20 = ZERO; v_19_20 = ZERO; v__4_20 = ZERO; v__5_20 = ZERO; v_14_20 = ZERO
!     v_24_20 = ZERO; v__6_20 = ZERO; v_15_20 = ZERO; v_25_20 = ZERO; v__7_20 = ZERO; v_21_20 = ZERO
!     v__8_20 = ZERO; v_23_20 = ZERO; v_10_20 = ZERO; v_12_20 = ZERO; v_17_20 = ZERO; v_18_20 = ZERO
!     v_20_20 = ZERO; v_22_20 = ZERO; v_26_20 = ZERO; v__1_22 = ZERO; v_11_22 = ZERO; v_27_22 = ZERO
!     v__2_22 = ZERO; v_13_22 = ZERO; v_28_22 = ZERO; v__3_22 = ZERO; v__9_22 = ZERO; v_19_22 = ZERO
!     v__4_22 = ZERO; v__5_22 = ZERO; v_14_22 = ZERO; v_24_22 = ZERO; v__6_22 = ZERO; v_15_22 = ZERO
!     v_25_22 = ZERO; v__7_22 = ZERO; v_21_22 = ZERO; v__8_22 = ZERO; v_23_22 = ZERO; v_10_22 = ZERO
!     v_12_22 = ZERO; v_17_22 = ZERO; v_18_22 = ZERO; v_20_22 = ZERO; v_22_22 = ZERO; v_26_22 = ZERO
!     v__1_26 = ZERO; v_11_26 = ZERO; v_27_26 = ZERO; v__2_26 = ZERO; v_13_26 = ZERO; v_28_26 = ZERO
!     v__3_26 = ZERO; v__9_26 = ZERO; v_19_26 = ZERO; v__4_26 = ZERO; v__5_26 = ZERO; v_14_26 = ZERO
!     v_24_26 = ZERO; v__6_26 = ZERO; v_15_26 = ZERO; v_25_26 = ZERO; v__7_26 = ZERO; v_21_26 = ZERO
!     v__8_26 = ZERO; v_23_26 = ZERO; v_10_26 = ZERO; v_12_26 = ZERO; v_17_26 = ZERO; v_18_26 = ZERO
!     v_20_26 = ZERO; v_22_26 = ZERO; v_26_26 = ZERO; v_16_16 = ZERO; v_31_16 = ZERO; v_16_31 = ZERO
!     v_31_31 = ZERO; v_29_16 = ZERO; v_29_31 = ZERO; v_30_16 = ZERO; v_30_31 = ZERO; v_16_29 = ZERO
!     v_31_29 = ZERO; v_29_29 = ZERO; v_30_29 = ZERO; v_16_30 = ZERO; v_31_30 = ZERO; v_29_30 = ZERO
!     v_30_30 = ZERO; v_16__1 = ZERO; v_31__1 = ZERO; v_16_11 = ZERO; v_31_11 = ZERO; v_16_27 = ZERO
!     v_31_27 = ZERO; v_29__1 = ZERO; v_29_11 = ZERO; v_29_27 = ZERO; v_30__1 = ZERO; v_30_11 = ZERO
!     v_30_27 = ZERO; v_16__2 = ZERO; v_31__2 = ZERO; v_16_13 = ZERO; v_31_13 = ZERO; v_16_28 = ZERO
!     v_31_28 = ZERO; v_29__2 = ZERO; v_29_13 = ZERO; v_29_28 = ZERO; v_30__2 = ZERO; v_30_13 = ZERO
!     v_30_28 = ZERO; v_16__3 = ZERO; v_31__3 = ZERO; v_16__9 = ZERO; v_31__9 = ZERO; v_16_19 = ZERO
!     v_31_19 = ZERO; v_29__3 = ZERO; v_29__9 = ZERO; v_29_19 = ZERO; v_30__3 = ZERO; v_30__9 = ZERO
!     v_30_19 = ZERO; v_16__4 = ZERO; v_31__4 = ZERO; v_29__4 = ZERO; v_30__4 = ZERO; v_16__5 = ZERO
!     v_31__5 = ZERO; v_16_14 = ZERO; v_31_14 = ZERO; v_16_24 = ZERO; v_31_24 = ZERO; v_29__5 = ZERO
!     v_29_14 = ZERO; v_29_24 = ZERO; v_30__5 = ZERO; v_30_14 = ZERO; v_30_24 = ZERO; v_16__6 = ZERO
!     v_31__6 = ZERO; v_16_15 = ZERO; v_31_15 = ZERO; v_16_25 = ZERO; v_31_25 = ZERO; v_29__6 = ZERO
!     v_29_15 = ZERO; v_29_25 = ZERO; v_30__6 = ZERO; v_30_15 = ZERO; v_30_25 = ZERO; v_16__7 = ZERO
!     v_31__7 = ZERO; v_16_21 = ZERO; v_31_21 = ZERO; v_29__7 = ZERO; v_29_21 = ZERO; v_30__7 = ZERO
!     v_30_21 = ZERO; v_16__8 = ZERO; v_31__8 = ZERO; v_16_23 = ZERO; v_31_23 = ZERO; v_29__8 = ZERO
!     v_29_23 = ZERO; v_30__8 = ZERO; v_30_23 = ZERO; v_16_10 = ZERO; v_31_10 = ZERO; v_29_10 = ZERO
!     v_30_10 = ZERO; v_16_12 = ZERO; v_31_12 = ZERO; v_29_12 = ZERO; v_30_12 = ZERO; v_16_17 = ZERO
!     v_31_17 = ZERO; v_29_17 = ZERO; v_30_17 = ZERO; v_16_18 = ZERO; v_31_18 = ZERO; v_29_18 = ZERO
!     v_30_18 = ZERO; v_16_20 = ZERO; v_31_20 = ZERO; v_29_20 = ZERO; v_30_20 = ZERO; v_16_22 = ZERO
!     v_31_22 = ZERO; v_29_22 = ZERO; v_30_22 = ZERO; v_16_26 = ZERO; v_31_26 = ZERO; v_29_26 = ZERO
!     v_30_26 = ZERO; v__1_16 = ZERO; v_11_16 = ZERO; v_27_16 = ZERO; v__1_31 = ZERO; v_11_31 = ZERO
!     v_27_31 = ZERO; v__2_16 = ZERO; v_13_16 = ZERO; v_28_16 = ZERO; v__2_31 = ZERO; v_13_31 = ZERO
!     v_28_31 = ZERO; v__3_16 = ZERO; v__9_16 = ZERO; v_19_16 = ZERO; v__3_31 = ZERO; v__9_31 = ZERO
!     v_19_31 = ZERO; v__4_16 = ZERO; v__4_31 = ZERO; v__5_16 = ZERO; v_14_16 = ZERO; v_24_16 = ZERO
!     v__5_31 = ZERO; v_14_31 = ZERO; v_24_31 = ZERO; v__6_16 = ZERO; v_15_16 = ZERO; v_25_16 = ZERO
!     v__6_31 = ZERO; v_15_31 = ZERO; v_25_31 = ZERO; v__7_16 = ZERO; v_21_16 = ZERO; v__7_31 = ZERO
!     v_21_31 = ZERO; v__8_16 = ZERO; v_23_16 = ZERO; v__8_31 = ZERO; v_23_31 = ZERO; v_10_16 = ZERO
!     v_10_31 = ZERO; v_12_16 = ZERO; v_12_31 = ZERO; v_17_16 = ZERO; v_17_31 = ZERO; v_18_16 = ZERO
!     v_18_31 = ZERO; v_20_16 = ZERO; v_20_31 = ZERO; v_22_16 = ZERO; v_22_31 = ZERO; v_26_16 = ZERO
!     v_26_31 = ZERO; v__1_29 = ZERO; v_11_29 = ZERO; v_27_29 = ZERO; v__2_29 = ZERO; v_13_29 = ZERO
!     v_28_29 = ZERO; v__3_29 = ZERO; v__9_29 = ZERO; v_19_29 = ZERO; v__4_29 = ZERO; v__5_29 = ZERO
!     v_14_29 = ZERO; v_24_29 = ZERO; v__6_29 = ZERO; v_15_29 = ZERO; v_25_29 = ZERO; v__7_29 = ZERO
!     v_21_29 = ZERO; v__8_29 = ZERO; v_23_29 = ZERO; v_10_29 = ZERO; v_12_29 = ZERO; v_17_29 = ZERO
!     v_18_29 = ZERO; v_20_29 = ZERO; v_22_29 = ZERO; v_26_29 = ZERO; v__1_30 = ZERO; v_11_30 = ZERO
!     v_27_30 = ZERO; v__2_30 = ZERO; v_13_30 = ZERO; v_28_30 = ZERO; v__3_30 = ZERO; v__9_30 = ZERO
!     v_19_30 = ZERO; v__4_30 = ZERO; v__5_30 = ZERO; v_14_30 = ZERO; v_24_30 = ZERO; v__6_30 = ZERO
!     v_15_30 = ZERO; v_25_30 = ZERO; v__7_30 = ZERO; v_21_30 = ZERO; v__8_30 = ZERO; v_23_30 = ZERO
!     v_10_30 = ZERO; v_12_30 = ZERO; v_17_30 = ZERO; v_18_30 = ZERO; v_20_30 = ZERO; v_22_30 = ZERO
!     v_26_30 = ZERO
!
!
!     do k = 1,.ab_n_gaussian_pairs
!         ab_cc = .ab_contraction_prefactor(k)
!         zeta = .ab_exponent_sum(k)
!         zinv = .ab_exponent_inv(k)
!         half_zinv = HALF * zinv
!         ab_cc = ab_cc * TWOPI5ON2
!         Px = .ab_pair_center(1,k)
!         Py = .ab_pair_center(2,k)
!         Pz = .ab_pair_center(3,k)
!         PAx = .ab_center_diff(1,k)
!         PAy = .ab_center_diff(2,k)
!         PAz = .ab_center_diff(3,k)
!         do j = 1,.cd_n_gaussian_pairs
!             cd_cc = .cd_contraction_prefactor(j)
!             eta  = .cd_exponent_sum(j)
!             einv = .cd_exponent_inv(j)
!             Qx = .cd_pair_center(1,j)
!             Qy = .cd_pair_center(2,j)
!             Qz = .cd_pair_center(3,j)
!             QCx = .cd_center_diff(1,j)
!             QCy = .cd_center_diff(2,j)
!             QCz = .cd_center_diff(3,j)
!             rho  = zeta * eta / (zeta + eta)
!             rho_zinv = rho * zinv
!             rho_einv = rho * einv
!             half_einv = HALF * einv
!             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
!             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
!             rys.get_weights(xx)
!             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
!
!             ! Now make the 2 dimensional integrals.
!             do n = 1,n_roots
!
!               t2      = rys.root(n)
!               wt      = rys.weight(n)
!               t2_rz = t2 * rho_zinv
!
!               Ix21 = PAx + t2_rz*QPx
!               Iy21 = PAy + t2_rz*QPy
!               Iz21 = PAz + t2_rz*QPz
!
!               ce  = (ONE - t2_rz) * half_zinv
!               Ix31 = Ix21*Ix21 + ce
!               Iy31 = Iy21*Iy21 + ce
!               Iz31 = Iz21*Iz21 + ce
!
!               ce1 = ce
!               ce1 = ce1 + ce
!               Ix41 = Ix21*Ix31 + ce1*Ix21
!               Iy41 = Iy21*Iy31 + ce1*Iy21
!               Iz41 = Iz21*Iz31 + ce1*Iz21
!
!               ce1 = ce1 + ce
!               Ix51 = Ix21*Ix41 + ce1*Ix31
!               Iy51 = Iy21*Iy41 + ce1*Iy31
!               Iz51 = Iz21*Iz41 + ce1*Iz31
!
!               t2_re = t2 * rho_einv
!               Ix12 = QCx - t2_re*QPx
!               Iy12 = QCy - t2_re*QPy
!               Iz12 = QCz - t2_re*QPz
!
!               cf  = (ONE - t2_re) * half_einv
!               Ix13 = Ix12*Ix12 + cf
!               Iy13 = Iy12*Iy12 + cf
!               Iz13 = Iz12*Iz12 + cf
!
!               cf1 = cf
!               cf1 = cf1 + cf
!               Ix14 = Ix12*Ix13 + cf1*Ix12
!               Iy14 = Iy12*Iy13 + cf1*Iy12
!               Iz14 = Iz12*Iz13 + cf1*Iz12
!
!               cf1 = cf1 + cf
!               Ix15 = Ix12*Ix14 + cf1*Ix13
!               Iy15 = Iy12*Iy14 + cf1*Iy13
!               Iz15 = Iz12*Iz14 + cf1*Iz13
!
!               bb = t2_rz * half_einv
!               Ix22 = Ix12*Ix21 + bb
!               Iy22 = Iy12*Iy21 + bb
!               Iz22 = Iz12*Iz21 + bb
!
!               Ix23 = Ix12*Ix22 + cf*Ix21 + bb*Ix12
!               Iy23 = Iy12*Iy22 + cf*Iy21 + bb*Iy12
!               Iz23 = Iz12*Iz22 + cf*Iz21 + bb*Iz12
!
!               Ix32 = Ix21*Ix22 + ce*Ix12 + bb*Ix21
!               Iy32 = Iy21*Iy22 + ce*Iy12 + bb*Iy21
!               Iz32 = Iz21*Iz22 + ce*Iz12 + bb*Iz21
!
!               cf1 = cf
!               cf1 = cf1 + cf
!               Ix24 = Ix12*Ix23 + cf1*Ix22 + bb*Ix13
!               Iy24 = Iy12*Iy23 + cf1*Iy22 + bb*Iy13
!               Iz24 = Iz12*Iz23 + cf1*Iz22 + bb*Iz13
!
!               cf1 = cf1 + cf
!               Ix25 = Ix12*Ix24 + cf1*Ix23 + bb*Ix14
!               Iy25 = Iy12*Iy24 + cf1*Iy23 + bb*Iy14
!               Iz25 = Iz12*Iz24 + cf1*Iz23 + bb*Iz14
!
!               ce1 = ce
!               ce1 = ce1 + ce
!               Ix42 = Ix21*Ix32 + ce1*Ix22 + bb*Ix31
!               Iy42 = Iy21*Iy32 + ce1*Iy22 + bb*Iy31
!               Iz42 = Iz21*Iz32 + ce1*Iz22 + bb*Iz31
!
!               ce1 = ce1 + ce
!               Ix52 = Ix21*Ix42 + ce1*Ix32 + bb*Ix41
!               Iy52 = Iy21*Iy42 + ce1*Iy32 + bb*Iy41
!               Iz52 = Iz21*Iz42 + ce1*Iz32 + bb*Iz41
!
!               f1_bb = bb
!               f1_bb = f1_bb + bb
!               ce1 = ZERO
!               ce1 = ce1 + ce
!               Ix33 = Ix21*Ix23 + ce1*Ix13 + f1_bb*Ix22
!               Iy33 = Iy21*Iy23 + ce1*Iy13 + f1_bb*Iy22
!               Iz33 = Iz21*Iz23 + ce1*Iz13 + f1_bb*Iz22
!
!               ce1 = ce1 + ce
!               Ix43 = Ix21*Ix33 + ce1*Ix23 + f1_bb*Ix32
!               Iy43 = Iy21*Iy33 + ce1*Iy23 + f1_bb*Iy32
!               Iz43 = Iz21*Iz33 + ce1*Iz23 + f1_bb*Iz32
!
!               ce1 = ce1 + ce
!               Ix53 = Ix21*Ix43 + ce1*Ix33 + f1_bb*Ix42
!               Iy53 = Iy21*Iy43 + ce1*Iy33 + f1_bb*Iy42
!               Iz53 = Iz21*Iz43 + ce1*Iz33 + f1_bb*Iz42
!
!               f1_bb = f1_bb + bb
!               ce1 = ZERO
!               ce1 = ce1 + ce
!               Ix34 = Ix21*Ix24 + ce1*Ix14 + f1_bb*Ix23
!               Iy34 = Iy21*Iy24 + ce1*Iy14 + f1_bb*Iy23
!               Iz34 = Iz21*Iz24 + ce1*Iz14 + f1_bb*Iz23
!
!               ce1 = ce1 + ce
!               Ix44 = Ix21*Ix34 + ce1*Ix24 + f1_bb*Ix33
!               Iy44 = Iy21*Iy34 + ce1*Iy24 + f1_bb*Iy33
!               Iz44 = Iz21*Iz34 + ce1*Iz24 + f1_bb*Iz33
!
!               ce1 = ce1 + ce
!               Ix54 = Ix21*Ix44 + ce1*Ix34 + f1_bb*Ix43
!               Iy54 = Iy21*Iy44 + ce1*Iy34 + f1_bb*Iy43
!               Iz54 = Iz21*Iz44 + ce1*Iz34 + f1_bb*Iz43
!
!               f1_bb = f1_bb + bb
!               ce1 = ZERO
!               ce1 = ce1 + ce
!               Ix35 = Ix21*Ix25 + ce1*Ix15 + f1_bb*Ix24
!               Iy35 = Iy21*Iy25 + ce1*Iy15 + f1_bb*Iy24
!               Iz35 = Iz21*Iz25 + ce1*Iz15 + f1_bb*Iz24
!
!               ce1 = ce1 + ce
!               Ix45 = Ix21*Ix35 + ce1*Ix25 + f1_bb*Ix34
!               Iy45 = Iy21*Iy35 + ce1*Iy25 + f1_bb*Iy34
!               Iz45 = Iz21*Iz35 + ce1*Iz25 + f1_bb*Iz34
!
!               ce1 = ce1 + ce
!               Ix55 = Ix21*Ix45 + ce1*Ix35 + f1_bb*Ix44
!               Iy55 = Iy21*Iy45 + ce1*Iy35 + f1_bb*Iy44
!               Iz55 = Iz21*Iz45 + ce1*Iz35 + f1_bb*Iz44
!
!               Iz21 = Iz21*wt
!               Iz31 = Iz31*wt
!               Iz41 = Iz41*wt
!               Iz51 = Iz51*wt
!
!               Iz12 = Iz12*wt
!               Iz22 = Iz22*wt
!               Iz32 = Iz32*wt
!               Iz42 = Iz42*wt
!               Iz52 = Iz52*wt
!
!               Iz13 = Iz13*wt
!               Iz23 = Iz23*wt
!               Iz33 = Iz33*wt
!               Iz43 = Iz43*wt
!               Iz53 = Iz53*wt
!
!               Iz14 = Iz14*wt
!               Iz24 = Iz24*wt
!               Iz34 = Iz34*wt
!               Iz44 = Iz44*wt
!               Iz54 = Iz54*wt
!
!               Iz15 = Iz15*wt
!               Iz25 = Iz25*wt
!               Iz35 = Iz35*wt
!               Iz45 = Iz45*wt
!               Iz55 = Iz55*wt
!
!               v__1__1 = v__1__1 + Ix33*wt
!               v_11__1 = v_11__1 + Ix33*Iz21
!               v_27__1 = v_27__1 + Ix33*Iz31
!               v__1_11 = v__1_11 + Ix33*Iz12
!               v_11_11 = v_11_11 + Ix33*Iz22
!               v_27_11 = v_27_11 + Ix33*Iz32
!               v__1_27 = v__1_27 + Ix33*Iz13
!               v_11_27 = v_11_27 + Ix33*Iz23
!               v_27_27 = v_27_27 + Ix33*Iz33
!               Ixy = Ix13*Iy31
!               v__2__1 = v__2__1 + Ixy*wt
!               v_13__1 = v_13__1 + Ixy*Iz21
!               v_28__1 = v_28__1 + Ixy*Iz31
!               v__2_11 = v__2_11 + Ixy*Iz12
!               v_13_11 = v_13_11 + Ixy*Iz22
!               v_28_11 = v_28_11 + Ixy*Iz32
!               v__2_27 = v__2_27 + Ixy*Iz13
!               v_13_27 = v_13_27 + Ixy*Iz23
!               v_28_27 = v_28_27 + Ixy*Iz33
!               v__3__1 = v__3__1 + Ix13*Iz31
!               v__9__1 = v__9__1 + Ix13*Iz41
!               v_19__1 = v_19__1 + Ix13*Iz51
!               v__3_11 = v__3_11 + Ix13*Iz32
!               v__9_11 = v__9_11 + Ix13*Iz42
!               v_19_11 = v_19_11 + Ix13*Iz52
!               v__3_27 = v__3_27 + Ix13*Iz33
!               v__9_27 = v__9_27 + Ix13*Iz43
!               v_19_27 = v_19_27 + Ix13*Iz53
!               Ixy = Ix23*Iy21
!               v__4__1 = v__4__1 + Ixy*wt
!               v__4_11 = v__4_11 + Ixy*Iz12
!               v__4_27 = v__4_27 + Ixy*Iz13
!               v__5__1 = v__5__1 + Ix23*Iz21
!               v_14__1 = v_14__1 + Ix23*Iz31
!               v_24__1 = v_24__1 + Ix23*Iz41
!               v__5_11 = v__5_11 + Ix23*Iz22
!               v_14_11 = v_14_11 + Ix23*Iz32
!               v_24_11 = v_24_11 + Ix23*Iz42
!               v__5_27 = v__5_27 + Ix23*Iz23
!               v_14_27 = v_14_27 + Ix23*Iz33
!               v_24_27 = v_24_27 + Ix23*Iz43
!               Ixy = Ix13*Iy21
!               v__6__1 = v__6__1 + Ixy*Iz21
!               v_15__1 = v_15__1 + Ixy*Iz31
!               v_25__1 = v_25__1 + Ixy*Iz41
!               v__6_11 = v__6_11 + Ixy*Iz22
!               v_15_11 = v_15_11 + Ixy*Iz32
!               v_25_11 = v_25_11 + Ixy*Iz42
!               v__6_27 = v__6_27 + Ixy*Iz23
!               v_15_27 = v_15_27 + Ixy*Iz33
!               v_25_27 = v_25_27 + Ixy*Iz43
!               v__7__1 = v__7__1 + Ix43*wt
!               v_21__1 = v_21__1 + Ix43*Iz21
!               v__7_11 = v__7_11 + Ix43*Iz12
!               v_21_11 = v_21_11 + Ix43*Iz22
!               v__7_27 = v__7_27 + Ix43*Iz13
!               v_21_27 = v_21_27 + Ix43*Iz23
!               Ixy = Ix13*Iy41
!               v__8__1 = v__8__1 + Ixy*wt
!               v_23__1 = v_23__1 + Ixy*Iz21
!               v__8_11 = v__8_11 + Ixy*Iz12
!               v_23_11 = v_23_11 + Ixy*Iz22
!               v__8_27 = v__8_27 + Ixy*Iz13
!               v_23_27 = v_23_27 + Ixy*Iz23
!               Ixy = Ix33*Iy21
!               v_10__1 = v_10__1 + Ixy*wt
!               v_10_11 = v_10_11 + Ixy*Iz12
!               v_10_27 = v_10_27 + Ixy*Iz13
!               Ixy = Ix23*Iy31
!               v_12__1 = v_12__1 + Ixy*wt
!               v_12_11 = v_12_11 + Ixy*Iz12
!               v_12_27 = v_12_27 + Ixy*Iz13
!               v_17__1 = v_17__1 + Ix53*wt
!               v_17_11 = v_17_11 + Ix53*Iz12
!               v_17_27 = v_17_27 + Ix53*Iz13
!               Ixy = Ix13*Iy51
!               v_18__1 = v_18__1 + Ixy*wt
!               v_18_11 = v_18_11 + Ixy*Iz12
!               v_18_27 = v_18_27 + Ixy*Iz13
!               Ixy = Ix43*Iy21
!               v_20__1 = v_20__1 + Ixy*wt
!               v_20_11 = v_20_11 + Ixy*Iz12
!               v_20_27 = v_20_27 + Ixy*Iz13
!               Ixy = Ix23*Iy41
!               v_22__1 = v_22__1 + Ixy*wt
!               v_22_11 = v_22_11 + Ixy*Iz12
!               v_22_27 = v_22_27 + Ixy*Iz13
!               Ixy = Ix33*Iy31
!               v_26__1 = v_26__1 + Ixy*wt
!               v_26_11 = v_26_11 + Ixy*Iz12
!               v_26_27 = v_26_27 + Ixy*Iz13
!               Ixy = Ix31*Iy13
!               v__1__2 = v__1__2 + Ixy*wt
!               v_11__2 = v_11__2 + Ixy*Iz21
!               v_27__2 = v_27__2 + Ixy*Iz31
!               v__1_13 = v__1_13 + Ixy*Iz12
!               v_11_13 = v_11_13 + Ixy*Iz22
!               v_27_13 = v_27_13 + Ixy*Iz32
!               v__1_28 = v__1_28 + Ixy*Iz13
!               v_11_28 = v_11_28 + Ixy*Iz23
!               v_27_28 = v_27_28 + Ixy*Iz33
!               v__2__2 = v__2__2 + Iy33*wt
!               v_13__2 = v_13__2 + Iy33*Iz21
!               v_28__2 = v_28__2 + Iy33*Iz31
!               v__2_13 = v__2_13 + Iy33*Iz12
!               v_13_13 = v_13_13 + Iy33*Iz22
!               v_28_13 = v_28_13 + Iy33*Iz32
!               v__2_28 = v__2_28 + Iy33*Iz13
!               v_13_28 = v_13_28 + Iy33*Iz23
!               v_28_28 = v_28_28 + Iy33*Iz33
!               v__3__2 = v__3__2 + Iy13*Iz31
!               v__9__2 = v__9__2 + Iy13*Iz41
!               v_19__2 = v_19__2 + Iy13*Iz51
!               v__3_13 = v__3_13 + Iy13*Iz32
!               v__9_13 = v__9_13 + Iy13*Iz42
!               v_19_13 = v_19_13 + Iy13*Iz52
!               v__3_28 = v__3_28 + Iy13*Iz33
!               v__9_28 = v__9_28 + Iy13*Iz43
!               v_19_28 = v_19_28 + Iy13*Iz53
!               Ixy = Ix21*Iy23
!               v__4__2 = v__4__2 + Ixy*wt
!               v__4_13 = v__4_13 + Ixy*Iz12
!               v__4_28 = v__4_28 + Ixy*Iz13
!               Ixy = Ix21*Iy13
!               v__5__2 = v__5__2 + Ixy*Iz21
!               v_14__2 = v_14__2 + Ixy*Iz31
!               v_24__2 = v_24__2 + Ixy*Iz41
!               v__5_13 = v__5_13 + Ixy*Iz22
!               v_14_13 = v_14_13 + Ixy*Iz32
!               v_24_13 = v_24_13 + Ixy*Iz42
!               v__5_28 = v__5_28 + Ixy*Iz23
!               v_14_28 = v_14_28 + Ixy*Iz33
!               v_24_28 = v_24_28 + Ixy*Iz43
!               v__6__2 = v__6__2 + Iy23*Iz21
!               v_15__2 = v_15__2 + Iy23*Iz31
!               v_25__2 = v_25__2 + Iy23*Iz41
!               v__6_13 = v__6_13 + Iy23*Iz22
!               v_15_13 = v_15_13 + Iy23*Iz32
!               v_25_13 = v_25_13 + Iy23*Iz42
!               v__6_28 = v__6_28 + Iy23*Iz23
!               v_15_28 = v_15_28 + Iy23*Iz33
!               v_25_28 = v_25_28 + Iy23*Iz43
!               Ixy = Ix41*Iy13
!               v__7__2 = v__7__2 + Ixy*wt
!               v_21__2 = v_21__2 + Ixy*Iz21
!               v__7_13 = v__7_13 + Ixy*Iz12
!               v_21_13 = v_21_13 + Ixy*Iz22
!               v__7_28 = v__7_28 + Ixy*Iz13
!               v_21_28 = v_21_28 + Ixy*Iz23
!               v__8__2 = v__8__2 + Iy43*wt
!               v_23__2 = v_23__2 + Iy43*Iz21
!               v__8_13 = v__8_13 + Iy43*Iz12
!               v_23_13 = v_23_13 + Iy43*Iz22
!               v__8_28 = v__8_28 + Iy43*Iz13
!               v_23_28 = v_23_28 + Iy43*Iz23
!               Ixy = Ix31*Iy23
!               v_10__2 = v_10__2 + Ixy*wt
!               v_10_13 = v_10_13 + Ixy*Iz12
!               v_10_28 = v_10_28 + Ixy*Iz13
!               Ixy = Ix21*Iy33
!               v_12__2 = v_12__2 + Ixy*wt
!               v_12_13 = v_12_13 + Ixy*Iz12
!               v_12_28 = v_12_28 + Ixy*Iz13
!               Ixy = Ix51*Iy13
!               v_17__2 = v_17__2 + Ixy*wt
!               v_17_13 = v_17_13 + Ixy*Iz12
!               v_17_28 = v_17_28 + Ixy*Iz13
!               v_18__2 = v_18__2 + Iy53*wt
!               v_18_13 = v_18_13 + Iy53*Iz12
!               v_18_28 = v_18_28 + Iy53*Iz13
!               Ixy = Ix41*Iy23
!               v_20__2 = v_20__2 + Ixy*wt
!               v_20_13 = v_20_13 + Ixy*Iz12
!               v_20_28 = v_20_28 + Ixy*Iz13
!               Ixy = Ix21*Iy43
!               v_22__2 = v_22__2 + Ixy*wt
!               v_22_13 = v_22_13 + Ixy*Iz12
!               v_22_28 = v_22_28 + Ixy*Iz13
!               Ixy = Ix31*Iy33
!               v_26__2 = v_26__2 + Ixy*wt
!               v_26_13 = v_26_13 + Ixy*Iz12
!               v_26_28 = v_26_28 + Ixy*Iz13
!               v__1__3 = v__1__3 + Ix31*Iz13
!               v_11__3 = v_11__3 + Ix31*Iz23
!               v_27__3 = v_27__3 + Ix31*Iz33
!               v__1__9 = v__1__9 + Ix31*Iz14
!               v_11__9 = v_11__9 + Ix31*Iz24
!               v_27__9 = v_27__9 + Ix31*Iz34
!               v__1_19 = v__1_19 + Ix31*Iz15
!               v_11_19 = v_11_19 + Ix31*Iz25
!               v_27_19 = v_27_19 + Ix31*Iz35
!               v__2__3 = v__2__3 + Iy31*Iz13
!               v_13__3 = v_13__3 + Iy31*Iz23
!               v_28__3 = v_28__3 + Iy31*Iz33
!               v__2__9 = v__2__9 + Iy31*Iz14
!               v_13__9 = v_13__9 + Iy31*Iz24
!               v_28__9 = v_28__9 + Iy31*Iz34
!               v__2_19 = v__2_19 + Iy31*Iz15
!               v_13_19 = v_13_19 + Iy31*Iz25
!               v_28_19 = v_28_19 + Iy31*Iz35
!               v__3__3 = v__3__3 + Iz33
!               v__9__3 = v__9__3 + Iz43
!               v_19__3 = v_19__3 + Iz53
!               v__3__9 = v__3__9 + Iz34
!               v__9__9 = v__9__9 + Iz44
!               v_19__9 = v_19__9 + Iz54
!               v__3_19 = v__3_19 + Iz35
!               v__9_19 = v__9_19 + Iz45
!               v_19_19 = v_19_19 + Iz55
!               Ixy = Ix21*Iy21
!               v__4__3 = v__4__3 + Ixy*Iz13
!               v__4__9 = v__4__9 + Ixy*Iz14
!               v__4_19 = v__4_19 + Ixy*Iz15
!               v__5__3 = v__5__3 + Ix21*Iz23
!               v_14__3 = v_14__3 + Ix21*Iz33
!               v_24__3 = v_24__3 + Ix21*Iz43
!               v__5__9 = v__5__9 + Ix21*Iz24
!               v_14__9 = v_14__9 + Ix21*Iz34
!               v_24__9 = v_24__9 + Ix21*Iz44
!               v__5_19 = v__5_19 + Ix21*Iz25
!               v_14_19 = v_14_19 + Ix21*Iz35
!               v_24_19 = v_24_19 + Ix21*Iz45
!               v__6__3 = v__6__3 + Iy21*Iz23
!               v_15__3 = v_15__3 + Iy21*Iz33
!               v_25__3 = v_25__3 + Iy21*Iz43
!               v__6__9 = v__6__9 + Iy21*Iz24
!               v_15__9 = v_15__9 + Iy21*Iz34
!               v_25__9 = v_25__9 + Iy21*Iz44
!               v__6_19 = v__6_19 + Iy21*Iz25
!               v_15_19 = v_15_19 + Iy21*Iz35
!               v_25_19 = v_25_19 + Iy21*Iz45
!               v__7__3 = v__7__3 + Ix41*Iz13
!               v_21__3 = v_21__3 + Ix41*Iz23
!               v__7__9 = v__7__9 + Ix41*Iz14
!               v_21__9 = v_21__9 + Ix41*Iz24
!               v__7_19 = v__7_19 + Ix41*Iz15
!               v_21_19 = v_21_19 + Ix41*Iz25
!               v__8__3 = v__8__3 + Iy41*Iz13
!               v_23__3 = v_23__3 + Iy41*Iz23
!               v__8__9 = v__8__9 + Iy41*Iz14
!               v_23__9 = v_23__9 + Iy41*Iz24
!               v__8_19 = v__8_19 + Iy41*Iz15
!               v_23_19 = v_23_19 + Iy41*Iz25
!               Ixy = Ix31*Iy21
!               v_10__3 = v_10__3 + Ixy*Iz13
!               v_10__9 = v_10__9 + Ixy*Iz14
!               v_10_19 = v_10_19 + Ixy*Iz15
!               Ixy = Ix21*Iy31
!               v_12__3 = v_12__3 + Ixy*Iz13
!               v_12__9 = v_12__9 + Ixy*Iz14
!               v_12_19 = v_12_19 + Ixy*Iz15
!               v_17__3 = v_17__3 + Ix51*Iz13
!               v_17__9 = v_17__9 + Ix51*Iz14
!               v_17_19 = v_17_19 + Ix51*Iz15
!               v_18__3 = v_18__3 + Iy51*Iz13
!               v_18__9 = v_18__9 + Iy51*Iz14
!               v_18_19 = v_18_19 + Iy51*Iz15
!               Ixy = Ix41*Iy21
!               v_20__3 = v_20__3 + Ixy*Iz13
!               v_20__9 = v_20__9 + Ixy*Iz14
!               v_20_19 = v_20_19 + Ixy*Iz15
!               Ixy = Ix21*Iy41
!               v_22__3 = v_22__3 + Ixy*Iz13
!               v_22__9 = v_22__9 + Ixy*Iz14
!               v_22_19 = v_22_19 + Ixy*Iz15
!               Ixy = Ix31*Iy31
!               v_26__3 = v_26__3 + Ixy*Iz13
!               v_26__9 = v_26__9 + Ixy*Iz14
!               v_26_19 = v_26_19 + Ixy*Iz15
!               Ixy = Ix32*Iy12
!               v__1__4 = v__1__4 + Ixy*wt
!               v_11__4 = v_11__4 + Ixy*Iz21
!               v_27__4 = v_27__4 + Ixy*Iz31
!               Ixy = Ix12*Iy32
!               v__2__4 = v__2__4 + Ixy*wt
!               v_13__4 = v_13__4 + Ixy*Iz21
!               v_28__4 = v_28__4 + Ixy*Iz31
!               Ixy = Ix12*Iy12
!               v__3__4 = v__3__4 + Ixy*Iz31
!               v__9__4 = v__9__4 + Ixy*Iz41
!               v_19__4 = v_19__4 + Ixy*Iz51
!               v__4__4 = v__4__4 + Ix22*Iy22*wt
!               Ixy = Ix22*Iy12
!               v__5__4 = v__5__4 + Ixy*Iz21
!               v_14__4 = v_14__4 + Ixy*Iz31
!               v_24__4 = v_24__4 + Ixy*Iz41
!               Ixy = Ix12*Iy22
!               v__6__4 = v__6__4 + Ixy*Iz21
!               v_15__4 = v_15__4 + Ixy*Iz31
!               v_25__4 = v_25__4 + Ixy*Iz41
!               Ixy = Ix42*Iy12
!               v__7__4 = v__7__4 + Ixy*wt
!               v_21__4 = v_21__4 + Ixy*Iz21
!               Ixy = Ix12*Iy42
!               v__8__4 = v__8__4 + Ixy*wt
!               v_23__4 = v_23__4 + Ixy*Iz21
!               v_10__4 = v_10__4 + Ix32*Iy22*wt
!               v_12__4 = v_12__4 + Ix22*Iy32*wt
!               v_17__4 = v_17__4 + Ix52*Iy12*wt
!               v_18__4 = v_18__4 + Ix12*Iy52*wt
!               v_20__4 = v_20__4 + Ix42*Iy22*wt
!               v_22__4 = v_22__4 + Ix22*Iy42*wt
!               v_26__4 = v_26__4 + Ix32*Iy32*wt
!               v__1__5 = v__1__5 + Ix32*Iz12
!               v_11__5 = v_11__5 + Ix32*Iz22
!               v_27__5 = v_27__5 + Ix32*Iz32
!               v__1_14 = v__1_14 + Ix32*Iz13
!               v_11_14 = v_11_14 + Ix32*Iz23
!               v_27_14 = v_27_14 + Ix32*Iz33
!               v__1_24 = v__1_24 + Ix32*Iz14
!               v_11_24 = v_11_24 + Ix32*Iz24
!               v_27_24 = v_27_24 + Ix32*Iz34
!               Ixy = Ix12*Iy31
!               v__2__5 = v__2__5 + Ixy*Iz12
!               v_13__5 = v_13__5 + Ixy*Iz22
!               v_28__5 = v_28__5 + Ixy*Iz32
!               v__2_14 = v__2_14 + Ixy*Iz13
!               v_13_14 = v_13_14 + Ixy*Iz23
!               v_28_14 = v_28_14 + Ixy*Iz33
!               v__2_24 = v__2_24 + Ixy*Iz14
!               v_13_24 = v_13_24 + Ixy*Iz24
!               v_28_24 = v_28_24 + Ixy*Iz34
!               v__3__5 = v__3__5 + Ix12*Iz32
!               v__9__5 = v__9__5 + Ix12*Iz42
!               v_19__5 = v_19__5 + Ix12*Iz52
!               v__3_14 = v__3_14 + Ix12*Iz33
!               v__9_14 = v__9_14 + Ix12*Iz43
!               v_19_14 = v_19_14 + Ix12*Iz53
!               v__3_24 = v__3_24 + Ix12*Iz34
!               v__9_24 = v__9_24 + Ix12*Iz44
!               v_19_24 = v_19_24 + Ix12*Iz54
!               Ixy = Ix22*Iy21
!               v__4__5 = v__4__5 + Ixy*Iz12
!               v__4_14 = v__4_14 + Ixy*Iz13
!               v__4_24 = v__4_24 + Ixy*Iz14
!               v__5__5 = v__5__5 + Ix22*Iz22
!               v_14__5 = v_14__5 + Ix22*Iz32
!               v_24__5 = v_24__5 + Ix22*Iz42
!               v__5_14 = v__5_14 + Ix22*Iz23
!               v_14_14 = v_14_14 + Ix22*Iz33
!               v_24_14 = v_24_14 + Ix22*Iz43
!               v__5_24 = v__5_24 + Ix22*Iz24
!               v_14_24 = v_14_24 + Ix22*Iz34
!               v_24_24 = v_24_24 + Ix22*Iz44
!               Ixy = Ix12*Iy21
!               v__6__5 = v__6__5 + Ixy*Iz22
!               v_15__5 = v_15__5 + Ixy*Iz32
!               v_25__5 = v_25__5 + Ixy*Iz42
!               v__6_14 = v__6_14 + Ixy*Iz23
!               v_15_14 = v_15_14 + Ixy*Iz33
!               v_25_14 = v_25_14 + Ixy*Iz43
!               v__6_24 = v__6_24 + Ixy*Iz24
!               v_15_24 = v_15_24 + Ixy*Iz34
!               v_25_24 = v_25_24 + Ixy*Iz44
!               v__7__5 = v__7__5 + Ix42*Iz12
!               v_21__5 = v_21__5 + Ix42*Iz22
!               v__7_14 = v__7_14 + Ix42*Iz13
!               v_21_14 = v_21_14 + Ix42*Iz23
!               v__7_24 = v__7_24 + Ix42*Iz14
!               v_21_24 = v_21_24 + Ix42*Iz24
!               Ixy = Ix12*Iy41
!               v__8__5 = v__8__5 + Ixy*Iz12
!               v_23__5 = v_23__5 + Ixy*Iz22
!               v__8_14 = v__8_14 + Ixy*Iz13
!               v_23_14 = v_23_14 + Ixy*Iz23
!               v__8_24 = v__8_24 + Ixy*Iz14
!               v_23_24 = v_23_24 + Ixy*Iz24
!               Ixy = Ix32*Iy21
!               v_10__5 = v_10__5 + Ixy*Iz12
!               v_10_14 = v_10_14 + Ixy*Iz13
!               v_10_24 = v_10_24 + Ixy*Iz14
!               Ixy = Ix22*Iy31
!               v_12__5 = v_12__5 + Ixy*Iz12
!               v_12_14 = v_12_14 + Ixy*Iz13
!               v_12_24 = v_12_24 + Ixy*Iz14
!               v_17__5 = v_17__5 + Ix52*Iz12
!               v_17_14 = v_17_14 + Ix52*Iz13
!               v_17_24 = v_17_24 + Ix52*Iz14
!               Ixy = Ix12*Iy51
!               v_18__5 = v_18__5 + Ixy*Iz12
!               v_18_14 = v_18_14 + Ixy*Iz13
!               v_18_24 = v_18_24 + Ixy*Iz14
!               Ixy = Ix42*Iy21
!               v_20__5 = v_20__5 + Ixy*Iz12
!               v_20_14 = v_20_14 + Ixy*Iz13
!               v_20_24 = v_20_24 + Ixy*Iz14
!               Ixy = Ix22*Iy41
!               v_22__5 = v_22__5 + Ixy*Iz12
!               v_22_14 = v_22_14 + Ixy*Iz13
!               v_22_24 = v_22_24 + Ixy*Iz14
!               Ixy = Ix32*Iy31
!               v_26__5 = v_26__5 + Ixy*Iz12
!               v_26_14 = v_26_14 + Ixy*Iz13
!               v_26_24 = v_26_24 + Ixy*Iz14
!               Ixy = Ix31*Iy12
!               v__1__6 = v__1__6 + Ixy*Iz12
!               v_11__6 = v_11__6 + Ixy*Iz22
!               v_27__6 = v_27__6 + Ixy*Iz32
!               v__1_15 = v__1_15 + Ixy*Iz13
!               v_11_15 = v_11_15 + Ixy*Iz23
!               v_27_15 = v_27_15 + Ixy*Iz33
!               v__1_25 = v__1_25 + Ixy*Iz14
!               v_11_25 = v_11_25 + Ixy*Iz24
!               v_27_25 = v_27_25 + Ixy*Iz34
!               v__2__6 = v__2__6 + Iy32*Iz12
!               v_13__6 = v_13__6 + Iy32*Iz22
!               v_28__6 = v_28__6 + Iy32*Iz32
!               v__2_15 = v__2_15 + Iy32*Iz13
!               v_13_15 = v_13_15 + Iy32*Iz23
!               v_28_15 = v_28_15 + Iy32*Iz33
!               v__2_25 = v__2_25 + Iy32*Iz14
!               v_13_25 = v_13_25 + Iy32*Iz24
!               v_28_25 = v_28_25 + Iy32*Iz34
!               v__3__6 = v__3__6 + Iy12*Iz32
!               v__9__6 = v__9__6 + Iy12*Iz42
!               v_19__6 = v_19__6 + Iy12*Iz52
!               v__3_15 = v__3_15 + Iy12*Iz33
!               v__9_15 = v__9_15 + Iy12*Iz43
!               v_19_15 = v_19_15 + Iy12*Iz53
!               v__3_25 = v__3_25 + Iy12*Iz34
!               v__9_25 = v__9_25 + Iy12*Iz44
!               v_19_25 = v_19_25 + Iy12*Iz54
!               Ixy = Ix21*Iy22
!               v__4__6 = v__4__6 + Ixy*Iz12
!               v__4_15 = v__4_15 + Ixy*Iz13
!               v__4_25 = v__4_25 + Ixy*Iz14
!               Ixy = Ix21*Iy12
!               v__5__6 = v__5__6 + Ixy*Iz22
!               v_14__6 = v_14__6 + Ixy*Iz32
!               v_24__6 = v_24__6 + Ixy*Iz42
!               v__5_15 = v__5_15 + Ixy*Iz23
!               v_14_15 = v_14_15 + Ixy*Iz33
!               v_24_15 = v_24_15 + Ixy*Iz43
!               v__5_25 = v__5_25 + Ixy*Iz24
!               v_14_25 = v_14_25 + Ixy*Iz34
!               v_24_25 = v_24_25 + Ixy*Iz44
!               v__6__6 = v__6__6 + Iy22*Iz22
!               v_15__6 = v_15__6 + Iy22*Iz32
!               v_25__6 = v_25__6 + Iy22*Iz42
!               v__6_15 = v__6_15 + Iy22*Iz23
!               v_15_15 = v_15_15 + Iy22*Iz33
!               v_25_15 = v_25_15 + Iy22*Iz43
!               v__6_25 = v__6_25 + Iy22*Iz24
!               v_15_25 = v_15_25 + Iy22*Iz34
!               v_25_25 = v_25_25 + Iy22*Iz44
!               Ixy = Ix41*Iy12
!               v__7__6 = v__7__6 + Ixy*Iz12
!               v_21__6 = v_21__6 + Ixy*Iz22
!               v__7_15 = v__7_15 + Ixy*Iz13
!               v_21_15 = v_21_15 + Ixy*Iz23
!               v__7_25 = v__7_25 + Ixy*Iz14
!               v_21_25 = v_21_25 + Ixy*Iz24
!               v__8__6 = v__8__6 + Iy42*Iz12
!               v_23__6 = v_23__6 + Iy42*Iz22
!               v__8_15 = v__8_15 + Iy42*Iz13
!               v_23_15 = v_23_15 + Iy42*Iz23
!               v__8_25 = v__8_25 + Iy42*Iz14
!               v_23_25 = v_23_25 + Iy42*Iz24
!               Ixy = Ix31*Iy22
!               v_10__6 = v_10__6 + Ixy*Iz12
!               v_10_15 = v_10_15 + Ixy*Iz13
!               v_10_25 = v_10_25 + Ixy*Iz14
!               Ixy = Ix21*Iy32
!               v_12__6 = v_12__6 + Ixy*Iz12
!               v_12_15 = v_12_15 + Ixy*Iz13
!               v_12_25 = v_12_25 + Ixy*Iz14
!               Ixy = Ix51*Iy12
!               v_17__6 = v_17__6 + Ixy*Iz12
!               v_17_15 = v_17_15 + Ixy*Iz13
!               v_17_25 = v_17_25 + Ixy*Iz14
!               v_18__6 = v_18__6 + Iy52*Iz12
!               v_18_15 = v_18_15 + Iy52*Iz13
!               v_18_25 = v_18_25 + Iy52*Iz14
!               Ixy = Ix41*Iy22
!               v_20__6 = v_20__6 + Ixy*Iz12
!               v_20_15 = v_20_15 + Ixy*Iz13
!               v_20_25 = v_20_25 + Ixy*Iz14
!               Ixy = Ix21*Iy42
!               v_22__6 = v_22__6 + Ixy*Iz12
!               v_22_15 = v_22_15 + Ixy*Iz13
!               v_22_25 = v_22_25 + Ixy*Iz14
!               Ixy = Ix31*Iy32
!               v_26__6 = v_26__6 + Ixy*Iz12
!               v_26_15 = v_26_15 + Ixy*Iz13
!               v_26_25 = v_26_25 + Ixy*Iz14
!               v__1__7 = v__1__7 + Ix34*wt
!               v_11__7 = v_11__7 + Ix34*Iz21
!               v_27__7 = v_27__7 + Ix34*Iz31
!               v__1_21 = v__1_21 + Ix34*Iz12
!               v_11_21 = v_11_21 + Ix34*Iz22
!               v_27_21 = v_27_21 + Ix34*Iz32
!               Ixy = Ix14*Iy31
!               v__2__7 = v__2__7 + Ixy*wt
!               v_13__7 = v_13__7 + Ixy*Iz21
!               v_28__7 = v_28__7 + Ixy*Iz31
!               v__2_21 = v__2_21 + Ixy*Iz12
!               v_13_21 = v_13_21 + Ixy*Iz22
!               v_28_21 = v_28_21 + Ixy*Iz32
!               v__3__7 = v__3__7 + Ix14*Iz31
!               v__9__7 = v__9__7 + Ix14*Iz41
!               v_19__7 = v_19__7 + Ix14*Iz51
!               v__3_21 = v__3_21 + Ix14*Iz32
!               v__9_21 = v__9_21 + Ix14*Iz42
!               v_19_21 = v_19_21 + Ix14*Iz52
!               Ixy = Ix24*Iy21
!               v__4__7 = v__4__7 + Ixy*wt
!               v__4_21 = v__4_21 + Ixy*Iz12
!               v__5__7 = v__5__7 + Ix24*Iz21
!               v_14__7 = v_14__7 + Ix24*Iz31
!               v_24__7 = v_24__7 + Ix24*Iz41
!               v__5_21 = v__5_21 + Ix24*Iz22
!               v_14_21 = v_14_21 + Ix24*Iz32
!               v_24_21 = v_24_21 + Ix24*Iz42
!               Ixy = Ix14*Iy21
!               v__6__7 = v__6__7 + Ixy*Iz21
!               v_15__7 = v_15__7 + Ixy*Iz31
!               v_25__7 = v_25__7 + Ixy*Iz41
!               v__6_21 = v__6_21 + Ixy*Iz22
!               v_15_21 = v_15_21 + Ixy*Iz32
!               v_25_21 = v_25_21 + Ixy*Iz42
!               v__7__7 = v__7__7 + Ix44*wt
!               v_21__7 = v_21__7 + Ix44*Iz21
!               v__7_21 = v__7_21 + Ix44*Iz12
!               v_21_21 = v_21_21 + Ix44*Iz22
!               Ixy = Ix14*Iy41
!               v__8__7 = v__8__7 + Ixy*wt
!               v_23__7 = v_23__7 + Ixy*Iz21
!               v__8_21 = v__8_21 + Ixy*Iz12
!               v_23_21 = v_23_21 + Ixy*Iz22
!               Ixy = Ix34*Iy21
!               v_10__7 = v_10__7 + Ixy*wt
!               v_10_21 = v_10_21 + Ixy*Iz12
!               Ixy = Ix24*Iy31
!               v_12__7 = v_12__7 + Ixy*wt
!               v_12_21 = v_12_21 + Ixy*Iz12
!               v_17__7 = v_17__7 + Ix54*wt
!               v_17_21 = v_17_21 + Ix54*Iz12
!               Ixy = Ix14*Iy51
!               v_18__7 = v_18__7 + Ixy*wt
!               v_18_21 = v_18_21 + Ixy*Iz12
!               Ixy = Ix44*Iy21
!               v_20__7 = v_20__7 + Ixy*wt
!               v_20_21 = v_20_21 + Ixy*Iz12
!               Ixy = Ix24*Iy41
!               v_22__7 = v_22__7 + Ixy*wt
!               v_22_21 = v_22_21 + Ixy*Iz12
!               Ixy = Ix34*Iy31
!               v_26__7 = v_26__7 + Ixy*wt
!               v_26_21 = v_26_21 + Ixy*Iz12
!               Ixy = Ix31*Iy14
!               v__1__8 = v__1__8 + Ixy*wt
!               v_11__8 = v_11__8 + Ixy*Iz21
!               v_27__8 = v_27__8 + Ixy*Iz31
!               v__1_23 = v__1_23 + Ixy*Iz12
!               v_11_23 = v_11_23 + Ixy*Iz22
!               v_27_23 = v_27_23 + Ixy*Iz32
!               v__2__8 = v__2__8 + Iy34*wt
!               v_13__8 = v_13__8 + Iy34*Iz21
!               v_28__8 = v_28__8 + Iy34*Iz31
!               v__2_23 = v__2_23 + Iy34*Iz12
!               v_13_23 = v_13_23 + Iy34*Iz22
!               v_28_23 = v_28_23 + Iy34*Iz32
!               v__3__8 = v__3__8 + Iy14*Iz31
!               v__9__8 = v__9__8 + Iy14*Iz41
!               v_19__8 = v_19__8 + Iy14*Iz51
!               v__3_23 = v__3_23 + Iy14*Iz32
!               v__9_23 = v__9_23 + Iy14*Iz42
!               v_19_23 = v_19_23 + Iy14*Iz52
!               Ixy = Ix21*Iy24
!               v__4__8 = v__4__8 + Ixy*wt
!               v__4_23 = v__4_23 + Ixy*Iz12
!               Ixy = Ix21*Iy14
!               v__5__8 = v__5__8 + Ixy*Iz21
!               v_14__8 = v_14__8 + Ixy*Iz31
!               v_24__8 = v_24__8 + Ixy*Iz41
!               v__5_23 = v__5_23 + Ixy*Iz22
!               v_14_23 = v_14_23 + Ixy*Iz32
!               v_24_23 = v_24_23 + Ixy*Iz42
!               v__6__8 = v__6__8 + Iy24*Iz21
!               v_15__8 = v_15__8 + Iy24*Iz31
!               v_25__8 = v_25__8 + Iy24*Iz41
!               v__6_23 = v__6_23 + Iy24*Iz22
!               v_15_23 = v_15_23 + Iy24*Iz32
!               v_25_23 = v_25_23 + Iy24*Iz42
!               Ixy = Ix41*Iy14
!               v__7__8 = v__7__8 + Ixy*wt
!               v_21__8 = v_21__8 + Ixy*Iz21
!               v__7_23 = v__7_23 + Ixy*Iz12
!               v_21_23 = v_21_23 + Ixy*Iz22
!               v__8__8 = v__8__8 + Iy44*wt
!               v_23__8 = v_23__8 + Iy44*Iz21
!               v__8_23 = v__8_23 + Iy44*Iz12
!               v_23_23 = v_23_23 + Iy44*Iz22
!               Ixy = Ix31*Iy24
!               v_10__8 = v_10__8 + Ixy*wt
!               v_10_23 = v_10_23 + Ixy*Iz12
!               Ixy = Ix21*Iy34
!               v_12__8 = v_12__8 + Ixy*wt
!               v_12_23 = v_12_23 + Ixy*Iz12
!               Ixy = Ix51*Iy14
!               v_17__8 = v_17__8 + Ixy*wt
!               v_17_23 = v_17_23 + Ixy*Iz12
!               v_18__8 = v_18__8 + Iy54*wt
!               v_18_23 = v_18_23 + Iy54*Iz12
!               Ixy = Ix41*Iy24
!               v_20__8 = v_20__8 + Ixy*wt
!               v_20_23 = v_20_23 + Ixy*Iz12
!               Ixy = Ix21*Iy44
!               v_22__8 = v_22__8 + Ixy*wt
!               v_22_23 = v_22_23 + Ixy*Iz12
!               Ixy = Ix31*Iy34
!               v_26__8 = v_26__8 + Ixy*wt
!               v_26_23 = v_26_23 + Ixy*Iz12
!               Ixy = Ix33*Iy12
!               v__1_10 = v__1_10 + Ixy*wt
!               v_11_10 = v_11_10 + Ixy*Iz21
!               v_27_10 = v_27_10 + Ixy*Iz31
!               Ixy = Ix13*Iy32
!               v__2_10 = v__2_10 + Ixy*wt
!               v_13_10 = v_13_10 + Ixy*Iz21
!               v_28_10 = v_28_10 + Ixy*Iz31
!               Ixy = Ix13*Iy12
!               v__3_10 = v__3_10 + Ixy*Iz31
!               v__9_10 = v__9_10 + Ixy*Iz41
!               v_19_10 = v_19_10 + Ixy*Iz51
!               v__4_10 = v__4_10 + Ix23*Iy22*wt
!               Ixy = Ix23*Iy12
!               v__5_10 = v__5_10 + Ixy*Iz21
!               v_14_10 = v_14_10 + Ixy*Iz31
!               v_24_10 = v_24_10 + Ixy*Iz41
!               Ixy = Ix13*Iy22
!               v__6_10 = v__6_10 + Ixy*Iz21
!               v_15_10 = v_15_10 + Ixy*Iz31
!               v_25_10 = v_25_10 + Ixy*Iz41
!               Ixy = Ix43*Iy12
!               v__7_10 = v__7_10 + Ixy*wt
!               v_21_10 = v_21_10 + Ixy*Iz21
!               Ixy = Ix13*Iy42
!               v__8_10 = v__8_10 + Ixy*wt
!               v_23_10 = v_23_10 + Ixy*Iz21
!               v_10_10 = v_10_10 + Ix33*Iy22*wt
!               v_12_10 = v_12_10 + Ix23*Iy32*wt
!               v_17_10 = v_17_10 + Ix53*Iy12*wt
!               v_18_10 = v_18_10 + Ix13*Iy52*wt
!               v_20_10 = v_20_10 + Ix43*Iy22*wt
!               v_22_10 = v_22_10 + Ix23*Iy42*wt
!               v_26_10 = v_26_10 + Ix33*Iy32*wt
!               Ixy = Ix32*Iy13
!               v__1_12 = v__1_12 + Ixy*wt
!               v_11_12 = v_11_12 + Ixy*Iz21
!               v_27_12 = v_27_12 + Ixy*Iz31
!               Ixy = Ix12*Iy33
!               v__2_12 = v__2_12 + Ixy*wt
!               v_13_12 = v_13_12 + Ixy*Iz21
!               v_28_12 = v_28_12 + Ixy*Iz31
!               Ixy = Ix12*Iy13
!               v__3_12 = v__3_12 + Ixy*Iz31
!               v__9_12 = v__9_12 + Ixy*Iz41
!               v_19_12 = v_19_12 + Ixy*Iz51
!               v__4_12 = v__4_12 + Ix22*Iy23*wt
!               Ixy = Ix22*Iy13
!               v__5_12 = v__5_12 + Ixy*Iz21
!               v_14_12 = v_14_12 + Ixy*Iz31
!               v_24_12 = v_24_12 + Ixy*Iz41
!               Ixy = Ix12*Iy23
!               v__6_12 = v__6_12 + Ixy*Iz21
!               v_15_12 = v_15_12 + Ixy*Iz31
!               v_25_12 = v_25_12 + Ixy*Iz41
!               Ixy = Ix42*Iy13
!               v__7_12 = v__7_12 + Ixy*wt
!               v_21_12 = v_21_12 + Ixy*Iz21
!               Ixy = Ix12*Iy43
!               v__8_12 = v__8_12 + Ixy*wt
!               v_23_12 = v_23_12 + Ixy*Iz21
!               v_10_12 = v_10_12 + Ix32*Iy23*wt
!               v_12_12 = v_12_12 + Ix22*Iy33*wt
!               v_17_12 = v_17_12 + Ix52*Iy13*wt
!               v_18_12 = v_18_12 + Ix12*Iy53*wt
!               v_20_12 = v_20_12 + Ix42*Iy23*wt
!               v_22_12 = v_22_12 + Ix22*Iy43*wt
!               v_26_12 = v_26_12 + Ix32*Iy33*wt
!               v__1_17 = v__1_17 + Ix35*wt
!               v_11_17 = v_11_17 + Ix35*Iz21
!               v_27_17 = v_27_17 + Ix35*Iz31
!               Ixy = Ix15*Iy31
!               v__2_17 = v__2_17 + Ixy*wt
!               v_13_17 = v_13_17 + Ixy*Iz21
!               v_28_17 = v_28_17 + Ixy*Iz31
!               v__3_17 = v__3_17 + Ix15*Iz31
!               v__9_17 = v__9_17 + Ix15*Iz41
!               v_19_17 = v_19_17 + Ix15*Iz51
!               v__4_17 = v__4_17 + Ix25*Iy21*wt
!               v__5_17 = v__5_17 + Ix25*Iz21
!               v_14_17 = v_14_17 + Ix25*Iz31
!               v_24_17 = v_24_17 + Ix25*Iz41
!               Ixy = Ix15*Iy21
!               v__6_17 = v__6_17 + Ixy*Iz21
!               v_15_17 = v_15_17 + Ixy*Iz31
!               v_25_17 = v_25_17 + Ixy*Iz41
!               v__7_17 = v__7_17 + Ix45*wt
!               v_21_17 = v_21_17 + Ix45*Iz21
!               Ixy = Ix15*Iy41
!               v__8_17 = v__8_17 + Ixy*wt
!               v_23_17 = v_23_17 + Ixy*Iz21
!               v_10_17 = v_10_17 + Ix35*Iy21*wt
!               v_12_17 = v_12_17 + Ix25*Iy31*wt
!               v_17_17 = v_17_17 + Ix55*wt
!               v_18_17 = v_18_17 + Ix15*Iy51*wt
!               v_20_17 = v_20_17 + Ix45*Iy21*wt
!               v_22_17 = v_22_17 + Ix25*Iy41*wt
!               v_26_17 = v_26_17 + Ix35*Iy31*wt
!               Ixy = Ix31*Iy15
!               v__1_18 = v__1_18 + Ixy*wt
!               v_11_18 = v_11_18 + Ixy*Iz21
!               v_27_18 = v_27_18 + Ixy*Iz31
!               v__2_18 = v__2_18 + Iy35*wt
!               v_13_18 = v_13_18 + Iy35*Iz21
!               v_28_18 = v_28_18 + Iy35*Iz31
!               v__3_18 = v__3_18 + Iy15*Iz31
!               v__9_18 = v__9_18 + Iy15*Iz41
!               v_19_18 = v_19_18 + Iy15*Iz51
!               v__4_18 = v__4_18 + Ix21*Iy25*wt
!               Ixy = Ix21*Iy15
!               v__5_18 = v__5_18 + Ixy*Iz21
!               v_14_18 = v_14_18 + Ixy*Iz31
!               v_24_18 = v_24_18 + Ixy*Iz41
!               v__6_18 = v__6_18 + Iy25*Iz21
!               v_15_18 = v_15_18 + Iy25*Iz31
!               v_25_18 = v_25_18 + Iy25*Iz41
!               Ixy = Ix41*Iy15
!               v__7_18 = v__7_18 + Ixy*wt
!               v_21_18 = v_21_18 + Ixy*Iz21
!               v__8_18 = v__8_18 + Iy45*wt
!               v_23_18 = v_23_18 + Iy45*Iz21
!               v_10_18 = v_10_18 + Ix31*Iy25*wt
!               v_12_18 = v_12_18 + Ix21*Iy35*wt
!               v_17_18 = v_17_18 + Ix51*Iy15*wt
!               v_18_18 = v_18_18 + Iy55*wt
!               v_20_18 = v_20_18 + Ix41*Iy25*wt
!               v_22_18 = v_22_18 + Ix21*Iy45*wt
!               v_26_18 = v_26_18 + Ix31*Iy35*wt
!               Ixy = Ix34*Iy12
!               v__1_20 = v__1_20 + Ixy*wt
!               v_11_20 = v_11_20 + Ixy*Iz21
!               v_27_20 = v_27_20 + Ixy*Iz31
!               Ixy = Ix14*Iy32
!               v__2_20 = v__2_20 + Ixy*wt
!               v_13_20 = v_13_20 + Ixy*Iz21
!               v_28_20 = v_28_20 + Ixy*Iz31
!               Ixy = Ix14*Iy12
!               v__3_20 = v__3_20 + Ixy*Iz31
!               v__9_20 = v__9_20 + Ixy*Iz41
!               v_19_20 = v_19_20 + Ixy*Iz51
!               v__4_20 = v__4_20 + Ix24*Iy22*wt
!               Ixy = Ix24*Iy12
!               v__5_20 = v__5_20 + Ixy*Iz21
!               v_14_20 = v_14_20 + Ixy*Iz31
!               v_24_20 = v_24_20 + Ixy*Iz41
!               Ixy = Ix14*Iy22
!               v__6_20 = v__6_20 + Ixy*Iz21
!               v_15_20 = v_15_20 + Ixy*Iz31
!               v_25_20 = v_25_20 + Ixy*Iz41
!               Ixy = Ix44*Iy12
!               v__7_20 = v__7_20 + Ixy*wt
!               v_21_20 = v_21_20 + Ixy*Iz21
!               Ixy = Ix14*Iy42
!               v__8_20 = v__8_20 + Ixy*wt
!               v_23_20 = v_23_20 + Ixy*Iz21
!               v_10_20 = v_10_20 + Ix34*Iy22*wt
!               v_12_20 = v_12_20 + Ix24*Iy32*wt
!               v_17_20 = v_17_20 + Ix54*Iy12*wt
!               v_18_20 = v_18_20 + Ix14*Iy52*wt
!               v_20_20 = v_20_20 + Ix44*Iy22*wt
!               v_22_20 = v_22_20 + Ix24*Iy42*wt
!               v_26_20 = v_26_20 + Ix34*Iy32*wt
!               Ixy = Ix32*Iy14
!               v__1_22 = v__1_22 + Ixy*wt
!               v_11_22 = v_11_22 + Ixy*Iz21
!               v_27_22 = v_27_22 + Ixy*Iz31
!               Ixy = Ix12*Iy34
!               v__2_22 = v__2_22 + Ixy*wt
!               v_13_22 = v_13_22 + Ixy*Iz21
!               v_28_22 = v_28_22 + Ixy*Iz31
!               Ixy = Ix12*Iy14
!               v__3_22 = v__3_22 + Ixy*Iz31
!               v__9_22 = v__9_22 + Ixy*Iz41
!               v_19_22 = v_19_22 + Ixy*Iz51
!               v__4_22 = v__4_22 + Ix22*Iy24*wt
!               Ixy = Ix22*Iy14
!               v__5_22 = v__5_22 + Ixy*Iz21
!               v_14_22 = v_14_22 + Ixy*Iz31
!               v_24_22 = v_24_22 + Ixy*Iz41
!               Ixy = Ix12*Iy24
!               v__6_22 = v__6_22 + Ixy*Iz21
!               v_15_22 = v_15_22 + Ixy*Iz31
!               v_25_22 = v_25_22 + Ixy*Iz41
!               Ixy = Ix42*Iy14
!               v__7_22 = v__7_22 + Ixy*wt
!               v_21_22 = v_21_22 + Ixy*Iz21
!               Ixy = Ix12*Iy44
!               v__8_22 = v__8_22 + Ixy*wt
!               v_23_22 = v_23_22 + Ixy*Iz21
!               v_10_22 = v_10_22 + Ix32*Iy24*wt
!               v_12_22 = v_12_22 + Ix22*Iy34*wt
!               v_17_22 = v_17_22 + Ix52*Iy14*wt
!               v_18_22 = v_18_22 + Ix12*Iy54*wt
!               v_20_22 = v_20_22 + Ix42*Iy24*wt
!               v_22_22 = v_22_22 + Ix22*Iy44*wt
!               v_26_22 = v_26_22 + Ix32*Iy34*wt
!               Ixy = Ix33*Iy13
!               v__1_26 = v__1_26 + Ixy*wt
!               v_11_26 = v_11_26 + Ixy*Iz21
!               v_27_26 = v_27_26 + Ixy*Iz31
!               Ixy = Ix13*Iy33
!               v__2_26 = v__2_26 + Ixy*wt
!               v_13_26 = v_13_26 + Ixy*Iz21
!               v_28_26 = v_28_26 + Ixy*Iz31
!               Ixy = Ix13*Iy13
!               v__3_26 = v__3_26 + Ixy*Iz31
!               v__9_26 = v__9_26 + Ixy*Iz41
!               v_19_26 = v_19_26 + Ixy*Iz51
!               v__4_26 = v__4_26 + Ix23*Iy23*wt
!               Ixy = Ix23*Iy13
!               v__5_26 = v__5_26 + Ixy*Iz21
!               v_14_26 = v_14_26 + Ixy*Iz31
!               v_24_26 = v_24_26 + Ixy*Iz41
!               Ixy = Ix13*Iy23
!               v__6_26 = v__6_26 + Ixy*Iz21
!               v_15_26 = v_15_26 + Ixy*Iz31
!               v_25_26 = v_25_26 + Ixy*Iz41
!               Ixy = Ix43*Iy13
!               v__7_26 = v__7_26 + Ixy*wt
!               v_21_26 = v_21_26 + Ixy*Iz21
!               Ixy = Ix13*Iy43
!               v__8_26 = v__8_26 + Ixy*wt
!               v_23_26 = v_23_26 + Ixy*Iz21
!               v_10_26 = v_10_26 + Ix33*Iy23*wt
!               v_12_26 = v_12_26 + Ix23*Iy33*wt
!               v_17_26 = v_17_26 + Ix53*Iy13*wt
!               v_18_26 = v_18_26 + Ix13*Iy53*wt
!               v_20_26 = v_20_26 + Ix43*Iy23*wt
!               v_22_26 = v_22_26 + Ix23*Iy43*wt
!               v_26_26 = v_26_26 + Ix33*Iy33*wt
!               Ixy = Ix22*Iy22
!               v_16_16 = v_16_16 + Ixy*Iz22
!               v_31_16 = v_31_16 + Ixy*Iz32
!               v_16_31 = v_16_31 + Ixy*Iz23
!               v_31_31 = v_31_31 + Ixy*Iz33
!               Ixy = Ix32*Iy22
!               v_29_16 = v_29_16 + Ixy*Iz22
!               v_29_31 = v_29_31 + Ixy*Iz23
!               Ixy = Ix22*Iy32
!               v_30_16 = v_30_16 + Ixy*Iz22
!               v_30_31 = v_30_31 + Ixy*Iz23
!               Ixy = Ix23*Iy22
!               v_16_29 = v_16_29 + Ixy*Iz22
!               v_31_29 = v_31_29 + Ixy*Iz32
!               v_29_29 = v_29_29 + Ix33*Iy22*Iz22
!               v_30_29 = v_30_29 + Ix23*Iy32*Iz22
!               Ixy = Ix22*Iy23
!               v_16_30 = v_16_30 + Ixy*Iz22
!               v_31_30 = v_31_30 + Ixy*Iz32
!               v_29_30 = v_29_30 + Ix32*Iy23*Iz22
!               v_30_30 = v_30_30 + Ix22*Iy33*Iz22
!               Ixy = Ix23*Iy21
!               v_16__1 = v_16__1 + Ixy*Iz21
!               v_31__1 = v_31__1 + Ixy*Iz31
!               v_16_11 = v_16_11 + Ixy*Iz22
!               v_31_11 = v_31_11 + Ixy*Iz32
!               v_16_27 = v_16_27 + Ixy*Iz23
!               v_31_27 = v_31_27 + Ixy*Iz33
!               Ixy = Ix33*Iy21
!               v_29__1 = v_29__1 + Ixy*Iz21
!               v_29_11 = v_29_11 + Ixy*Iz22
!               v_29_27 = v_29_27 + Ixy*Iz23
!               Ixy = Ix23*Iy31
!               v_30__1 = v_30__1 + Ixy*Iz21
!               v_30_11 = v_30_11 + Ixy*Iz22
!               v_30_27 = v_30_27 + Ixy*Iz23
!               Ixy = Ix21*Iy23
!               v_16__2 = v_16__2 + Ixy*Iz21
!               v_31__2 = v_31__2 + Ixy*Iz31
!               v_16_13 = v_16_13 + Ixy*Iz22
!               v_31_13 = v_31_13 + Ixy*Iz32
!               v_16_28 = v_16_28 + Ixy*Iz23
!               v_31_28 = v_31_28 + Ixy*Iz33
!               Ixy = Ix31*Iy23
!               v_29__2 = v_29__2 + Ixy*Iz21
!               v_29_13 = v_29_13 + Ixy*Iz22
!               v_29_28 = v_29_28 + Ixy*Iz23
!               Ixy = Ix21*Iy33
!               v_30__2 = v_30__2 + Ixy*Iz21
!               v_30_13 = v_30_13 + Ixy*Iz22
!               v_30_28 = v_30_28 + Ixy*Iz23
!               Ixy = Ix21*Iy21
!               v_16__3 = v_16__3 + Ixy*Iz23
!               v_31__3 = v_31__3 + Ixy*Iz33
!               v_16__9 = v_16__9 + Ixy*Iz24
!               v_31__9 = v_31__9 + Ixy*Iz34
!               v_16_19 = v_16_19 + Ixy*Iz25
!               v_31_19 = v_31_19 + Ixy*Iz35
!               Ixy = Ix31*Iy21
!               v_29__3 = v_29__3 + Ixy*Iz23
!               v_29__9 = v_29__9 + Ixy*Iz24
!               v_29_19 = v_29_19 + Ixy*Iz25
!               Ixy = Ix21*Iy31
!               v_30__3 = v_30__3 + Ixy*Iz23
!               v_30__9 = v_30__9 + Ixy*Iz24
!               v_30_19 = v_30_19 + Ixy*Iz25
!               Ixy = Ix22*Iy22
!               v_16__4 = v_16__4 + Ixy*Iz21
!               v_31__4 = v_31__4 + Ixy*Iz31
!               v_29__4 = v_29__4 + Ix32*Iy22*Iz21
!               v_30__4 = v_30__4 + Ix22*Iy32*Iz21
!               Ixy = Ix22*Iy21
!               v_16__5 = v_16__5 + Ixy*Iz22
!               v_31__5 = v_31__5 + Ixy*Iz32
!               v_16_14 = v_16_14 + Ixy*Iz23
!               v_31_14 = v_31_14 + Ixy*Iz33
!               v_16_24 = v_16_24 + Ixy*Iz24
!               v_31_24 = v_31_24 + Ixy*Iz34
!               Ixy = Ix32*Iy21
!               v_29__5 = v_29__5 + Ixy*Iz22
!               v_29_14 = v_29_14 + Ixy*Iz23
!               v_29_24 = v_29_24 + Ixy*Iz24
!               Ixy = Ix22*Iy31
!               v_30__5 = v_30__5 + Ixy*Iz22
!               v_30_14 = v_30_14 + Ixy*Iz23
!               v_30_24 = v_30_24 + Ixy*Iz24
!               Ixy = Ix21*Iy22
!               v_16__6 = v_16__6 + Ixy*Iz22
!               v_31__6 = v_31__6 + Ixy*Iz32
!               v_16_15 = v_16_15 + Ixy*Iz23
!               v_31_15 = v_31_15 + Ixy*Iz33
!               v_16_25 = v_16_25 + Ixy*Iz24
!               v_31_25 = v_31_25 + Ixy*Iz34
!               Ixy = Ix31*Iy22
!               v_29__6 = v_29__6 + Ixy*Iz22
!               v_29_15 = v_29_15 + Ixy*Iz23
!               v_29_25 = v_29_25 + Ixy*Iz24
!               Ixy = Ix21*Iy32
!               v_30__6 = v_30__6 + Ixy*Iz22
!               v_30_15 = v_30_15 + Ixy*Iz23
!               v_30_25 = v_30_25 + Ixy*Iz24
!               Ixy = Ix24*Iy21
!               v_16__7 = v_16__7 + Ixy*Iz21
!               v_31__7 = v_31__7 + Ixy*Iz31
!               v_16_21 = v_16_21 + Ixy*Iz22
!               v_31_21 = v_31_21 + Ixy*Iz32
!               Ixy = Ix34*Iy21
!               v_29__7 = v_29__7 + Ixy*Iz21
!               v_29_21 = v_29_21 + Ixy*Iz22
!               Ixy = Ix24*Iy31
!               v_30__7 = v_30__7 + Ixy*Iz21
!               v_30_21 = v_30_21 + Ixy*Iz22
!               Ixy = Ix21*Iy24
!               v_16__8 = v_16__8 + Ixy*Iz21
!               v_31__8 = v_31__8 + Ixy*Iz31
!               v_16_23 = v_16_23 + Ixy*Iz22
!               v_31_23 = v_31_23 + Ixy*Iz32
!               Ixy = Ix31*Iy24
!               v_29__8 = v_29__8 + Ixy*Iz21
!               v_29_23 = v_29_23 + Ixy*Iz22
!               Ixy = Ix21*Iy34
!               v_30__8 = v_30__8 + Ixy*Iz21
!               v_30_23 = v_30_23 + Ixy*Iz22
!               Ixy = Ix23*Iy22
!               v_16_10 = v_16_10 + Ixy*Iz21
!               v_31_10 = v_31_10 + Ixy*Iz31
!               v_29_10 = v_29_10 + Ix33*Iy22*Iz21
!               v_30_10 = v_30_10 + Ix23*Iy32*Iz21
!               Ixy = Ix22*Iy23
!               v_16_12 = v_16_12 + Ixy*Iz21
!               v_31_12 = v_31_12 + Ixy*Iz31
!               v_29_12 = v_29_12 + Ix32*Iy23*Iz21
!               v_30_12 = v_30_12 + Ix22*Iy33*Iz21
!               Ixy = Ix25*Iy21
!               v_16_17 = v_16_17 + Ixy*Iz21
!               v_31_17 = v_31_17 + Ixy*Iz31
!               v_29_17 = v_29_17 + Ix35*Iy21*Iz21
!               v_30_17 = v_30_17 + Ix25*Iy31*Iz21
!               Ixy = Ix21*Iy25
!               v_16_18 = v_16_18 + Ixy*Iz21
!               v_31_18 = v_31_18 + Ixy*Iz31
!               v_29_18 = v_29_18 + Ix31*Iy25*Iz21
!               v_30_18 = v_30_18 + Ix21*Iy35*Iz21
!               Ixy = Ix24*Iy22
!               v_16_20 = v_16_20 + Ixy*Iz21
!               v_31_20 = v_31_20 + Ixy*Iz31
!               v_29_20 = v_29_20 + Ix34*Iy22*Iz21
!               v_30_20 = v_30_20 + Ix24*Iy32*Iz21
!               Ixy = Ix22*Iy24
!               v_16_22 = v_16_22 + Ixy*Iz21
!               v_31_22 = v_31_22 + Ixy*Iz31
!               v_29_22 = v_29_22 + Ix32*Iy24*Iz21
!               v_30_22 = v_30_22 + Ix22*Iy34*Iz21
!               Ixy = Ix23*Iy23
!               v_16_26 = v_16_26 + Ixy*Iz21
!               v_31_26 = v_31_26 + Ixy*Iz31
!               v_29_26 = v_29_26 + Ix33*Iy23*Iz21
!               v_30_26 = v_30_26 + Ix23*Iy33*Iz21
!               Ixy = Ix32*Iy12
!               v__1_16 = v__1_16 + Ixy*Iz12
!               v_11_16 = v_11_16 + Ixy*Iz22
!               v_27_16 = v_27_16 + Ixy*Iz32
!               v__1_31 = v__1_31 + Ixy*Iz13
!               v_11_31 = v_11_31 + Ixy*Iz23
!               v_27_31 = v_27_31 + Ixy*Iz33
!               Ixy = Ix12*Iy32
!               v__2_16 = v__2_16 + Ixy*Iz12
!               v_13_16 = v_13_16 + Ixy*Iz22
!               v_28_16 = v_28_16 + Ixy*Iz32
!               v__2_31 = v__2_31 + Ixy*Iz13
!               v_13_31 = v_13_31 + Ixy*Iz23
!               v_28_31 = v_28_31 + Ixy*Iz33
!               Ixy = Ix12*Iy12
!               v__3_16 = v__3_16 + Ixy*Iz32
!               v__9_16 = v__9_16 + Ixy*Iz42
!               v_19_16 = v_19_16 + Ixy*Iz52
!               v__3_31 = v__3_31 + Ixy*Iz33
!               v__9_31 = v__9_31 + Ixy*Iz43
!               v_19_31 = v_19_31 + Ixy*Iz53
!               Ixy = Ix22*Iy22
!               v__4_16 = v__4_16 + Ixy*Iz12
!               v__4_31 = v__4_31 + Ixy*Iz13
!               Ixy = Ix22*Iy12
!               v__5_16 = v__5_16 + Ixy*Iz22
!               v_14_16 = v_14_16 + Ixy*Iz32
!               v_24_16 = v_24_16 + Ixy*Iz42
!               v__5_31 = v__5_31 + Ixy*Iz23
!               v_14_31 = v_14_31 + Ixy*Iz33
!               v_24_31 = v_24_31 + Ixy*Iz43
!               Ixy = Ix12*Iy22
!               v__6_16 = v__6_16 + Ixy*Iz22
!               v_15_16 = v_15_16 + Ixy*Iz32
!               v_25_16 = v_25_16 + Ixy*Iz42
!               v__6_31 = v__6_31 + Ixy*Iz23
!               v_15_31 = v_15_31 + Ixy*Iz33
!               v_25_31 = v_25_31 + Ixy*Iz43
!               Ixy = Ix42*Iy12
!               v__7_16 = v__7_16 + Ixy*Iz12
!               v_21_16 = v_21_16 + Ixy*Iz22
!               v__7_31 = v__7_31 + Ixy*Iz13
!               v_21_31 = v_21_31 + Ixy*Iz23
!               Ixy = Ix12*Iy42
!               v__8_16 = v__8_16 + Ixy*Iz12
!               v_23_16 = v_23_16 + Ixy*Iz22
!               v__8_31 = v__8_31 + Ixy*Iz13
!               v_23_31 = v_23_31 + Ixy*Iz23
!               Ixy = Ix32*Iy22
!               v_10_16 = v_10_16 + Ixy*Iz12
!               v_10_31 = v_10_31 + Ixy*Iz13
!               Ixy = Ix22*Iy32
!               v_12_16 = v_12_16 + Ixy*Iz12
!               v_12_31 = v_12_31 + Ixy*Iz13
!               Ixy = Ix52*Iy12
!               v_17_16 = v_17_16 + Ixy*Iz12
!               v_17_31 = v_17_31 + Ixy*Iz13
!               Ixy = Ix12*Iy52
!               v_18_16 = v_18_16 + Ixy*Iz12
!               v_18_31 = v_18_31 + Ixy*Iz13
!               Ixy = Ix42*Iy22
!               v_20_16 = v_20_16 + Ixy*Iz12
!               v_20_31 = v_20_31 + Ixy*Iz13
!               Ixy = Ix22*Iy42
!               v_22_16 = v_22_16 + Ixy*Iz12
!               v_22_31 = v_22_31 + Ixy*Iz13
!               Ixy = Ix32*Iy32
!               v_26_16 = v_26_16 + Ixy*Iz12
!               v_26_31 = v_26_31 + Ixy*Iz13
!               Ixy = Ix33*Iy12
!               v__1_29 = v__1_29 + Ixy*Iz12
!               v_11_29 = v_11_29 + Ixy*Iz22
!               v_27_29 = v_27_29 + Ixy*Iz32
!               Ixy = Ix13*Iy32
!               v__2_29 = v__2_29 + Ixy*Iz12
!               v_13_29 = v_13_29 + Ixy*Iz22
!               v_28_29 = v_28_29 + Ixy*Iz32
!               Ixy = Ix13*Iy12
!               v__3_29 = v__3_29 + Ixy*Iz32
!               v__9_29 = v__9_29 + Ixy*Iz42
!               v_19_29 = v_19_29 + Ixy*Iz52
!               v__4_29 = v__4_29 + Ix23*Iy22*Iz12
!               Ixy = Ix23*Iy12
!               v__5_29 = v__5_29 + Ixy*Iz22
!               v_14_29 = v_14_29 + Ixy*Iz32
!               v_24_29 = v_24_29 + Ixy*Iz42
!               Ixy = Ix13*Iy22
!               v__6_29 = v__6_29 + Ixy*Iz22
!               v_15_29 = v_15_29 + Ixy*Iz32
!               v_25_29 = v_25_29 + Ixy*Iz42
!               Ixy = Ix43*Iy12
!               v__7_29 = v__7_29 + Ixy*Iz12
!               v_21_29 = v_21_29 + Ixy*Iz22
!               Ixy = Ix13*Iy42
!               v__8_29 = v__8_29 + Ixy*Iz12
!               v_23_29 = v_23_29 + Ixy*Iz22
!               v_10_29 = v_10_29 + Ix33*Iy22*Iz12
!               v_12_29 = v_12_29 + Ix23*Iy32*Iz12
!               v_17_29 = v_17_29 + Ix53*Iy12*Iz12
!               v_18_29 = v_18_29 + Ix13*Iy52*Iz12
!               v_20_29 = v_20_29 + Ix43*Iy22*Iz12
!               v_22_29 = v_22_29 + Ix23*Iy42*Iz12
!               v_26_29 = v_26_29 + Ix33*Iy32*Iz12
!               Ixy = Ix32*Iy13
!               v__1_30 = v__1_30 + Ixy*Iz12
!               v_11_30 = v_11_30 + Ixy*Iz22
!               v_27_30 = v_27_30 + Ixy*Iz32
!               Ixy = Ix12*Iy33
!               v__2_30 = v__2_30 + Ixy*Iz12
!               v_13_30 = v_13_30 + Ixy*Iz22
!               v_28_30 = v_28_30 + Ixy*Iz32
!               Ixy = Ix12*Iy13
!               v__3_30 = v__3_30 + Ixy*Iz32
!               v__9_30 = v__9_30 + Ixy*Iz42
!               v_19_30 = v_19_30 + Ixy*Iz52
!               v__4_30 = v__4_30 + Ix22*Iy23*Iz12
!               Ixy = Ix22*Iy13
!               v__5_30 = v__5_30 + Ixy*Iz22
!               v_14_30 = v_14_30 + Ixy*Iz32
!               v_24_30 = v_24_30 + Ixy*Iz42
!               Ixy = Ix12*Iy23
!               v__6_30 = v__6_30 + Ixy*Iz22
!               v_15_30 = v_15_30 + Ixy*Iz32
!               v_25_30 = v_25_30 + Ixy*Iz42
!               Ixy = Ix42*Iy13
!               v__7_30 = v__7_30 + Ixy*Iz12
!               v_21_30 = v_21_30 + Ixy*Iz22
!               Ixy = Ix12*Iy43
!               v__8_30 = v__8_30 + Ixy*Iz12
!               v_23_30 = v_23_30 + Ixy*Iz22
!               v_10_30 = v_10_30 + Ix32*Iy23*Iz12
!               v_12_30 = v_12_30 + Ix22*Iy33*Iz12
!               v_17_30 = v_17_30 + Ix52*Iy13*Iz12
!               v_18_30 = v_18_30 + Ix12*Iy53*Iz12
!               v_20_30 = v_20_30 + Ix42*Iy23*Iz12
!               v_22_30 = v_22_30 + Ix22*Iy43*Iz12
!               v_26_30 = v_26_30 + Ix32*Iy33*Iz12
!
!             end
!         end     ! -- loops over c,d
!     end         ! -- loops over a,b
!
!     rys.destroy
!
!     ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
!
!     esfs( 1, 1) = v__1__1
!     esfs(11, 1) = v_11__1
!     esfs(27, 1) = v_27__1
!     esfs( 1,11) = v__1_11
!     esfs(11,11) = v_11_11
!     esfs(27,11) = v_27_11
!     esfs( 1,27) = v__1_27
!     esfs(11,27) = v_11_27
!     esfs(27,27) = v_27_27
!     esfs( 2, 1) = v__2__1
!     esfs(13, 1) = v_13__1
!     esfs(28, 1) = v_28__1
!     esfs( 2,11) = v__2_11
!     esfs(13,11) = v_13_11
!     esfs(28,11) = v_28_11
!     esfs( 2,27) = v__2_27
!     esfs(13,27) = v_13_27
!     esfs(28,27) = v_28_27
!     esfs( 3, 1) = v__3__1
!     esfs( 9, 1) = v__9__1
!     esfs(19, 1) = v_19__1
!     esfs( 3,11) = v__3_11
!     esfs( 9,11) = v__9_11
!     esfs(19,11) = v_19_11
!     esfs( 3,27) = v__3_27
!     esfs( 9,27) = v__9_27
!     esfs(19,27) = v_19_27
!     esfs( 4, 1) = v__4__1
!     esfs( 4,11) = v__4_11
!     esfs( 4,27) = v__4_27
!     esfs( 5, 1) = v__5__1
!     esfs(14, 1) = v_14__1
!     esfs(24, 1) = v_24__1
!     esfs( 5,11) = v__5_11
!     esfs(14,11) = v_14_11
!     esfs(24,11) = v_24_11
!     esfs( 5,27) = v__5_27
!     esfs(14,27) = v_14_27
!     esfs(24,27) = v_24_27
!     esfs( 6, 1) = v__6__1
!     esfs(15, 1) = v_15__1
!     esfs(25, 1) = v_25__1
!     esfs( 6,11) = v__6_11
!     esfs(15,11) = v_15_11
!     esfs(25,11) = v_25_11
!     esfs( 6,27) = v__6_27
!     esfs(15,27) = v_15_27
!     esfs(25,27) = v_25_27
!     esfs( 7, 1) = v__7__1
!     esfs(21, 1) = v_21__1
!     esfs( 7,11) = v__7_11
!     esfs(21,11) = v_21_11
!     esfs( 7,27) = v__7_27
!     esfs(21,27) = v_21_27
!     esfs( 8, 1) = v__8__1
!     esfs(23, 1) = v_23__1
!     esfs( 8,11) = v__8_11
!     esfs(23,11) = v_23_11
!     esfs( 8,27) = v__8_27
!     esfs(23,27) = v_23_27
!     esfs(10, 1) = v_10__1
!     esfs(10,11) = v_10_11
!     esfs(10,27) = v_10_27
!     esfs(12, 1) = v_12__1
!     esfs(12,11) = v_12_11
!     esfs(12,27) = v_12_27
!     esfs(17, 1) = v_17__1
!     esfs(17,11) = v_17_11
!     esfs(17,27) = v_17_27
!     esfs(18, 1) = v_18__1
!     esfs(18,11) = v_18_11
!     esfs(18,27) = v_18_27
!     esfs(20, 1) = v_20__1
!     esfs(20,11) = v_20_11
!     esfs(20,27) = v_20_27
!     esfs(22, 1) = v_22__1
!     esfs(22,11) = v_22_11
!     esfs(22,27) = v_22_27
!     esfs(26, 1) = v_26__1
!     esfs(26,11) = v_26_11
!     esfs(26,27) = v_26_27
!     esfs( 1, 2) = v__1__2
!     esfs(11, 2) = v_11__2
!     esfs(27, 2) = v_27__2
!     esfs( 1,13) = v__1_13
!     esfs(11,13) = v_11_13
!     esfs(27,13) = v_27_13
!     esfs( 1,28) = v__1_28
!     esfs(11,28) = v_11_28
!     esfs(27,28) = v_27_28
!     esfs( 2, 2) = v__2__2
!     esfs(13, 2) = v_13__2
!     esfs(28, 2) = v_28__2
!     esfs( 2,13) = v__2_13
!     esfs(13,13) = v_13_13
!     esfs(28,13) = v_28_13
!     esfs( 2,28) = v__2_28
!     esfs(13,28) = v_13_28
!     esfs(28,28) = v_28_28
!     esfs( 3, 2) = v__3__2
!     esfs( 9, 2) = v__9__2
!     esfs(19, 2) = v_19__2
!     esfs( 3,13) = v__3_13
!     esfs( 9,13) = v__9_13
!     esfs(19,13) = v_19_13
!     esfs( 3,28) = v__3_28
!     esfs( 9,28) = v__9_28
!     esfs(19,28) = v_19_28
!     esfs( 4, 2) = v__4__2
!     esfs( 4,13) = v__4_13
!     esfs( 4,28) = v__4_28
!     esfs( 5, 2) = v__5__2
!     esfs(14, 2) = v_14__2
!     esfs(24, 2) = v_24__2
!     esfs( 5,13) = v__5_13
!     esfs(14,13) = v_14_13
!     esfs(24,13) = v_24_13
!     esfs( 5,28) = v__5_28
!     esfs(14,28) = v_14_28
!     esfs(24,28) = v_24_28
!     esfs( 6, 2) = v__6__2
!     esfs(15, 2) = v_15__2
!     esfs(25, 2) = v_25__2
!     esfs( 6,13) = v__6_13
!     esfs(15,13) = v_15_13
!     esfs(25,13) = v_25_13
!     esfs( 6,28) = v__6_28
!     esfs(15,28) = v_15_28
!     esfs(25,28) = v_25_28
!     esfs( 7, 2) = v__7__2
!     esfs(21, 2) = v_21__2
!     esfs( 7,13) = v__7_13
!     esfs(21,13) = v_21_13
!     esfs( 7,28) = v__7_28
!     esfs(21,28) = v_21_28
!     esfs( 8, 2) = v__8__2
!     esfs(23, 2) = v_23__2
!     esfs( 8,13) = v__8_13
!     esfs(23,13) = v_23_13
!     esfs( 8,28) = v__8_28
!     esfs(23,28) = v_23_28
!     esfs(10, 2) = v_10__2
!     esfs(10,13) = v_10_13
!     esfs(10,28) = v_10_28
!     esfs(12, 2) = v_12__2
!     esfs(12,13) = v_12_13
!     esfs(12,28) = v_12_28
!     esfs(17, 2) = v_17__2
!     esfs(17,13) = v_17_13
!     esfs(17,28) = v_17_28
!     esfs(18, 2) = v_18__2
!     esfs(18,13) = v_18_13
!     esfs(18,28) = v_18_28
!     esfs(20, 2) = v_20__2
!     esfs(20,13) = v_20_13
!     esfs(20,28) = v_20_28
!     esfs(22, 2) = v_22__2
!     esfs(22,13) = v_22_13
!     esfs(22,28) = v_22_28
!     esfs(26, 2) = v_26__2
!     esfs(26,13) = v_26_13
!     esfs(26,28) = v_26_28
!     esfs( 1, 3) = v__1__3
!     esfs(11, 3) = v_11__3
!     esfs(27, 3) = v_27__3
!     esfs( 1, 9) = v__1__9
!     esfs(11, 9) = v_11__9
!     esfs(27, 9) = v_27__9
!     esfs( 1,19) = v__1_19
!     esfs(11,19) = v_11_19
!     esfs(27,19) = v_27_19
!     esfs( 2, 3) = v__2__3
!     esfs(13, 3) = v_13__3
!     esfs(28, 3) = v_28__3
!     esfs( 2, 9) = v__2__9
!     esfs(13, 9) = v_13__9
!     esfs(28, 9) = v_28__9
!     esfs( 2,19) = v__2_19
!     esfs(13,19) = v_13_19
!     esfs(28,19) = v_28_19
!     esfs( 3, 3) = v__3__3
!     esfs( 9, 3) = v__9__3
!     esfs(19, 3) = v_19__3
!     esfs( 3, 9) = v__3__9
!     esfs( 9, 9) = v__9__9
!     esfs(19, 9) = v_19__9
!     esfs( 3,19) = v__3_19
!     esfs( 9,19) = v__9_19
!     esfs(19,19) = v_19_19
!     esfs( 4, 3) = v__4__3
!     esfs( 4, 9) = v__4__9
!     esfs( 4,19) = v__4_19
!     esfs( 5, 3) = v__5__3
!     esfs(14, 3) = v_14__3
!     esfs(24, 3) = v_24__3
!     esfs( 5, 9) = v__5__9
!     esfs(14, 9) = v_14__9
!     esfs(24, 9) = v_24__9
!     esfs( 5,19) = v__5_19
!     esfs(14,19) = v_14_19
!     esfs(24,19) = v_24_19
!     esfs( 6, 3) = v__6__3
!     esfs(15, 3) = v_15__3
!     esfs(25, 3) = v_25__3
!     esfs( 6, 9) = v__6__9
!     esfs(15, 9) = v_15__9
!     esfs(25, 9) = v_25__9
!     esfs( 6,19) = v__6_19
!     esfs(15,19) = v_15_19
!     esfs(25,19) = v_25_19
!     esfs( 7, 3) = v__7__3
!     esfs(21, 3) = v_21__3
!     esfs( 7, 9) = v__7__9
!     esfs(21, 9) = v_21__9
!     esfs( 7,19) = v__7_19
!     esfs(21,19) = v_21_19
!     esfs( 8, 3) = v__8__3
!     esfs(23, 3) = v_23__3
!     esfs( 8, 9) = v__8__9
!     esfs(23, 9) = v_23__9
!     esfs( 8,19) = v__8_19
!     esfs(23,19) = v_23_19
!     esfs(10, 3) = v_10__3
!     esfs(10, 9) = v_10__9
!     esfs(10,19) = v_10_19
!     esfs(12, 3) = v_12__3
!     esfs(12, 9) = v_12__9
!     esfs(12,19) = v_12_19
!     esfs(17, 3) = v_17__3
!     esfs(17, 9) = v_17__9
!     esfs(17,19) = v_17_19
!     esfs(18, 3) = v_18__3
!     esfs(18, 9) = v_18__9
!     esfs(18,19) = v_18_19
!     esfs(20, 3) = v_20__3
!     esfs(20, 9) = v_20__9
!     esfs(20,19) = v_20_19
!     esfs(22, 3) = v_22__3
!     esfs(22, 9) = v_22__9
!     esfs(22,19) = v_22_19
!     esfs(26, 3) = v_26__3
!     esfs(26, 9) = v_26__9
!     esfs(26,19) = v_26_19
!     esfs( 1, 4) = v__1__4
!     esfs(11, 4) = v_11__4
!     esfs(27, 4) = v_27__4
!     esfs( 2, 4) = v__2__4
!     esfs(13, 4) = v_13__4
!     esfs(28, 4) = v_28__4
!     esfs( 3, 4) = v__3__4
!     esfs( 9, 4) = v__9__4
!     esfs(19, 4) = v_19__4
!     esfs( 4, 4) = v__4__4
!     esfs( 5, 4) = v__5__4
!     esfs(14, 4) = v_14__4
!     esfs(24, 4) = v_24__4
!     esfs( 6, 4) = v__6__4
!     esfs(15, 4) = v_15__4
!     esfs(25, 4) = v_25__4
!     esfs( 7, 4) = v__7__4
!     esfs(21, 4) = v_21__4
!     esfs( 8, 4) = v__8__4
!     esfs(23, 4) = v_23__4
!     esfs(10, 4) = v_10__4
!     esfs(12, 4) = v_12__4
!     esfs(17, 4) = v_17__4
!     esfs(18, 4) = v_18__4
!     esfs(20, 4) = v_20__4
!     esfs(22, 4) = v_22__4
!     esfs(26, 4) = v_26__4
!     esfs( 1, 5) = v__1__5
!     esfs(11, 5) = v_11__5
!     esfs(27, 5) = v_27__5
!     esfs( 1,14) = v__1_14
!     esfs(11,14) = v_11_14
!     esfs(27,14) = v_27_14
!     esfs( 1,24) = v__1_24
!     esfs(11,24) = v_11_24
!     esfs(27,24) = v_27_24
!     esfs( 2, 5) = v__2__5
!     esfs(13, 5) = v_13__5
!     esfs(28, 5) = v_28__5
!     esfs( 2,14) = v__2_14
!     esfs(13,14) = v_13_14
!     esfs(28,14) = v_28_14
!     esfs( 2,24) = v__2_24
!     esfs(13,24) = v_13_24
!     esfs(28,24) = v_28_24
!     esfs( 3, 5) = v__3__5
!     esfs( 9, 5) = v__9__5
!     esfs(19, 5) = v_19__5
!     esfs( 3,14) = v__3_14
!     esfs( 9,14) = v__9_14
!     esfs(19,14) = v_19_14
!     esfs( 3,24) = v__3_24
!     esfs( 9,24) = v__9_24
!     esfs(19,24) = v_19_24
!     esfs( 4, 5) = v__4__5
!     esfs( 4,14) = v__4_14
!     esfs( 4,24) = v__4_24
!     esfs( 5, 5) = v__5__5
!     esfs(14, 5) = v_14__5
!     esfs(24, 5) = v_24__5
!     esfs( 5,14) = v__5_14
!     esfs(14,14) = v_14_14
!     esfs(24,14) = v_24_14
!     esfs( 5,24) = v__5_24
!     esfs(14,24) = v_14_24
!     esfs(24,24) = v_24_24
!     esfs( 6, 5) = v__6__5
!     esfs(15, 5) = v_15__5
!     esfs(25, 5) = v_25__5
!     esfs( 6,14) = v__6_14
!     esfs(15,14) = v_15_14
!     esfs(25,14) = v_25_14
!     esfs( 6,24) = v__6_24
!     esfs(15,24) = v_15_24
!     esfs(25,24) = v_25_24
!     esfs( 7, 5) = v__7__5
!     esfs(21, 5) = v_21__5
!     esfs( 7,14) = v__7_14
!     esfs(21,14) = v_21_14
!     esfs( 7,24) = v__7_24
!     esfs(21,24) = v_21_24
!     esfs( 8, 5) = v__8__5
!     esfs(23, 5) = v_23__5
!     esfs( 8,14) = v__8_14
!     esfs(23,14) = v_23_14
!     esfs( 8,24) = v__8_24
!     esfs(23,24) = v_23_24
!     esfs(10, 5) = v_10__5
!     esfs(10,14) = v_10_14
!     esfs(10,24) = v_10_24
!     esfs(12, 5) = v_12__5
!     esfs(12,14) = v_12_14
!     esfs(12,24) = v_12_24
!     esfs(17, 5) = v_17__5
!     esfs(17,14) = v_17_14
!     esfs(17,24) = v_17_24
!     esfs(18, 5) = v_18__5
!     esfs(18,14) = v_18_14
!     esfs(18,24) = v_18_24
!     esfs(20, 5) = v_20__5
!     esfs(20,14) = v_20_14
!     esfs(20,24) = v_20_24
!     esfs(22, 5) = v_22__5
!     esfs(22,14) = v_22_14
!     esfs(22,24) = v_22_24
!     esfs(26, 5) = v_26__5
!     esfs(26,14) = v_26_14
!     esfs(26,24) = v_26_24
!     esfs( 1, 6) = v__1__6
!     esfs(11, 6) = v_11__6
!     esfs(27, 6) = v_27__6
!     esfs( 1,15) = v__1_15
!     esfs(11,15) = v_11_15
!     esfs(27,15) = v_27_15
!     esfs( 1,25) = v__1_25
!     esfs(11,25) = v_11_25
!     esfs(27,25) = v_27_25
!     esfs( 2, 6) = v__2__6
!     esfs(13, 6) = v_13__6
!     esfs(28, 6) = v_28__6
!     esfs( 2,15) = v__2_15
!     esfs(13,15) = v_13_15
!     esfs(28,15) = v_28_15
!     esfs( 2,25) = v__2_25
!     esfs(13,25) = v_13_25
!     esfs(28,25) = v_28_25
!     esfs( 3, 6) = v__3__6
!     esfs( 9, 6) = v__9__6
!     esfs(19, 6) = v_19__6
!     esfs( 3,15) = v__3_15
!     esfs( 9,15) = v__9_15
!     esfs(19,15) = v_19_15
!     esfs( 3,25) = v__3_25
!     esfs( 9,25) = v__9_25
!     esfs(19,25) = v_19_25
!     esfs( 4, 6) = v__4__6
!     esfs( 4,15) = v__4_15
!     esfs( 4,25) = v__4_25
!     esfs( 5, 6) = v__5__6
!     esfs(14, 6) = v_14__6
!     esfs(24, 6) = v_24__6
!     esfs( 5,15) = v__5_15
!     esfs(14,15) = v_14_15
!     esfs(24,15) = v_24_15
!     esfs( 5,25) = v__5_25
!     esfs(14,25) = v_14_25
!     esfs(24,25) = v_24_25
!     esfs( 6, 6) = v__6__6
!     esfs(15, 6) = v_15__6
!     esfs(25, 6) = v_25__6
!     esfs( 6,15) = v__6_15
!     esfs(15,15) = v_15_15
!     esfs(25,15) = v_25_15
!     esfs( 6,25) = v__6_25
!     esfs(15,25) = v_15_25
!     esfs(25,25) = v_25_25
!     esfs( 7, 6) = v__7__6
!     esfs(21, 6) = v_21__6
!     esfs( 7,15) = v__7_15
!     esfs(21,15) = v_21_15
!     esfs( 7,25) = v__7_25
!     esfs(21,25) = v_21_25
!     esfs( 8, 6) = v__8__6
!     esfs(23, 6) = v_23__6
!     esfs( 8,15) = v__8_15
!     esfs(23,15) = v_23_15
!     esfs( 8,25) = v__8_25
!     esfs(23,25) = v_23_25
!     esfs(10, 6) = v_10__6
!     esfs(10,15) = v_10_15
!     esfs(10,25) = v_10_25
!     esfs(12, 6) = v_12__6
!     esfs(12,15) = v_12_15
!     esfs(12,25) = v_12_25
!     esfs(17, 6) = v_17__6
!     esfs(17,15) = v_17_15
!     esfs(17,25) = v_17_25
!     esfs(18, 6) = v_18__6
!     esfs(18,15) = v_18_15
!     esfs(18,25) = v_18_25
!     esfs(20, 6) = v_20__6
!     esfs(20,15) = v_20_15
!     esfs(20,25) = v_20_25
!     esfs(22, 6) = v_22__6
!     esfs(22,15) = v_22_15
!     esfs(22,25) = v_22_25
!     esfs(26, 6) = v_26__6
!     esfs(26,15) = v_26_15
!     esfs(26,25) = v_26_25
!     esfs( 1, 7) = v__1__7
!     esfs(11, 7) = v_11__7
!     esfs(27, 7) = v_27__7
!     esfs( 1,21) = v__1_21
!     esfs(11,21) = v_11_21
!     esfs(27,21) = v_27_21
!     esfs( 2, 7) = v__2__7
!     esfs(13, 7) = v_13__7
!     esfs(28, 7) = v_28__7
!     esfs( 2,21) = v__2_21
!     esfs(13,21) = v_13_21
!     esfs(28,21) = v_28_21
!     esfs( 3, 7) = v__3__7
!     esfs( 9, 7) = v__9__7
!     esfs(19, 7) = v_19__7
!     esfs( 3,21) = v__3_21
!     esfs( 9,21) = v__9_21
!     esfs(19,21) = v_19_21
!     esfs( 4, 7) = v__4__7
!     esfs( 4,21) = v__4_21
!     esfs( 5, 7) = v__5__7
!     esfs(14, 7) = v_14__7
!     esfs(24, 7) = v_24__7
!     esfs( 5,21) = v__5_21
!     esfs(14,21) = v_14_21
!     esfs(24,21) = v_24_21
!     esfs( 6, 7) = v__6__7
!     esfs(15, 7) = v_15__7
!     esfs(25, 7) = v_25__7
!     esfs( 6,21) = v__6_21
!     esfs(15,21) = v_15_21
!     esfs(25,21) = v_25_21
!     esfs( 7, 7) = v__7__7
!     esfs(21, 7) = v_21__7
!     esfs( 7,21) = v__7_21
!     esfs(21,21) = v_21_21
!     esfs( 8, 7) = v__8__7
!     esfs(23, 7) = v_23__7
!     esfs( 8,21) = v__8_21
!     esfs(23,21) = v_23_21
!     esfs(10, 7) = v_10__7
!     esfs(10,21) = v_10_21
!     esfs(12, 7) = v_12__7
!     esfs(12,21) = v_12_21
!     esfs(17, 7) = v_17__7
!     esfs(17,21) = v_17_21
!     esfs(18, 7) = v_18__7
!     esfs(18,21) = v_18_21
!     esfs(20, 7) = v_20__7
!     esfs(20,21) = v_20_21
!     esfs(22, 7) = v_22__7
!     esfs(22,21) = v_22_21
!     esfs(26, 7) = v_26__7
!     esfs(26,21) = v_26_21
!     esfs( 1, 8) = v__1__8
!     esfs(11, 8) = v_11__8
!     esfs(27, 8) = v_27__8
!     esfs( 1,23) = v__1_23
!     esfs(11,23) = v_11_23
!     esfs(27,23) = v_27_23
!     esfs( 2, 8) = v__2__8
!     esfs(13, 8) = v_13__8
!     esfs(28, 8) = v_28__8
!     esfs( 2,23) = v__2_23
!     esfs(13,23) = v_13_23
!     esfs(28,23) = v_28_23
!     esfs( 3, 8) = v__3__8
!     esfs( 9, 8) = v__9__8
!     esfs(19, 8) = v_19__8
!     esfs( 3,23) = v__3_23
!     esfs( 9,23) = v__9_23
!     esfs(19,23) = v_19_23
!     esfs( 4, 8) = v__4__8
!     esfs( 4,23) = v__4_23
!     esfs( 5, 8) = v__5__8
!     esfs(14, 8) = v_14__8
!     esfs(24, 8) = v_24__8
!     esfs( 5,23) = v__5_23
!     esfs(14,23) = v_14_23
!     esfs(24,23) = v_24_23
!     esfs( 6, 8) = v__6__8
!     esfs(15, 8) = v_15__8
!     esfs(25, 8) = v_25__8
!     esfs( 6,23) = v__6_23
!     esfs(15,23) = v_15_23
!     esfs(25,23) = v_25_23
!     esfs( 7, 8) = v__7__8
!     esfs(21, 8) = v_21__8
!     esfs( 7,23) = v__7_23
!     esfs(21,23) = v_21_23
!     esfs( 8, 8) = v__8__8
!     esfs(23, 8) = v_23__8
!     esfs( 8,23) = v__8_23
!     esfs(23,23) = v_23_23
!     esfs(10, 8) = v_10__8
!     esfs(10,23) = v_10_23
!     esfs(12, 8) = v_12__8
!     esfs(12,23) = v_12_23
!     esfs(17, 8) = v_17__8
!     esfs(17,23) = v_17_23
!     esfs(18, 8) = v_18__8
!     esfs(18,23) = v_18_23
!     esfs(20, 8) = v_20__8
!     esfs(20,23) = v_20_23
!     esfs(22, 8) = v_22__8
!     esfs(22,23) = v_22_23
!     esfs(26, 8) = v_26__8
!     esfs(26,23) = v_26_23
!     esfs( 1,10) = v__1_10
!     esfs(11,10) = v_11_10
!     esfs(27,10) = v_27_10
!     esfs( 2,10) = v__2_10
!     esfs(13,10) = v_13_10
!     esfs(28,10) = v_28_10
!     esfs( 3,10) = v__3_10
!     esfs( 9,10) = v__9_10
!     esfs(19,10) = v_19_10
!     esfs( 4,10) = v__4_10
!     esfs( 5,10) = v__5_10
!     esfs(14,10) = v_14_10
!     esfs(24,10) = v_24_10
!     esfs( 6,10) = v__6_10
!     esfs(15,10) = v_15_10
!     esfs(25,10) = v_25_10
!     esfs( 7,10) = v__7_10
!     esfs(21,10) = v_21_10
!     esfs( 8,10) = v__8_10
!     esfs(23,10) = v_23_10
!     esfs(10,10) = v_10_10
!     esfs(12,10) = v_12_10
!     esfs(17,10) = v_17_10
!     esfs(18,10) = v_18_10
!     esfs(20,10) = v_20_10
!     esfs(22,10) = v_22_10
!     esfs(26,10) = v_26_10
!     esfs( 1,12) = v__1_12
!     esfs(11,12) = v_11_12
!     esfs(27,12) = v_27_12
!     esfs( 2,12) = v__2_12
!     esfs(13,12) = v_13_12
!     esfs(28,12) = v_28_12
!     esfs( 3,12) = v__3_12
!     esfs( 9,12) = v__9_12
!     esfs(19,12) = v_19_12
!     esfs( 4,12) = v__4_12
!     esfs( 5,12) = v__5_12
!     esfs(14,12) = v_14_12
!     esfs(24,12) = v_24_12
!     esfs( 6,12) = v__6_12
!     esfs(15,12) = v_15_12
!     esfs(25,12) = v_25_12
!     esfs( 7,12) = v__7_12
!     esfs(21,12) = v_21_12
!     esfs( 8,12) = v__8_12
!     esfs(23,12) = v_23_12
!     esfs(10,12) = v_10_12
!     esfs(12,12) = v_12_12
!     esfs(17,12) = v_17_12
!     esfs(18,12) = v_18_12
!     esfs(20,12) = v_20_12
!     esfs(22,12) = v_22_12
!     esfs(26,12) = v_26_12
!     esfs( 1,17) = v__1_17
!     esfs(11,17) = v_11_17
!     esfs(27,17) = v_27_17
!     esfs( 2,17) = v__2_17
!     esfs(13,17) = v_13_17
!     esfs(28,17) = v_28_17
!     esfs( 3,17) = v__3_17
!     esfs( 9,17) = v__9_17
!     esfs(19,17) = v_19_17
!     esfs( 4,17) = v__4_17
!     esfs( 5,17) = v__5_17
!     esfs(14,17) = v_14_17
!     esfs(24,17) = v_24_17
!     esfs( 6,17) = v__6_17
!     esfs(15,17) = v_15_17
!     esfs(25,17) = v_25_17
!     esfs( 7,17) = v__7_17
!     esfs(21,17) = v_21_17
!     esfs( 8,17) = v__8_17
!     esfs(23,17) = v_23_17
!     esfs(10,17) = v_10_17
!     esfs(12,17) = v_12_17
!     esfs(17,17) = v_17_17
!     esfs(18,17) = v_18_17
!     esfs(20,17) = v_20_17
!     esfs(22,17) = v_22_17
!     esfs(26,17) = v_26_17
!     esfs( 1,18) = v__1_18
!     esfs(11,18) = v_11_18
!     esfs(27,18) = v_27_18
!     esfs( 2,18) = v__2_18
!     esfs(13,18) = v_13_18
!     esfs(28,18) = v_28_18
!     esfs( 3,18) = v__3_18
!     esfs( 9,18) = v__9_18
!     esfs(19,18) = v_19_18
!     esfs( 4,18) = v__4_18
!     esfs( 5,18) = v__5_18
!     esfs(14,18) = v_14_18
!     esfs(24,18) = v_24_18
!     esfs( 6,18) = v__6_18
!     esfs(15,18) = v_15_18
!     esfs(25,18) = v_25_18
!     esfs( 7,18) = v__7_18
!     esfs(21,18) = v_21_18
!     esfs( 8,18) = v__8_18
!     esfs(23,18) = v_23_18
!     esfs(10,18) = v_10_18
!     esfs(12,18) = v_12_18
!     esfs(17,18) = v_17_18
!     esfs(18,18) = v_18_18
!     esfs(20,18) = v_20_18
!     esfs(22,18) = v_22_18
!     esfs(26,18) = v_26_18
!     esfs( 1,20) = v__1_20
!     esfs(11,20) = v_11_20
!     esfs(27,20) = v_27_20
!     esfs( 2,20) = v__2_20
!     esfs(13,20) = v_13_20
!     esfs(28,20) = v_28_20
!     esfs( 3,20) = v__3_20
!     esfs( 9,20) = v__9_20
!     esfs(19,20) = v_19_20
!     esfs( 4,20) = v__4_20
!     esfs( 5,20) = v__5_20
!     esfs(14,20) = v_14_20
!     esfs(24,20) = v_24_20
!     esfs( 6,20) = v__6_20
!     esfs(15,20) = v_15_20
!     esfs(25,20) = v_25_20
!     esfs( 7,20) = v__7_20
!     esfs(21,20) = v_21_20
!     esfs( 8,20) = v__8_20
!     esfs(23,20) = v_23_20
!     esfs(10,20) = v_10_20
!     esfs(12,20) = v_12_20
!     esfs(17,20) = v_17_20
!     esfs(18,20) = v_18_20
!     esfs(20,20) = v_20_20
!     esfs(22,20) = v_22_20
!     esfs(26,20) = v_26_20
!     esfs( 1,22) = v__1_22
!     esfs(11,22) = v_11_22
!     esfs(27,22) = v_27_22
!     esfs( 2,22) = v__2_22
!     esfs(13,22) = v_13_22
!     esfs(28,22) = v_28_22
!     esfs( 3,22) = v__3_22
!     esfs( 9,22) = v__9_22
!     esfs(19,22) = v_19_22
!     esfs( 4,22) = v__4_22
!     esfs( 5,22) = v__5_22
!     esfs(14,22) = v_14_22
!     esfs(24,22) = v_24_22
!     esfs( 6,22) = v__6_22
!     esfs(15,22) = v_15_22
!     esfs(25,22) = v_25_22
!     esfs( 7,22) = v__7_22
!     esfs(21,22) = v_21_22
!     esfs( 8,22) = v__8_22
!     esfs(23,22) = v_23_22
!     esfs(10,22) = v_10_22
!     esfs(12,22) = v_12_22
!     esfs(17,22) = v_17_22
!     esfs(18,22) = v_18_22
!     esfs(20,22) = v_20_22
!     esfs(22,22) = v_22_22
!     esfs(26,22) = v_26_22
!     esfs( 1,26) = v__1_26
!     esfs(11,26) = v_11_26
!     esfs(27,26) = v_27_26
!     esfs( 2,26) = v__2_26
!     esfs(13,26) = v_13_26
!     esfs(28,26) = v_28_26
!     esfs( 3,26) = v__3_26
!     esfs( 9,26) = v__9_26
!     esfs(19,26) = v_19_26
!     esfs( 4,26) = v__4_26
!     esfs( 5,26) = v__5_26
!     esfs(14,26) = v_14_26
!     esfs(24,26) = v_24_26
!     esfs( 6,26) = v__6_26
!     esfs(15,26) = v_15_26
!     esfs(25,26) = v_25_26
!     esfs( 7,26) = v__7_26
!     esfs(21,26) = v_21_26
!     esfs( 8,26) = v__8_26
!     esfs(23,26) = v_23_26
!     esfs(10,26) = v_10_26
!     esfs(12,26) = v_12_26
!     esfs(17,26) = v_17_26
!     esfs(18,26) = v_18_26
!     esfs(20,26) = v_20_26
!     esfs(22,26) = v_22_26
!     esfs(26,26) = v_26_26
!     esfs(16,16) = v_16_16
!     esfs(31,16) = v_31_16
!     esfs(16,31) = v_16_31
!     esfs(31,31) = v_31_31
!     esfs(29,16) = v_29_16
!     esfs(29,31) = v_29_31
!     esfs(30,16) = v_30_16
!     esfs(30,31) = v_30_31
!     esfs(16,29) = v_16_29
!     esfs(31,29) = v_31_29
!     esfs(29,29) = v_29_29
!     esfs(30,29) = v_30_29
!     esfs(16,30) = v_16_30
!     esfs(31,30) = v_31_30
!     esfs(29,30) = v_29_30
!     esfs(30,30) = v_30_30
!     esfs(16, 1) = v_16__1
!     esfs(31, 1) = v_31__1
!     esfs(16,11) = v_16_11
!     esfs(31,11) = v_31_11
!     esfs(16,27) = v_16_27
!     esfs(31,27) = v_31_27
!     esfs(29, 1) = v_29__1
!     esfs(29,11) = v_29_11
!     esfs(29,27) = v_29_27
!     esfs(30, 1) = v_30__1
!     esfs(30,11) = v_30_11
!     esfs(30,27) = v_30_27
!     esfs(16, 2) = v_16__2
!     esfs(31, 2) = v_31__2
!     esfs(16,13) = v_16_13
!     esfs(31,13) = v_31_13
!     esfs(16,28) = v_16_28
!     esfs(31,28) = v_31_28
!     esfs(29, 2) = v_29__2
!     esfs(29,13) = v_29_13
!     esfs(29,28) = v_29_28
!     esfs(30, 2) = v_30__2
!     esfs(30,13) = v_30_13
!     esfs(30,28) = v_30_28
!     esfs(16, 3) = v_16__3
!     esfs(31, 3) = v_31__3
!     esfs(16, 9) = v_16__9
!     esfs(31, 9) = v_31__9
!     esfs(16,19) = v_16_19
!     esfs(31,19) = v_31_19
!     esfs(29, 3) = v_29__3
!     esfs(29, 9) = v_29__9
!     esfs(29,19) = v_29_19
!     esfs(30, 3) = v_30__3
!     esfs(30, 9) = v_30__9
!     esfs(30,19) = v_30_19
!     esfs(16, 4) = v_16__4
!     esfs(31, 4) = v_31__4
!     esfs(29, 4) = v_29__4
!     esfs(30, 4) = v_30__4
!     esfs(16, 5) = v_16__5
!     esfs(31, 5) = v_31__5
!     esfs(16,14) = v_16_14
!     esfs(31,14) = v_31_14
!     esfs(16,24) = v_16_24
!     esfs(31,24) = v_31_24
!     esfs(29, 5) = v_29__5
!     esfs(29,14) = v_29_14
!     esfs(29,24) = v_29_24
!     esfs(30, 5) = v_30__5
!     esfs(30,14) = v_30_14
!     esfs(30,24) = v_30_24
!     esfs(16, 6) = v_16__6
!     esfs(31, 6) = v_31__6
!     esfs(16,15) = v_16_15
!     esfs(31,15) = v_31_15
!     esfs(16,25) = v_16_25
!     esfs(31,25) = v_31_25
!     esfs(29, 6) = v_29__6
!     esfs(29,15) = v_29_15
!     esfs(29,25) = v_29_25
!     esfs(30, 6) = v_30__6
!     esfs(30,15) = v_30_15
!     esfs(30,25) = v_30_25
!     esfs(16, 7) = v_16__7
!     esfs(31, 7) = v_31__7
!     esfs(16,21) = v_16_21
!     esfs(31,21) = v_31_21
!     esfs(29, 7) = v_29__7
!     esfs(29,21) = v_29_21
!     esfs(30, 7) = v_30__7
!     esfs(30,21) = v_30_21
!     esfs(16, 8) = v_16__8
!     esfs(31, 8) = v_31__8
!     esfs(16,23) = v_16_23
!     esfs(31,23) = v_31_23
!     esfs(29, 8) = v_29__8
!     esfs(29,23) = v_29_23
!     esfs(30, 8) = v_30__8
!     esfs(30,23) = v_30_23
!     esfs(16,10) = v_16_10
!     esfs(31,10) = v_31_10
!     esfs(29,10) = v_29_10
!     esfs(30,10) = v_30_10
!     esfs(16,12) = v_16_12
!     esfs(31,12) = v_31_12
!     esfs(29,12) = v_29_12
!     esfs(30,12) = v_30_12
!     esfs(16,17) = v_16_17
!     esfs(31,17) = v_31_17
!     esfs(29,17) = v_29_17
!     esfs(30,17) = v_30_17
!     esfs(16,18) = v_16_18
!     esfs(31,18) = v_31_18
!     esfs(29,18) = v_29_18
!     esfs(30,18) = v_30_18
!     esfs(16,20) = v_16_20
!     esfs(31,20) = v_31_20
!     esfs(29,20) = v_29_20
!     esfs(30,20) = v_30_20
!     esfs(16,22) = v_16_22
!     esfs(31,22) = v_31_22
!     esfs(29,22) = v_29_22
!     esfs(30,22) = v_30_22
!     esfs(16,26) = v_16_26
!     esfs(31,26) = v_31_26
!     esfs(29,26) = v_29_26
!     esfs(30,26) = v_30_26
!     esfs( 1,16) = v__1_16
!     esfs(11,16) = v_11_16
!     esfs(27,16) = v_27_16
!     esfs( 1,31) = v__1_31
!     esfs(11,31) = v_11_31
!     esfs(27,31) = v_27_31
!     esfs( 2,16) = v__2_16
!     esfs(13,16) = v_13_16
!     esfs(28,16) = v_28_16
!     esfs( 2,31) = v__2_31
!     esfs(13,31) = v_13_31
!     esfs(28,31) = v_28_31
!     esfs( 3,16) = v__3_16
!     esfs( 9,16) = v__9_16
!     esfs(19,16) = v_19_16
!     esfs( 3,31) = v__3_31
!     esfs( 9,31) = v__9_31
!     esfs(19,31) = v_19_31
!     esfs( 4,16) = v__4_16
!     esfs( 4,31) = v__4_31
!     esfs( 5,16) = v__5_16
!     esfs(14,16) = v_14_16
!     esfs(24,16) = v_24_16
!     esfs( 5,31) = v__5_31
!     esfs(14,31) = v_14_31
!     esfs(24,31) = v_24_31
!     esfs( 6,16) = v__6_16
!     esfs(15,16) = v_15_16
!     esfs(25,16) = v_25_16
!     esfs( 6,31) = v__6_31
!     esfs(15,31) = v_15_31
!     esfs(25,31) = v_25_31
!     esfs( 7,16) = v__7_16
!     esfs(21,16) = v_21_16
!     esfs( 7,31) = v__7_31
!     esfs(21,31) = v_21_31
!     esfs( 8,16) = v__8_16
!     esfs(23,16) = v_23_16
!     esfs( 8,31) = v__8_31
!     esfs(23,31) = v_23_31
!     esfs(10,16) = v_10_16
!     esfs(10,31) = v_10_31
!     esfs(12,16) = v_12_16
!     esfs(12,31) = v_12_31
!     esfs(17,16) = v_17_16
!     esfs(17,31) = v_17_31
!     esfs(18,16) = v_18_16
!     esfs(18,31) = v_18_31
!     esfs(20,16) = v_20_16
!     esfs(20,31) = v_20_31
!     esfs(22,16) = v_22_16
!     esfs(22,31) = v_22_31
!     esfs(26,16) = v_26_16
!     esfs(26,31) = v_26_31
!     esfs( 1,29) = v__1_29
!     esfs(11,29) = v_11_29
!     esfs(27,29) = v_27_29
!     esfs( 2,29) = v__2_29
!     esfs(13,29) = v_13_29
!     esfs(28,29) = v_28_29
!     esfs( 3,29) = v__3_29
!     esfs( 9,29) = v__9_29
!     esfs(19,29) = v_19_29
!     esfs( 4,29) = v__4_29
!     esfs( 5,29) = v__5_29
!     esfs(14,29) = v_14_29
!     esfs(24,29) = v_24_29
!     esfs( 6,29) = v__6_29
!     esfs(15,29) = v_15_29
!     esfs(25,29) = v_25_29
!     esfs( 7,29) = v__7_29
!     esfs(21,29) = v_21_29
!     esfs( 8,29) = v__8_29
!     esfs(23,29) = v_23_29
!     esfs(10,29) = v_10_29
!     esfs(12,29) = v_12_29
!     esfs(17,29) = v_17_29
!     esfs(18,29) = v_18_29
!     esfs(20,29) = v_20_29
!     esfs(22,29) = v_22_29
!     esfs(26,29) = v_26_29
!     esfs( 1,30) = v__1_30
!     esfs(11,30) = v_11_30
!     esfs(27,30) = v_27_30
!     esfs( 2,30) = v__2_30
!     esfs(13,30) = v_13_30
!     esfs(28,30) = v_28_30
!     esfs( 3,30) = v__3_30
!     esfs( 9,30) = v__9_30
!     esfs(19,30) = v_19_30
!     esfs( 4,30) = v__4_30
!     esfs( 5,30) = v__5_30
!     esfs(14,30) = v_14_30
!     esfs(24,30) = v_24_30
!     esfs( 6,30) = v__6_30
!     esfs(15,30) = v_15_30
!     esfs(25,30) = v_25_30
!     esfs( 7,30) = v__7_30
!     esfs(21,30) = v_21_30
!     esfs( 8,30) = v__8_30
!     esfs(23,30) = v_23_30
!     esfs(10,30) = v_10_30
!     esfs(12,30) = v_12_30
!     esfs(17,30) = v_17_30
!     esfs(18,30) = v_18_30
!     esfs(20,30) = v_20_30
!     esfs(22,30) = v_22_30
!     esfs(26,30) = v_26_30
!
!   end

!   make_esfs_dd(esfs) ::: private
!   ! Makes the initial (es|fs) integrals, summed over the primitives
!     self :: IN
!     esfs :: MAT{REAL}, OUT
!     Ixa,Iya,Iza :: MAT3{REAL}*
!     Ix,Iy,Iz :: MAT{REAL}*
!     Ix_f,Iy_f,Iz_f,Ix_1,Iy_1,Iz_1 :: VEC{REAL}*
!     QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
!     zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
!     wt,t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
!     ce,cf,bb,ce1,cf1 :: REAL
!     Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
!     Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
!     Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
!     Ixe, Iye, Ize, Ixf, Iyf, Izf  :: REAL
!     Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
!     n_roots,dim1,dim2 :: INT
!     e,f,em1,fm1,ep1,fp1,n,i,j,k,n_sum :: INT
!     rys :: RYS*
!
!     dim1 = .ab_l_sum + 1
!     dim2 = .cd_l_sum + 1
!     n_roots = (dim1+dim2)/2
!     n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
!     Ixa.create(n_sum,dim1,dim2)
!     Iya.create(n_sum,dim1,dim2)
!     Iza.create(n_sum,dim1,dim2)
!
!     rys.create(n_roots)
!
!     i = 0
!     do k = 1,.ab_n_gaussian_pairs
!         ab_cc = .ab_contraction_prefactor(k)
!         zeta = .ab_exponent_sum(k)
!         zinv = .ab_exponent_inv(k)
!         half_zinv = HALF * zinv
!         ab_cc = ab_cc * TWOPI5ON2
!         Px = .ab_pair_center(1,k)
!         Py = .ab_pair_center(2,k)
!         Pz = .ab_pair_center(3,k)
!         PAx = .ab_center_diff(1,k)
!         PAy = .ab_center_diff(2,k)
!         PAz = .ab_center_diff(3,k)
!         do j = 1,.cd_n_gaussian_pairs
!             cd_cc = .cd_contraction_prefactor(j)
!             eta  = .cd_exponent_sum(j)
!             einv = .cd_exponent_inv(j)
!             half_einv = HALF * einv
!             Qx = .cd_pair_center(1,j)
!             Qy = .cd_pair_center(2,j)
!             Qz = .cd_pair_center(3,j)
!             QCx = .cd_center_diff(1,j)
!             QCy = .cd_center_diff(2,j)
!             QCz = .cd_center_diff(3,j)
!             rho  = zeta * eta / (zeta + eta)
!             rho_zinv = rho * zinv
!             rho_einv = rho * einv
!             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
!             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
!             rys.get_weights(xx)
!             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
!             ! Now make the 2 dimensional integrals.
!             do n = 1,n_roots
!               i = i + 1
!               Ix => Ixa(i,:,:)
!               Iy => Iya(i,:,:)
!               Iz => Iza(i,:,:)
!               t2      = rys.root(n)
!               wt      = rys.weight(n)
!               Ix(1,1) = ONE
!               Iy(1,1) = ONE
!               Iz(1,1) = wt
!               t2_rz = t2 * rho_zinv
!               Ix21 = PAx + t2_rz*QPx; Ix(2,1) = Ix21
!               Iy21 = PAy + t2_rz*QPy; Iy(2,1) = Iy21
!               Iz21 = PAz + t2_rz*QPz; Iz(2,1) = Iz21*wt
!               ce  = (ONE - t2_rz) * half_zinv
!               Ix31 = Ix21*Ix21 + ce; Ix(3,1) = Ix31
!               Iy31 = Iy21*Iy21 + ce; Iy(3,1) = Iy31
!               Iz31 = Iz21*Iz21 + ce; Iz(3,1) = Iz31*wt
!               t2_re = t2 * rho_einv
!               Ix12 = QCx - t2_re*QPx; Ix(1,2) = Ix12
!               Iy12 = QCy - t2_re*QPy; Iy(1,2) = Iy12
!               Iz12 = QCz - t2_re*QPz; Iz(1,2) = Iz12*wt
!               cf  = (ONE - t2_re) * half_einv
!               Ix13 = Ix12*Ix12 + cf; Ix(1,3) = Ix13
!               Iy13 = Iy12*Iy12 + cf; Iy(1,3) = Iy13
!               Iz13 = Iz12*Iz12 + cf; Iz(1,3) = Iz13*wt
!               bb = t2_rz * half_einv
!               Ix22 = Ix12*Ix21 + bb; Ix(2,2) = Ix22
!               Iy22 = Iy12*Iy21 + bb; Iy(2,2) = Iy22
!               Iz22 = Iz12*Iz21 + bb; Iz(2,2) = Iz22*wt
!               Ix23 = Ix12*Ix22 + cf*Ix21 + bb*Ix12; Ix(2,3) = Ix23
!               Iy23 = Iy12*Iy22 + cf*Iy21 + bb*Iy12; Iy(2,3) = Iy23
!               Iz23 = Iz12*Iz22 + cf*Iz21 + bb*Iz12; Iz(2,3) = Iz23
!               Ix32 = Ix21*Ix22 + ce*Ix12 + bb*Ix21; Ix(3,2) = Ix32
!               Iy32 = Iy21*Iy22 + ce*Iy12 + bb*Iy21; Iy(3,2) = Iy32
!               Iz32 = Iz21*Iz22 + ce*Iz12 + bb*Iz21; Iz(3,2) = Iz32*wt
!               f1_bb = bb + bb
!               Ixp1 = Ix21*Ix23 + ce*Ix13 + f1_bb*Ix22; Ix(3,3) = Ixp1
!               Iyp1 = Iy21*Iy23 + ce*Iy13 + f1_bb*Iy22; Iy(3,3) = Iyp1
!               Izp1 = Iz21*Iz23 + ce*Iz13 + f1_bb*Iz22; Iz(3,3) = Izp1*wt
!             end
!         end     ! -- loops over c,d
!     end         ! -- loops over a,b
!
!     rys.destroy
!
!     .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
!
!     Iza.destroy
!     Iya.destroy
!     Ixa.destroy
!   end

!   make_esfs_fs(esfs) ::: private
!   ! Makes the initial (es|fs) integrals, summed over the primitives
!     self :: IN
!     esfs :: MAT{REAL}, OUT
!     Ixa,Iya,Iza :: MAT3{REAL}*
!     Ix,Iy,Iz :: MAT{REAL}*
!     Ix_f,Iy_f,Iz_f,Ix_1,Iy_1,Iz_1 :: VEC{REAL}*
!     QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,Px,Py,Pz :: REAL
!     zeta,eta,xx,ab_cc,cd_cc,rho,zinv,rho_zinv :: REAL
!     wt,t2,t2_rz,t2_re,half_zinv,f1_bb :: REAL
!     ce,cf,bb,ce1,cf1 :: REAL
!     Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
!     Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
!     Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
!     Ixe, Iye, Ize, Ixf, Iyf, Izf  :: REAL
!     Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
!     n_roots,dim1,dim2 :: INT
!     e,f,em1,fm1,ep1,fp1,n,i,j,k,n_sum :: INT
!     rys :: RYS*
!
!     dim1 = .ab_l_sum + 1
!     dim2 = .cd_l_sum + 1
!     n_roots = (dim1+dim2)/2
!     n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
!     Ixa.create(n_sum,dim1,dim2)
!     Iya.create(n_sum,dim1,dim2)
!     Iza.create(n_sum,dim1,dim2)
!
!     rys.create(n_roots)
!
!     i = 0
!     do k = 1,.ab_n_gaussian_pairs
!         ab_cc = .ab_contraction_prefactor(k)
!         zeta = .ab_exponent_sum(k)
!         zinv = .ab_exponent_inv(k)
!         half_zinv = HALF * zinv
!         ab_cc = ab_cc * TWOPI5ON2
!         Px = .ab_pair_center(1,k)
!         Py = .ab_pair_center(2,k)
!         Pz = .ab_pair_center(3,k)
!         PAx = .ab_center_diff(1,k)
!         PAy = .ab_center_diff(2,k)
!         PAz = .ab_center_diff(3,k)
!         do j = 1,.cd_n_gaussian_pairs
!             cd_cc = .cd_contraction_prefactor(j)
!             eta  = .cd_exponent_sum(j)
!             Qx = .cd_pair_center(1,j)
!             Qy = .cd_pair_center(2,j)
!             Qz = .cd_pair_center(3,j)
!             rho  = zeta * eta / (zeta + eta)
!             rho_zinv = rho * zinv
!             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
!             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
!             rys.get_weights(xx)
!             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
!             ! Now make the 2 dimensional integrals.
!             do n = 1,n_roots
!               i = i + 1
!               Ix => Ixa(i,:,:)
!               Iy => Iya(i,:,:)
!               Iz => Iza(i,:,:)
!               t2      = rys.root(n)
!               wt      = rys.weight(n)
!               ! Ix(1,1) = ONE
!               ! Iy(1,1) = ONE
!               Iz(1,1) = wt
!               t2_rz = t2 * rho_zinv
!               Ix21 = PAx + t2_rz*QPx; Ix(2,1) = Ix21
!               Iy21 = PAy + t2_rz*QPy; Iy(2,1) = Iy21
!               Iz21 = PAz + t2_rz*QPz; Iz(2,1) = Iz21*wt
!               ce  = (ONE - t2_rz) * half_zinv
!               Ix31 = Ix21*Ix21 + ce; Ix(3,1) = Ix31
!               Iy31 = Iy21*Iy21 + ce; Iy(3,1) = Iy31
!               Iz31 = Iz21*Iz21 + ce; Iz(3,1) = Iz31*wt
!               ce1 = ce + ce
!               Ixp1 = Ix21*Ix31 + ce1*Ix21; Ix(4,1) = Ixp1
!               Iyp1 = Iy21*Iy31 + ce1*Iy21; Iy(4,1) = Iyp1
!               Izp1 = Iz21*Iz31 + ce1*Iz21; Iz(4,1) = Izp1*wt
!             end
!         end     ! -- loops over c,d
!     end         ! -- loops over a,b
!
!     rys.destroy
!
!     .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
!
!     Iza.destroy
!     Iya.destroy
!     Ixa.destroy
!   end

!   make_esfs_sf(esfs) ::: private
!   ! Makes the initial (es|fs) integrals, summed over the primitives
!     self :: IN
!     esfs :: MAT{REAL}, OUT
!     Ixa,Iya,Iza :: MAT3{REAL}*
!     Ix,Iy,Iz :: MAT{REAL}*
!     Ix_f,Iy_f,Iz_f,Ix_1,Iy_1,Iz_1 :: VEC{REAL}*
!     QPx,QPy,QPz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
!     zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
!     wt,t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
!     ce,cf,bb,ce1,cf1 :: REAL
!     Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
!     Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
!     Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
!     Ixe, Iye, Ize, Ixf, Iyf, Izf  :: REAL
!     Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
!     n_roots,dim1,dim2 :: INT
!     e,f,em1,fm1,ep1,fp1,n,i,j,k,n_sum :: INT
!     rys :: RYS*
!
!     dim1 = .ab_l_sum + 1                            ! Space for 2D integrals
!     dim2 = .cd_l_sum + 1
!     n_roots = (dim1+dim2)/2
!     n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
!     Ixa.create(n_sum,dim1,dim2)                     ! Allocate 2D integrals
!     Iya.create(n_sum,dim1,dim2)
!     Iza.create(n_sum,dim1,dim2)
!
!     rys.create(n_roots)
!
!     i = 0
!     do k = 1,.ab_n_gaussian_pairs
!         ab_cc = .ab_contraction_prefactor(k)
!         zeta = .ab_exponent_sum(k)
!         ab_cc = ab_cc * TWOPI5ON2
!         Px = .ab_pair_center(1,k)
!         Py = .ab_pair_center(2,k)
!         Pz = .ab_pair_center(3,k)
!         do j = 1,.cd_n_gaussian_pairs
!             cd_cc = .cd_contraction_prefactor(j)
!             eta  = .cd_exponent_sum(j)
!             einv = .cd_exponent_inv(j)
!             Qx = .cd_pair_center(1,j)
!             Qy = .cd_pair_center(2,j)
!             Qz = .cd_pair_center(3,j)
!             QCx = .cd_center_diff(1,j)
!             QCy = .cd_center_diff(2,j)
!             QCz = .cd_center_diff(3,j)
!             rho  = zeta * eta / (zeta + eta)
!             rho_einv = rho * einv
!             half_einv = HALF * einv
!             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
!             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
!             rys.get_weights(xx)
!             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
!             ! Now make the 2 dimensional integrals.
!             do n = 1,n_roots
!               i = i + 1
!               Ix => Ixa(i,:,:)
!               Iy => Iya(i,:,:)
!               Iz => Iza(i,:,:)
!               t2      = rys.root(n)
!               wt      = rys.weight(n)
!               ! Ix(1,1) = ONE
!               ! Iy(1,1) = ONE
!               Iz(1,1) = wt
!               t2_re = t2 * rho_einv
!               Ix12 = QCx - t2_re*QPx; Ix(1,2) = Ix12
!               Iy12 = QCy - t2_re*QPy; Iy(1,2) = Iy12
!               Iz12 = QCz - t2_re*QPz; Iz(1,2) = Iz12*wt
!               cf  = (ONE - t2_re) * half_einv
!               Ix13 = Ix12*Ix12 + cf; Ix(1,3) = Ix13
!               Iy13 = Iy12*Iy12 + cf; Iy(1,3) = Iy13
!               Iz13 = Iz12*Iz12 + cf; Iz(1,3) = Iz13*wt
!               cf1 = cf + cf
!               Ixp1 = Ix12*Ix13 + cf1*Ix12; Ix(1,4) = Ixp1
!               Iyp1 = Iy12*Iy13 + cf1*Iy12; Iy(1,4) = Iyp1
!               Izp1 = Iz12*Iz13 + cf1*Iz12; Iz(1,4) = Izp1*wt
!             end
!         end     ! -- loops over c,d
!     end         ! -- loops over a,b
!
!     rys.destroy
!
!     .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
!
!     Iza.destroy
!     Iya.destroy
!     Ixa.destroy
!   end

   make_esfs_Xs(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: VEC{REAL}(.n_ab), OUT

      Ixa,Iya,Iza :: MAT{REAL}*
      Ix,Iy,Iz :: VEC{REAL}*
      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,rho_zinv :: REAL
      t2,t2_rz,half_zinv :: REAL
      ce,ce1 :: REAL
      Ix21,Iy21,Iz21 :: REAL
      Ix31,Iy31,Iz31 :: REAL
      Ixe, Iye, Ize  :: REAL
      Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
      n_roots,dim1,dim2 :: INT
      ep1,n,i,j,k,n_sum :: INT
      rys :: RYS*

      dim1 = .ab_l_sum + 1
      dim2 = .cd_l_sum + 1 ! This is 1
      n_roots = (dim1+dim2)/2
      n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
      Ixa.create(n_sum,dim1)
      Iya.create(n_sum,dim1)
      Iza.create(n_sum,dim1)

      rys.create(n_roots)

      i = 0
      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               i = i + 1
               Ix => Ixa(i,:)
               Iy => Iya(i,:)
               Iz => Iza(i,:)
               t2      = rys.root(n)
               Ix(1) = ONE
               Iy(1) = ONE
               Iz(1) = ONE
                 t2_rz = t2 * rho_zinv
                 Ix21 = PAx + t2_rz*QPx; Ix(2) = Ix21
                 Iy21 = PAy + t2_rz*QPy; Iy(2) = Iy21
                 Iz21 = PAz + t2_rz*QPz; Iz(2) = Iz21
                 ce  = (ONE - t2_rz) * half_zinv
                 Ix31 = Ix21*Ix21 + ce; Ix(3) = Ix31
                 Iy31 = Iy21*Iy21 + ce; Iy(3) = Iy31
                 Iz31 = Iz21*Iz21 + ce; Iz(3) = Iz31
                 Ixe = Ix31; Ixm1 = Ix21
                 Iye = Iy31; Iym1 = Iy21
                 Ize = Iz31; Izm1 = Iz21
                 ce1 = ce
                 do ep1 = 4,.ab_l_sum+1
                   ce1 = ce1 + ce
                   Ixp1 = Ix21*Ixe + ce1*Ixm1; Ix(ep1) = Ixp1
                   Iyp1 = Iy21*Iye + ce1*Iym1; Iy(ep1) = Iyp1
                   Izp1 = Iz21*Ize + ce1*Izm1; Iz(ep1) = Izp1
                   Ixm1 = Ixe; Ixe = Ixp1
                   Iym1 = Iye; Iye = Iyp1
                   Izm1 = Ize; Ize = Izp1
                 end
               Iz = Iz * rys.weight(n)
             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      .form_esss(esfs,Ixa,Iya,Iza,Iza(:,1),n_sum)

      Iza.destroy
      Iya.destroy
      Ixa.destroy
   end

   make_esfs_sX(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: VEC{REAL}(.n_cd), OUT

      Ixa,Iya,Iza :: MAT{REAL}*
      Ix,Iy,Iz :: VEC{REAL}*
      QPx,QPy,QPz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,einv,rho_einv :: REAL
      t2,t2_re,half_einv :: REAL
      cf,cf1 :: REAL
      Ix12,Iy12,Iz12 :: REAL
      Ix13,Iy13,Iz13 :: REAL
      Ixf, Iyf, Izf  :: REAL
      Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
      n_roots,dim1,dim2 :: INT
      fp1,n,i,j,k,n_sum :: INT
      rys :: RYS*

      dim1 = .ab_l_sum + 1 ! This is 1
      dim2 = .cd_l_sum + 1
      n_roots = (dim1+dim2)/2
      n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
      Ixa.create(n_sum,dim2)
      Iya.create(n_sum,dim2)
      Iza.create(n_sum,dim2)

      rys.create(n_roots)

      i = 0
      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               i = i + 1
               Ix => Ixa(i,:)
               Iy => Iya(i,:)
               Iz => Iza(i,:)
               t2      = rys.root(n)
               Ix(1) = ONE
               Iy(1) = ONE
               Iz(1) = ONE
                 t2_re = t2 * rho_einv
                 Ix12 = QCx - t2_re*QPx; Ix(2) = Ix12
                 Iy12 = QCy - t2_re*QPy; Iy(2) = Iy12
                 Iz12 = QCz - t2_re*QPz; Iz(2) = Iz12
                 cf  = (ONE - t2_re) * half_einv
                 Ix13 = Ix12*Ix12 + cf; Ix(3) = Ix13
                 Iy13 = Iy12*Iy12 + cf; Iy(3) = Iy13
                 Iz13 = Iz12*Iz12 + cf; Iz(3) = Iz13
                 Ixf = Ix13; Ixm1 = Ix12
                 Iyf = Iy13; Iym1 = Iy12
                 Izf = Iz13; Izm1 = Iz12
                 cf1 = cf
                 do fp1 = 4,.cd_l_sum+1
                   cf1 = cf1 + cf
                   Ixp1 = Ix12*Ixf + cf1*Ixm1; Ix(fp1) = Ixp1
                   Iyp1 = Iy12*Iyf + cf1*Iym1; Iy(fp1) = Iyp1
                   Izp1 = Iz12*Izf + cf1*Izm1; Iz(fp1) = Izp1
                   Ixm1 = Ixf; Ixf = Ixp1
                   Iym1 = Iyf; Iyf = Iyp1
                   Izm1 = Izf; Izf = Izp1
                 end
               Iz = Iz * rys.weight(n)
             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      .form_ssfs(esfs,Ixa,Iya,Iza,Iza(:,1),n_sum)

      Iza.destroy
      Iya.destroy
      Ixa.destroy
   end

   make_esfs_Xp(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      Ixa,Iya,Iza :: MAT3{REAL}*
      Ix,Iy,Iz :: MAT{REAL}*
      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      t2,t2_rz,t2_re,half_zinv,half_einv :: REAL
      ce,bb,ce1 :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      Ix31,Iy31,Iz31 :: REAL
      Ix32,Iy32,Iz32 :: REAL
      Ixe, Iye, Ize  :: REAL
      Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
      n_roots,dim1,dim2 :: INT
      e,ep1,n,i,j,k,n_sum :: INT
      rys :: RYS*

      dim1 = .ab_l_sum + 1                            ! Space for 2D integrals
      dim2 = .cd_l_sum + 1
      n_roots = (dim1+dim2)/2
      n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
      Ixa.create(n_sum,dim1,dim2)                     ! Allocate 2D integrals
      Iya.create(n_sum,dim1,dim2)
      Iza.create(n_sum,dim1,dim2)

      rys.create(n_roots)

      i = 0
      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               i = i + 1
               Ix => Ixa(i,:,:)
               Iy => Iya(i,:,:)
               Iz => Iza(i,:,:)
               t2      = rys.root(n)
               Ix(1,1) = ONE
               Iy(1,1) = ONE
               Iz(1,1) = ONE
                 t2_rz = t2 * rho_zinv
                 Ix21 = PAx + t2_rz*QPx; Ix(2,1) = Ix21
                 Iy21 = PAy + t2_rz*QPy; Iy(2,1) = Iy21
                 Iz21 = PAz + t2_rz*QPz; Iz(2,1) = Iz21
                 ce  = (ONE - t2_rz) * half_zinv
                 Ix31 = Ix21*Ix21 + ce; Ix(3,1) = Ix31
                 Iy31 = Iy21*Iy21 + ce; Iy(3,1) = Iy31
                 Iz31 = Iz21*Iz21 + ce; Iz(3,1) = Iz31
                 Ixe = Ix31; Ixm1 = Ix21
                 Iye = Iy31; Iym1 = Iy21
                 Ize = Iz31; Izm1 = Iz21
                 ce1 = ce
                 do ep1 = 4,.ab_l_sum+1
                   ce1 = ce1 + ce
                   Ixp1 = Ix21*Ixe + ce1*Ixm1; Ix(ep1,1) = Ixp1
                   Iyp1 = Iy21*Iye + ce1*Iym1; Iy(ep1,1) = Iyp1
                   Izp1 = Iz21*Ize + ce1*Izm1; Iz(ep1,1) = Izp1
                   Ixm1 = Ixe; Ixe = Ixp1
                   Iym1 = Iye; Iye = Iyp1
                   Izm1 = Ize; Ize = Izp1
                 end
                 t2_re = t2 * rho_einv
                 Ix12 = QCx - t2_re*QPx; Ix(1,2) = Ix12
                 Iy12 = QCy - t2_re*QPy; Iy(1,2) = Iy12
                 Iz12 = QCz - t2_re*QPz; Iz(1,2) = Iz12
                 bb = t2_rz * half_einv
                 Ix22 = Ix12*Ix21 + bb; Ix(2,2) = Ix22
                 Iy22 = Iy12*Iy21 + bb; Iy(2,2) = Iy22
                 Iz22 = Iz12*Iz21 + bb; Iz(2,2) = Iz22
                 Ix32 = Ix21*Ix22 + ce*Ix12 + bb*Ix21; Ix(3,2) = Ix32
                 Iy32 = Iy21*Iy22 + ce*Iy12 + bb*Iy21; Iy(3,2) = Iy32
                 Iz32 = Iz21*Iz22 + ce*Iz12 + bb*Iz21; Iz(3,2) = Iz32
                 Ixe = Ix32; Ixm1 = Ix22
                 Iye = Iy32; Iym1 = Iy22
                 Ize = Iz32; Izm1 = Iz22
                 ce1 = ce
                 do e = 3,.ab_l_sum
                   ep1 = e + 1
                   ce1 = ce1 + ce
                   Ixp1 = Ix21*Ixe + ce1*Ixm1 + bb*Ix(e,1); Ix(ep1,2) = Ixp1
                   Iyp1 = Iy21*Iye + ce1*Iym1 + bb*Iy(e,1); Iy(ep1,2) = Iyp1
                   Izp1 = Iz21*Ize + ce1*Izm1 + bb*Iz(e,1); Iz(ep1,2) = Izp1
                   Ixm1 = Ixe; Ixe = Ixp1
                   Iym1 = Iye; Iye = Iyp1
                   Izm1 = Ize; Ize = Izp1
                 end
               Iz = Iz * rys.weight(n)
             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
   ! SHELL1QUARTET::form_esfs_rms2(self,esfs,Ixa,Iya,Iza,Iza(:,1,1),n_sum,dim1,dim2)

      Iza.destroy
      Iya.destroy
      Ixa.destroy
   end

   make_esfs_pX(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      Ixa,Iya,Iza :: MAT3{REAL}*
      Ix,Iy,Iz :: MAT{REAL}*
      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      t2,t2_rz,t2_re,half_einv :: REAL
      cf,bb,cf1 :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      Ix13,Iy13,Iz13 :: REAL
      Ix23,Iy23,Iz23 :: REAL
      Ixf, Iyf, Izf  :: REAL
      Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
      n_roots,dim1,dim2 :: INT
      f,fp1,n,i,j,k,n_sum :: INT
      rys :: RYS*

      dim1 = .ab_l_sum + 1
      dim2 = .cd_l_sum + 1
      n_roots = (dim1+dim2)/2
      n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
      Ixa.create(n_sum,dim1,dim2)
      Iya.create(n_sum,dim1,dim2)
      Iza.create(n_sum,dim1,dim2)

      rys.create(n_roots)

      i = 0
      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               i = i + 1
               Ix => Ixa(i,:,:)
               Iy => Iya(i,:,:)
               Iz => Iza(i,:,:)
               t2      = rys.root(n)
               Ix(1,1) = ONE
               Iy(1,1) = ONE
               Iz(1,1) = ONE
                 t2_rz = t2 * rho_zinv
                 Ix21 = PAx + t2_rz*QPx; Ix(2,1) = Ix21
                 Iy21 = PAy + t2_rz*QPy; Iy(2,1) = Iy21
                 Iz21 = PAz + t2_rz*QPz; Iz(2,1) = Iz21
                 t2_re = t2 * rho_einv
                 Ix12 = QCx - t2_re*QPx; Ix(1,2) = Ix12
                 Iy12 = QCy - t2_re*QPy; Iy(1,2) = Iy12
                 Iz12 = QCz - t2_re*QPz; Iz(1,2) = Iz12
                 cf  = (ONE - t2_re) * half_einv
                 Ix13 = Ix12*Ix12 + cf; Ix(1,3) = Ix13
                 Iy13 = Iy12*Iy12 + cf; Iy(1,3) = Iy13
                 Iz13 = Iz12*Iz12 + cf; Iz(1,3) = Iz13
                 Ixf = Ix13; Ixm1 = Ix12
                 Iyf = Iy13; Iym1 = Iy12
                 Izf = Iz13; Izm1 = Iz12
                 cf1 = cf
                 do fp1 = 4,.cd_l_sum+1
                   cf1 = cf1 + cf
                   Ixp1 = Ix12*Ixf + cf1*Ixm1; Ix(1,fp1) = Ixp1
                   Iyp1 = Iy12*Iyf + cf1*Iym1; Iy(1,fp1) = Iyp1
                   Izp1 = Iz12*Izf + cf1*Izm1; Iz(1,fp1) = Izp1
                   Ixm1 = Ixf; Ixf = Ixp1
                   Iym1 = Iyf; Iyf = Iyp1
                   Izm1 = Izf; Izf = Izp1
                 end
                 bb = t2_rz * half_einv
                 Ix22 = Ix12*Ix21 + bb; Ix(2,2) = Ix22
                 Iy22 = Iy12*Iy21 + bb; Iy(2,2) = Iy22
                 Iz22 = Iz12*Iz21 + bb; Iz(2,2) = Iz22
                 Ix23 = Ix12*Ix22 + cf*Ix21 + bb*Ix12; Ix(2,3) = Ix23
                 Iy23 = Iy12*Iy22 + cf*Iy21 + bb*Iy12; Iy(2,3) = Iy23
                 Iz23 = Iz12*Iz22 + cf*Iz21 + bb*Iz12; Iz(2,3) = Iz23
                 Ixf = Ix23; Ixm1 = Ix22
                 Iyf = Iy23; Iym1 = Iy22
                 Izf = Iz23; Izm1 = Iz22
                 cf1 = cf
                 do f = 3,.cd_l_sum
                   fp1 = f + 1
                   cf1 = cf1 + cf
                   Ixp1 = Ix12*Ixf + cf1*Ixm1 + bb*Ix(1,f); Ix(2,fp1) = Ixp1
                   Iyp1 = Iy12*Iyf + cf1*Iym1 + bb*Iy(1,f); Iy(2,fp1) = Iyp1
                   Izp1 = Iz12*Izf + cf1*Izm1 + bb*Iz(1,f); Iz(2,fp1) = Izp1
                   Ixm1 = Ixf; Ixf = Ixp1
                   Iym1 = Iyf; Iyf = Iyp1
                   Izm1 = Izf; Izf = Izp1
                 end
               Iz = Iz * rys.weight(n)
             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
   ! SHELL1QUARTET::form_esfs_rms2(self,esfs,Ixa,Iya,Iza,Iza(:,1,1),n_sum,dim1,dim2)

      Iza.destroy
      Iya.destroy
      Ixa.destroy
   end

   make_esfs_Xd(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      Ixa,Iya,Iza :: MAT3{REAL}*
      Ix,Iy,Iz :: MAT{REAL}*
      Ix_f,Iy_f,Iz_f,Ix_1,Iy_1,Iz_1 :: VEC{REAL}*
      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
      ce,cf,bb,ce1 :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
      Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
      Ixe, Iye, Ize  :: REAL
      Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
      n_roots,dim1,dim2 :: INT
      e,f,fm1,ep1,n,i,j,k,n_sum :: INT
      rys :: RYS*

      dim1 = .ab_l_sum + 1
      dim2 = .cd_l_sum + 1
      n_roots = (dim1+dim2)/2
      n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
      Ixa.create(n_sum,dim1,dim2)
      Iya.create(n_sum,dim1,dim2)
      Iza.create(n_sum,dim1,dim2)

      rys.create(n_roots)

      i = 0
      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               i = i + 1
               Ix => Ixa(i,:,:)
               Iy => Iya(i,:,:)
               Iz => Iza(i,:,:)
               t2      = rys.root(n)
               Ix(1,1) = ONE
               Iy(1,1) = ONE
               Iz(1,1) = ONE
                 t2_rz = t2 * rho_zinv
                 Ix21 = PAx + t2_rz*QPx; Ix(2,1) = Ix21
                 Iy21 = PAy + t2_rz*QPy; Iy(2,1) = Iy21
                 Iz21 = PAz + t2_rz*QPz; Iz(2,1) = Iz21
                 ce  = (ONE - t2_rz) * half_zinv
                 Ix31 = Ix21*Ix21 + ce; Ix(3,1) = Ix31
                 Iy31 = Iy21*Iy21 + ce; Iy(3,1) = Iy31
                 Iz31 = Iz21*Iz21 + ce; Iz(3,1) = Iz31
                 Ixe = Ix31; Ixm1 = Ix21
                 Iye = Iy31; Iym1 = Iy21
                 Ize = Iz31; Izm1 = Iz21
                 ce1 = ce
                 do ep1 = 4,.ab_l_sum+1
                   ce1 = ce1 + ce
                   Ixp1 = Ix21*Ixe + ce1*Ixm1; Ix(ep1,1) = Ixp1
                   Iyp1 = Iy21*Iye + ce1*Iym1; Iy(ep1,1) = Iyp1
                   Izp1 = Iz21*Ize + ce1*Izm1; Iz(ep1,1) = Izp1
                   Ixm1 = Ixe; Ixe = Ixp1
                   Iym1 = Iye; Iye = Iyp1
                   Izm1 = Ize; Ize = Izp1
                 end
                 t2_re = t2 * rho_einv
                 Ix12 = QCx - t2_re*QPx; Ix(1,2) = Ix12
                 Iy12 = QCy - t2_re*QPy; Iy(1,2) = Iy12
                 Iz12 = QCz - t2_re*QPz; Iz(1,2) = Iz12
                 cf  = (ONE - t2_re) * half_einv
                 Ix13 = Ix12*Ix12 + cf; Ix(1,3) = Ix13
                 Iy13 = Iy12*Iy12 + cf; Iy(1,3) = Iy13
                 Iz13 = Iz12*Iz12 + cf; Iz(1,3) = Iz13
                 bb = t2_rz * half_einv
                 Ix22 = Ix12*Ix21 + bb; Ix(2,2) = Ix22
                 Iy22 = Iy12*Iy21 + bb; Iy(2,2) = Iy22
                 Iz22 = Iz12*Iz21 + bb; Iz(2,2) = Iz22
                 Ix23 = Ix12*Ix22 + cf*Ix21 + bb*Ix12; Ix(2,3) = Ix23
                 Iy23 = Iy12*Iy22 + cf*Iy21 + bb*Iy12; Iy(2,3) = Iy23
                 Iz23 = Iz12*Iz22 + cf*Iz21 + bb*Iz12; Iz(2,3) = Iz23
                 Ix32 = Ix21*Ix22 + ce*Ix12 + bb*Ix21; Ix(3,2) = Ix32
                 Iy32 = Iy21*Iy22 + ce*Iy12 + bb*Iy21; Iy(3,2) = Iy32
                 Iz32 = Iz21*Iz22 + ce*Iz12 + bb*Iz21; Iz(3,2) = Iz32
                 Ixe = Ix32; Ixm1 = Ix22
                 Iye = Iy32; Iym1 = Iy22
                 Ize = Iz32; Izm1 = Iz22
                 ce1 = ce
                 do e = 3,.ab_l_sum
                   ep1 = e + 1
                   ce1 = ce1 + ce
                   Ixp1 = Ix21*Ixe + ce1*Ixm1 + bb*Ix(e,1); Ix(ep1,2) = Ixp1
                   Iyp1 = Iy21*Iye + ce1*Iym1 + bb*Iy(e,1); Iy(ep1,2) = Iyp1
                   Izp1 = Iz21*Ize + ce1*Izm1 + bb*Iz(e,1); Iz(ep1,2) = Izp1
                   Ixm1 = Ixe; Ixe = Ixp1
                   Iym1 = Iye; Iye = Iyp1
                   Izm1 = Ize; Ize = Izp1
                 end
                 f1_bb = bb
                 do f = 3,.cd_l_sum+1
                   fm1 = f - 1
                   Ix_f => Ix(:,f)
                   Iy_f => Iy(:,f)
                   Iz_f => Iz(:,f)
                   Ix_1 => Ix(:,fm1)
                   Iy_1 => Iy(:,fm1)
                   Iz_1 => Iz(:,fm1)
                   Ixe = Ix_f(2); Ixm1 = Ix_f(1)
                   Iye = Iy_f(2); Iym1 = Iy_f(1)
                   Ize = Iz_f(2); Izm1 = Iz_f(1)
                   f1_bb = f1_bb + bb
                   ce1 = ZERO
                   do e = 2,.ab_l_sum
                     ep1 = e + 1
                     ce1 = ce1 + ce
                     Ixp1 = Ix21*Ixe + ce1*Ixm1 + f1_bb*Ix_1(e); Ix_f(ep1) = Ixp1
                     Iyp1 = Iy21*Iye + ce1*Iym1 + f1_bb*Iy_1(e); Iy_f(ep1) = Iyp1
                     Izp1 = Iz21*Ize + ce1*Izm1 + f1_bb*Iz_1(e); Iz_f(ep1) = Izp1
                     Ixm1 = Ixe; Ixe = Ixp1
                     Iym1 = Iye; Iye = Iyp1
                     Izm1 = Ize; Ize = Izp1
                   end
                 end
               Iz = Iz * rys.weight(n)
             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
   ! SHELL1QUARTET::form_esfs_rms2(self,esfs,Ixa,Iya,Iza,Iza(:,1,1),n_sum,dim1,dim2)

      Iza.destroy
      Iya.destroy
      Ixa.destroy
   end

   make_esfs_dX(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      Ixa,Iya,Iza :: MAT3{REAL}*
      Ix,Iy,Iz :: MAT{REAL}*
      Ix_f,Iy_f,Iz_f,Ix_1,Iy_1,Iz_1 :: VEC{REAL}*
      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
      ce,cf,bb,ce1,cf1 :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
      Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
      Ixe, Iye, Ize, Ixf, Iyf, Izf  :: REAL
      Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
      n_roots,dim1,dim2 :: INT
      e,f,fm1,ep1,fp1,n,i,j,k,n_sum :: INT
      rys :: RYS*

      dim1 = .ab_l_sum + 1
      dim2 = .cd_l_sum + 1
      n_roots = (dim1+dim2)/2
      n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
      Ixa.create(n_sum,dim1,dim2)
      Iya.create(n_sum,dim1,dim2)
      Iza.create(n_sum,dim1,dim2)

      rys.create(n_roots)

      i = 0
      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               i = i + 1
               Ix => Ixa(i,:,:)
               Iy => Iya(i,:,:)
               Iz => Iza(i,:,:)
               t2      = rys.root(n)
               Ix(1,1) = ONE
               Iy(1,1) = ONE
               Iz(1,1) = ONE
                 t2_rz = t2 * rho_zinv
                 Ix21 = PAx + t2_rz*QPx; Ix(2,1) = Ix21
                 Iy21 = PAy + t2_rz*QPy; Iy(2,1) = Iy21
                 Iz21 = PAz + t2_rz*QPz; Iz(2,1) = Iz21
                 ce  = (ONE - t2_rz) * half_zinv
                 Ix31 = Ix21*Ix21 + ce; Ix(3,1) = Ix31
                 Iy31 = Iy21*Iy21 + ce; Iy(3,1) = Iy31
                 Iz31 = Iz21*Iz21 + ce; Iz(3,1) = Iz31
                 t2_re = t2 * rho_einv
                 Ix12 = QCx - t2_re*QPx; Ix(1,2) = Ix12
                 Iy12 = QCy - t2_re*QPy; Iy(1,2) = Iy12
                 Iz12 = QCz - t2_re*QPz; Iz(1,2) = Iz12
                 cf  = (ONE - t2_re) * half_einv
                 Ix13 = Ix12*Ix12 + cf; Ix(1,3) = Ix13
                 Iy13 = Iy12*Iy12 + cf; Iy(1,3) = Iy13
                 Iz13 = Iz12*Iz12 + cf; Iz(1,3) = Iz13
                 Ixf = Ix13; Ixm1 = Ix12
                 Iyf = Iy13; Iym1 = Iy12
                 Izf = Iz13; Izm1 = Iz12
                 cf1 = cf
                 do fp1 = 4,.cd_l_sum+1
                   cf1 = cf1 + cf
                   Ixp1 = Ix12*Ixf + cf1*Ixm1; Ix(1,fp1) = Ixp1
                   Iyp1 = Iy12*Iyf + cf1*Iym1; Iy(1,fp1) = Iyp1
                   Izp1 = Iz12*Izf + cf1*Izm1; Iz(1,fp1) = Izp1
                   Ixm1 = Ixf; Ixf = Ixp1
                   Iym1 = Iyf; Iyf = Iyp1
                   Izm1 = Izf; Izf = Izp1
                 end
                 bb = t2_rz * half_einv
                 Ix22 = Ix12*Ix21 + bb; Ix(2,2) = Ix22
                 Iy22 = Iy12*Iy21 + bb; Iy(2,2) = Iy22
                 Iz22 = Iz12*Iz21 + bb; Iz(2,2) = Iz22
                 Ix23 = Ix12*Ix22 + cf*Ix21 + bb*Ix12; Ix(2,3) = Ix23
                 Iy23 = Iy12*Iy22 + cf*Iy21 + bb*Iy12; Iy(2,3) = Iy23
                 Iz23 = Iz12*Iz22 + cf*Iz21 + bb*Iz12; Iz(2,3) = Iz23
                 Ix32 = Ix21*Ix22 + ce*Ix12 + bb*Ix21; Ix(3,2) = Ix32
                 Iy32 = Iy21*Iy22 + ce*Iy12 + bb*Iy21; Iy(3,2) = Iy32
                 Iz32 = Iz21*Iz22 + ce*Iz12 + bb*Iz21; Iz(3,2) = Iz32
                 Ixf = Ix23; Ixm1 = Ix22
                 Iyf = Iy23; Iym1 = Iy22
                 Izf = Iz23; Izm1 = Iz22
                 cf1 = cf
                 do f = 3,.cd_l_sum
                   fp1 = f + 1
                   cf1 = cf1 + cf
                   Ixp1 = Ix12*Ixf + cf1*Ixm1 + bb*Ix(1,f); Ix(2,fp1) = Ixp1
                   Iyp1 = Iy12*Iyf + cf1*Iym1 + bb*Iy(1,f); Iy(2,fp1) = Iyp1
                   Izp1 = Iz12*Izf + cf1*Izm1 + bb*Iz(1,f); Iz(2,fp1) = Izp1
                   Ixm1 = Ixf; Ixf = Ixp1
                   Iym1 = Iyf; Iyf = Iyp1
                   Izm1 = Izf; Izf = Izp1
                 end
                 f1_bb = bb
                 do f = 3,.cd_l_sum+1
                   fm1 = f - 1
                   Ix_f => Ix(:,f)
                   Iy_f => Iy(:,f)
                   Iz_f => Iz(:,f)
                   Ix_1 => Ix(:,fm1)
                   Iy_1 => Iy(:,fm1)
                   Iz_1 => Iz(:,fm1)
                   Ixe = Ix_f(2); Ixm1 = Ix_f(1)
                   Iye = Iy_f(2); Iym1 = Iy_f(1)
                   Ize = Iz_f(2); Izm1 = Iz_f(1)
                   f1_bb = f1_bb + bb
                   ce1 = ZERO
                   do e = 2,.ab_l_sum
                     ep1 = e + 1
                     ce1 = ce1 + ce
                     Ixp1 = Ix21*Ixe + ce1*Ixm1 + f1_bb*Ix_1(e); Ix_f(ep1) = Ixp1
                     Iyp1 = Iy21*Iye + ce1*Iym1 + f1_bb*Iy_1(e); Iy_f(ep1) = Iyp1
                     Izp1 = Iz21*Ize + ce1*Izm1 + f1_bb*Iz_1(e); Iz_f(ep1) = Izp1
                     Ixm1 = Ixe; Ixe = Ixp1
                     Iym1 = Iye; Iye = Iyp1
                     Izm1 = Ize; Ize = Izp1
                   end
                 end
               Iz = Iz * rys.weight(n)
             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
   ! SHELL1QUARTET::form_esfs_rms2(self,esfs,Ixa,Iya,Iza,Iza(:,1,1),n_sum,dim1,dim2)

      Iza.destroy
      Iya.destroy
      Ixa.destroy
   end

   make_esfs_XX(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      Ixa,Iya,Iza :: MAT3{REAL}*
      Ix,Iy,Iz :: MAT{REAL}*
      Ix_f,Iy_f,Iz_f,Ix_1,Iy_1,Iz_1 :: VEC{REAL}*
      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
      ce,cf,bb,ce1,cf1 :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
      Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
      Ixe, Iye, Ize, Ixf, Iyf, Izf  :: REAL
      Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
      n_roots,dim1,dim2 :: INT
      e,f,fm1,ep1,fp1,n,i,j,k,n_sum :: INT
      rys :: RYS*

      dim1 = .ab_l_sum + 1                            ! Space for 2D integrals
      dim2 = .cd_l_sum + 1
      n_roots = (dim1+dim2)/2
      n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
      Ixa.create(n_sum,dim1,dim2)                     ! Allocate 2D integrals
      Iya.create(n_sum,dim1,dim2)
      Iza.create(n_sum,dim1,dim2)

      rys.create(n_roots)

      i = 0
      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               i = i + 1
               Ix => Ixa(i,:,:)
               Iy => Iya(i,:,:)
               Iz => Iza(i,:,:)
               t2      = rys.root(n)
               Ix(1,1) = ONE
               Iy(1,1) = ONE
               Iz(1,1) = ONE
                 t2_rz = t2 * rho_zinv
                 Ix21 = PAx + t2_rz*QPx; Ix(2,1) = Ix21
                 Iy21 = PAy + t2_rz*QPy; Iy(2,1) = Iy21
                 Iz21 = PAz + t2_rz*QPz; Iz(2,1) = Iz21
                 ce  = (ONE - t2_rz) * half_zinv
                 Ix31 = Ix21*Ix21 + ce; Ix(3,1) = Ix31
                 Iy31 = Iy21*Iy21 + ce; Iy(3,1) = Iy31
                 Iz31 = Iz21*Iz21 + ce; Iz(3,1) = Iz31
                 Ixe = Ix31; Ixm1 = Ix21
                 Iye = Iy31; Iym1 = Iy21
                 Ize = Iz31; Izm1 = Iz21
                 ce1 = ce
                 do ep1 = 4,.ab_l_sum+1
                   ce1 = ce1 + ce
                   Ixp1 = Ix21*Ixe + ce1*Ixm1; Ix(ep1,1) = Ixp1
                   Iyp1 = Iy21*Iye + ce1*Iym1; Iy(ep1,1) = Iyp1
                   Izp1 = Iz21*Ize + ce1*Izm1; Iz(ep1,1) = Izp1
                   Ixm1 = Ixe; Ixe = Ixp1
                   Iym1 = Iye; Iye = Iyp1
                   Izm1 = Ize; Ize = Izp1
                 end
                 t2_re = t2 * rho_einv
                 Ix12 = QCx - t2_re*QPx; Ix(1,2) = Ix12
                 Iy12 = QCy - t2_re*QPy; Iy(1,2) = Iy12
                 Iz12 = QCz - t2_re*QPz; Iz(1,2) = Iz12
                 cf  = (ONE - t2_re) * half_einv
                 Ix13 = Ix12*Ix12 + cf; Ix(1,3) = Ix13
                 Iy13 = Iy12*Iy12 + cf; Iy(1,3) = Iy13
                 Iz13 = Iz12*Iz12 + cf; Iz(1,3) = Iz13
                 Ixf = Ix13; Ixm1 = Ix12
                 Iyf = Iy13; Iym1 = Iy12
                 Izf = Iz13; Izm1 = Iz12
                 cf1 = cf
                 do fp1 = 4,.cd_l_sum+1
                   cf1 = cf1 + cf
                   Ixp1 = Ix12*Ixf + cf1*Ixm1; Ix(1,fp1) = Ixp1
                   Iyp1 = Iy12*Iyf + cf1*Iym1; Iy(1,fp1) = Iyp1
                   Izp1 = Iz12*Izf + cf1*Izm1; Iz(1,fp1) = Izp1
                   Ixm1 = Ixf; Ixf = Ixp1
                   Iym1 = Iyf; Iyf = Iyp1
                   Izm1 = Izf; Izf = Izp1
                 end
                 bb = t2_rz * half_einv
                 Ix22 = Ix12*Ix21 + bb; Ix(2,2) = Ix22
                 Iy22 = Iy12*Iy21 + bb; Iy(2,2) = Iy22
                 Iz22 = Iz12*Iz21 + bb; Iz(2,2) = Iz22
                 Ix23 = Ix12*Ix22 + cf*Ix21 + bb*Ix12; Ix(2,3) = Ix23
                 Iy23 = Iy12*Iy22 + cf*Iy21 + bb*Iy12; Iy(2,3) = Iy23
                 Iz23 = Iz12*Iz22 + cf*Iz21 + bb*Iz12; Iz(2,3) = Iz23
                 Ix32 = Ix21*Ix22 + ce*Ix12 + bb*Ix21; Ix(3,2) = Ix32
                 Iy32 = Iy21*Iy22 + ce*Iy12 + bb*Iy21; Iy(3,2) = Iy32
                 Iz32 = Iz21*Iz22 + ce*Iz12 + bb*Iz21; Iz(3,2) = Iz32
                 Ixf = Ix23; Ixm1 = Ix22
                 Iyf = Iy23; Iym1 = Iy22
                 Izf = Iz23; Izm1 = Iz22
                 cf1 = cf
                 do f = 3,.cd_l_sum
                   fp1 = f + 1
                   cf1 = cf1 + cf
                   Ixp1 = Ix12*Ixf + cf1*Ixm1 + bb*Ix(1,f); Ix(2,fp1) = Ixp1
                   Iyp1 = Iy12*Iyf + cf1*Iym1 + bb*Iy(1,f); Iy(2,fp1) = Iyp1
                   Izp1 = Iz12*Izf + cf1*Izm1 + bb*Iz(1,f); Iz(2,fp1) = Izp1
                   Ixm1 = Ixf; Ixf = Ixp1
                   Iym1 = Iyf; Iyf = Iyp1
                   Izm1 = Izf; Izf = Izp1
                 end
                 Ixe = Ix32; Ixm1 = Ix22
                 Iye = Iy32; Iym1 = Iy22
                 Ize = Iz32; Izm1 = Iz22
                 ce1 = ce
                 do e = 3,.ab_l_sum
                   ep1 = e + 1
                   ce1 = ce1 + ce
                   Ixp1 = Ix21*Ixe + ce1*Ixm1 + bb*Ix(e,1); Ix(ep1,2) = Ixp1
                   Iyp1 = Iy21*Iye + ce1*Iym1 + bb*Iy(e,1); Iy(ep1,2) = Iyp1
                   Izp1 = Iz21*Ize + ce1*Izm1 + bb*Iz(e,1); Iz(ep1,2) = Izp1
                   Ixm1 = Ixe; Ixe = Ixp1
                   Iym1 = Iye; Iye = Iyp1
                   Izm1 = Ize; Ize = Izp1
                 end
                 f1_bb = bb
                 do f = 3,.cd_l_sum+1
                   fm1 = f - 1
                   Ix_f => Ix(:,f)
                   Iy_f => Iy(:,f)
                   Iz_f => Iz(:,f)
                   Ix_1 => Ix(:,fm1)
                   Iy_1 => Iy(:,fm1)
                   Iz_1 => Iz(:,fm1)
                   Ixe = Ix_f(2); Ixm1 = Ix_f(1)
                   Iye = Iy_f(2); Iym1 = Iy_f(1)
                   Ize = Iz_f(2); Izm1 = Iz_f(1)
                   f1_bb = f1_bb + bb
                   ce1 = ZERO
                   do e = 2,.ab_l_sum
                     ep1 = e + 1
                     ce1 = ce1 + ce
                     Ixp1 = Ix21*Ixe + ce1*Ixm1 + f1_bb*Ix_1(e); Ix_f(ep1) = Ixp1
                     Iyp1 = Iy21*Iye + ce1*Iym1 + f1_bb*Iy_1(e); Iy_f(ep1) = Iyp1
                     Izp1 = Iz21*Ize + ce1*Izm1 + f1_bb*Iz_1(e); Iz_f(ep1) = Izp1
                     Ixm1 = Ixe; Ixe = Ixp1
                     Iym1 = Iye; Iye = Iyp1
                     Izm1 = Ize; Ize = Izp1
                   end
                 end
               Iz = Iz * rys.weight(n)
             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
   ! SHELL1QUARTET::form_esfs_rms2(self,esfs,Ixa,Iya,Iza,Iza(:,1,1),n_sum,dim1,dim2)

      Iza.destroy
      Iya.destroy
      Ixa.destroy

   end

!  ==========================================
!  Form (e0|f0) integrals as sum(Ix*Iy*Iz*wt)
!  ==========================================

   form_esfs(esfs,Ix,Iy,Iz,wt) ::: private
   ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
   ! This version does not use the reduced multiplication scheme.
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT
      self :: IN

      Ix,Iy,Iz :: MAT3{REAL}, IN
      wt :: VEC{REAL}, IN

      ex,ey,ez :: VEC{INT}*
      fx,fy,fz :: VEC{INT}*
      fe,le,ff,lf,e,f,ze,ye,xe,zf,yf,xf :: INT

      if      (.ab_l_max==0 AND .cd_l_max==0) then
        esfs(1,1) = sum(wt)
      else
        fe = .ab_first_gaussian; le = .ab_last_gaussian
        ff = .cd_first_gaussian; lf = .cd_last_gaussian
        ex => GAUSSIAN_DATA::nx(fe:le); ey => GAUSSIAN_DATA::ny(fe:le); ez => GAUSSIAN_DATA::nz(fe:le)
        fx => GAUSSIAN_DATA::nx(ff:lf); fy => GAUSSIAN_DATA::ny(ff:lf); fz => GAUSSIAN_DATA::nz(ff:lf)
        do f = 1,esfs.dim2
           xf = fx(f); yf = fy(f); zf = fz(f)
           do e = 1,esfs.dim1
              xe = ex(e); ye = ey(e); ze = ez(e)
              esfs(e,f) = sum(Ix(:,xe,xf)*Iy(:,ye,yf)*Iz(:,ze,zf))
           end
        end
      end

   end

   form_esss(esfs,Ix,Iy,Iz,wt,n_sum) ::: private
   ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
   ! This version does not use the reduced multiplication scheme.
      self :: IN
      esfs :: VEC{REAL}(.n_ab), OUT

      n_sum :: INT, IN
      Ix,Iy,Iz :: MAT{REAL}(n_sum,*), IN
      wt :: VEC{REAL}, IN

      ex,ey,ez :: VEC{INT}*
      fe,le,e,ze,ye,xe :: INT

!     Ixy :: VEC{REAL}*
!     exyz0,eyz0,exz0,exy0,ez0,ey0,ex0,en0,ea0,e0,erms :: VEC{INT}*
!     fxyz0,fyz0,fxz0,fxy0,fz0,fy0,fx0,fn0,fa0,f0,frms :: VEC{INT}*
!     er,fr :: RMS_INDICES*
!     ee,em :: INT

      if      (.ab_l_max==0 AND .cd_l_max==0) then

        esfs(1) = sum(wt)

      else

        fe = .ab_first_gaussian; le = .ab_last_gaussian
        ex => GAUSSIAN_DATA::nx(fe:le)
        ey => GAUSSIAN_DATA::ny(fe:le)
        ez => GAUSSIAN_DATA::nz(fe:le)
        do e = 1,esfs.dim
           xe = ex(e); ye = ey(e); ze = ez(e)
           esfs(e) = sum(Ix(:,xe)*Iy(:,ye)*Iz(:,ze))
        end

!        fe = .ab_first_gaussian; le = .ab_last_gaussian
!        ex => GAUSSIAN_DATA::nx(fe:le)
!        ey => GAUSSIAN_DATA::ny(fe:le)
!        ez => GAUSSIAN_DATA::nz(fe:le)
!        er => GAUSSIAN_DATA::rms_indices(.ab_l_max,.ab_l_min)
!        exyz0 => er.xyz0; en0 => er.n0
!        eyz0  => er.yz0; exz0 => er.xz0; exy0 => er.xy0
!        ez0   => er.z0;  ey0  => er.y0;  ex0  => er.x0
!        do ee = 1,exyz0.dim
!           e  = exyz0(ee)
!           esfs(e) = sum(wt)
!        end
!        do ee = 1,eyz0.dim
!           e  = eyz0(ee)
!           xe = ex(e)
!           esfs(e) = sum(Ix(:,xe)*wt)
!        end
!        do ee = 1,exz0.dim
!           e  = exz0(ee)
!           ye = ey(e)
!           esfs(e) = sum(Iy(:,ye)*wt)
!        end
!        do ee = 1,exy0.dim
!           e  = exy0(ee)
!           ze = ez(e)
!           esfs(e) = sum(Iz(:,ze)   )
!        end
!        do ee = 1,ez0.dim
!           e  = ez0(ee)
!           xe = ex(e)
!           ye = ey(e)
!           esfs(e) = sum(Ix(:,xe)*Iy(:,ye)*wt      )
!        end
!        do ee = 1,ey0.dim
!           e  = ey0(ee)
!           xe = ex(e)
!           ze = ez(e)
!           esfs(e) = sum(Ix(:,xe)         *Iz(:,ze))
!        end
!        do ee = 1,ex0.dim
!           e  = ex0(ee)
!           ye = ey(e)
!           ze = ez(e)
!           esfs(e) = sum(         Iy(:,ye)*Iz(:,ze))
!        end
!        exy_rms => er.xy_rms_n
!        if (exy_rms.dim==en0.dim) then
!           do ee = 1,en0.dim
!              e  = en0(ee)
!              xe = ex(e); ye = ey(e); ze = ez(e)
!              esfs(e) = sum(Ix(:,xe)*Iy(:,ye)*Iz(:,ze))
!           end
!        else if (exy_rms.dim>0) then
!           Ixy.create(Ix.dim1)
!           do ee = 1,exy_rms.dim                 ! Apply (e) RMS here
!              erms => exy_rms(ee).element
!              e  = en0(erms(1))
!              xe = ex(e)
!              ye = ey(e)
!              ze = ez(e)
!              Ixy = Ix(:,xe)*Iy(:,ye)
!              esfs(e) = sum(Ixy*Iz(:,ze))
!              do em = 2,erms.dim
!                 e = en0(erms(em))
!                 ze = ez(e)
!                 esfs(e) = sum(Ixy*Iz(:,ze))
!              end
!           end
!           Ixy.destroy
!        end

      end

   end

   form_ssfs(esfs,Ix,Iy,Iz,wt,n_sum) ::: private
   ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
   ! This version does not use the reduced multiplication scheme.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), OUT

      n_sum :: INT, IN
      Ix,Iy,Iz :: MAT{REAL}(n_sum,*), IN
      wt :: VEC{REAL}, IN

      fx,fy,fz :: VEC{INT}*
      ff,lf,f,zf,yf,xf :: INT

!     Ixy :: VEC{REAL}*
!     fxyz0,fyz0,fxz0,fxy0,fz0,fy0,fx0,fn0,fa0,f0,frms :: VEC{INT}*
!     fr :: RMS_INDICES*
!     fxy_rms :: VEC{VEC_{INT}}*
!     fm :: INT

      if (.ab_l_max==0 AND .cd_l_max==0) then

        esfs(1) = sum(wt)

      else

        ff = .cd_first_gaussian; lf = .cd_last_gaussian
        fx => GAUSSIAN_DATA::nx(ff:lf)
        fy => GAUSSIAN_DATA::ny(ff:lf)
        fz => GAUSSIAN_DATA::nz(ff:lf)

        do f = 1,esfs.dim
           xf = fx(f); yf = fy(f); zf = fz(f)
           esfs(f) = sum(Ix(:,xf)*Iy(:,yf)*Iz(:,zf))
        end

!        ff = .cd_first_gaussian; lf = .cd_last_gaussian
!        fx => GAUSSIAN_DATA::nx(ff:lf)
!        fy => GAUSSIAN_DATA::ny(ff:lf)
!        fz => GAUSSIAN_DATA::nz(ff:lf)
!        fr => GAUSSIAN_DATA::rms_indices(.cd_l_max,.cd_l_min)
!        fxyz0 => fr.xyz0; fn0 => fr.n0
!        fyz0  => fr.yz0; fxz0 => fr.xz0; fxy0 => fr.xy0
!        fz0   => fr.z0;  fy0  => fr.y0;  fx0  => fr.x0
!        do ff = 1,fxyz0.dim
!           f  = fxyz0(ff)
!           esfs(f) = sum(wt)
!        end
!        do ff = 1,fyz0.dim
!           f  = fyz0(ff)
!           xf = fx(f)
!           esfs(f) = sum(Ix(:,xf)*wt)
!        end
!        do ff = 1,fxz0.dim
!           f  = fxz0(ff)
!           yf = fy(f)
!           esfs(f) = sum(Iy(:,yf)*wt)
!        end
!        do ff = 1,fxy0.dim
!           f  = fxy0(ff)
!           zf = fz(f)
!           esfs(f) = sum(Iz(:,zf)   )
!        end
!        do ff = 1,fz0.dim
!           f  = fz0(ff)
!           xf = fx(f)
!           yf = fy(f)
!           esfs(f) = sum(Ix(:,xf)*Iy(:,yf)*wt      )
!        end
!        do ff = 1,fy0.dim
!           f  = fy0(ff)
!           xf = fx(f)
!           zf = fz(f)
!           esfs(f) = sum(Ix(:,xf)         *Iz(:,zf))
!        end
!        do ff = 1,fx0.dim
!           f  = fx0(ff)
!           yf = fy(f)
!           zf = fz(f)
!           esfs(f) = sum(         Iy(:,yf)*Iz(:,zf))
!        end
!        fxy_rms => fr.xy_rms_n
!        if (fxy_rms.dim==fn0.dim) then
!           do ff = 1,fn0.dim
!              f  = fn0(ff)
!              xf = fx(f); yf = fy(f); zf = fz(f)
!              esfs(f) = sum(Ix(:,xf)*Iy(:,yf)*Iz(:,zf))
!           end
!        else if (fxy_rms.dim>0) then
!           Ixy.create(Ix.dim1)
!           do ff = 1,fxy_rms.dim                 ! Apply (f) RMS here
!              frms => fxy_rms(ff).element
!              f  = fn0(frms(1))
!              xf = fx(f)
!              yf = fy(f)
!              zf = fz(f)
!              Ixy = Ix(:,xf)*Iy(:,yf)
!              esfs(f) = sum(Ixy*Iz(:,zf))
!              do fm = 2,frms.dim
!                 f = fn0(frms(fm))
!                 zf = fz(f)
!                 esfs(f) = sum(Ixy*Iz(:,zf))
!              end
!           end
!           Ixy.destroy
!        end
      end
   end

!   form_esfs_rms2(esfs,Ix,Iy,Iz,wt,n_sum,dim1,dim2) ::: private
!   ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
!   ! This version does not use the reduced multiplication scheme.
!      self :: IN
!      esfs :: VEC{REAL}(.n_ab*.n_cd), OUT
!      Ix,Iy :: MAT{REAL}(n_sum,dim1*dim2), target, IN
!      Iz :: MAT{REAL}(n_sum,dim1*dim2), IN
!      wt :: VEC{REAL}(n_sum), IN
!      n_sum,dim1,dim2 :: INT, IN
!
!      Ixy :: VEC{REAL}*
!      do_Ixy_is_x,do_Ixy_is_y,do_Ixy :: VEC{BIN}*
!      ef,efx,efy,efz :: VEC{INT}*
!      rms2 :: RMS2_INDICES*
!      i,n1,nx,ny,n :: INT
!
!      if (.ab_l_max==0 AND .cd_l_max==0) then
!
!        esfs(1) = sum(wt)
!
!      else
!
!      ! rms2 => GAUSSIAN_DATA::rms2_indices(.ab_l_max,.ab_l_min,.cd_l_max,.cd_l_min)
!        rms2 => GAUSSIAN_DATA::rms2_indices(.ab_l_tri,.cd_l_tri)
!        ef  => rms2.ef
!        efx => rms2.efx
!        efy => rms2.efy
!        efz => rms2.efz
!        do_Ixy_is_x => rms2.do_Ixy_is_x
!        do_Ixy_is_y => rms2.do_Ixy_is_y
!        do_Ixy      => rms2.do_Ixy
!        n1 = rms2.no_Ixy_is_1
!        nx = rms2.no_Ixy_is_x
!        ny = rms2.no_Ixy_is_y
!        n  = esfs.dim
!        do i = 1,n1
!           esfs(ef(i)) = sum(Iz(:,efz(i)))
!        end
!        do i = n1+1,nx
!           if (do_Ixy_is_x(i)) Ixy => Ix(:,efx(i))
!           esfs(ef(i)) = sum(Ixy*Iz(:,efz(i)))
!        end
!        do i = nx+1,ny
!           if (do_Ixy_is_y(i)) Ixy => Iy(:,efy(i))
!           esfs(ef(i)) = sum(Ixy*Iz(:,efz(i)))
!        end
!        Ixy.create(Ix.dim1)
!        do i = ny+1,n
!           if (do_Ixy(i)) Ixy = Ix(:,efx(i))*Iy(:,efy(i))
!           esfs(ef(i)) = sum(Ixy*Iz(:,efz(i)))
!        end
!        Ixy.destroy
!
!      end
!
!   end

!   form_esfs_rms2(esfs,Ix,Iy,Iz,wt,n_sum,dim1,dim2) ::: private
!   ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
!   ! This version does not use the reduced multiplication scheme.
!     self :: IN
!     esfs :: MAT{REAL}(.n_ab,.n_cd), OUT
!     n_sum,dim1,dim2 :: INT, IN
!     Ix,Iy,Iz :: MAT3{REAL}(n_sum,dim1,dim2), target, IN
!     wt :: VEC{REAL}(n_sum), IN
!     Ixy :: VEC{REAL}*
!     Ixy_is_1,Ixy_is_x,Ixy_is_y,Ixy_is_p :: VEC{INT}*
!     ee,ex,ey,ez, ff,fx,fy,fz :: VEC{INT}*
!     rms2 :: RMS2_INDICES*
!     k,nr,i1,i2,ir,e,f,ze,ye,xe,zf,yf,xf :: INT
!     if      (.ab_l_max==0 AND .cd_l_max==0) then
!        esfs(1,1) = sum(wt)
!     else
!        rms2 => GAUSSIAN_DATA::rms2_indices(.ab_l_max,.ab_l_min,.cd_l_max,.cd_l_min)
!        ee => rms2.e;  ff => rms2.f
!        ex => rms2.ex; ey => rms2.ey; ez => rms2.ez
!        fx => rms2.fx; fy => rms2.fy; fz => rms2.fz
!        Ixy_is_1 => rms2.Ixy_is_1
!        Ixy_is_x => rms2.Ixy_is_x
!        Ixy_is_y => rms2.Ixy_is_y
!        Ixy_is_p => rms2.Ixy_is_p
!        i2 = 0
!        do k = 1,Ixy_is_1.dim1
!           nr = Ixy_is_1(k)
!           i1 = i2 + 1
!           i2 = i2 + nr
!           do ir = i1,i2
!              e  = ee(ir); f  = ff(ir)
!              ze = ez(ir)
!              zf = fz(ir)
!              esfs(e,f) = sum(Iz(:,ze,zf))
!           end
!        end
!        do k = 1,Ixy_is_x.dim1
!           nr = Ixy_is_x(k)
!           i1 = i2 + 1
!           i2 = i2 + nr
!           e  = ee(i1); f  = ff(i1)
!           xe = ex(i1); ze = ez(i1)
!           xf = fx(i1); zf = fz(i1)
!           Ixy => Ix(:,xe,xf)
!           esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!           do ir = i1+1,i2
!              e  = ee(ir); f  = ff(ir)
!              ze = ez(ir)
!              zf = fz(ir)
!              esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!           end
!        end
!        do k = 1,Ixy_is_y.dim
!           nr = Ixy_is_y(k)
!           i1 = i2 + 1
!           i2 = i2 + nr
!           e  = ee(i1); f  = ff(i1)
!           ye = ey(i1); ze = ez(i1)
!           yf = fy(i1); zf = fz(i1)
!           Ixy => Iy(:,ye,yf)
!           esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!           do ir = i1+1,i2
!              e  = ee(ir); f  = ff(ir)
!              ze = ez(ir)
!              zf = fz(ir)
!              esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!           end
!        end
!        Ixy.create(Ix.dim1)
!        do k = 1,Ixy_is_p.dim
!           nr = Ixy_is_p(k)
!           i1 = i2 + 1
!           i2 = i2 + nr
!           e  = ee(i1); f  = ff(i1)
!           xe = ex(i1); ye = ey(i1); ze = ez(i1)
!           xf = fx(i1); yf = fy(i1); zf = fz(i1)
!           Ixy = Ix(:,xe,xf)*Iy(:,ye,yf)
!           esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!           do ir = i1+1,i2
!              e  = ee(ir); f  = ff(ir)
!              ze = ez(ir)
!              zf = fz(ir)
!              esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!           end
!        end
!        Ixy.destroy
!     end
!   end

!   form_esfs(esfs,Ix,Iy,Iz,wt) ::: private
!   ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
!   ! This version does not use the reduced multiplication scheme.
!     esfs :: MAT{REAL}, OUT
!     self :: IN
!     Ix,Iy,Iz :: MAT3{REAL}, IN
!     wt :: VEC{REAL}, IN
!     Ixy :: VEC{REAL}*
!     ex,ey,ez, exyz0,eyz0,exz0,exy0,ez0,ey0,ex0,en0,ea0,e0,erms :: VEC{INT}*
!     fx,fy,fz, fxyz0,fyz0,fxz0,fxy0,fz0,fy0,fx0,fn0,fa0,f0,frms :: VEC{INT}*
!     fxy_rms,exy_rms :: VEC{VEC_{INT}}*
!     er,fr :: RMS_INDICES*
!     fe,le,ff,lf,e,f,ee,   ze,ye,xe,zf,yf,xf,fs,es,fm,em :: INT
!     xe1,ye1,xf1,yf1,xye1,xyf1,xy1 :: BIN
!     if      (.ab_l_max==0 AND .cd_l_max==0) then
!        esfs(1,1) = sum(wt)
!     else if (.ab_l_max==0) then
!        ff = .cd_first_gaussian; lf = .cd_last_gaussian
!        fx => GAUSSIAN_DATA::nx(ff:lf)
!        fy => GAUSSIAN_DATA::ny(ff:lf)
!        fz => GAUSSIAN_DATA::nz(ff:lf)
!        fr => GAUSSIAN_DATA::rms_indices(.cd_l_max,.cd_l_min)
!        fxyz0 => fr.xyz0; fn0 => fr.n0
!        fyz0  => fr.yz0; fxz0 => fr.xz0; fxy0 => fr.xy0
!        fz0   => fr.z0;  fy0  => fr.y0;  fx0  => fr.x0
!        do ff = 1,fxyz0.dim
!           f  = fxyz0(ff)
!           esfs(1,f) = sum(wt)
!        end
!        do ff = 1,fyz0.dim
!           f  = fyz0(ff)
!           xf = fx(f)
!           esfs(1,f) = sum(Ix(:,1,xf)*wt)
!        end
!        do ff = 1,fxz0.dim
!           f  = fxz0(ff)
!           yf = fy(f)
!           esfs(1,f) = sum(Iy(:,1,yf)*wt)
!        end
!        do ff = 1,fxy0.dim
!           f  = fxy0(ff)
!           zf = fz(f)
!           esfs(1,f) = sum(Iz(:,1,zf)   )
!        end
!        do ff = 1,fz0.dim
!           f  = fz0(ff)
!           xf = fx(f)
!           yf = fy(f)
!           esfs(1,f) = sum(Ix(:,1,xf)*Iy(:,1,yf)*wt      )
!        end
!        do ff = 1,fy0.dim
!           f  = fy0(ff)
!           xf = fx(f)
!           zf = fz(f)
!           esfs(1,f) = sum(Ix(:,1,xf)         *Iz(:,1,zf))
!        end
!        do ff = 1,fx0.dim
!           f  = fx0(ff)
!           yf = fy(f)
!           zf = fz(f)
!           esfs(1,f) = sum(         Iy(:,1,yf)*Iz(:,1,zf))
!        end
!        fxy_rms => fr.xy_rms_n
!        if (fxy_rms.dim==fn0.dim) then
!           do ff = 1,fn0.dim
!              f  = fn0(ff)
!              xf = fx(f); yf = fy(f); zf = fz(f)
!              esfs(1,f) = sum(Ix(:,1,xf)*Iy(:,1,yf)*Iz(:,1,zf))
!           end
!        else if (fxy_rms.dim>0) then
!           Ixy.create(Ix.dim1)
!           do ff = 1,fxy_rms.dim                 ! Apply (f) RMS here
!              frms => fxy_rms(ff).element
!              f  = fn0(frms(1))
!              xf = fx(f)
!              yf = fy(f)
!              zf = fz(f)
!              Ixy = Ix(:,1,xf)*Iy(:,1,yf)
!              esfs(1,f) = sum(Ixy*Iz(:,1,zf))
!              do fm = 2,frms.dim
!                 f = fn0(frms(fm))
!                 zf = fz(f)
!                 esfs(1,f) = sum(Ixy*Iz(:,1,zf))
!              end
!           end
!           Ixy.destroy
!        end
!     else if (.cd_l_max==0) then
!        fe = .ab_first_gaussian; le = .ab_last_gaussian
!        ex => GAUSSIAN_DATA::nx(fe:le)
!        ey => GAUSSIAN_DATA::ny(fe:le)
!        ez => GAUSSIAN_DATA::nz(fe:le)
!        er => rms_indices(.ab_l_max,.ab_l_min)
!        exyz0 => er.xyz0; en0 => er.n0
!        eyz0  => er.yz0; exz0 => er.xz0; exy0 => er.xy0
!        ez0   => er.z0;  ey0  => er.y0;  ex0  => er.x0
!        do ee = 1,exyz0.dim
!           e  = exyz0(ee)
!           esfs(e,1) = sum(wt)
!        end
!        do ee = 1,eyz0.dim
!           e  = eyz0(ee)
!           xe = ex(e)
!           esfs(e,1) = sum(Ix(:,xe,1)*wt)
!        end
!        do ee = 1,exz0.dim
!           e  = exz0(ee)
!           ye = ey(e)
!           esfs(e,1) = sum(Iy(:,ye,1)*wt)
!        end
!        do ee = 1,exy0.dim
!           e  = exy0(ee)
!           ze = ez(e)
!           esfs(e,1) = sum(Iz(:,ze,1)   )
!        end
!        do ee = 1,ez0.dim
!           e  = ez0(ee)
!           xe = ex(e)
!           ye = ey(e)
!           esfs(e,1) = sum(Ix(:,xe,1)*Iy(:,ye,1)*wt      )
!        end
!        do ee = 1,ey0.dim
!           e  = ey0(ee)
!           xe = ex(e)
!           ze = ez(e)
!           esfs(e,1) = sum(Ix(:,xe,1)         *Iz(:,ze,1))
!        end
!        do ee = 1,ex0.dim
!           e  = ex0(ee)
!           ye = ey(e)
!           ze = ez(e)
!           esfs(e,1) = sum(         Iy(:,ye,1)*Iz(:,ze,1))
!        end
!        exy_rms => er.xy_rms_n
!        if (exy_rms.dim==en0.dim) then
!           do ee = 1,en0.dim
!              e  = en0(ee)
!              xe = ex(e); ye = ey(e); ze = ez(e)
!              esfs(e,1) = sum(Ix(:,xe,1)*Iy(:,ye,1)*Iz(:,ze,1))
!           end
!        else if (exy_rms.dim>0) then
!           Ixy.create(Ix.dim1)
!           do ee = 1,exy_rms.dim                 ! Apply (e) RMS here
!              erms => exy_rms(ee).element
!              e  = en0(erms(1))
!              xe = ex(e)
!              ye = ey(e)
!              ze = ez(e)
!              Ixy = Ix(:,xe,1)*Iy(:,ye,1)
!              esfs(e,1) = sum(Ixy*Iz(:,ze,1))
!              do em = 2,erms.dim
!                 e = en0(erms(em))
!                 ze = ez(e)
!                 esfs(e,1) = sum(Ixy*Iz(:,ze,1))
!              end
!           end
!           Ixy.destroy
!        end
!     else
!        fe = .ab_first_gaussian; le = .ab_last_gaussian
!        ff = .cd_first_gaussian; lf = .cd_last_gaussian
!        ex => nx(fe:le); ey => ny(fe:le); ez => nz(fe:le)
!        fx => nx(ff:lf); fy => ny(ff:lf); fz => nz(ff:lf)
!        do f = 1,esfs.dim2
!           xf = fx(f); yf = fy(f); zf = fz(f)
!           do e = 1,esfs.dim1
!              xe = ex(e); ye = ey(e); ze = ez(e)
!              esfs(e,f) = sum(Ix(:,xe,xf)*Iy(:,ye,yf)*Iz(:,ze,zf))
!           end
!        end
!    return
!        er => GAUSSIAN_DATA::rms_indices(.ab_l_max,.ab_l_min)
!        fr => GAUSSIAN_DATA::rms_indices(.cd_l_max,.cd_l_min)
!        en0 => er.n0; ea0 => er.a0
!        fn0 => fr.n0; fa0 => fr.a0
!        fxy_rms => fr.xy_rms_n
!        exy_rms => er.xy_rms_n
!        f0 => fn0
!        e0 => en0
!        Ixy.create(Ix.dim1)
!        do fs = 1,fxy_rms.dim                            ! Apply (f) RMS here
!           frms => fxy_rms(fs).element
!           f = f0(frms(1))
!           xf  = fx(f); yf = fy(f)
!           do es = 1,exy_rms.dim                         ! Apply (e) RMS here
!              erms => exy_rms(es).element
!              e = e0(erms(1))
!              xe  = ex(e); ye  = ey(e)
!              Ixy = Ix(:,xe,xf)*Iy(:,ye,yf)
!              do fm = 1,frms.dim
!                 f = f0(frms(fm))
!                 zf = fz(f)
!                 do em = 1,erms.dim
!                    e = e0(erms(em))
!                    ze = ez(e)
!                    esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!                 end
!              end
!           end
!        end
!        fxy_rms => fr.xy_rms_a
!        exy_rms => er.xy_rms_n
!        f0 => fa0
!        e0 => en0
!        do fs = 1,fxy_rms.dim                            ! Apply (f) RMS here
!           frms => fxy_rms(fs).element
!           f = f0(frms(1))
!           xf  = fx(f); yf = fy(f)
!           do es = 1,exy_rms.dim                         ! Apply (e) RMS here
!              erms => exy_rms(es).element
!              e = e0(erms(1))
!              xe  = ex(e); ye  = ey(e)
!              Ixy = Ix(:,xe,xf)*Iy(:,ye,yf)
!              do fm = 1,frms.dim
!                 f = f0(frms(fm))
!                 zf = fz(f)
!                 do em = 1,erms.dim
!                    e = e0(erms(em))
!                    ze = ez(e)
!                    esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!                 end
!              end
!           end
!        end
!        fxy_rms => fr.xy_rms_n
!        exy_rms => er.xy_rms_a
!        f0 => fn0
!        e0 => ea0
!        do fs = 1,fxy_rms.dim                            ! Apply (f) RMS here
!           frms => fxy_rms(fs).element
!           f = f0(frms(1))
!           xf  = fx(f); yf = fy(f)
!           do es = 1,exy_rms.dim                         ! Apply (e) RMS here
!              erms => exy_rms(es).element
!              e = e0(erms(1))
!              xe  = ex(e); ye  = ey(e)
!              Ixy = Ix(:,xe,xf)*Iy(:,ye,yf)
!              do fm = 1,frms.dim
!                 f = f0(frms(fm))
!                 zf = fz(f)
!                 do em = 1,erms.dim
!                    e = e0(erms(em))
!                    ze = ez(e)
!                    esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!                 end
!              end
!           end
!        end
!        fxy_rms => fr.xy_rms_a
!        exy_rms => er.xy_rms_a
!        f0 => fa0
!        e0 => ea0
!        do fs = 1,fxy_rms.dim                            ! Apply (f) RMS here
!           frms => fxy_rms(fs).element
!           f = f0(frms(1))
!           xf  = fx(f); yf = fy(f)
!           xf1 = xf==1; yf1 = yf==1
!           xyf1 = xf1 AND yf1
!           do es = 1,exy_rms.dim                         ! Apply (e) RMS here
!              erms => exy_rms(es).element
!              e = e0(erms(1))
!              xe  = ex(e); ye  = ey(e)
!              xe1 = xe==1; ye1 = ye==1                   ! Eliminate unity factors
!              xye1 = xe1  AND ye1
!              xy1  = xyf1 AND xye1
!              if      (    xy1    ) then; ! both factors are one
!              else if (xe1 AND xf1) then; Ixy = Iy(:,ye,yf)
!              else if (ye1 AND yf1) then; Ixy = Ix(:,xe,xf)
!              else;                       Ixy = Ix(:,xe,xf) * Iy(:,ye,yf)
!              end
!              do fm = 1,frms.dim
!                 f = f0(frms(fm))
!                 zf = fz(f)
!                 do em = 1,erms.dim
!                    e = e0(erms(em))
!                    ze = ez(e)
!                    if (xy1) then; esfs(e,f) = sum(    Iz(:,ze,zf))
!                    else;          esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!                    end
!                 end
!              end
!           end
!        end
!        Ixy.destroy
!     end
!   end

!  ==================
!  Transfer relations
!  ==================

   transfer_cd(esfs,escd)
   ! Applies the transfer equation to (es|fs) to give (es|cd)
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), IN
      escd :: MAT3{REAL}(.n_ab,.c.n_comp,.d.n_comp), OUT

      if (.cd_same_center) then

        if (.c.l > .d.l) then; .transfer_l_c_same(esfs,escd)
        else;                  .transfer_l_d_same(esfs,escd)
        end

      else

        if (.c.l > .d.l) then; .transfer_l_c_high(esfs,escd)
        else;                  .transfer_l_d_high(esfs,escd)
        end

      end

   end

   transfer_l_c_same(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where c and d have
   ! the same center and c has high momentum.
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), IN
      escd :: MAT3{REAL}(.n_ab,.c.n_comp,.d.n_comp), OUT

   ENSURE(.c.l>=.d.l,"shell c must have higher momentum than d")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT3{REAL}*
      e,c,d,c1,c2,c3,cc,d1,l,ne,nc,fc,nd,fd,pd,dd,t :: INT

      select case (.d.l)

        case (0)                                  ! (es|cs) case
           escd(:,:,1) = esfs

        case (1)
           ne = esfs.dim1
           if (.c.l==1) then                      ! (es|pp) case
              do e = 1,ne
                 escd(e,1,1) = esfs(e,4)
                 escd(e,1,2) = esfs(e,7)
                 escd(e,1,3) = esfs(e,8)
                 escd(e,2,1) = esfs(e,7)
                 escd(e,2,2) = esfs(e,5)
                 escd(e,2,3) = esfs(e,9)
                 escd(e,3,1) = esfs(e,8)
                 escd(e,3,2) = esfs(e,9)
                 escd(e,3,3) = esfs(e,6)
              end
           else                                   ! (es|cp) case
              nc = .c.n_comp
              fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)           ! Offset into the index array
              do c = 1,nc                                        ! Put (es|fs) straight to (es|cd)
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                 do e = 1,ne
                    escd(e,c,1) = esfs(e,c1)
                    escd(e,c,2) = esfs(e,c2)
                    escd(e,c,3) = esfs(e,c3)
                 end
              end
           end

        case default                              ! general (es|cd) case
           ne = esfs.dim1
           fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)              ! Offset into the index array
           nc = esfs.dim2 - GAUSSIAN_DATA:n_comp(.cd_l_sum)     ! No. of c's in int_new goes down
           int_new.create(ne,nc,3)
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                 do e = 1,ne
                    int_new(e,c,1) = esfs(e,c1)
                    int_new(e,c,2) = esfs(e,c2)
                    int_new(e,c,3) = esfs(e,c3)
                 end
              end
           fd = 1
           nd = 3
           do l = 2,.d.l-1
              nc = nc - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of c's in int_new goes down
              pd = fd                             ! Previous offset for d, in int_old
              fd = fd + nd                        ! Offset into index arrays
              nd = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed d's
              int_old => int_new
              int_new.create(ne,nc,nd)
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(dd)           ! Transfer component
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                    do e = 1,ne
                       int_new(e,c,d) = int_old(e,c1,d1)
                    end
                 end
              end
              int_old.destroy
           end
              nc = .c.n_comp                      ! Final transfer into (es|cd)
              pd = fd
              fd = fd + nd
              nd = .d.n_comp
              int_old => int_new
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd
                 t = GAUSSIAN_DATA::first_nonzero(dd)
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                    do e = 1,ne
                       escd(e,c,d) = int_old(e,c1,d1)
                    end
                 end
               end
               int_old.destroy
        end ! case statement

   end

   transfer_l_d_same(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where c and d have
   ! the same center and d has high momentum.
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), IN
      escd :: MAT3{REAL}(.n_ab,.c.n_comp,.d.n_comp), OUT

   ENSURE(.d.l>=.c.l,"shell d must have higher momentum than c")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT3{REAL}*
      e,c,d,c1,d1,d2,d3,dd,l,ne,nd,fd,nc,fc,pc,cc,t :: INT

      select case (.c.l)

        case (0)                                  ! (es|sd) case
           escd(:,1,:) = esfs

        case (1)
           ne = esfs.dim1
           if (.d.l==1) then                      ! (es|pp) case
              do e = 1,ne
                 escd(e,1,1) = esfs(e,4)
                 escd(e,2,1) = esfs(e,7)
                 escd(e,3,1) = esfs(e,8)
                 escd(e,1,2) = esfs(e,7)
                 escd(e,2,2) = esfs(e,5)
                 escd(e,3,2) = esfs(e,9)
                 escd(e,1,3) = esfs(e,8)
                 escd(e,2,3) = esfs(e,9)
                 escd(e,3,3) = esfs(e,6)
              end
           else                                   ! (es|pd) case
              nd = .d.n_comp
              fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)           ! Offset into the index array
              do d = 1,nd                                        ! Put (es|fs) straight to (es|cd)
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                 do e = 1,ne
                    escd(e,1,d) = esfs(e,d1)
                    escd(e,2,d) = esfs(e,d2)
                    escd(e,3,d) = esfs(e,d3)
                 end
              end
           end

        case default                              ! general (es|cd) case
           ne = esfs.dim1
           fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)              ! Offset into the index array
           nd = esfs.dim2 - GAUSSIAN_DATA:n_comp(.cd_l_sum)     ! No. of d's in int_new goes down
           int_new.create(ne,nd,3)                ! NOTE: d is transposed relative to c
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                 do e = 1,ne
                    int_new(e,d,1) = esfs(e,d1)
                    int_new(e,d,2) = esfs(e,d2)
                    int_new(e,d,3) = esfs(e,d3)
                 end
              end
           fc = 1
           nc = 3
           do l = 2,.c.l-1
              nd = nd - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of d's in int_new goes down
              pc = fc                             ! Previous offset for c, in int_old
              fc = fc + nc                        ! Offset into index arrays
              nc = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(ne,nd,nc)            ! TRANSPOSED
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(cc)           ! Transfer component
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                    do e = 1,ne
                       int_new(e,d,c) = int_old(e,d1,c1)
                    end
                 end
              end
              int_old.destroy
           end
              nd = .d.n_comp                      ! Final transfer into (es|cd)
              pc = fc
              fc = fc + nc
              nc = .c.n_comp
              int_old => int_new
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc
                 t = GAUSSIAN_DATA::first_nonzero(cc)
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                    do e = 1,ne
                       escd(e,c,d) = int_old(e,d1,c1)
                    end
                 end
               end
               int_old.destroy
        end ! case statement

   end

   transfer_l_c_high(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where shell c has the higher
   ! angular momentum.
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), IN
      escd :: MAT3{REAL}(.n_ab,.c.n_comp,.d.n_comp), OUT

   ENSURE(.c.l>=.d.l,"shell c must have higher momentum than d")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT3{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,esfs_ec :: REAL
      e,c,d,c1,c2,c3,cc,d1,l,ne,nc,fc,nd,fd,pd,dd,t :: INT

      select case (.d.l)

        case (0)                                  ! (es|cs) case
           escd(:,:,1) = esfs

        case (1)
           R  = .c.position - .d.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           ne = esfs.dim1
           if (.c.l==1) then                      ! (es|pp) case
              do e = 1,ne
                 esfs_ec = esfs(e,1)
                 escd(e,1,1) = esfs(e,4) + R1*esfs_ec
                 escd(e,1,2) = esfs(e,7) + R2*esfs_ec
                 escd(e,1,3) = esfs(e,8) + R3*esfs_ec
                 esfs_ec = esfs(e,2)
                 escd(e,2,1) = esfs(e,7) + R1*esfs_ec
                 escd(e,2,2) = esfs(e,5) + R2*esfs_ec
                 escd(e,2,3) = esfs(e,9) + R3*esfs_ec
                 esfs_ec = esfs(e,3)
                 escd(e,3,1) = esfs(e,8) + R1*esfs_ec
                 escd(e,3,2) = esfs(e,9) + R2*esfs_ec
                 escd(e,3,3) = esfs(e,6) + R3*esfs_ec
              end
           else                                   ! (es|cp) case
              nc = .c.n_comp
              fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)           ! Offset into the index array
              do c = 1,nc                         ! Put (es|fs) straight to (es|cd)
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                 do e = 1,ne
                    esfs_ec = esfs(e,c)
                    escd(e,c,1) = esfs(e,c1) + R1*esfs_ec
                    escd(e,c,2) = esfs(e,c2) + R2*esfs_ec
                    escd(e,c,3) = esfs(e,c3) + R3*esfs_ec
                 end
              end
           end

        case default                              ! general (es|cd) case
           R  = .c.position - .d.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           ne = esfs.dim1
           fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)              ! Offset into the index array
           nc = esfs.dim2 - GAUSSIAN_DATA:n_comp(.cd_l_sum)     ! No. of c's in int_new goes down
           int_new.create(ne,nc,3)
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                 do e = 1,ne
                    esfs_ec = esfs(e,c)
                    int_new(e,c,1) = esfs(e,c1) + R1*esfs_ec
                    int_new(e,c,2) = esfs(e,c2) + R2*esfs_ec
                    int_new(e,c,3) = esfs(e,c3) + R3*esfs_ec
                 end
              end
           fd = 1
           nd = 3
           do l = 2,.d.l-1
              nc = nc - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of c's in int_new goes down
              pd = fd                             ! Previous offset for d, in int_old
              fd = fd + nd                        ! Offset into index arrays
              nd = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed d's
              int_old => int_new
              int_new.create(ne,nc,nd)
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(dd)           ! Transfer component
                 Rt = R(t)
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                    do e = 1,ne
                       int_new(e,c,d) = int_old(e,c1,d1) + Rt*int_old(e,c,d1)
                    end
                 end
              end
              int_old.destroy
           end
              nc = .c.n_comp                      ! Final transfer into (es|cd)
              pd = fd
              fd = fd + nd
              nd = .d.n_comp
              int_old => int_new
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd
                 t = GAUSSIAN_DATA::first_nonzero(dd)
                 Rt = R(t)
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                    do e = 1,ne
                       escd(e,c,d) = int_old(e,c1,d1) + Rt*int_old(e,c,d1)
                    end
                 end
               end
               int_old.destroy
        end ! case statement

   end

   transfer_l_d_high(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where shell d has the higher
   ! angular momentum.
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), IN
      escd :: MAT3{REAL}(.n_ab,.c.n_comp,.d.n_comp), OUT

   ENSURE(.d.l>=.c.l,"shell d must have higher momentum than c")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT3{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,esfs_ed :: REAL
      e,c,d,c1,d1,d2,d3,dd,l,ne,nd,fd,nc,fc,pc,cc,t :: INT

      select case (.c.l)

        case (0)                                  ! (es|sd) case
           escd(:,1,:) = esfs

        case (1)
           R  = .d.position - .c.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           ne = esfs.dim1
           if (.d.l==1) then                      ! (es|pp) case
              do e = 1,ne
                 esfs_ed = esfs(e,1)
                 escd(e,1,1) = esfs(e,4) + R1*esfs_ed
                 escd(e,2,1) = esfs(e,7) + R2*esfs_ed
                 escd(e,3,1) = esfs(e,8) + R3*esfs_ed
                 esfs_ed = esfs(e,2)
                 escd(e,1,2) = esfs(e,7) + R1*esfs_ed
                 escd(e,2,2) = esfs(e,5) + R2*esfs_ed
                 escd(e,3,2) = esfs(e,9) + R3*esfs_ed
                 esfs_ed = esfs(e,3)
                 escd(e,1,3) = esfs(e,8) + R1*esfs_ed
                 escd(e,2,3) = esfs(e,9) + R2*esfs_ed
                 escd(e,3,3) = esfs(e,6) + R3*esfs_ed
              end
           else                                   ! (es|pd) case
              nd = .d.n_comp
              fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)           ! Offset into the index array
              do d = 1,nd                         ! Put (es|fs) straight to (es|cd)
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                 do e = 1,ne
                    esfs_ed = esfs(e,d)
                    escd(e,1,d) = esfs(e,d1) + R1*esfs_ed
                    escd(e,2,d) = esfs(e,d2) + R2*esfs_ed
                    escd(e,3,d) = esfs(e,d3) + R3*esfs_ed
                 end
              end
           end

        case default                              ! general (es|cd) case
           R  = .d.position - .c.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           ne = esfs.dim1
           fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)              ! Offset into the index array
           nd = esfs.dim2 - GAUSSIAN_DATA:n_comp(.cd_l_sum)     ! No. of d's in int_new goes down
           int_new.create(ne,nd,3)                ! NOTE: d is transposed relative to c
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                 do e = 1,ne
                    esfs_ed = esfs(e,d)
                    int_new(e,d,1) = esfs(e,d1) + R1*esfs_ed
                    int_new(e,d,2) = esfs(e,d2) + R2*esfs_ed
                    int_new(e,d,3) = esfs(e,d3) + R3*esfs_ed
                 end
              end
           fc = 1
           nc = 3
           do l = 2,.c.l-1
              nd = nd - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of d's in int_new goes down
              pc = fc                             ! Previous offset for c, in int_old
              fc = fc + nc                        ! Offset into index arrays
              nc = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(ne,nd,nc)            ! TRANSPOSED
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(cc)           ! Transfer component
                 Rt = R(t)
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                    do e = 1,ne
                       int_new(e,d,c) = int_old(e,d1,c1) + Rt*int_old(e,d,c1)
                    end
                 end
              end
              int_old.destroy
           end
              nd = .d.n_comp                      ! Final transfer into (es|cd)
              pc = fc
              fc = fc + nc
              nc = .c.n_comp
              int_old => int_new
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc
                 t = GAUSSIAN_DATA::first_nonzero(cc)
                 Rt = R(t)
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                    do e = 1,ne
                       escd(e,c,d) = int_old(e,d1,c1) + Rt*int_old(e,d,c1)
                    end
                 end
               end
               int_old.destroy
        end ! case statement

   end


   transfer_cd_s(esfs,escd)
   ! Applies the transfer equation to (es|fs) to give (es|cd)
   ! in the case when e=s.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT

      if (.cd_same_center) then

        if (.c.l > .d.l) then; .transfer_l_c_same_s(esfs,escd)
        else;                  .transfer_l_d_same_s(esfs,escd)
        end

      else

        if (.c.l > .d.l) then; .transfer_l_c_high_s(esfs,escd)
        else;                  .transfer_l_d_high_s(esfs,escd)
        end

      end

   end

   transfer_l_c_same_s(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where c and d have
   ! the same center and c has high momentum. This version is when .n_ab is 1.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT

   ENSURE(.c.l>=.d.l,"shell c must have higher momentum than d")
 ! ENSURE(.n_ab==1,"n_ab must be 1")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      c,d,c1,c2,c3,cc,d1,l,nc,fc,nd,fd,pd,dd,t :: INT

      select case (.d.l)

        case (0)                                  ! (es|cs) case
           escd(:,1) = esfs

        case (1)
           if (.c.l==1) then                      ! (es|pp) case
                 escd(1,1) = esfs(4)
                 escd(1,2) = esfs(7)
                 escd(1,3) = esfs(8)
                 escd(2,1) = esfs(7)
                 escd(2,2) = esfs(5)
                 escd(2,3) = esfs(9)
                 escd(3,1) = esfs(8)
                 escd(3,2) = esfs(9)
                 escd(3,3) = esfs(6)
           else                                   ! (es|cp) case
              nc = .c.n_comp
              fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)           ! Offset into the index array
              do c = 1,nc                         ! Put (es|fs) straight to (es|cd)
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                    escd(c,1) = esfs(c1)
                    escd(c,2) = esfs(c2)
                    escd(c,3) = esfs(c3)
              end
           end

        case default                              ! general (es|cd) case
           fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)              ! Offset into the index array
           nc = .n_cd - GAUSSIAN_DATA:n_comp(.cd_l_sum)         ! No. of c's in int_new goes down
           int_new.create(nc,3)
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                    int_new(c,1) = esfs(c1)
                    int_new(c,2) = esfs(c2)
                    int_new(c,3) = esfs(c3)
              end
           fd = 1
           nd = 3
           do l = 2,.d.l-1
              nc = nc - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of c's in int_new goes down
              pd = fd                             ! Previous offset for d, in int_old
              fd = fd + nd                        ! Offset into index arrays
              nd = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed d's
              int_old => int_new
              int_new.create(nc,nd)
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(dd)           ! Transfer component
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                       int_new(c,d) = int_old(c1,d1)
                 end
              end
              int_old.destroy
           end
              nc = .c.n_comp                      ! Final transfer into (es|cd)
              pd = fd
              fd = fd + nd
              nd = .d.n_comp
              int_old => int_new
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd
                 t = GAUSSIAN_DATA::first_nonzero(dd)
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                       escd(c,d) = int_old(c1,d1)
                 end
               end
               int_old.destroy
        end ! case statement

   end

   transfer_l_d_same_s(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where c and d have
   ! the same center and d has high momentum.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT

   ENSURE(.d.l>=.c.l,"shell d must have higher momentum than c")
 ! ENSURE(.n_ab==1,"n_ab must be 1")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      c,d,c1,d1,d2,d3,dd,l,nd,fd,nc,fc,pc,cc,t :: INT

      select case (.c.l)

        case (0)                                  ! (es|sd) case
           escd(1,:) = esfs

        case (1)
           if (.d.l==1) then                      ! (es|pp) case
                 escd(1,1) = esfs(4)
                 escd(2,1) = esfs(7)
                 escd(3,1) = esfs(8)
                 escd(1,2) = esfs(7)
                 escd(2,2) = esfs(5)
                 escd(3,2) = esfs(9)
                 escd(1,3) = esfs(8)
                 escd(2,3) = esfs(9)
                 escd(3,3) = esfs(6)
           else                                   ! (es|pd) case
              nd = .d.n_comp
              fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)           ! Offset into the index array
              do d = 1,nd                         ! Put (es|fs) straight to (es|cd)
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                    escd(1,d) = esfs(d1)
                    escd(2,d) = esfs(d2)
                    escd(3,d) = esfs(d3)
              end
           end

        case default                              ! general (es|cd) case
           fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)              ! Offset into the index array
           nd = .n_cd - GAUSSIAN_DATA:n_comp(.cd_l_sum)         ! No. of d's in int_new goes down
           int_new.create(nd,3)                   ! NOTE: d is transposed relative to c
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                    int_new(d,1) = esfs(d1)
                    int_new(d,2) = esfs(d2)
                    int_new(d,3) = esfs(d3)
              end
           fc = 1
           nc = 3
           do l = 2,.c.l-1
              nd = nd - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of d's in int_new goes down
              pc = fc                             ! Previous offset for c, in int_old
              fc = fc + nc                        ! Offset into index arrays
              nc = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(nd,nc)               ! TRANSPOSED
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(cc)           ! Transfer component
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                       int_new(d,c) = int_old(d1,c1)
                 end
              end
              int_old.destroy
           end
              nd = .d.n_comp                      ! Final transfer into (es|cd)
              pc = fc
              fc = fc + nc
              nc = .c.n_comp
              int_old => int_new
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc
                 t = GAUSSIAN_DATA::first_nonzero(cc)
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                       escd(c,d) = int_old(d1,c1)
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_c_high_s(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where shell c has the higher
   ! angular momentum.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT

   ENSURE(.c.l>=.d.l,"shell c must have higher momentum than d")
 ! ENSURE(.n_ab==1,"n_ab must be 1")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,esfs_ec :: REAL
      c,d,c1,c2,c3,cc,d1,l,nc,fc,nd,fd,pd,dd,t :: INT

      select case (.d.l)

        case (0)                                  ! (es|cs) case
           escd(:,1) = esfs

        case (1)
           R  = .c.position - .d.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.c.l==1) then                      ! (es|pp) case
                 esfs_ec = esfs(1)
                 escd(1,1) = esfs(4) + R1*esfs_ec
                 escd(1,2) = esfs(7) + R2*esfs_ec
                 escd(1,3) = esfs(8) + R3*esfs_ec
                 esfs_ec = esfs(2)
                 escd(2,1) = esfs(7) + R1*esfs_ec
                 escd(2,2) = esfs(5) + R2*esfs_ec
                 escd(2,3) = esfs(9) + R3*esfs_ec
                 esfs_ec = esfs(3)
                 escd(3,1) = esfs(8) + R1*esfs_ec
                 escd(3,2) = esfs(9) + R2*esfs_ec
                 escd(3,3) = esfs(6) + R3*esfs_ec
           else                                   ! (es|cp) case
              nc = .c.n_comp
              fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)           ! Offset into the index array
              do c = 1,nc                         ! Put (es|fs) straight to (es|cd)
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                    esfs_ec = esfs(c)
                    escd(c,1) = esfs(c1) + R1*esfs_ec
                    escd(c,2) = esfs(c2) + R2*esfs_ec
                    escd(c,3) = esfs(c3) + R3*esfs_ec
              end
           end

        case default                              ! general (es|cd) case
           R  = .c.position - .d.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)              ! Offset into the index array
           nc = .n_cd - GAUSSIAN_DATA:n_comp(.cd_l_sum)         ! No. of c's in int_new goes down
           int_new.create(nc,3)
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                    esfs_ec = esfs(c)
                    int_new(c,1) = esfs(c1) + R1*esfs_ec
                    int_new(c,2) = esfs(c2) + R2*esfs_ec
                    int_new(c,3) = esfs(c3) + R3*esfs_ec
              end
           fd = 1
           nd = 3
           do l = 2,.d.l-1
              nc = nc - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of c's in int_new goes down
              pd = fd                             ! Previous offset for d, in int_old
              fd = fd + nd                        ! Offset into index arrays
              nd = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed d's
              int_old => int_new
              int_new.create(nc,nd)
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(dd)           ! Transfer component
                 Rt = R(t)
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                       int_new(c,d) = int_old(c1,d1) + Rt*int_old(c,d1)
                 end
              end
              int_old.destroy
           end
              nc = .c.n_comp                      ! Final transfer into (es|cd)
              pd = fd
              fd = fd + nd
              nd = .d.n_comp
              int_old => int_new
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd
                 t = GAUSSIAN_DATA::first_nonzero(dd)
                 Rt = R(t)
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                       escd(c,d) = int_old(c1,d1) + Rt*int_old(c,d1)
                 end
              end
              int_old.destroy

        end ! case statement

   end

   transfer_l_d_high_s(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where shell d has the higher
   ! angular momentum.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT

   ENSURE(.d.l>=.c.l,"shell d must have higher momentum than c")
 ! ENSURE(.n_ab==1,"n_ab must be 1")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,esfs_ed :: REAL
      c,d,c1,d1,d2,d3,dd,l,nd,fd,nc,fc,pc,cc,t :: INT

      select case (.c.l)

        case (0)                                  ! (es|sd) case
           escd(1,:) = esfs

        case (1)
           R  = .d.position - .c.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.d.l==1) then                      ! (es|pp) case
                 esfs_ed = esfs(1)
                 escd(1,1) = esfs(4) + R1*esfs_ed
                 escd(2,1) = esfs(7) + R2*esfs_ed
                 escd(3,1) = esfs(8) + R3*esfs_ed
                 esfs_ed = esfs(2)
                 escd(1,2) = esfs(7) + R1*esfs_ed
                 escd(2,2) = esfs(5) + R2*esfs_ed
                 escd(3,2) = esfs(9) + R3*esfs_ed
                 esfs_ed = esfs(3)
                 escd(1,3) = esfs(8) + R1*esfs_ed
                 escd(2,3) = esfs(9) + R2*esfs_ed
                 escd(3,3) = esfs(6) + R3*esfs_ed
           else                                   ! (es|pd) case
              nd = .d.n_comp
              fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)           ! Offset into the index array
              do d = 1,nd                         ! Put (es|fs) straight to (es|cd)
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                    esfs_ed = esfs(d)
                    escd(1,d) = esfs(d1) + R1*esfs_ed
                    escd(2,d) = esfs(d2) + R2*esfs_ed
                    escd(3,d) = esfs(d3) + R3*esfs_ed
              end
           end

        case default                              ! general (es|cd) case
           R  = .d.position - .c.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)              ! Offset into the index array
           nd = .n_cd - GAUSSIAN_DATA:n_comp(.cd_l_sum)         ! No. of d's in int_new goes down
           int_new.create(nd,3)                   ! NOTE: d is transposed relative to c
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                    esfs_ed = esfs(d)
                    int_new(d,1) = esfs(d1) + R1*esfs_ed
                    int_new(d,2) = esfs(d2) + R2*esfs_ed
                    int_new(d,3) = esfs(d3) + R3*esfs_ed
              end
           fc = 1
           nc = 3
           do l = 2,.c.l-1
              nd = nd - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of d's in int_new goes down
              pc = fc                             ! Previous offset for c, in int_old
              fc = fc + nc                        ! Offset into index arrays
              nc = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(nd,nc)               ! TRANSPOSED
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(cc)           ! Transfer component
                 Rt = R(t)
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                       int_new(d,c) = int_old(d1,c1) + Rt*int_old(d,c1)
                 end
              end
              int_old.destroy
           end
              nd = .d.n_comp                      ! Final transfer into (es|cd)
              pc = fc
              fc = fc + nc
              nc = .c.n_comp
              int_old => int_new
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc
                 t = GAUSSIAN_DATA::first_nonzero(cc)
                 Rt = R(t)
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                       escd(c,d) = int_old(d1,c1) + Rt*int_old(d,c1)
                 end
               end
               int_old.destroy

        end ! case statement

   end


   transfer_cd_s_add(esfs,escd)
   ! Applies the transfer equation to (es|fs) to give (es|cd)
   ! in the case when e=s. This version accumulates.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT

      if (.cd_same_center) then

        if (.c.l > .d.l) then; .transfer_l_c_same_s_add(esfs,escd)
        else;                  .transfer_l_d_same_s_add(esfs,escd)
        end

      else

        if (.c.l > .d.l) then; .transfer_l_c_high_s_add(esfs,escd)
        else;                  .transfer_l_d_high_s_add(esfs,escd)
        end

      end

   end

   transfer_l_c_same_s_add(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where c and d have
   ! the same center and c has high momentum. This version accumulates.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT
   ENSURE(.c.l>=.d.l,"shell c must have higher momentum than d")

 ! ENSURE(.n_ab==1,"n_ab must be 1")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      c,d,c1,c2,c3,cc,d1,l,nc,fc,nd,fd,pd,dd,t :: INT

      select case (.d.l)

        case (0)                                  ! (es|cs) case
           escd(:,1) = escd(:,1) + esfs

        case (1)
           if (.c.l==1) then                      ! (es|pp) case
                 escd(1,1) = escd(1,1) + esfs(4)
                 escd(1,2) = escd(1,2) + esfs(7)
                 escd(1,3) = escd(1,3) + esfs(8)
                 escd(2,1) = escd(2,1) + esfs(7)
                 escd(2,2) = escd(2,2) + esfs(5)
                 escd(2,3) = escd(2,3) + esfs(9)
                 escd(3,1) = escd(3,1) + esfs(8)
                 escd(3,2) = escd(3,2) + esfs(9)
                 escd(3,3) = escd(3,3) + esfs(6)
           else                                   ! (es|cp) case
              nc = .c.n_comp
              fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)           ! Offset into the index array
              do c = 1,nc                         ! Put (es|fs) straight to (es|cd)
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                    escd(c,1) = escd(c,1) + esfs(c1)
                    escd(c,2) = escd(c,2) + esfs(c2)
                    escd(c,3) = escd(c,3) + esfs(c3)
              end
           end

        case default                              ! general (es|cd) case
           fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)              ! Offset into the index array
           nc = .n_cd - GAUSSIAN_DATA:n_comp(.cd_l_sum)         ! No. of c's in int_new goes down
           int_new.create(nc,3)
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                    int_new(c,1) = esfs(c1)
                    int_new(c,2) = esfs(c2)
                    int_new(c,3) = esfs(c3)
              end
           fd = 1
           nd = 3
           do l = 2,.d.l-1
              nc = nc - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of c's in int_new goes down
              pd = fd                             ! Previous offset for d, in int_old
              fd = fd + nd                        ! Offset into index arrays
              nd = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed d's
              int_old => int_new
              int_new.create(nc,nd)
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(dd)           ! Transfer component
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                       int_new(c,d) = int_old(c1,d1)
                 end
              end
              int_old.destroy
           end
              nc = .c.n_comp                      ! Final transfer into (es|cd)
              pd = fd
              fd = fd + nd
              nd = .d.n_comp
              int_old => int_new
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd
                 t = GAUSSIAN_DATA::first_nonzero(dd)
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                       escd(c,d) = escd(c,d) + int_old(c1,d1)
                 end
               end
               int_old.destroy
        end ! case statement

   end

   transfer_l_d_same_s_add(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where c and d have
   ! the same center and d has high momentum. This version accumulates.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT

   ENSURE(.d.l>=.c.l,"shell d must have higher momentum than c")
 ! ENSURE(.n_ab==1,"n_ab must be 1")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      c,d,c1,d1,d2,d3,dd,l,nd,fd,nc,fc,pc,cc,t :: INT

      select case (.c.l)

        case (0)                                  ! (es|sd) case
           escd(1,:) = escd(1,:) + esfs

        case (1)
           if (.d.l==1) then                      ! (es|pp) case
                 escd(1,1) = escd(1,1) + esfs(4)
                 escd(2,1) = escd(2,1) + esfs(7)
                 escd(3,1) = escd(3,1) + esfs(8)
                 escd(1,2) = escd(1,2) + esfs(7)
                 escd(2,2) = escd(2,2) + esfs(5)
                 escd(3,2) = escd(3,2) + esfs(9)
                 escd(1,3) = escd(1,3) + esfs(8)
                 escd(2,3) = escd(2,3) + esfs(9)
                 escd(3,3) = escd(3,3) + esfs(6)
           else                                   ! (es|pd) case
              nd = .d.n_comp
              fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)           ! Offset into the index array
              do d = 1,nd                         ! Put (es|fs) straight to (es|cd)
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                    escd(1,d) = escd(1,d) + esfs(d1)
                    escd(2,d) = escd(2,d) + esfs(d2)
                    escd(3,d) = escd(3,d) + esfs(d3)
              end
           end

        case default                              ! general (es|cd) case
           fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)              ! Offset into the index array
           nd = .n_cd - GAUSSIAN_DATA:n_comp(.cd_l_sum)         ! No. of d's in int_new goes down
           int_new.create(nd,3)                   ! NOTE: d is transposed relative to c
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                    int_new(d,1) = esfs(d1)
                    int_new(d,2) = esfs(d2)
                    int_new(d,3) = esfs(d3)
              end
           fc = 1
           nc = 3
           do l = 2,.c.l-1
              nd = nd - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of d's in int_new goes down
              pc = fc                             ! Previous offset for c, in int_old
              fc = fc + nc                        ! Offset into index arrays
              nc = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(nd,nc)               ! TRANSPOSED
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(cc)           ! Transfer component
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                       int_new(d,c) = int_old(d1,c1)
                 end
              end
              int_old.destroy
           end
              nd = .d.n_comp                      ! Final transfer into (es|cd)
              pc = fc
              fc = fc + nc
              nc = .c.n_comp
              int_old => int_new
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc
                 t = GAUSSIAN_DATA::first_nonzero(cc)
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                       escd(c,d) = escd(c,d) + int_old(d1,c1)
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_c_high_s_add(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where shell c has the higher
   ! angular momentum. This version acumulates.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT

   ENSURE(.c.l>=.d.l,"shell c must have higher momentum than d")
 ! ENSURE(.n_ab==1,"n_ab must be 1")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,esfs_ec :: REAL
      c,d,c1,c2,c3,cc,d1,l,nc,fc,nd,fd,pd,dd,t :: INT

      select case (.d.l)

        case (0)                                  ! (es|cs) case
           escd(:,1) = escd(:,1) + esfs

        case (1)
           R  = .c.position - .d.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.c.l==1) then                      ! (es|pp) case
                 esfs_ec = esfs(1)
                 escd(1,1) = escd(1,1) + esfs(4) + R1*esfs_ec
                 escd(1,2) = escd(1,2) + esfs(7) + R2*esfs_ec
                 escd(1,3) = escd(1,3) + esfs(8) + R3*esfs_ec
                 esfs_ec = esfs(2)
                 escd(2,1) = escd(2,1) + esfs(7) + R1*esfs_ec
                 escd(2,2) = escd(2,2) + esfs(5) + R2*esfs_ec
                 escd(2,3) = escd(2,3) + esfs(9) + R3*esfs_ec
                 esfs_ec = esfs(3)
                 escd(3,1) = escd(3,1) + esfs(8) + R1*esfs_ec
                 escd(3,2) = escd(3,2) + esfs(9) + R2*esfs_ec
                 escd(3,3) = escd(3,3) + esfs(6) + R3*esfs_ec
           else                                   ! (es|cp) case
              nc = .c.n_comp
              fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)           ! Offset into the index array
              do c = 1,nc                         ! Put (es|fs) straight to (es|cd)
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                    esfs_ec = esfs(c)
                    escd(c,1) = escd(c,1) + esfs(c1) + R1*esfs_ec
                    escd(c,2) = escd(c,2) + esfs(c2) + R2*esfs_ec
                    escd(c,3) = escd(c,3) + esfs(c3) + R3*esfs_ec
              end
           end

        case default                              ! general (es|cd) case
           R  = .c.position - .d.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)              ! Offset into the index array
           nc = .n_cd - GAUSSIAN_DATA:n_comp(.cd_l_sum)         ! No. of c's in int_new goes down
           int_new.create(nc,3)
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                    esfs_ec = esfs(c)
                    int_new(c,1) = esfs(c1) + R1*esfs_ec
                    int_new(c,2) = esfs(c2) + R2*esfs_ec
                    int_new(c,3) = esfs(c3) + R3*esfs_ec
              end
           fd = 1
           nd = 3
           do l = 2,.d.l-1
              nc = nc - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of c's in int_new goes down
              pd = fd                             ! Previous offset for d, in int_old
              fd = fd + nd                        ! Offset into index arrays
              nd = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed d's
              int_old => int_new
              int_new.create(nc,nd)
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(dd)           ! Transfer component
                 Rt = R(t)
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                       int_new(c,d) = int_old(c1,d1) + Rt*int_old(c,d1)
                 end
              end
              int_old.destroy
           end
              nc = .c.n_comp                      ! Final transfer into (es|cd)
              pd = fd
              fd = fd + nd
              nd = .d.n_comp
              int_old => int_new
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd
                 t = GAUSSIAN_DATA::first_nonzero(dd)
                 Rt = R(t)
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                       escd(c,d) = escd(c,d) + int_old(c1,d1) + Rt*int_old(c,d1)
                 end
              end
              int_old.destroy

        end ! case statement

   end

   transfer_l_d_high_s_add(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where shell d has the higher
   ! angular momentum. This version accumulates.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT

   ENSURE(.d.l>=.c.l,"shell d must have higher momentum than c")
 ! ENSURE(.n_ab==1,"n_ab must be 1")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,esfs_ed :: REAL
      c,d,c1,d1,d2,d3,dd,l,nd,fd,nc,fc,pc,cc,t :: INT

      select case (.c.l)

        case (0)                                  ! (es|sd) case
           escd(1,:) = escd(1,:) + esfs

        case (1)
           R  = .d.position - .c.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.d.l==1) then                      ! (es|pp) case
                 esfs_ed = esfs(1)
                 escd(1,1) = escd(1,1) + esfs(4) + R1*esfs_ed
                 escd(2,1) = escd(2,1) + esfs(7) + R2*esfs_ed
                 escd(3,1) = escd(3,1) + esfs(8) + R3*esfs_ed
                 esfs_ed = esfs(2)
                 escd(1,2) = escd(1,2) + esfs(7) + R1*esfs_ed
                 escd(2,2) = escd(2,2) + esfs(5) + R2*esfs_ed
                 escd(3,2) = escd(3,2) + esfs(9) + R3*esfs_ed
                 esfs_ed = esfs(3)
                 escd(1,3) = escd(1,3) + esfs(8) + R1*esfs_ed
                 escd(2,3) = escd(2,3) + esfs(9) + R2*esfs_ed
                 escd(3,3) = escd(3,3) + esfs(6) + R3*esfs_ed
           else                                   ! (es|pd) case
              nd = .d.n_comp
              fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)           ! Offset into the index array
              do d = 1,nd                         ! Put (es|fs) straight to (es|cd)
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                    esfs_ed = esfs(d)
                    escd(1,d) = escd(1,d) + esfs(d1) + R1*esfs_ed
                    escd(2,d) = escd(2,d) + esfs(d2) + R2*esfs_ed
                    escd(3,d) = escd(3,d) + esfs(d3) + R3*esfs_ed
              end
           end

        case default                              ! general (es|cd) case
           R  = .d.position - .c.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)              ! Offset into the index array
           nd = .n_cd - GAUSSIAN_DATA:n_comp(.cd_l_sum)         ! No. of d's in int_new goes down
           int_new.create(nd,3)                   ! NOTE: d is transposed relative to c
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                    esfs_ed = esfs(d)
                    int_new(d,1) = esfs(d1) + R1*esfs_ed
                    int_new(d,2) = esfs(d2) + R2*esfs_ed
                    int_new(d,3) = esfs(d3) + R3*esfs_ed
              end
           fc = 1
           nc = 3
           do l = 2,.c.l-1
              nd = nd - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of d's in int_new goes down
              pc = fc                             ! Previous offset for c, in int_old
              fc = fc + nc                        ! Offset into index arrays
              nc = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(nd,nc)               ! TRANSPOSED
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(cc)           ! Transfer component
                 Rt = R(t)
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                       int_new(d,c) = int_old(d1,c1) + Rt*int_old(d,c1)
                 end
              end
              int_old.destroy
           end
              nd = .d.n_comp                      ! Final transfer into (es|cd)
              pc = fc
              fc = fc + nc
              nc = .c.n_comp
              int_old => int_new
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc
                 t = GAUSSIAN_DATA::first_nonzero(cc)
                 Rt = R(t)
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                       escd(c,d) = escd(c,d) + int_old(d1,c1) + Rt*int_old(d,c1)
                 end
               end
               int_old.destroy

        end ! case statement

   end


   transfer_ab(escd,abcd)
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
      self :: IN
      escd :: MAT3{REAL}(.n_ab,.c.n_comp,.d.n_comp), IN
      abcd :: MAT4{REAL}(.a.n_comp,.b.n_comp,.c.n_comp,.d.n_comp), OUT

      if (.ab_same_center) then

        if (.a.l > .b.l) then; SHELL1QUARTET::transfer_l_a_same(self,escd,abcd)
        else;                  SHELL1QUARTET::transfer_l_b_same(self,escd,abcd)
        end

      else

        if (.a.l > .b.l) then; SHELL1QUARTET::transfer_l_a_high(self,escd,abcd)
        else;                  SHELL1QUARTET::transfer_l_b_high(self,escd,abcd)
        end

      end

   end

   transfer_l_a_same(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where a and b have
   ! the same center and where shell a has the higher angular momentum. NOTE:
   ! this routine treats the cd indices an compressed together, with size "ncd".
      self :: IN
      escd :: MAT{REAL}(.n_ab,*), IN
      abcd :: MAT3{REAL}(.a.n_comp,.b.n_comp,*), OUT

   ENSURE(.a.l>=.b.l,"shell a must have higher momentum than b")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT3{REAL}*
      ncd,cd,a,b,a1,a2,a3,aa,b1,l,na,fa,nb,fb,pb,bb,t :: INT
      ncd = .c.n_comp*.d.n_comp

      select case (.b.l)

        case (0)                                  ! (as|cd) case
           do cd = 1,ncd
           do a = 1,.a.n_comp
              abcd(a,1,cd) = escd(a,cd)
           end
           end

        case (1)
           if (.a.l==1) then                      ! (pp|cd) case
              do cd = 1,ncd
                 abcd(1,1,cd) = escd(4,cd)
                 abcd(1,2,cd) = escd(7,cd)
                 abcd(1,3,cd) = escd(8,cd)
                 abcd(2,1,cd) = escd(7,cd)
                 abcd(2,2,cd) = escd(5,cd)
                 abcd(2,3,cd) = escd(9,cd)
                 abcd(3,1,cd) = escd(8,cd)
                 abcd(3,2,cd) = escd(9,cd)
                 abcd(3,3,cd) = escd(6,cd)
              end
           else                                   ! (ap|cd) case
              na = .a.n_comp
              fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)           ! Offset into the index array
              do a = 1,na                         ! Put (es|cd) straight to (ap|cd)
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                 do cd = 1,ncd
                    abcd(a,1,cd) = escd(a1,cd)
                    abcd(a,2,cd) = escd(a2,cd)
                    abcd(a,3,cd) = escd(a3,cd)
                 end
              end
           end

        case default                              ! general (ab|cd) case
           fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)              ! Offset into the index array
           na = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of a's in int_new goes down
           int_new.create(ncd,na,3)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                 do cd = 1,ncd
                    int_new(cd,a,1) = escd(a1,cd)
                    int_new(cd,a,2) = escd(a2,cd)
                    int_new(cd,a,3) = escd(a3,cd)
                 end
              end
           fb = 1
           nb = 3
           do l = 2,.b.l-1
              na = na - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of a's in int_new goes down
              pb = fb                             ! Previous offset for b, in int_old
              fb = fb + nb                        ! Offset into index arrays
              nb = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(ncd,na,nb)
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb           ! b1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(bb)           ! Transfer component
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    do cd = 1,ncd
                       int_new(cd,a,b) = int_old(cd,a1,b1)
                    end
                 end
              end
              int_old.destroy
           end
              na = .a.n_comp                      ! Final transfer into (ab|cd)
              pb = fb
              fb = fb + nb
              nb = .b.n_comp
              int_old => int_new
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb
                 t = GAUSSIAN_DATA::first_nonzero(bb)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    do cd = 1,ncd
                       abcd(a,b,cd) = int_old(cd,a1,b1)
                    end
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_b_same(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where a and b have
   ! the same center and where shell b has the higher angular momentum. NOTE:
   ! this routine treats the cd indices an compressed together, with size "ncd".
      self :: IN
      escd :: MAT{REAL}(.n_ab,*), IN
      abcd :: MAT3{REAL}(.a.n_comp,.b.n_comp,*), OUT

   ENSURE(.b.l>=.a.l,"shell b must have higher momentum than a")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT3{REAL}*
      ncd,cd,a,a1,b,b1,b2,b3,bb,l,nb,fb,na,fa,pa,aa,t :: INT
      ncd = .c.n_comp*.d.n_comp

      select case (.a.l)

        case (0)                                  ! (sb|cd) case
           do cd = 1,ncd
           do b = 1,.b.n_comp
              abcd(1,b,cd) = escd(b,cd)
           end
           end

        case (1)
           if (.b.l==1) then                      ! (pp|cd) case
              do cd = 1,ncd
                 abcd(1,1,cd) = escd(4,cd)
                 abcd(2,1,cd) = escd(7,cd)
                 abcd(3,1,cd) = escd(8,cd)
                 abcd(1,2,cd) = escd(7,cd)
                 abcd(2,2,cd) = escd(5,cd)
                 abcd(3,2,cd) = escd(9,cd)
                 abcd(1,3,cd) = escd(8,cd)
                 abcd(2,3,cd) = escd(9,cd)
                 abcd(3,3,cd) = escd(6,cd)
              end
           else                                   ! (pb|cd) case
              nb = .b.n_comp
              fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)           ! Offset into the index array
              do b = 1,nb                         ! Put (es|cd) straight to (pb|cd)
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                 do cd = 1,ncd
                    abcd(1,b,cd) = escd(b1,cd)
                    abcd(2,b,cd) = escd(b2,cd)
                    abcd(3,b,cd) = escd(b3,cd)
                 end
              end
           end

        case default                              ! general (ab|cd) case
           fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)              ! Offset into the index array
           nb = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of b's in int_new goes down
           int_new.create(ncd,nb,3)               ! TRANSPOSED
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                 do cd = 1,ncd
                    int_new(cd,b,1) = escd(b1,cd)
                    int_new(cd,b,2) = escd(b2,cd)
                    int_new(cd,b,3) = escd(b3,cd)
                 end
              end
           fa = 1
           na = 3
           do l = 2,.a.l-1
              nb = nb - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of b's in int_new goes down
              pa = fa                             ! Previous offset for a, in int_old
              fa = fa + na                        ! Offset into index arrays
              na = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed a's
              int_old => int_new
              int_new.create(ncd,nb,na)           ! TRANSPOSED
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa           ! a1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(aa)           ! Transfer component
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    do cd = 1,ncd
                       int_new(cd,b,a) = int_old(cd,b1,a1)
                    end
                 end
              end
              int_old.destroy
           end
              nb = .b.n_comp                      ! Final transfer into (ab|cd)
              pa = fa
              fa = fa + na
              na = .a.n_comp
              int_old => int_new
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa
                 t = GAUSSIAN_DATA::first_nonzero(aa)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    do cd = 1,ncd
                       abcd(a,b,cd) = int_old(cd,b1,a1)
                    end
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_a_high(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where shell a has the higher
   ! angular momentum. NOTE: this routine treats the cd indices an compressed
   ! together, with size "ncd".
      self :: IN
      escd :: MAT{REAL}(.n_ab,*), IN
      abcd :: MAT3{REAL}(.a.n_comp,.b.n_comp,*), OUT

   ENSURE(.a.l>=.b.l,"shell a must have higher momentum than b")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT3{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,escd_acd :: REAL
      ncd,cd,a,b,a1,a2,a3,aa,b1,l,na,fa,nb,fb,pb,bb,t :: INT
      ncd = .c.n_comp*.d.n_comp

      select case (.b.l)

        case (0)                                  ! (as|cd) case
           do cd = 1,ncd
           do a = 1,.a.n_comp
              abcd(a,1,cd) = escd(a,cd)
           end
           end

        case (1)
           R  = .a.position - .b.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.a.l==1) then                      ! (pp|cd) case
              do cd = 1,ncd
                 escd_acd = escd(1,cd)
                 abcd(1,1,cd) = escd(4,cd) + R1*escd_acd
                 abcd(1,2,cd) = escd(7,cd) + R2*escd_acd
                 abcd(1,3,cd) = escd(8,cd) + R3*escd_acd
                 escd_acd = escd(2,cd)
                 abcd(2,1,cd) = escd(7,cd) + R1*escd_acd
                 abcd(2,2,cd) = escd(5,cd) + R2*escd_acd
                 abcd(2,3,cd) = escd(9,cd) + R3*escd_acd
                 escd_acd = escd(3,cd)
                 abcd(3,1,cd) = escd(8,cd) + R1*escd_acd
                 abcd(3,2,cd) = escd(9,cd) + R2*escd_acd
                 abcd(3,3,cd) = escd(6,cd) + R3*escd_acd
              end
           else                                   ! (ap|cd) case
              na = .a.n_comp
              fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)           ! Offset into the index array
              do a = 1,na                         ! Put (es|cd) straight to (ap|cd)
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                 do cd = 1,ncd
                    escd_acd = escd(a,cd)
                    abcd(a,1,cd) = escd(a1,cd) + R1*escd_acd
                    abcd(a,2,cd) = escd(a2,cd) + R2*escd_acd
                    abcd(a,3,cd) = escd(a3,cd) + R3*escd_acd
                 end
              end
           end

        case default                              ! general (ab|cd) case
           R  = .a.position - .b.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)              ! Offset into the index array
           na = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of a's in int_new goes down
           int_new.create(ncd,na,3)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                 do cd = 1,ncd
                    escd_acd = escd(a,cd)
                    int_new(cd,a,1) = escd(a1,cd) + R1*escd_acd
                    int_new(cd,a,2) = escd(a2,cd) + R2*escd_acd
                    int_new(cd,a,3) = escd(a3,cd) + R3*escd_acd
                 end
              end
           fb = 1
           nb = 3
           do l = 2,.b.l-1
              na = na - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of a's in int_new goes down
              pb = fb                             ! Previous offset for b, in int_old
              fb = fb + nb                        ! Offset into index arrays
              nb = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(ncd,na,nb)
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb           ! b1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(bb)           ! Transfer component
                 Rt = R(t)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    do cd = 1,ncd
                       int_new(cd,a,b) = int_old(cd,a1,b1) + Rt*int_old(cd,a,b1)
                    end
                 end
              end
              int_old.destroy
           end
              na = .a.n_comp                      ! Final transfer into (ab|cd)
              pb = fb
              fb = fb + nb
              nb = .b.n_comp
              int_old => int_new
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb
                 t = GAUSSIAN_DATA::first_nonzero(bb)
                 Rt = R(t)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    do cd = 1,ncd
                       abcd(a,b,cd) = int_old(cd,a1,b1) + Rt*int_old(cd,a,b1)
                    end
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_b_high(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where shell b has the higher
   ! angular momentum. NOTE: this routine treats the cd indices an compressed
   ! together, with size "ncd".
      self :: IN
      escd :: MAT{REAL}(.n_ab,*), IN
      abcd :: MAT3{REAL}(.a.n_comp,.b.n_comp,*), OUT

   ENSURE(.b.l>=.a.l,"shell b must have higher momentum than a")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT3{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,escd_bcd :: REAL
      ncd,cd,a,a1,b,b1,b2,b3,bb,l,nb,fb,na,fa,pa,aa,t :: INT
      ncd = .c.n_comp*.d.n_comp

      select case (.a.l)

        case (0)                                  ! (sb|cd) case
           do cd = 1,ncd
           do b = 1,.b.n_comp
              abcd(1,b,cd) = escd(b,cd)
           end
           end

        case (1)
           R  = .b.position - .a.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.b.l==1) then                      ! (pp|cd) case
              do cd = 1,ncd
                 escd_bcd = escd(1,cd)
                 abcd(1,1,cd) = escd(4,cd) + R1*escd_bcd
                 abcd(2,1,cd) = escd(7,cd) + R2*escd_bcd
                 abcd(3,1,cd) = escd(8,cd) + R3*escd_bcd
                 escd_bcd = escd(2,cd)
                 abcd(1,2,cd) = escd(7,cd) + R1*escd_bcd
                 abcd(2,2,cd) = escd(5,cd) + R2*escd_bcd
                 abcd(3,2,cd) = escd(9,cd) + R3*escd_bcd
                 escd_bcd = escd(3,cd)
                 abcd(1,3,cd) = escd(8,cd) + R1*escd_bcd
                 abcd(2,3,cd) = escd(9,cd) + R2*escd_bcd
                 abcd(3,3,cd) = escd(6,cd) + R3*escd_bcd
              end
           else                                   ! (pb|cd) case
              nb = .b.n_comp
              fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)           ! Offset into the index array
              do b = 1,nb                         ! Put (es|cd) straight to (pb|cd)
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                 do cd = 1,ncd
                    escd_bcd = escd(b,cd)
                    abcd(1,b,cd) = escd(b1,cd) + R1*escd_bcd
                    abcd(2,b,cd) = escd(b2,cd) + R2*escd_bcd
                    abcd(3,b,cd) = escd(b3,cd) + R3*escd_bcd
                 end
              end
           end

        case default                              ! general (ab|cd) case
           R  = .b.position - .a.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)              ! Offset into the index array
           nb = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of b's in int_new goes down
           int_new.create(ncd,nb,3)               ! TRANSPOSED
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                 do cd = 1,ncd
                    escd_bcd = escd(b,cd)
                    int_new(cd,b,1) = escd(b1,cd) + R1*escd_bcd
                    int_new(cd,b,2) = escd(b2,cd) + R2*escd_bcd
                    int_new(cd,b,3) = escd(b3,cd) + R3*escd_bcd
                 end
              end
           fa = 1
           na = 3
           do l = 2,.a.l-1
              nb = nb - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of b's in int_new goes down
              pa = fa                             ! Previous offset for a, in int_old
              fa = fa + na                        ! Offset into index arrays
              na = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed a's
              int_old => int_new
              int_new.create(ncd,nb,na)           ! TRANSPOSED
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa           ! a1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(aa)           ! Transfer component
                 Rt = R(t)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    do cd = 1,ncd
                       int_new(cd,b,a) = int_old(cd,b1,a1) + Rt*int_old(cd,b,a1)
                    end
                 end
              end
              int_old.destroy
           end
              nb = .b.n_comp                      ! Final transfer into (ab|cd)
              pa = fa
              fa = fa + na
              na = .a.n_comp
              int_old => int_new
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa
                 t = GAUSSIAN_DATA::first_nonzero(aa)
                 Rt = R(t)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    do cd = 1,ncd
                       abcd(a,b,cd) = int_old(cd,b1,a1) + Rt*int_old(cd,b,a1)
                    end
                 end
               end
               int_old.destroy

        end ! case statement

   end


   transfer_ab_s(escd,abcd)
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
   ! in the case when f=s.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT

      if (.ab_same_center) then

        if (.a.l > .b.l) then; .transfer_l_a_same_s(escd,abcd)
        else;                  .transfer_l_b_same_s(escd,abcd)
        end

      else

        if (.a.l > .b.l) then; .transfer_l_a_high_s(escd,abcd)
        else;                  .transfer_l_b_high_s(escd,abcd)
        end

      end

   end

   transfer_l_a_same_s(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where a and b have
   ! the same center and where shell a has the higher angular momentum. NOTE:
   ! this routine treats the cd indices an compressed together, with size "ncd".
   ! NOTE: .set_hrr_indexing_arrays must be called beforehand.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT
   ENSURE(.a.l>=.b.l,"shell a must have higher momentum than b")

 ! ENSURE(.n_cd==1,"n_cd must be 1")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      a,b,a1,a2,a3,aa,b1,l,na,fa,nb,fb,pb,bb,t :: INT

      select case (.b.l)

        case (0)                                  ! (as|cd) case
           abcd(:,1) = escd

        case (1)
           if (.a.l==1) then                      ! (pp|cd) case
                 abcd(1,1) = escd(4)
                 abcd(1,2) = escd(7)
                 abcd(1,3) = escd(8)
                 abcd(2,1) = escd(7)
                 abcd(2,2) = escd(5)
                 abcd(2,3) = escd(9)
                 abcd(3,1) = escd(8)
                 abcd(3,2) = escd(9)
                 abcd(3,3) = escd(6)
           else                                   ! (ap|cd) case
              na = .a.n_comp
              fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)           ! Offset into the index array
              do a = 1,na                         ! Put (es|cd) straight to (ap|cd)
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                    abcd(a,1) = escd(a1)
                    abcd(a,2) = escd(a2)
                    abcd(a,3) = escd(a3)
              end
           end

        case default                              ! general (ab|cd) case
           fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)              ! Offset into the index array
           na = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of a's in int_new goes down
           int_new.create(na,3)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                    int_new(a,1) = escd(a1)
                    int_new(a,2) = escd(a2)
                    int_new(a,3) = escd(a3)
              end
           fb = 1
           nb = 3
           do l = 2,.b.l-1
              na = na - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of a's in int_new goes down
              pb = fb                             ! Previous offset for b, in int_old
              fb = fb + nb                        ! Offset into index arrays
              nb = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(na,nb)
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb           ! b1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(bb)           ! Transfer component
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                       int_new(a,b) = int_old(a1,b1)
                 end
              end
              int_old.destroy
           end
              na = .a.n_comp                      ! Final transfer into (ab|cd)
              pb = fb
              fb = fb + nb
              nb = .b.n_comp
              int_old => int_new
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb
                 t = GAUSSIAN_DATA::first_nonzero(bb)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                       abcd(a,b) = int_old(a1,b1)
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_b_same_s(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where a and b have
   ! the same center and where shell b has the higher angular momentum. NOTE:
   ! this routine treats the cd indices an compressed together, with size "ncd".
   ! NOTE: .set_hrr_indexing_arrays must be called beforehand.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT

   ENSURE(.b.l>=.a.l,"shell b must have higher momentum than a")
 ! ENSURE(.n_cd==1,"n_cd must be 1")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      a,a1,b,b1,b2,b3,bb,l,nb,fb,na,fa,pa,aa,t :: INT

      select case (.a.l)

        case (0)                                  ! (sb|cd) case
              abcd(1,:) = escd

        case (1)
           if (.b.l==1) then                      ! (pp|cd) case
                 abcd(1,1) = escd(4)
                 abcd(2,1) = escd(7)
                 abcd(3,1) = escd(8)
                 abcd(1,2) = escd(7)
                 abcd(2,2) = escd(5)
                 abcd(3,2) = escd(9)
                 abcd(1,3) = escd(8)
                 abcd(2,3) = escd(9)
                 abcd(3,3) = escd(6)
           else                                   ! (pb|cd) case
              nb = .b.n_comp
              fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)           ! Offset into the index array
              do b = 1,nb                         ! Put (es|cd) straight to (pb|cd)
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                    abcd(1,b) = escd(b1)
                    abcd(2,b) = escd(b2)
                    abcd(3,b) = escd(b3)
              end
           end

        case default                              ! general (ab|cd) case
           fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)              ! Offset into the index array
           nb = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of b's in int_new goes down
           int_new.create(nb,3)                   ! TRANSPOSED
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                    int_new(b,1) = escd(b1)
                    int_new(b,2) = escd(b2)
                    int_new(b,3) = escd(b3)
              end
           fa = 1
           na = 3
           do l = 2,.a.l-1
              nb = nb - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of b's in int_new goes down
              pa = fa                             ! Previous offset for a, in int_old
              fa = fa + na                        ! Offset into index arrays
              na = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed a's
              int_old => int_new
              int_new.create(nb,na)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa           ! a1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(aa)           ! Transfer component
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                       int_new(b,a) = int_old(b1,a1)
                 end
              end
              int_old.destroy
           end
              nb = .b.n_comp                      ! Final transfer into (ab|cd)
              pa = fa
              fa = fa + na
              na = .a.n_comp
              int_old => int_new
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa
                 t = GAUSSIAN_DATA::first_nonzero(aa)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                       abcd(a,b) = int_old(b1,a1)
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_a_high_s(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where shell a has the higher
   ! angular momentum. NOTE: this routine treats the cd indices an compressed
   ! together, with size "ncd". NOTE: .set_hrr_indexing_arrays must be called beforehand.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT

   ENSURE(.a.l>=.b.l,"shell a must have higher momentum than b")
 ! ENSURE(.n_cd==1,"n_cd must be 1")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,escd_acd :: REAL
      a,b,a1,a2,a3,aa,b1,l,na,fa,nb,fb,pb,bb,t :: INT

      select case (.b.l)

        case (0)                                  ! (as|cd) case
           abcd(:,1) = escd

        case (1)
           R  = .a.position - .b.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.a.l==1) then                      ! (pp|cd) case
                 escd_acd = escd(1)
                 abcd(1,1) = escd(4) + R1*escd_acd
                 abcd(1,2) = escd(7) + R2*escd_acd
                 abcd(1,3) = escd(8) + R3*escd_acd
                 escd_acd = escd(2)
                 abcd(2,1) = escd(7) + R1*escd_acd
                 abcd(2,2) = escd(5) + R2*escd_acd
                 abcd(2,3) = escd(9) + R3*escd_acd
                 escd_acd = escd(3)
                 abcd(3,1) = escd(8) + R1*escd_acd
                 abcd(3,2) = escd(9) + R2*escd_acd
                 abcd(3,3) = escd(6) + R3*escd_acd
           else                                   ! (ap|cd) case
              na = .a.n_comp
              fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)           ! Offset into the index array
              do a = 1,na                         ! Put (es|cd) straight to (ap|cd)
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                    escd_acd = escd(a)
                    abcd(a,1) = escd(a1) + R1*escd_acd
                    abcd(a,2) = escd(a2) + R2*escd_acd
                    abcd(a,3) = escd(a3) + R3*escd_acd
              end
           end

        case default                              ! general (ab|cd) case
           R  = .a.position - .b.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)              ! Offset into the index array
           na = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of a's in int_new goes down
           int_new.create(na,3)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                    escd_acd = escd(a)
                    int_new(a,1) = escd(a1) + R1*escd_acd
                    int_new(a,2) = escd(a2) + R2*escd_acd
                    int_new(a,3) = escd(a3) + R3*escd_acd
              end
           fb = 1
           nb = 3
           do l = 2,.b.l-1
              na = na - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of a's in int_new goes down
              pb = fb                             ! Previous offset for b, in int_old
              fb = fb + nb                        ! Offset into index arrays
              nb = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(na,nb)
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb           ! b1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(bb)           ! Transfer component
                 Rt = R(t)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                       int_new(a,b) = int_old(a1,b1) + Rt*int_old(a,b1)
                 end
              end
              int_old.destroy
           end
              na = .a.n_comp                      ! Final transfer into (ab|cd)
              pb = fb
              fb = fb + nb
              nb = .b.n_comp
              int_old => int_new
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb
                 t = GAUSSIAN_DATA::first_nonzero(bb)
                 Rt = R(t)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                       abcd(a,b) = int_old(a1,b1) + Rt*int_old(a,b1)
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_b_high_s(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where shell b has the higher
   ! angular momentum. NOTE: this routine treats the cd indices an compressed
   ! together, with size "ncd". NOTE: .set_hrr_indexing_arrays must be called beforehand.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT

   ENSURE(.b.l>=.a.l,"shell b must have higher momentum than a")
 ! ENSURE(.n_cd==1,"n_cd must be 1")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,escd_bcd :: REAL
      a,a1,b,b1,b2,b3,bb,l,nb,fb,na,fa,pa,aa,t :: INT

      select case (.a.l)

        case (0)                                  ! (sb|cd) case
           abcd(1,:) = escd

        case (1)
           R  = .b.position - .a.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.b.l==1) then                      ! (pp|cd) case
                 escd_bcd = escd(1)
                 abcd(1,1) = escd(4) + R1*escd_bcd
                 abcd(2,1) = escd(7) + R2*escd_bcd
                 abcd(3,1) = escd(8) + R3*escd_bcd
                 escd_bcd = escd(2)
                 abcd(1,2) = escd(7) + R1*escd_bcd
                 abcd(2,2) = escd(5) + R2*escd_bcd
                 abcd(3,2) = escd(9) + R3*escd_bcd
                 escd_bcd = escd(3)
                 abcd(1,3) = escd(8) + R1*escd_bcd
                 abcd(2,3) = escd(9) + R2*escd_bcd
                 abcd(3,3) = escd(6) + R3*escd_bcd
           else                                   ! (pb|cd) case
              nb = .b.n_comp
              fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)           ! Offset into the index array
              do b = 1,nb                         ! Put (es|cd) straight to (pb|cd)
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                    escd_bcd = escd(b)
                    abcd(1,b) = escd(b1) + R1*escd_bcd
                    abcd(2,b) = escd(b2) + R2*escd_bcd
                    abcd(3,b) = escd(b3) + R3*escd_bcd
              end
           end

        case default                              ! general (ab|cd) case
           R  = .b.position - .a.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)              ! Offset into the index array
           nb = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of b's in int_new goes down
           int_new.create(nb,3)
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                    escd_bcd = escd(b)
                    int_new(b,1) = escd(b1) + R1*escd_bcd
                    int_new(b,2) = escd(b2) + R2*escd_bcd
                    int_new(b,3) = escd(b3) + R3*escd_bcd
              end
           fa = 1
           na = 3
           do l = 2,.a.l-1
              nb = nb - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of b's in int_new goes down
              pa = fa                             ! Previous offset for a, in int_old
              fa = fa + na                        ! Offset into index arrays
              na = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed a's
              int_old => int_new
              int_new.create(nb,na)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa           ! a1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(aa)           ! Transfer component
                 Rt = R(t)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                       int_new(b,a) = int_old(b1,a1) + Rt*int_old(b,a1)
                 end
              end
              int_old.destroy
           end
              nb = .b.n_comp                      ! Final transfer into (ab|cd)
              pa = fa
              fa = fa + na
              na = .a.n_comp
              int_old => int_new
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa
                 t = GAUSSIAN_DATA::first_nonzero(aa)
                 Rt = R(t)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                       abcd(a,b) = int_old(b1,a1) + Rt*int_old(b,a1)
                 end
               end
               int_old.destroy

        end ! case statement

   end


   transfer_ab_s_add(escd,abcd)
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
   ! in the case when f=s. This version accumulates.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT

      if (.ab_same_center) then

        if (.a.l > .b.l) then; .transfer_l_a_same_s_add(escd,abcd)
        else;                  .transfer_l_b_same_s_add(escd,abcd)
        end

      else

        if (.a.l > .b.l) then; .transfer_l_a_high_s_add(escd,abcd)
        else;                  .transfer_l_b_high_s_add(escd,abcd)
        end

      end

   end

   transfer_l_a_same_s_add(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where a and b have
   ! the same center and where shell a has the higher angular momentum. NOTE:
   ! this routine treats the cd indices as compressed together, with size "ncd".
   ! This version accumulates.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT

   ENSURE(.a.l>=.b.l,"shell a must have higher momentum than b")
 ! ENSURE(.n_cd==1,"n_cd must be 1")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      a,b,a1,a2,a3,aa,b1,l,na,fa,nb,fb,pb,bb,t :: INT

      select case (.b.l)

        case (0)                                  ! (as|cd) case
           abcd(:,1) = abcd(:,1) + escd

        case (1)
           if (.a.l==1) then                      ! (pp|cd) case
                 abcd(1,1) = abcd(1,1) + escd(4)
                 abcd(1,2) = abcd(1,2) + escd(7)
                 abcd(1,3) = abcd(1,3) + escd(8)
                 abcd(2,1) = abcd(2,1) + escd(7)
                 abcd(2,2) = abcd(2,2) + escd(5)
                 abcd(2,3) = abcd(2,3) + escd(9)
                 abcd(3,1) = abcd(3,1) + escd(8)
                 abcd(3,2) = abcd(3,2) + escd(9)
                 abcd(3,3) = abcd(3,3) + escd(6)
           else                                   ! (ap|cd) case
              na = .a.n_comp
              fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)           ! Offset into the index array
              do a = 1,na                         ! Put (es|cd) straight to (ap|cd)
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                    abcd(a,1) = abcd(a,1) + escd(a1)
                    abcd(a,2) = abcd(a,2) + escd(a2)
                    abcd(a,3) = abcd(a,3) + escd(a3)
              end
           end

        case default                              ! general (ab|cd) case
           fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)              ! Offset into the index array
           na = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of a's in int_new goes down
           int_new.create(na,3)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                    int_new(a,1) = escd(a1)
                    int_new(a,2) = escd(a2)
                    int_new(a,3) = escd(a3)
              end
           fb = 1
           nb = 3
           do l = 2,.b.l-1
              na = na - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of a's in int_new goes down
              pb = fb                             ! Previous offset for b, in int_old
              fb = fb + nb                        ! Offset into index arrays
              nb = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(na,nb)
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb           ! b1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(bb)           ! Transfer component
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                       int_new(a,b) = int_old(a1,b1)
                 end
              end
              int_old.destroy
           end
              na = .a.n_comp                      ! Final transfer into (ab|cd)
              pb = fb
              fb = fb + nb
              nb = .b.n_comp
              int_old => int_new
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb
                 t = GAUSSIAN_DATA::first_nonzero(bb)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                       abcd(a,b) = abcd(a,b) + int_old(a1,b1)
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_b_same_s_add(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where a and b have
   ! the same center and where shell b has the higher angular momentum. NOTE:
   ! this routine treats the cd indices an compressed together, with size "ncd".
   ! This version accumulates.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT

   ENSURE(.b.l>=.a.l,"shell b must have higher momentum than a")
 ! ENSURE(.n_cd==1,"n_cd must be 1")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      a,a1,b,b1,b2,b3,bb,l,nb,fb,na,fa,pa,aa,t :: INT

      select case (.a.l)

        case (0)                                  ! (sb|cd) case
              abcd(1,:) = abcd(1,:) + escd

        case (1)
           if (.b.l==1) then                      ! (pp|cd) case
                 abcd(1,1) = abcd(1,1) + escd(4)
                 abcd(2,1) = abcd(2,1) + escd(7)
                 abcd(3,1) = abcd(3,1) + escd(8)
                 abcd(1,2) = abcd(1,2) + escd(7)
                 abcd(2,2) = abcd(2,2) + escd(5)
                 abcd(3,2) = abcd(3,2) + escd(9)
                 abcd(1,3) = abcd(1,3) + escd(8)
                 abcd(2,3) = abcd(2,3) + escd(9)
                 abcd(3,3) = abcd(3,3) + escd(6)
           else                                   ! (pb|cd) case
              nb = .b.n_comp
              fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)           ! Offset into the index array
              do b = 1,nb                         ! Put (es|cd) straight to (pb|cd)
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                    abcd(1,b) = abcd(1,b) + escd(b1)
                    abcd(2,b) = abcd(2,b) + escd(b2)
                    abcd(3,b) = abcd(3,b) + escd(b3)
              end
           end

        case default                              ! general (ab|cd) case
           fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)              ! Offset into the index array
           nb = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of b's in int_new goes down
           int_new.create(nb,3)                   ! TRANSPOSED
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                    int_new(b,1) = escd(b1)
                    int_new(b,2) = escd(b2)
                    int_new(b,3) = escd(b3)
              end
           fa = 1
           na = 3
           do l = 2,.a.l-1
              nb = nb - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of b's in int_new goes down
              pa = fa                             ! Previous offset for a, in int_old
              fa = fa + na                        ! Offset into index arrays
              na = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed a's
              int_old => int_new
              int_new.create(nb,na)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa           ! a1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(aa)           ! Transfer component
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                       int_new(b,a) = int_old(b1,a1)
                 end
              end
              int_old.destroy
           end
              nb = .b.n_comp                      ! Final transfer into (ab|cd)
              pa = fa
              fa = fa + na
              na = .a.n_comp
              int_old => int_new
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa
                 t = GAUSSIAN_DATA::first_nonzero(aa)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                       abcd(a,b) = abcd(a,b) + int_old(b1,a1)
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_a_high_s_add(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where shell a has the higher
   ! angular momentum. NOTE: this routine treats the cd indices an compressed
   ! together, with size "ncd". This version accumulates.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT

   ENSURE(.a.l>=.b.l,"shell a must have higher momentum than b")
 ! ENSURE(.n_cd==1,"n_cd must be 1")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,escd_acd :: REAL
      a,b,a1,a2,a3,aa,b1,l,na,fa,nb,fb,pb,bb,t :: INT

      select case (.b.l)

        case (0)                                  ! (as|cd) case
           abcd(:,1) = abcd(:,1) + escd

        case (1)
           R  = .a.position - .b.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.a.l==1) then                      ! (pp|cd) case
                 escd_acd = escd(1)
                 abcd(1,1) = abcd(1,1) + escd(4) + R1*escd_acd
                 abcd(1,2) = abcd(1,2) + escd(7) + R2*escd_acd
                 abcd(1,3) = abcd(1,3) + escd(8) + R3*escd_acd
                 escd_acd = escd(2)
                 abcd(2,1) = abcd(2,1) + escd(7) + R1*escd_acd
                 abcd(2,2) = abcd(2,2) + escd(5) + R2*escd_acd
                 abcd(2,3) = abcd(2,3) + escd(9) + R3*escd_acd
                 escd_acd = escd(3)
                 abcd(3,1) = abcd(3,1) + escd(8) + R1*escd_acd
                 abcd(3,2) = abcd(3,2) + escd(9) + R2*escd_acd
                 abcd(3,3) = abcd(3,3) + escd(6) + R3*escd_acd
           else                                   ! (ap|cd) case
              na = .a.n_comp
              fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)           ! Offset into the index array
              do a = 1,na                         ! Put (es|cd) straight to (ap|cd)
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                    escd_acd = escd(a)
                    abcd(a,1) = abcd(a,1) + escd(a1) + R1*escd_acd
                    abcd(a,2) = abcd(a,2) + escd(a2) + R2*escd_acd
                    abcd(a,3) = abcd(a,3) + escd(a3) + R3*escd_acd
              end
           end

        case default                              ! general (ab|cd) case
           R  = .a.position - .b.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)              ! Offset into the index array
           na = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of a's in int_new goes down
           int_new.create(na,3)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                    escd_acd = escd(a)
                    int_new(a,1) = escd(a1) + R1*escd_acd
                    int_new(a,2) = escd(a2) + R2*escd_acd
                    int_new(a,3) = escd(a3) + R3*escd_acd
              end
           fb = 1
           nb = 3
           do l = 2,.b.l-1
              na = na - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of a's in int_new goes down
              pb = fb                             ! Previous offset for b, in int_old
              fb = fb + nb                        ! Offset into index arrays
              nb = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(na,nb)
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb           ! b1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(bb)           ! Transfer component
                 Rt = R(t)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                       int_new(a,b) = int_old(a1,b1) + Rt*int_old(a,b1)
                 end
              end
              int_old.destroy
           end
              na = .a.n_comp                      ! Final transfer into (ab|cd)
              pb = fb
              fb = fb + nb
              nb = .b.n_comp
              int_old => int_new
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb
                 t = GAUSSIAN_DATA::first_nonzero(bb)
                 Rt = R(t)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                       abcd(a,b) = abcd(a,b) + int_old(a1,b1) + Rt*int_old(a,b1)
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_b_high_s_add(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where shell b has the higher
   ! angular momentum. NOTE: this routine treats the cd indices an compressed
   ! together, with size "ncd". This version accumulates.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT

   ENSURE(.b.l>=.a.l,"shell b must have higher momentum than a")
 ! ENSURE(.n_cd==1,"n_cd must be 1")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,escd_bcd :: REAL
      a,a1,b,b1,b2,b3,bb,l,nb,fb,na,fa,pa,aa,t :: INT

      select case (.a.l)

        case (0)                                  ! (sb|cd) case
           abcd(1,:) = abcd(1,:) + escd

        case (1)
           R  = .b.position - .a.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.b.l==1) then                      ! (pp|cd) case
                 escd_bcd = escd(1)
                 abcd(1,1) = abcd(1,1) + escd(4) + R1*escd_bcd
                 abcd(2,1) = abcd(2,1) + escd(7) + R2*escd_bcd
                 abcd(3,1) = abcd(3,1) + escd(8) + R3*escd_bcd
                 escd_bcd = escd(2)
                 abcd(1,2) = abcd(1,2) + escd(7) + R1*escd_bcd
                 abcd(2,2) = abcd(2,2) + escd(5) + R2*escd_bcd
                 abcd(3,2) = abcd(3,2) + escd(9) + R3*escd_bcd
                 escd_bcd = escd(3)
                 abcd(1,3) = abcd(1,3) + escd(8) + R1*escd_bcd
                 abcd(2,3) = abcd(2,3) + escd(9) + R2*escd_bcd
                 abcd(3,3) = abcd(3,3) + escd(6) + R3*escd_bcd
           else                                   ! (pb|cd) case
              nb = .b.n_comp
              fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)           ! Offset into the index array
              do b = 1,nb                         ! Put (es|cd) straight to (pb|cd)
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                    escd_bcd = escd(b)
                    abcd(1,b) = abcd(1,b) + escd(b1) + R1*escd_bcd
                    abcd(2,b) = abcd(2,b) + escd(b2) + R2*escd_bcd
                    abcd(3,b) = abcd(3,b) + escd(b3) + R3*escd_bcd
              end
           end

        case default                              ! general (ab|cd) case
           R  = .b.position - .a.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)              ! Offset into the index array
           nb = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of b's in int_new goes down
           int_new.create(nb,3)
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                    escd_bcd = escd(b)
                    int_new(b,1) = escd(b1) + R1*escd_bcd
                    int_new(b,2) = escd(b2) + R2*escd_bcd
                    int_new(b,3) = escd(b3) + R3*escd_bcd
              end
           fa = 1
           na = 3
           do l = 2,.a.l-1
              nb = nb - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of b's in int_new goes down
              pa = fa                             ! Previous offset for a, in int_old
              fa = fa + na                        ! Offset into index arrays
              na = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed a's
              int_old => int_new
              int_new.create(nb,na)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa           ! a1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(aa)           ! Transfer component
                 Rt = R(t)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                       int_new(b,a) = int_old(b1,a1) + Rt*int_old(b,a1)
                 end
              end
              int_old.destroy
           end
              nb = .b.n_comp                      ! Final transfer into (ab|cd)
              pa = fa
              fa = fa + na
              na = .a.n_comp
              int_old => int_new
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa
                 t = GAUSSIAN_DATA::first_nonzero(aa)
                 Rt = R(t)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                       abcd(a,b) = abcd(a,b) + int_old(b1,a1) + Rt*int_old(b,a1)
                 end
               end
               int_old.destroy

        end ! case statement

   end

!  =============
!  Ishida scheme
!  =============

!   make_e0f0(e0f0) ::: private
!   ! Makes the (g0|00) integrals then the (e0|f0) from them
!     self :: IN
!     e0f0 :: MAT{REAL}(.n_ab,.n_cd), OUT
!
!     Ixa,Iya,Iza :: MAT3{REAL}*
!     Ix,Iy,Iz :: MAT{REAL}*
!     QPx,QPy,QPz,PAx,PAy,PAz,Px,Py,Pz :: REAL
!     ce,cf,bb,ce1,cf1 :: REAL
!     n_roots,n,i,j,k :: INT
!     rys :: RYS*
!     ss :: BIN
!
!     ss = .ab_l_max==0 AND .cd_l_max==0
!     l_sum = .ab_l_sum +.cd_l_sum
!     l_sp1 = l_sum + 1
!
!     gdim = GAUSSIAN_DATA:n_comp_up_to(l_sum)
!     Ix.create(gdim)                     ! Allocate 2D integrals
!     Iy.create(gdim)
!     Iz.create(gdim)
!
!     gx => GAUSSIAN_DATA::nx(:gdim)
!     gy => GAUSSIAN_DATA::ny(:gdim)
!     gz => GAUSSIAN_DATA::nz(:gdim)
!
!     n_roots = (l_sum+2)/2
!     rys.create(n_roots)
!
!     do k = 1,.ab_n_gaussian_pairs
!
!         ab_cc = TWOPI5ON2 * .ab_contraction_prefactor(k)
!         sigma1 = HALF*.ab_exponent_inv(k)
!         PAx = .ab_center_diff(1,k)
!         PAy = .ab_center_diff(2,k)
!         PAz = .ab_center_diff(3,k)
!
!         do j = 1,.cd_n_gaussian_pairs
!
!             cd_cc = .cd_contraction_prefactor(j)
!             sigma2 = HALF*.cd_exponent_inv(j)
!             sigma12 = ONE/(sigma1+sigma2)
!
!             rho  = HALF*sigma12
!             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
!             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
!             rys.get_weights(xx,only_weight=ss)
!             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
!
!             rho1 = sigma1*sigma12
!             px = rho1*QPx
!             py = rho1*QPy
!             pz = rho1*QPz
!             rho1 = sigma1*rho1
!
!             ! Now make the 2 dimensional integrals.
!             do n = 1,n_roots
!
!               t2 = rys.root(n)
!               ax = PAx + px*t2
!               ay = PAy + py*t2
!               az = PAz + pz*t2
!               s1 = sigma1 - rho1*t2
!
!               Ix(1) = ONE
!               Iy(1) = ONE
!               Iz(1) = ONE
!
!               if (l_sum==0) cycle
!
!               Ix(2) = ax
!               Iy(2) = ay
!               Iz(2) = az
!
!               if (l_sum==1) cycle
!
!               sl = ZERO
!               do i = 2,l_sp1
!                  sl = sl + s1
!                  Ix(i+1) = ax*Ix(i) + sl*Ix(i-1)
!                  Iy(i+1) = ay*Iy(i) + sl*Iy(i-1)
!                  Iz(i+1) = az*Iz(i) + sl*Iz(i-1)
!               end
!
!               Iz = Iz * rys.weight(n)
!
!               g000 = Ix(gx)*Iy(gy)*Iz(gz)
!
!             end
!         end     ! -- loops over c,d
!     end         ! -- loops over a,b
!
!     rys.destroy
!
!     .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
!   ! SHELL1QUARTET::form_esfs_rms2(self,esfs,Ixa,Iya,Iza,Iza(:,1,1),n_sum,dim1,dim2)
!
!     Iza.destroy
!     Iya.destroy
!     Ixa.destroy
!   end

!  ================================================================
!  Make only the J contributions from the shell4 and density matrix
!  ================================================================

   make_r_J(J,Pab,Pcd,factor,fa,la,fb,lb,fc,lc,fd,ld)
   ! Makes the J matrix directly from the (es|fs) integrals.
   ! This is a J matrix engine.
      self :: IN
      J :: MAT{REAL}
      Pab,Pcd :: VEC{REAL}
      factor :: REAL, IN
      fa,la,fb,lb,fc,lc,fd,ld :: INT, IN

   ENSURE(.n_ab==Pab.dim,"size of Pab wrong")
   ENSURE(.n_cd==Pcd.dim,"size of Pcd wrong")

      esfs,Jab,Jcd :: MAT{REAL}*
      evfv,ev,fv :: VEC{REAL}*
      ssss :: REAL

      if      (.ab_l_sum==0 AND .cd_l_sum==0) then

        .make_esfs_ss_0000(ssss)
        ssss = factor*ssss
        J(fa,fb) = J(fa,fb) + ssss*Pcd(1)
        J(fc,fd) = J(fc,fd) + ssss*Pab(1)

      else if (.ab_l_sum==0) then

        Jcd.create(.c.n_comp,.d.n_comp)
        evfv.create(.n_cd)
        SHELL1QUARTET::make_esfs(self,evfv)            ! Make (ss|fs) integrals
        J(fa,fb) = J(fa,fb) + factor*sum(evfv*Pcd)
        evfv = evfv*Pab(1)
        SHELL1QUARTET::transfer_cd_s(self,evfv,Jcd)
        evfv.destroy
        J(fc:lc,fd:ld) = J(fc:lc,fd:ld) + factor*Jcd
        Jcd.destroy

      else if (.cd_l_sum==0) then

        Jab.create(.a.n_comp,.b.n_comp)
        evfv.create(.n_ab)
        SHELL1QUARTET::make_esfs(self,evfv)            ! Make (es|ss) integrals
        J(fc,fd) = J(fc,fd) + factor*sum(evfv*Pab)
        evfv = evfv*Pcd(1)
        SHELL1QUARTET::transfer_ab_s(self,evfv,Jab)
        evfv.destroy
        J(fa:la,fb:lb) = J(fa:la,fb:lb) + factor*Jab
        Jab.destroy

      else

        Jab.create(.a.n_comp,.b.n_comp)
        Jcd.create(.c.n_comp,.d.n_comp)
        esfs.create(.n_ab,.n_cd)
        ev.create(.n_ab)
        fv.create(.n_cd)
        SHELL1QUARTET::make_esfs(self,esfs)            ! Make (es|fs) integrals
        ev.to_product_of(esfs,Pcd)
        fv.to_product_of(esfs,Pab,transpose_a=TRUE)
        SHELL1QUARTET::transfer_cd_s(self,fv,Jcd)
        SHELL1QUARTET::transfer_ab_s(self,ev,Jab)
        fv.destroy; ev.destroy
        esfs.destroy
        J(fa:la,fb:lb) = J(fa:la,fb:lb) + factor*Jab
        J(fc:lc,fd:ld) = J(fc:lc,fd:ld) + factor*Jcd
        Jcd.destroy
        Jab.destroy

      end

   end

   make_r_J_engine(Jab,Jcd,Pab,Pcd,factor,same)
   ! Makes the J matrix directly from the (es|fs) integrals.
   ! This is a J matrix engine.
      self :: IN
      Jab,Jcd :: VEC{REAL}
      Pab,Pcd :: VEC{REAL}, IN
      factor :: REAL, IN
      same :: BIN, IN

   ENSURE(.n_ab==Jab.dim,"size of Jab wrong")
   ENSURE(.n_cd==Jcd.dim,"size of Jcd wrong")
   ENSURE(.n_ab==Pab.dim,"size of Pab wrong")
   ENSURE(.n_cd==Pcd.dim,"size of Pcd wrong")

      esfs :: MAT{REAL}*
      evfv,ev,fv :: VEC{REAL}*
      ssss,fac :: REAL

      if      (.ab_l_sum==0 AND .cd_l_sum==0) then

        .make_esfs_ss_0000(ssss)
        ssss = factor*ssss
        if (same) then
           ssss = TWO*ssss
           Jab(1) = Jab(1) + ssss*Pcd(1)
        else
           Jab(1) = Jab(1) + ssss*Pcd(1)
           Jcd(1) = Jcd(1) + ssss*Pab(1)
        end

      else if (.ab_l_sum==0) then

        evfv.create(.n_cd)
        SHELL1QUARTET::make_esfs(self,evfv)            ! Make (ss|fs) integrals
        fac = factor*Pab(1)
        Jab(1) = Jab(1) + factor*sum(evfv*Pcd)
        Jcd    = Jcd    + fac*evfv
        evfv.destroy

      else if (.cd_l_sum==0) then

        evfv.create(.n_ab)
        SHELL1QUARTET::make_esfs(self,evfv)            ! Make (es|ss) integrals
        fac = factor*Pcd(1)
        Jcd(1) = Jcd(1) + factor*sum(evfv*Pab)
        Jab    = Jab    + fac*evfv
        evfv.destroy

      else

        ev.create(.n_ab)
        fv.create(.n_cd)
        esfs.create(.n_ab,.n_cd)
        SHELL1QUARTET::make_esfs(self,esfs)            ! Make (es|fs) integrals
        ev.to_product_of(esfs,Pcd)
        fv.to_product_of(esfs,Pab,transpose_a=TRUE)
        esfs.destroy
        if (same) then
           fac = TWO*factor
           Jab = Jab + fac*ev
        else
           Jab = Jab + factor*ev
           Jcd = Jcd + factor*fv
        end
        fv.destroy; ev.destroy

      end

   end

   make_r_JK_engine(Jab,Jcd,Pab,Pcd,K,P,skip_J,skip_K,same,factor,fa,la,fb,lb,fc,lc,fd,ld)
   ! Makes the J matrix directly from the (es|fs) integrals (J matrix engine).
   ! Makes the K matrix normally. There are independent skips for each.
      self :: IN
      Jab,Jcd :: VEC{REAL}
      Pab,Pcd :: VEC{REAL}, IN
      K :: MAT{REAL}
      P :: MAT{REAL}, IN
      skip_J,skip_K,same :: BIN, IN
      factor :: REAL, IN
      fa,la,fb,lb,fc,lc,fd,ld :: INT, IN

 ! ENSURE(NOT .is_spherical,"not implemented")
 ! ENSURE(.n_ab==Jab.dim,"size of Jab wrong")
 ! ENSURE(.n_cd==Jcd.dim,"size of Jcd wrong")
 ! ENSURE(.n_ab==Pab.dim,"size of Pab wrong")
 ! ENSURE(.n_cd==Pcd.dim,"size of Pcd wrong")

      esfs :: MAT{REAL}*
      evfv,ev,fv,I,escd :: VEC{REAL}*
      ssss,fac,I_abcd :: REAL
      a,b,c,d,abcd :: INT

      if      (.ab_l_sum==0 AND .cd_l_sum==0) then       ! Make (ss|ss) integrals

        .make_esfs_ss_0000(ssss)
        ssss = factor*ssss
        if (NOT skip_J) then
           if (same) then
              Jab(1) = Jab(1) + TWO*ssss*Pcd(1)
           else
              Jab(1) = Jab(1) + ssss*Pcd(1)
              Jcd(1) = Jcd(1) + ssss*Pab(1)
           end
        end
        if (NOT skip_K) then
           K(fa,fc) = K(fa,fc) + ssss*P(fd,fb)
           K(fa,fd) = K(fa,fd) + ssss*P(fc,fb)
           K(fb,fc) = K(fb,fc) + ssss*P(fd,fa)
           K(fb,fd) = K(fb,fd) + ssss*P(fc,fa)
        end

      else if (.ab_l_sum==0) then

        evfv.create(.n_cd)
        SHELL1QUARTET::make_esfs(self,evfv)            ! Make (ss|fs) integrals
        if (NOT skip_J) then
           fac = factor*Pab(1)
           Jab(1) = Jab(1) + factor*sum(evfv*Pcd)
           Jcd    = Jcd    + fac*evfv
        end
        if (NOT skip_K) then
           I.create(.cd_n_comp_pairs)
           SHELL1QUARTET::transfer_cd_s(self,evfv,I)   ! Transfer, ab = ss
           abcd = 0
           do d = fd,ld
           do c = fc,lc
              abcd = abcd + 1
              I_abcd = factor * I(abcd)
              K(fa,c) = K(fa,c) + I_abcd*P(d,fb)
              K(fa,d) = K(fa,d) + I_abcd*P(c,fb)
              K(fb,c) = K(fb,c) + I_abcd*P(d,fa)
              K(fb,d) = K(fb,d) + I_abcd*P(c,fa)
           end
           end
           I.destroy
        end
        evfv.destroy

      else if (.cd_l_sum==0) then

        evfv.create(.n_ab)
        SHELL1QUARTET::make_esfs(self,evfv)            ! Make (es|ss) integrals
        if (NOT skip_J) then
           fac = factor*Pcd(1)
           Jcd(1) = Jcd(1) + factor*sum(evfv*Pab)
           Jab    = Jab    + fac*evfv
        end
        if (NOT skip_K) then
           I.create(.ab_n_comp_pairs)
           SHELL1QUARTET::transfer_ab_s(self,evfv,I)   ! Transfer, cd = ss
           abcd = 0
           do b = fb,lb
           do a = fa,la
              abcd = abcd + 1
              I_abcd = factor * I(abcd)
              K(a,fc) = K(a,fc) + I_abcd*P(fd,b)
              K(a,fd) = K(a,fd) + I_abcd*P(fc,b)
              K(b,fc) = K(b,fc) + I_abcd*P(fd,a)
              K(b,fd) = K(b,fd) + I_abcd*P(fc,a)
           end
           end
           I.destroy
        end
        evfv.destroy

      else

        esfs.create(.n_ab,.n_cd)
        SHELL1QUARTET::make_esfs(self,esfs)            ! Make (es|fs) integrals
        if (NOT skip_J) then
           ev.create(.n_ab)
           fv.create(.n_cd)
           ev.to_product_of(esfs,Pcd)
           fv.to_product_of(esfs,Pab,transpose_a=TRUE)
           if (same) then
              fac = TWO*factor
              Jab = Jab + fac*ev
           else
              Jab = Jab + factor*ev
              Jcd = Jcd + factor*fv
           end
           fv.destroy; ev.destroy
        end
        if (NOT skip_K) then
           I.create(.ab_n_comp_pairs*.cd_n_comp_pairs)
           escd.create(.n_ab*.c.n_comp*.d.n_comp)
           SHELL1QUARTET::transfer_cd(self,esfs,escd)     ! Transfer relations
           SHELL1QUARTET::transfer_ab(self,escd,I)
           escd.destroy
           abcd = 0
           do d = fd,ld
           do c = fc,lc
           do b = fb,lb
           do a = fa,la
              abcd = abcd + 1
              I_abcd = factor * I(abcd)
              K(a,c) = K(a,c) + I_abcd*P(d,b)
              K(a,d) = K(a,d) + I_abcd*P(c,b)
              K(b,c) = K(b,c) + I_abcd*P(d,a)
              K(b,d) = K(b,d) + I_abcd*P(c,a)
           end
           end
           end
           end
           I.destroy
        end
        esfs.destroy

      end

   end

   make_r_JK_engine(JAab,JBab,JAcd,JBcd,PAab,PBab,PAcd,PBcd,Ka,Kb,Pa,Pb,sJ,sK,same,factor,fa,la,fb,lb,fc,lc,fd,ld)
   ! Makes the alpha and beta J matrix directly from the (es|fs) integrals (J matrix engine).
   ! Makes the alpha and beta K matrix normally. There are independent skips for each.
      self :: IN
      JAab,JBab,JAcd,JBcd :: VEC{REAL}
      PAab,PBab,PAcd,PBcd :: VEC{REAL}, IN
      Ka,Kb :: MAT{REAL}
      Pa,Pb :: MAT{REAL}, IN
      sJ,sK,same :: BIN, IN ! skip_J, skip_K, same
      factor :: REAL, IN
      fa,la,fb,lb,fc,lc,fd,ld :: INT, IN

      esfs :: MAT{REAL}*
      evfv,ev,fv,I,escd :: VEC{REAL}*
      ssss,fac,I_abcd :: REAL
      a,b,c,d,abcd :: INT

      if      (.ab_l_sum==0 AND .cd_l_sum==0) then       ! Make (ss|ss) integrals

        .make_esfs_ss_0000(ssss)
        ssss = factor*ssss

        if (NOT sJ) then
           if (same) then
              JAab(1) = JAab(1) + TWO*ssss*PAcd(1)
              JBab(1) = JBab(1) + TWO*ssss*PBcd(1)
           else
              JAab(1) = JAab(1) + ssss*PAcd(1)
              JAcd(1) = JAcd(1) + ssss*PAab(1)
              JBab(1) = JBab(1) + ssss*PBcd(1)
              JBcd(1) = JBcd(1) + ssss*PBab(1)
           end
        end

        if (NOT sK) then
           Ka(fa,fc) = Ka(fa,fc) + ssss*Pa(fd,fb)
           Ka(fa,fd) = Ka(fa,fd) + ssss*Pa(fc,fb)
           Ka(fb,fc) = Ka(fb,fc) + ssss*Pa(fd,fa)
           Ka(fb,fd) = Ka(fb,fd) + ssss*Pa(fc,fa)
           Kb(fa,fc) = Kb(fa,fc) + ssss*Pb(fd,fb)
           Kb(fa,fd) = Kb(fa,fd) + ssss*Pb(fc,fb)
           Kb(fb,fc) = Kb(fb,fc) + ssss*Pb(fd,fa)
           Kb(fb,fd) = Kb(fb,fd) + ssss*Pb(fc,fa)
        end

      else if (.ab_l_sum==0) then

        evfv.create(.n_cd)

        SHELL1QUARTET::make_esfs(self,evfv)            ! Make (ss|fs) integrals

        if (NOT sJ) then
           fac = factor*PAab(1)
           JAab(1) = JAab(1) + factor*sum(evfv*PAcd)
           JAcd    = JAcd    + fac*evfv
           fac = factor*PBab(1)
           JBab(1) = JBab(1) + factor*sum(evfv*PBcd)
           JBcd    = JBcd    + fac*evfv
        end

        if (NOT sK) then
           I.create(.cd_n_comp_pairs)
           SHELL1QUARTET::transfer_cd_s(self,evfv,I)   ! Transfer, ab = ss
           abcd = 0
           do d = fd,ld
           do c = fc,lc
              abcd = abcd + 1
              I_abcd = factor * I(abcd)
              Ka(fa,c) = Ka(fa,c) + I_abcd*Pa(d,fb)
              Ka(fa,d) = Ka(fa,d) + I_abcd*Pa(c,fb)
              Ka(fb,c) = Ka(fb,c) + I_abcd*Pa(d,fa)
              Ka(fb,d) = Ka(fb,d) + I_abcd*Pa(c,fa)
              Kb(fa,c) = Kb(fa,c) + I_abcd*Pb(d,fb)
              Kb(fa,d) = Kb(fa,d) + I_abcd*Pb(c,fb)
              Kb(fb,c) = Kb(fb,c) + I_abcd*Pb(d,fa)
              Kb(fb,d) = Kb(fb,d) + I_abcd*Pb(c,fa)
           end
           end
           I.destroy
        end

        evfv.destroy

      else if (.cd_l_sum==0) then

        evfv.create(.n_ab)

        SHELL1QUARTET::make_esfs(self,evfv)            ! Make (es|ss) integrals

        if (NOT sJ) then
           fac = factor*PAcd(1)
           JAcd(1) = JAcd(1) + factor*sum(evfv*PAab)
           JAab    = JAab    + fac*evfv
           fac = factor*PBcd(1)
           JBcd(1) = JBcd(1) + factor*sum(evfv*PBab)
           JBab    = JBab    + fac*evfv
        end

        if (NOT sK) then
           I.create(.ab_n_comp_pairs)
           SHELL1QUARTET::transfer_ab_s(self,evfv,I)   ! Transfer, cd = ss
           abcd = 0
           do b = fb,lb
           do a = fa,la
              abcd = abcd + 1
              I_abcd = factor * I(abcd)
              Ka(a,fc) = Ka(a,fc) + I_abcd*Pa(fd,b)
              Ka(a,fd) = Ka(a,fd) + I_abcd*Pa(fc,b)
              Ka(b,fc) = Ka(b,fc) + I_abcd*Pa(fd,a)
              Ka(b,fd) = Ka(b,fd) + I_abcd*Pa(fc,a)
              Kb(a,fc) = Kb(a,fc) + I_abcd*Pb(fd,b)
              Kb(a,fd) = Kb(a,fd) + I_abcd*Pb(fc,b)
              Kb(b,fc) = Kb(b,fc) + I_abcd*Pb(fd,a)
              Kb(b,fd) = Kb(b,fd) + I_abcd*Pb(fc,a)
           end
           end
           I.destroy
        end

        evfv.destroy

      else

        esfs.create(.n_ab,.n_cd)

        SHELL1QUARTET::make_esfs(self,esfs)            ! Make (es|fs) integrals

        if (NOT sJ) then
           ev.create(.n_ab)
           fv.create(.n_cd)
           ev.to_product_of(esfs,PAcd)
           fv.to_product_of(esfs,PAab,transpose_a=TRUE)
           if (same) then
              fac = TWO*factor
              JAab = JAab + fac*ev
           else
              JAab = JAab + factor*ev
              JAcd = JAcd + factor*fv
           end
           ev.to_product_of(esfs,PBcd)
           fv.to_product_of(esfs,PBab,transpose_a=TRUE)
           if (same) then
              fac = TWO*factor
              JBab = JBab + fac*ev
           else
              JBab = JBab + factor*ev
              JBcd = JBcd + factor*fv
           end
           fv.destroy; ev.destroy
        end

        if (NOT sK) then
           I.create(.ab_n_comp_pairs*.cd_n_comp_pairs)
           escd.create(.n_ab*.c.n_comp*.d.n_comp)
           SHELL1QUARTET::transfer_cd(self,esfs,escd)     ! Transfer relations
           SHELL1QUARTET::transfer_ab(self,escd,I)
           escd.destroy
           abcd = 0
           do d = fd,ld
           do c = fc,lc
           do b = fb,lb
           do a = fa,la
              abcd = abcd + 1
              I_abcd = factor * I(abcd)
              Ka(a,c) = Ka(a,c) + I_abcd*Pa(d,b)
              Ka(a,d) = Ka(a,d) + I_abcd*Pa(c,b)
              Ka(b,c) = Ka(b,c) + I_abcd*Pa(d,a)
              Ka(b,d) = Ka(b,d) + I_abcd*Pa(c,a)
              Kb(a,c) = Kb(a,c) + I_abcd*Pb(d,b)
              Kb(a,d) = Kb(a,d) + I_abcd*Pb(c,b)
              Kb(b,c) = Kb(b,c) + I_abcd*Pb(d,a)
              Kb(b,d) = Kb(b,d) + I_abcd*Pb(c,a)
           end
           end
           end
           end
           I.destroy
        end

        esfs.destroy

      end

   end

!   make_r_JK_engine(skip_J,skip_K,Jab,Jcd,Pab,Pcd,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
!   ! Makes the J matrix directly from the (es|fs) integrals.
!   ! This is a J matrix engine.
!     self :: IN
!     skip_J,skip_K :: BIN, IN
!     Jab,Jcd :: VEC{REAL}
!     Pab,Pcd :: VEC{REAL}, IN
!     K :: MAT{REAL}
!     P :: MAT{REAL}
!     factor :: REAL, IN
!     fa,la,fb,lb,fc,lc,fd,ld :: INT, IN
!   ENSURE(.n_ab==Jab.dim,"size of Jab wrong")
!   ENSURE(.n_cd==Jcd.dim,"size of Jcd wrong")
!   ENSURE(.n_ab==Pab.dim,"size of Pab wrong")
!   ENSURE(.n_cd==Pcd.dim,"size of Pcd wrong")
!     esfs :: MAT{REAL}*
!     evfv,ev,fv,abcd,escd :: VEC{REAL}*
!     ssss,fac :: REAL
!     if (skip_J AND skip_K) return
!     if      (.ab_l_sum==0 AND .cd_l_sum==0) then
!        .make_esfs_ss_0000(ssss)
!        ssss = factor*ssss
!        if (NOT skip_J) then
!           Jab(1) = Jab(1) + ssss*Pcd(1)
!           Jcd(1) = Jcd(1) + ssss*Pab(1)
!        end
!        if (NOT skip_K) then
!           K(fa,fc) = K(fa,fc) + ssss*P(fd,fb)
!           K(fa,fd) = K(fa,fd) + ssss*P(fc,fb)
!           K(fb,fc) = K(fb,fc) + ssss*P(fd,fa)
!           K(fb,fd) = K(fb,fd) + ssss*P(fc,fa)
!        end
!     else if (.ab_l_sum==0) then
!        evfv.create(.n_cd)
!        SHELL1QUARTET::make_esfs(self,evfv)            ! Make (ss|fs) integrals
!        if (NOT skip_J) then
!           fac = factor*Pab(1)
!           Jab(1) = Jab(1) + factor*sum(evfv*Pcd)
!           Jcd    = Jcd    + fac*evfv
!        end
!        if (NOT skip_K) then
!           abcd.create(.cd_n_comp_pairs)
!           SHELL1QUARTET::transfer_cd_s(self,evfv,abcd)
!           SHELL1QUARTET::make_r_K_sscd_1(self,K,P,abcd,factor,fa,fb,fc,lc,fd,ld)
!           abcd.destroy
!        end
!        evfv.destroy
!     else if (.cd_l_sum==0) then
!        evfv.create(.n_ab)
!        SHELL1QUARTET::make_esfs(self,evfv)            ! Make (es|ss) integrals
!        if (NOT skip_J) then
!           fac = factor*Pcd(1)
!           Jcd(1) = Jcd(1) + factor*sum(evfv*Pab)
!           Jab    = Jab    + fac*evfv
!        end
!        if (NOT skip_K) then
!           abcd.create(.ab_n_comp_pairs)
!           SHELL1QUARTET::transfer_ab_s(self,evfv,abcd)
!           SHELL1QUARTET::make_r_K_abss_1(self,K,P,abcd,factor,fa,la,fb,lb,fc,fd)
!           abcd.destroy
!        end
!        evfv.destroy
!     else
!        esfs.create(.n_ab,.n_cd)
!        SHELL1QUARTET::make_esfs(self,esfs)            ! Make (es|fs) integrals
!        if (NOT skip_J) then
!           ev.create(.n_ab)
!           fv.create(.n_cd)
!           ev.to_product_of(esfs,Pcd)
!           fv.to_product_of(Pab,esfs)
!           Jab = Jab + factor*ev
!           Jcd = Jcd + factor*fv
!           fv.destroy; ev.destroy
!        end
!        if (NOT skip_K) then
!           abcd.create(.ab_n_comp_pairs*.cd_n_comp_pairs)
!           escd.create(.n_ab*.cd_n_comp_pairs)
!           SHELL1QUARTET::transfer_cd(self,esfs,escd)     ! Transfer relations
!           SHELL1QUARTET::transfer_ab(self,escd,abcd)
!           escd.destroy
!           SHELL1QUARTET::make_r_K_abcd_1(self,K,P,abcd,factor,fa,la,fb,lb,fc,lc,fd,ld)
!           abcd.destroy
!        end
!        esfs.destroy
!     end
!   end

!  ===============
!  Output Routines
!  ===============

   put
   ! Put the shell4 information to file "out"

      n_cc,i :: INT

      stdout.flush
      stdout.show("A shell l quantum number =",.a.l)
      stdout.show("B shell l quantum number =",.b.l)
      stdout.show("C shell l quantum number =",.c.l)
      stdout.show("D shell l quantum number =",.d.l)
      stdout.show("A position               =",.a.position)
      stdout.show("B position               =",.b.position)
      stdout.show("C position               =",.c.position)
      stdout.show("D position               =",.d.position)
      stdout.flush
      stdout.dash(int_fields=1,real_fields=8)
      stdout.put("N", int_width=TRUE)
      stdout.put("ex_a")
      stdout.put("cc_a")
      stdout.put("ex_b")
      stdout.put("cc_b")
      stdout.put("ex_c")
      stdout.put("cc_c")
      stdout.put("ex_d")
      stdout.put("cc_d")
      stdout.flush

      stdout.dash(int_fields=1,real_fields=8)

      n_cc = max(.a.n_cc,.b.n_cc,.c.n_cc,.d.n_cc)
      do i = 1,n_cc
        stdout.put(i)
        if (i<=.a.n_cc) then
        stdout.put( .a.exponent(i))
        stdout.put( .a.contraction(i))
        else
        stdout.tab(real_fields=2)
        end
        if (i<=.b.n_cc) then
        stdout.put( .b.exponent(i))
        stdout.put( .b.contraction(i))
        else
        stdout.tab(real_fields=2)
        end
        if (i<=.c.n_cc) then
        stdout.put( .c.exponent(i))
        stdout.put( .c.contraction(i))
        else
        stdout.tab(real_fields=2)
        end
        if (i<=.d.n_cc) then
        stdout.put( .d.exponent(i))
        stdout.put( .d.contraction(i))
        else
        stdout.tab(real_fields=2)
        end
        stdout.flush
      end

      stdout.dash(int_fields=1,real_fields=8)

   end

end
