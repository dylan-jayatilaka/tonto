!-------------------------------------------------------------------------------
!
! DIFFRACTION_DATA: Diffraction data structure for crystals
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module DIFFRACTION_DATA

   implicit none

   saved_self :: DIFFRACTION_DATA*, private

   debug_list :: VEC{STR}*, private  DEFAULT_NULL

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Destroy an object
   end

   nullify_ptr_part ::: pure
   ! Nullify the pointer parts of the diffraction data object
      self :: INOUT

      nullify(.reflection0)
      nullify(.reflections)
      nullify(.hkl_range)

      nullify(.scale_factors)

      nullify(.refine_U_iso_for_atom)
      nullify(.refine_3rd_order_for_atom)
      nullify(.refine_4th_order_for_atom)
      nullify(.refine_atom_parameters)

      nullify(.fit_table)
      nullify(.ref_table)

      nullify(.dX)
      nullify(.X_fit)
      nullify(.X_fit0)
      nullify(.X_ref)
      nullify(.X_ref0)

      nullify(.near_0_eigenvalues)
      nullify(.near_0_eigenvectors)

      nullify(.esd)
      nullify(.covariance_matrix)
      nullify(.correlation_matrix)
      nullify(.fragment_covariance_matrix)

   end

   destroy_ptr_part ::: leaky, PURE
   ! Erase all pointer information
      self :: INOUT

      ! Reflection related data
      .destroy_reflection_data

      .refine_U_iso_for_atom.destroy
      ! Refinement/fit related data

      .refine_3rd_order_for_atom.destroy
      .refine_4th_order_for_atom.destroy
      .refine_atom_parameters.destroy
      .destroy_fit_data
      .destroy_refinement_data

   end

   destroy_reflection_data ::: leaky, PURE
   ! Erase all reflection data
      self :: INOUT

      if (.reflection_data_exists) then

         .scale_factor      = DIFFRACTION_DATA_SCALE_FACTOR
         .exp_scale_factor  = DIFFRACTION_DATA_EXP_SCALE_FACTOR
         .extinction_factor = DIFFRACTION_DATA_EXTINCTION_FACTOR

         .reflection0.destroy
         .reflections.destroy
         .hkl_range.destroy

         .scale_factors.destroy

      end

   end

   destroy_fit_data ::: leaky, PURE
   ! Erase all generated fit arrays
      self :: INOUT

      .fit_table.destroy

      .dX.destroy
      .X_fit.destroy
      .X_fit0.destroy

      .near_0_eigenvalues.destroy
      .near_0_eigenvectors.destroy

      .esd.destroy
      .covariance_matrix.destroy
      .correlation_matrix.destroy
      .fragment_covariance_matrix.destroy

   end

   destroy_refinement_data ::: leaky, PURE
   ! Erase all generated refinement arrays
      self :: INOUT

      .ref_table.destroy

      .X_ref.destroy
      .X_ref0.destroy

   end

!  ====
!  Copy
!  ====

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(data) ::: leaky
   ! Set self to be crystal.
      data :: DIFFRACTION_DATA, IN

      self = data

      .nullify_ptr_part

      ! Reflection-related data
      if (data.reflection0.associated)                .reflection0.create_copy(data.reflection0)
      if (data.reflections.associated)                .reflections.create_copy(data.reflections)
      if (data.hkl_range.associated)                  .hkl_range.create_copy(data.hkl_range)
      if (data.scale_factors.associated)              .scale_factors.create_copy(data.scale_factors)

      ! Refinement/fit related data
      if (data.refine_U_iso_for_atom.associated)      &
         .refine_U_iso_for_atom.create_copy(data.refine_U_iso_for_atom)

      if (data.refine_3rd_order_for_atom.associated)  &
         .refine_3rd_order_for_atom.create_copy(data.refine_3rd_order_for_atom)
      if (data.refine_4th_order_for_atom.associated)  &
         .refine_4th_order_for_atom.create_copy(data.refine_4th_order_for_atom)
      if (data.refine_atom_parameters.associated)     &
         .refine_atom_parameters.create_copy(data.refine_atom_parameters)

      if (data.fit_table.associated)                  .fit_table.create_copy(data.fit_table)
      if (data.ref_table.associated)                  .ref_table.create_copy(data.ref_table)

      if (data.dX.associated)                         .dX.create_copy(data.dX)
      if (data.X_fit.associated)                      .X_fit.create_copy(data.X_fit)
      if (data.X_fit0.associated)                     .X_fit0.create_copy(data.X_fit0)
      if (data.X_ref.associated)                      .X_ref.create_copy(data.X_ref)
      if (data.X_ref0.associated)                     .X_ref0.create_copy(data.X_ref0)

      if (data.near_0_eigenvalues.associated)         .near_0_eigenvalues.create_copy(data.near_0_eigenvalues)
      if (data.near_0_eigenvectors.associated)        .near_0_eigenvectors.create_copy(data.near_0_eigenvectors)

      if (data.esd.associated)                        .esd.create_copy(data.esd)
      if (data.covariance_matrix.associated)          .covariance_matrix.create_copy(data.covariance_matrix)
      if (data.correlation_matrix.associated)         .correlation_matrix.create_copy(data.correlation_matrix)
      if (data.fragment_covariance_matrix.associated) &
         .fragment_covariance_matrix.create_copy(data.fragment_covariance_matrix)

   end

!  ===========
!  Set methods
!  ===========

   set_defaults ::: leaky, PURE
   ! Set up a default diffraction_data object
      self :: INOUT

      .destroy_reflection_data

      .data_kind              = DIFFRACTION_DATA_DATA_KIND

      ! Experimental data
      .wavelength             = -ONE
      .temperature            = ZERO
      .NKA_T_sequence_no      = 0

      ! Data treatment options
      .F_sigma_cutoff         = DIFFRACTION_DATA_F_SIGMA_CUTOFF
      .I_sigma_cutoff         = DIFFRACTION_DATA_I_SIGMA_CUTOFF
      .F_z_cutoff             = -ONE
      .I_z_cutoff             = -ONE
      .F_calc_cutoff          = TOL(3)
      .F_pred_cutoff          = -ONE
      .I_pred_cutoff          = -ONE
      .stl_high_cutoff        = -ONE
      .stl_low_cutoff         = -ONE
      .stl_limit              = -ONE
      .show_rejects           = FALSE
      .synthesize_sigma_I     = DIFFRACTION_DATA_SYNTHESIZE_SIGMA_I
      .SF_mixing_parameter    = ZERO

      ! Structure factor calculation parameters
      .partition_model        = DIFFRACTION_DATA_PARTITION_MODEL
      .thermal_smearing_model = DIFFRACTION_DATA_THERMAL_SMEARING_MODEL
      .use_Voronoi_atoms      = FALSE
      .use_KM_atoms           = FALSE
      .use_IAM_density        = FALSE
      .use_IAM_ITC_FFs        = TRUE
      .use_zero_overlap       = FALSE

      ! Invarioms
      .invariom_database_directory = " "
      .invariom_refinement         = FALSE

      ! Experimental corrections
      .optimize_scale         = DIFFRACTION_DATA_OPTIMIZE_SCALE
      .scale_factor           = DIFFRACTION_DATA_SCALE_FACTOR
      .exp_scale_factor       = DIFFRACTION_DATA_EXP_SCALE_FACTOR
      .optimize_extinction    = DIFFRACTION_DATA_OPTIMIZE_EXTINCTION
      .extinction_factor      = DIFFRACTION_DATA_EXTINCTION_FACTOR
      .correct_dispersion     = DIFFRACTION_DATA_CORRECT_DISPERSION

      ! Agreement statistics
      .n_param                  = 0
      .n_param_manually_set     = FALSE
      .chi2                     = ZERO
      .max_residual             = ZERO
      .min_residual             = ZERO
      .rms_residual             = ZERO
      .max_atom_residual        = ZERO
      .max_atom_residual_tag    = " "
      .min_atom_residual        = ZERO
      .min_atom_residual_tag    = " "
      .rms_atom_residual        = ZERO

      ! Refine/fit switches
      .fit_structure                = FALSE
      .refine_structure             = FALSE
      .refine_F                     = TRUE
      .refine_positions_only        = FALSE
      .refine_ADPs_only             = FALSE
      .refine_H_ADPs                = TRUE
      .refine_H_pos                 = TRUE ! test new keyword for H_positons. Lorraine
      .refine_H_U_iso               = FALSE
      .refine_anharmonicity         = FALSE
      .refine_4th_order_only        = FALSE
      .restart_HAR_with_promolecule = FALSE
      .XCW                          = FALSE

      ! Refine/fit iteration termination
      .max_iterations           = DIFFRACTION_DATA_MAX_ITER
      .min_iterations           = DIFFRACTION_DATA_MIN_ITER
      .max_allowed_param_shift  = DIFFRACTION_DATA_MAX_ALLOWED_SHIFT

      ! Least squares options (zero/near zero eigenvalues)
      .tol_for_shift_on_esd     = DIFFRACTION_DATA_TOL_FOR_SHIFT_ON_ESD
      .tol_near_0               = DIFFRACTION_DATA_TOL_NEAR_0

      ! Refinement/fit output control
      .show_fit_output             = FALSE
      .display_near_0_eigenvectors = FALSE
      .display_correlation_matrix  = FALSE
      .min_correlation             = DIFFRACTION_DATA_MIN_CORRELATION

      ! Set the internal variables for a refine/fit data
      .destroy_fit_data
      .set_fit_data

      .destroy_refinement_data
      .set_refinement_data

   end

   set_fit_data ::: pure
   ! Set the defaults internal variables for a fit
      self :: INOUT

      ! Refinement/fit iteration data
      .fit_iteration           = 0
      .chi2_fit                = ZERO
      .chi2_fit0               = ZERO
      .max_shift               = ZERO
      .max_shift_on_esd        = ZERO
      .max_shift_on_esd_ind    = 0
      .max_shift_on_esd_par    = " "
      .fit_converged           = FALSE
      .chi2_increased          = FALSE
      .too_many_fit_iterations = FALSE

      ! Near zero eigenvalues in the least-squares
      .n_0                 = 0
      .n_near_0            = 0

   end

   set_refinement_data ::: pure
   ! Set the defaults internal variables for a refinement
      self :: INOUT

      ! Refinement/fit iteration data
      .ref_iteration           = 0
      .chi2_ref                = ZERO
      .chi2_ref0               = ZERO
      .max_refshift            = ZERO
      .max_refshift_on_esd     = ZERO
      .ave_refshift_on_esd     = ZERO
      .max_refshift_on_esd_ind = 0
      .max_refshift_on_esd_par = " "
      .refinement_converged    = FALSE
      .too_many_ref_iterations = FALSE

   end

   update(unit_cell,spacegroup) ::: leaky
   ! Update the crystal information after setting values. If the
   ! "unit_cell" is provided, then that is used to define the
   ! reflection .theta values.
      self :: INOUT
      unit_cell :: UNIT_CELL, IN
      spacegroup :: SPACEGROUP, IN

      if (.reflections.disassociated) then

         ! Set hkl range ?
         if (.hkl_range.associated) &
            .reflections.set_hkl_range(.hkl_range)

         ! Set hkl up to stl_limit?
         if (.stl_limit>ZERO) &
            .reflections.set_hkl_up_to_stl_limit(.stl_limit,unit_cell)

      else

         ! Keep original reflections
         .reflection0.destroy
         .reflection0.create_copy(.reflections)
        
         ! Set d, stl, theta 
         .reflection0.set_d_and_theta(unit_cell)
         .reflections.set_d_and_theta(unit_cell)
        
         ! Equivalence factors
         .reflection0.set_equivalence_factors(spacegroup)
         .reflections.set_equivalence_factors(spacegroup)
        
         ! Prune !!!!!!!!!!
         .prune_reflections
         !!!!!!!!!!!!!!!!!!
        
         if (.reflections.have_F_exp) then

            ENSURE(.reflections.have_F_sigma,"no experimental F_sigma's")

            ! Explicit scaling
            if (.exp_scale_factor>ZERO) then

               .reflection0.scale_F_exp(.exp_scale_factor)
               .reflections.scale_F_exp(.exp_scale_factor)
               .reflection0.scale_F_sigma(.exp_scale_factor)
               .reflections.scale_F_sigma(.exp_scale_factor)

               ! Turn off next time
               .exp_scale_factor = -ONE

            end

         else

            .optimize_scale      = FALSE
            .optimize_extinction = FALSE

         end
        

      end

      if (.show_rejects) then
      if (.reflection0.dim>.reflections.dim) then

         stdout.flush
         stdout.text("==========================")
         stdout.text("Reflections before pruning")
         stdout.text("==========================")
         .reflection0.put

         stdout.flush
         stdout.text("=========================")
         stdout.text("Reflections after pruning")
         stdout.text("=========================")
         .reflections.put

      end
      end

      if (.use_IAM_density) then
      DIE_IF(.use_Voronoi_atoms  ,"cannot use Voronoi and IAM_density together")
      DIE_IF(.invariom_refinement,"cannot use invarioms and IAM_density together")
      DIE_IF(.use_KM_atoms       ,"cannot use KM_atomsand IAM_density together")
      end

   end


   set_use_IAM_density(val) ::: pure
   ! Set
      self :: INOUT
      val :: BIN, IN

      .use_IAM_density = val

      ! By default use tabulated FFs
      .use_IAM_ITC_FFs = val

   end

   set_use_IAM_ITC_FFs(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.use_IAM_ITC_FFs), pure
   ! Generic set
   end


   set_data_kind(val) ::: PURE
   ! Read the data kind of crystal experiment
      self :: INOUT
      val :: STR, IN

   ENSURE(val.is_one_of(["x-ray","pnd  "]),"unknown data_kind, "//trim(val))

      .data_kind = val

      .data_kind.to_lower_case

   end

   set_thermal_smearing_model(val) ::: PURE
   ! Read the thermal smearing model to use to correct for thermal vibration
   ! in the calculated structure factors
      self :: INOUT
      val :: STR, IN

   ENSURE(val.is_one_of(["coppens  ","hirshfeld","none     ","stewart  ","tanaka   "]),"unknown data_kind, "//trim(val))

      .thermal_smearing_model = val

      .thermal_smearing_model.to_lower_case

   end

!Test Lorraine
   set_partition_model(val) ::: PURE
   ! Read the thermal smearing model to use to correct for thermal vibration
   ! in the calculated structure factors
      self :: INOUT
      val :: STR, IN

   ENSURE(val.is_one_of(["         ","none     ","mulliken ","gaussian "]),"unknown data_kind, "//trim(val))

      .partition_model = val

      .partition_model.to_lower_case

   end

   set_optimize_extinction(val) ::: pure
   ! Set whether to correct extinction or not according to the Larson formula
      self :: INOUT
      val :: BIN, IN

      .optimize_extinction = val

   end

   set_wavelength(val)
   ! Read the experimental wavelength
      self :: INOUT
      val :: REAL, IN

      .wavelength = val
      REFLECTION:set_wavelength(val)

   end

   set_refine_structure(val) ::: pure
   ! Set whether to refine the structure
      self :: INOUT
      val :: BIN, IN

      .refine_structure = val

      ! If refining you can't be fitting
      if (val) .fit_structure = NOT val

   end

   ! test new keyword for H_positons. Lorraine
   set_refine_H_pos(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.refine_H_pos), pure
   ! Generic set
   end

   set_refine_H_ADPs(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.refine_H_ADPs), pure
   ! Generic set
   end

   set_refine_H_U_iso(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.refine_H_U_iso), pure
   ! Generic set
   end

   set_refine_4th_order(val) ::: leaky, PURE
   ! Read the list of atoms for which fourth-order anharmonicty
   ! parameters are to be refined.
      self :: INOUT
      val :: VEC{STR}, IN

      .refine_4th_order_for_atom.create_copy(val)

      .refine_anharmonicity = TRUE

   end

   set_refine_4th_order_only(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.refine_4th_order_only), pure
   ! Generic set
   end

   set_restart_HAR_with_promolecule(val) ::: PURE
   ! Set whether to restart HAR with promolecule every time.
      self :: INOUT
      val :: BIN, IN

      .restart_HAR_with_promolecule = val

   end

   set_correct_dispersion(val) ::: pure
   ! Set whether to correct dispersion in the refinement
      self :: INOUT
      val :: BIN, IN

      .correct_dispersion = val

   end


   set_fit_structure(val) ::: pure
   ! Set whether to rigid-fit the structure
      self :: INOUT
      val :: BIN, IN

      .fit_structure = val

      ! If fitting, you can't be refining
      if (NOT val) .refine_structure = NOT val

   end


   set_show_refinement_output(val) ::: pure
   ! Set whether to show refinement output
      self :: INOUT
      val :: BIN, IN

      .show_refinement_output  = val
      .show_refinement_results = val

   end

   set_show_refinement_results(val) ::: pure
   ! Set whether to show refinmenet statistics results
      self :: INOUT
      val :: BIN, IN

      .show_refinement_results = val

   end

   set_show_fit_output(val) ::: pure
   ! Set whether to show fit output
      self :: INOUT
      val :: BIN, IN

      .show_fit_output  = val
      .show_fit_results = val

   end

   set_show_fit_results(val) ::: pure
   ! Set whether to show fit statistics results
      self :: INOUT
      val :: BIN, IN

      .show_fit_results = val

   end

   set_n_worst_reflections(val) ::: pure
   ! Set the no. of worst reflections to show
      self :: INOUT
      val :: INT, IN

      .n_worst_reflections = val

   end

! Cutoffs

   set_F_sigma_cutoff(val) ::: PURE
   ! Set the minimum acceptable value for F_exp/sigma
      self :: INOUT
      val :: REAL, IN

   ENSURE(val>ZERO,"cutoff must be positive")

      .F_sigma_cutoff = val

   end

   set_I_sigma_cutoff(val) ::: PURE
   ! Set the minimum acceptable value for F2_exp/sigma
      self :: INOUT
      val :: REAL, IN

   ENSURE(val>ZERO,"cutoff must be positive")

      .I_sigma_cutoff = val

   end

   set_F_z_cutoff(val) ::: PURE
   ! Set the F_z_cutoff (in sigma units) for prune_bad_reflections
      self :: INOUT
      val :: REAL, IN

   ENSURE(val>ZERO,"cutoff must be positive")

      .F_z_cutoff = val

   end

   set_I_z_cutoff(val) ::: PURE
   ! Set the I_z_cutoff (in sigma units) for prune_bad_reflections
      self :: INOUT
      val :: REAL, IN

   ENSURE(val>ZERO,"cutoff must be positive")

      .I_z_cutoff = val

   end

   set_F_calc_cutoff(val) ::: PURE
   ! Set the F_calc_cutoff
      self :: INOUT
      val :: REAL, IN

   ENSURE(val>ZERO,"cutoff must be positive")

      .F_calc_cutoff = val

   end

   set_F_pred_cutoff(val) ::: PURE
   ! Set the F_pred_cutoff
      self :: INOUT
      val :: REAL, IN

   ENSURE(val>ZERO,"cutoff must be positive")

      .F_pred_cutoff = val

   end

   set_I_pred_cutoff(val) ::: PURE
   ! Set the I_pred_cutoff
      self :: INOUT
      val :: REAL, IN

   ENSURE(val>ZERO,"cutoff must be positive")

      .I_pred_cutoff = val

   end


   set_n_param(val) ::: PURE
   ! Set the number of paramters in the model "by hand"
      self :: INOUT
      val :: INT, IN

   ENSURE(val>1,"n_param must be non negative")

      .n_param = val
      .n_param_manually_set = TRUE

   end

   set_XCW(val) ::: PURE
   ! Set if doing an XCW calculation - needed for calculating
   ! n_param, which is incremented by 1 for lambda.
      self :: INOUT
      val :: BIN, IN

      .XCW = val

   end


!   set_F_calc(F_calc) ::: PURE
!   ! Set the calculated structure factors
!      self :: INOUT
!
!      F_calc :: VEC{CPX}, IN
!
!   ENSURE(.reflection_data_exists,"no reflection data")
!
!      .reflections.set_F_calc(F_calc)
!
!   end
!
!   set_I_calc(I_calc) ::: PURE
!   ! Set the calculated intensities
!      self :: INOUT
!      I_calc :: VEC{REAL}, IN
!
!   ENSURE(.reflection_data_exists,"no reflection data")
!
!      .reflections.set_I_calc(I_calc)
!
!   end

!  ============
!  Read methods
!  ============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
      self :: PTR
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      self :: PTR
      keyword :: STR

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)

         case ("}                             ")  ! exit read_loop

         case ("stop_after_dispersion=        "); .read_stop_after_dispersion
         case ("use_real_dispersion=          "); .read_use_real_dispersion

         case ("correct_dispersion=           "); .read_correct_dispersion

         case ("d_low_cutoff=                 "); .read_d_low_cutoff
         case ("debug_off                     "); .read_debug_off
         case ("debug_on                      "); .read_debug_on
         case ("destroy_reflection_data       "); .destroy_reflection_data
         case ("display_correlation_matrix=   "); .read_display_corr_matrix
         case ("display_near_0_eigenvectors=  "); .read_display_near_0_evecs
         case ("do_residual_cube=             "); .read_do_residual_cube

         case ("exp_scale_factor=             "); .read_exp_scale_factor

         case ("f_calc_cutoff=                "); .read_F_calc_cutoff
         case ("f_pred_cutoff=                "); .read_F_pred_cutoff
         case ("f_sigma_cutoff=               "); .read_F_sigma_cutoff
         case ("f_z_cutoff=                   "); .read_F_z_cutoff

         case ("hkl_range=                    "); .read_hkl_range

         case ("i_pred_cutoff=                "); .read_I_pred_cutoff
         case ("i_sigma_cutoff=               "); .read_I_sigma_cutoff
         case ("i_z_cutoff=                   "); .read_I_z_cutoff
         case ("invariom_database_directory=  "); .read_invariom_directory
         case ("invariom_refinement=          "); .read_invariom_refinement

         case ("junk=                         "); .read_junk

         case ("kind=                         "); .read_data_kind

         case ("make_f_predicted              "); .make_F_predicted
         case ("max_allowed_param_shift=      "); .read_max_allowed_param_shift
         case ("max_iterations=               "); .read_max_iterations
         case ("min_correlation=              "); .read_min_correlation
         case ("min_iterations=               "); .read_min_iterations

         case ("nka_t_sequence_no=            "); .read_NKA_T_seq_no
         case ("n_param=                      "); .read_n_param
         case ("n_worst_reflections=          "); .read_n_worst_reflections

         case ("optimise_extinction=          "); .read_optimize_extinction
         case ("optimize_extinction=          "); .read_optimize_extinction
         case ("optimise_scale_factor=        "); .read_optimize_scale
         case ("optimize_scale_factor=        "); .read_optimize_scale
         case ("optimise_scale_factors=       "); .read_optimize_scale
         case ("optimize_scale_factors=       "); .read_optimize_scale

         case ("partition_model=              "); .read_partition_model
         case ("prune_reflections             "); .prune_reflections
         case ("put                           "); .put
         case ("put_debug_list                "); .put_debug_list
         case ("put_worst_reflections         "); .put_worst_reflections
         case ("put_sin_theta_on_lambda       "); .put_sin_theta_on_lambda
         case ("put_wavelength                "); .put_wavelength

         case ("read_cif                      "); .read_CIF
         case ("redirect                      "); .redirect
         case ("refine_3rd_order_for_atoms=   "); .read_refine_3rd_order
         case ("refine_4th_order_for_atoms=   "); .read_refine_4th_order
         case ("refine_4th_order_only=        "); .read_refine_4th_order_only
         case ("refine_adps_only=             "); .read_refine_ADPs_only
         case ("refine_f=                     "); .read_refine_F
         case ("refine_h_pos=                 "); .read_refine_H_pos ! test new keyword for H_positons. Lorraine
         case ("refine_h_adps=                "); .read_refine_H_ADPs
         case ("refine_h_u_iso=               "); .read_refine_H_U_iso
         case ("refine_positions_only=        "); .read_refine_positions_only
         case ("refine_u_iso_for_atoms=       "); .read_refine_U_iso_atoms
         case ("reflection_data=              "); .read_reflection_data
         case ("restart_har_with_promolecule= "); .read_restart_with_promolecule
         case ("revert                        "); .revert

         case ("sf_mixing_parameter=          "); .read_SF_mixing_parameter
         case ("show_fit_output=              "); .read_show_fit_output
         case ("show_fit_results=             "); .read_show_fit_results
         case ("show_refinement_output=       "); .read_show_ref_output
         case ("show_refinement_results=      "); .read_show_ref_results
         case ("show_rejects=                 "); .read_show_rejects
         case ("stl_high_cutoff=              "); .read_stl_high_cutoff
         case ("stl_limit=                    "); .read_stl_limit
         case ("stl_low_cutoff=               "); .read_stl_low_cutoff
         case ("synthesize_sigma_i=           "); .read_synthesize_sigma_I

         case ("thermal_smearing_model=       "); .read_thermal_smearing_model
         case ("temperature=                  "); .read_temperature
         case ("tolerance_near_0=             "); .read_tol_near_0
         case ("tol_for_shift_on_esd=         "); .read_tol_for_shift_on_esd

         case ("units=                        "); .read_units
         case ("use_iam_density=              "); .read_use_IAM_density
         case ("use_iam_itc_ffs=              "); .read_use_IAM_ITC_FFs
         case ("use_km_atoms=                 "); .read_use_KM_atoms
         case ("use_voronoi_atoms=            "); .read_use_Voronoi_atoms
         case ("use_zero_overlap=             "); .read_use_zero_overlap

         case ("wavelength=                   "); .read_wavelength

         case default;                       UNKNOWN(word)

      end

   end

! Reading

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input
   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file
   end

   read_data_kind
   ! Read the data kind of crystal experiment
      self :: INOUT

      val :: STR

      stdin.read(val)

      .set_data_kind(val)

   end

   read_hkl_range ::: leaky, private
   ! Read the F_pred_cutoff for prune_F_preds
      self :: INOUT

      .hkl_range.destroy

      stdin.read_ptr(.hkl_range)

   end

   read_invariom_directory ::: private
   ! Read in the directory for the invariom database.
      self :: INOUT

      stdin.read(.invariom_database_directory)

   end

   read_invariom_refinement ::: private
   ! Read in the logical switch for the invariom refinement.
      self :: INOUT

      stdin.read(.invariom_refinement)

   end

   read_F_sigma_cutoff ::: private
   ! Read the maximum acceptable value for F_cutoff
      self :: INOUT

      val :: REAL

      stdin.read(val)

      .set_F_sigma_cutoff(val)

   end

   read_I_sigma_cutoff ::: private
   ! Read the maximum acceptable value for I_cutoff
      self :: INOUT

      val :: REAL

      stdin.read(val)

      .set_I_sigma_cutoff(val)

   end

   read_F_z_cutoff ::: private
   ! Read the F_z cutoff for prune_bad_reflections
      self :: INOUT

      val :: REAL

      stdin.read(val)

      .set_F_z_cutoff(val)

   end

   read_I_z_cutoff ::: private
   ! Read the I_z cutoff for prune_bad_reflections
      self :: INOUT

      val :: REAL

      stdin.read(val)

      .set_I_z_cutoff(val)

   end

   read_F_calc_cutoff ::: private
   ! Read the F_calc_cutoff for prune_F_calcs
      self :: INOUT

      val :: REAL

      stdin.read(val)

      .set_F_calc_cutoff(val)

   end

   read_F_pred_cutoff ::: private
   ! Read the F_pred_cutoff for prune_F_preds
      self :: INOUT

      val :: REAL

      stdin.read(val)

      .set_F_pred_cutoff(val)

   end

   read_I_pred_cutoff ::: private
   ! Read the I_pred_cutoff for prune_I_preds
      self :: INOUT

      val :: REAL

      stdin.read(val)

      .set_I_pred_cutoff(val)

   end

   read_stl_high_cutoff ::: private
   ! Read the stl_cutoff for prune_high_angle_reflections
      self :: INOUT

      stdin.read_quantity(.stl_high_cutoff)

      ENSURE(.stl_high_cutoff>=ZERO,"must be positive")

   end

   read_stl_low_cutoff ::: private
   ! Read the stl_cutoff for prune_low_angle_reflections
      self :: INOUT

      stdin.read_quantity(.stl_low_cutoff)

      ENSURE(.stl_low_cutoff>=ZERO,"must be positive")

   end

   read_stl_limit
   ! Read in the stl limit for generating (h k l)
      self :: INOUT

      stdin.read_quantity(.stl_limit)

      ENSURE(.stl_limit>ZERO,"must be +ve!")

   end

   read_d_low_cutoff ::: private
   ! Read the d_low_cutoff (spacings below this are pruned) which is
   ! converted to a stl_high_cutoff for prune_high_angle_reflections
      self :: INOUT

      d :: REAL

      stdin.read_quantity(d)

      .stl_high_cutoff = HALF/d

      ENSURE(.stl_high_cutoff>=ZERO,"must be positive")

   end


   read_show_fit_output ::: private
   ! Read whether to show the fit output (including fit results)
      self :: INOUT

      val :: BIN

      stdin.read(val)

      .set_show_fit_output(val)

   end

   read_show_fit_results ::: private
   ! Read whether to show the fit results, without parameters
      self :: INOUT

      val :: BIN

      stdin.read(val)

      .set_show_fit_results(val)

   end

   read_show_ref_output ::: private
   ! Read whether to show any refinement output
   ! (including refinement results)
      self :: INOUT

      val :: BIN

      stdin.read(val)

      .set_show_refinement_output(val)

   end

   read_show_ref_results::: private
   ! Read whether to show the refinement results, without parameters
      self :: INOUT

      val :: BIN

      stdin.read(val)

      .set_show_refinement_results(val)

   end


   read_show_rejects ::: private
   ! Read whether to show the rejected reflections
      self :: INOUT

      stdin.read(.show_rejects)

   end


   read_exp_scale_factor ::: private
   ! Read the structure factor multiplier
      self :: INOUT

      stdin.read(.exp_scale_factor)

   end

   read_wavelength ::: private
   ! Read the experimental wavelength
      self :: INOUT

      val :: REAL

      stdin.read_quantity(val)

      .set_wavelength(val)

   end

   read_optimize_scale ::: private
   ! Read the switch whether to use and overall scale factor to minimise
   ! the chi2 statistic when calculating the structure factors.
   ! NOTE: this is not the same at the overall .scale_factor which is applied
   ! to the experimental structure factors.
      self :: INOUT

      stdin.read(.optimize_scale)

   end

   read_SF_mixing_parameter ::: private
   ! Read the SF mixining parameter which inlcudes some percentage of
   ! the experimental structure factors into the predicted structure
   ! factors. This may help convergence in constrained HF problems.
      self :: INOUT

      stdin.read(.SF_mixing_parameter)

   end

   read_synthesize_sigma_I ::: private
   ! Read the switch whether to artificially create sigma(I) errors when
   ! evaluating the chi2 statistics based on intensities. Refer to routine
   ! .I_sigma
      self :: INOUT

      stdin.read(.synthesize_sigma_I)

   end

   read_optimize_extinction ::: private
   ! Read the switch whether to correct extinction or not, according to the
   ! Larson formula
      self :: INOUT

      val :: BIN

      stdin.read(val)

      .set_optimize_extinction(val)

   end

   read_correct_dispersion ::: private
   ! Read the switch whether to correct dispersion or not, according to the
   ! atomic dispersion factors
      self :: INOUT

      val :: BIN

      stdin.read(val)

      .set_correct_dispersion(val)

   end

   read_use_real_dispersion ::: private
   ! Read the switch whether to correct real dispersion or not,
   ! according to the atomic dispersion factors
      self :: INOUT

      stdin.read(.use_real_dispersion)

   end

   read_stop_after_dispersion ::: private
   ! Stop after applying dispersion correction in the zeroth iteration
   ! of a refinement.
      self :: INOUT

      stdin.read(.stop_after_dispersion)

   end

   read_thermal_smearing_model ::: private
   ! Read the thermal smearing model to use to correct for thermal vibration
   ! in the calculated structure factors
      self :: INOUT

      val :: STR

      stdin.read(val)

      .set_thermal_smearing_model(val)

   end

!  read_partition_model ::: private
!  ! Read the partition model to used to correct for oversampled fragments
!  ! of the unit cell when calculating the structure factors
!     self :: INOUT

!     stdin.read(.partition_model)

!     .partition_model.to_lower_case

!     select case(.partition_model)
!        case("        ")
!        case("none    ")
!        case("mulliken")
!        case("gaussian")
!        case default;    UNKNOWN(.partition_model)
!     end

!  end

   read_partition_model ::: private
   ! Read the partition model to used to correct for oversampled fragments
   ! of the unit cell when calculating the structure factors
      self :: INOUT

      val :: STR

      stdin.read(val)

      .set_partition_model(val)

!     select case(.partition_model)
!        case("        ")
!        case("none    ")
!        case("mulliken")
!        case("gaussian")
!        case default;    UNKNOWN(.partition_model)
!     end

   end

   read_temperature
   ! Read the temperature
      self :: INOUT

      stdin.read(.temperature)

   ENSURE(.temperature>=0,"temperature is not positive!")

   end

   read_NKA_T_seq_no
   ! Read the temperature sequence no for NKA output file
      self :: INOUT

      stdin.read(.NKA_T_sequence_no)

   ENSURE(.NKA_T_sequence_no>0,"sequence no is not positive!")

   end

   read_n_param
   ! Read the no of parameters for refinement explicitly.
   ! DO this if you are doing an XCW after an HAR
      self :: INOUT

      val :: INT

      stdin.read(val)

      .set_n_param(val)

   end

   read_n_worst_reflections
   ! Read the no of worst reflections to show.
      self :: INOUT

      val :: INT

      stdin.read(val)
      .set_n_worst_reflections(val)

   end

!  Refinement options

   read_max_allowed_param_shift
   ! Read the maximum allowed shift in a structure refinement
   ! parameter
      self :: INOUT

      stdin.read(.max_allowed_param_shift)

   ENSURE(.max_allowed_param_shift>ZERO,"not positive")

   end

   read_max_iterations
   ! Read the maximum number of iterations
      self :: INOUT

      stdin.read(.max_iterations)

   ENSURE(.max_iterations>-1,             "max_iterations < 0 !")
   ENSURE(.max_iterations>.min_iterations,"max_iterations <= min_iterations !")

   end

   read_min_iterations
   ! Read the minimum number of iterations
      self :: INOUT

      stdin.read(.min_iterations)

   ENSURE(.min_iterations>-1,             "min_iterations < 0 !")
   ENSURE(.max_iterations>.min_iterations,"min_iterations >= max_iterations !")

   end

   read_min_correlation
   ! Read the minimum number of iterations
      self :: INOUT

      stdin.read(.min_correlation)

   ENSURE(.min_correlation>=-ONE,"min_iterations < -1 !")
   ENSURE(.min_correlation<= ONE,"min_iterations > +1 !")

   end

   read_reflection_data ::: leaky, private
   ! Read in reflection data in the standard order from "stdin".
      self :: INOUT

   DIE_IF(REFLECTION:wavelength()<ZERO,"specify wavelength for radiation before reflection_data!")

      if (.reflections.associated) .reflections.destroy

      .reflections.read_list_keywords

   end

   read_refine_ADPs_only
   ! Read whether to refine only the ADP's
      self :: INOUT

      stdin.read(.refine_ADPs_only)

   end

   read_refine_F
   ! Read in whether to refine F's instead of I's
      self :: INOUT

      stdin.read(.refine_F)

   end

   ! test new keyword for H_positons. Lorraine
   read_refine_H_pos
   ! Read whether to refine only the H atom positions
      self :: INOUT

      val :: BIN

      stdin.read(val)

      .set_refine_H_pos(val)

   end

   read_refine_H_ADPs
   ! Read whether to refine only the H atom ADP's
      self :: INOUT

      val :: BIN

      stdin.read(val)

      .set_refine_H_ADPs(val)

   end

   read_refine_H_U_iso
   ! Read whether to refine only the H atom U_iso's
      self :: INOUT

      val :: BIN

      stdin.read(val)

      .set_refine_H_U_iso(val)

   end

   read_refine_positions_only
   ! Read whether to refine only the atom positions
      self :: INOUT

      stdin.read(.refine_positions_only)

   end

   read_refine_3rd_order ::: leaky
   ! Read the list of atoms for which third-order anharmonicty
   ! parameters are to be refined.
      self :: INOUT

      stdin.read_ptr(.refine_3rd_order_for_atom)

      .refine_anharmonicity = TRUE

   end

   read_refine_4th_order ::: leaky
   ! Read the list of atoms for which fourth-order anharmonicty
   ! parameters are to be refined.
      self :: INOUT

      stdin.read_ptr(.refine_4th_order_for_atom)

      .refine_anharmonicity = TRUE

   end

   read_refine_4th_order_only
   ! Read whether to refine 4th order coefficients only,
   ! ignoring changes to 3rd order coefficients.
   ! NOTE: it is up to you to set the ADP3s to zero.
      self :: INOUT

      val :: BIN

      stdin.read(val)

      .set_refine_4th_order_only(val)

   end

   read_refine_U_iso_atoms ::: leaky
   ! Read the list of atoms refined isotropically
      self :: INOUT

      stdin.read_ptr(.refine_U_iso_for_atom)

   end

   read_use_Voronoi_atoms
   ! Read whether to use Voronoi atoms in refinement
      self :: INOUT

      stdin.read(.use_Voronoi_atoms)

   end

   read_use_KM_atoms
   ! Read whether to use KM atom density in refinement
      self :: INOUT

      stdin.read(.use_KM_atoms)

   end

   read_use_IAM_density
   ! Read whether to IAM density, either tabulated or
   ! from the existing atomic density matrix.
      self :: INOUT

      val :: BIN

      stdin.read(val)

      ! NOTE: use IAM form factors by default
      .set_use_IAM_density(val)

   end

   read_use_IAM_ITC_FFs
   ! Read whether to use International Tables C form factors.
   ! If set FALSE, then the existing atomic density is used.
      self :: INOUT

      val :: BIN

      stdin.read(.use_IAM_ITC_FFs)

      .set_use_IAM_ITC_FFs(val)

   end

   read_use_zero_overlap
   ! Read whether to use KM density in refinement
      self :: INOUT

      stdin.read(.use_zero_overlap)

   end

   read_restart_with_promolecule ::: leaky
   ! Read whether to restart with promolecule initial guess.
      self :: INOUT

      stdin.read(.restart_HAR_with_promolecule)

   end

   read_tol_near_0
   ! Read the tolerance for deciding on *near* zero eigenvalues in
   ! solving the normal equations.
      self :: INOUT

      stdin.read(.tol_near_0)

   ENSURE(.tol_near_0>ZERO,"tol_near_0 must be positive")

   end

   read_tol_for_shift_on_esd
   ! Read the tolerance for the shift on esd to decide on convergence.
      self :: INOUT

      stdin.read(.tol_for_shift_on_esd)

   ENSURE(.tol_for_shift_on_esd>ZERO,"must be positive")

   end

   read_display_corr_matrix
   ! Read whether to display the correlation matrix.
      self :: INOUT

      stdin.read(.display_correlation_matrix)
   
   end

   read_display_near_0_evecs
   ! Read whether to display the near 0 eigenvectros of the correlation matrix.
      self :: INOUT

      stdin.read(.display_near_0_eigenvectors)

   end

   read_do_residual_cube
   ! Read whether to write the residual density gaussian cube file.
   ! Can be used to speed up writing.
      self :: INOUT

      stdin.read(.do_residual_cube)

   end


! ========
! Read CIF
! ========

   read_CIF ::: leaky
   ! Read information from a Crystallographic Information File
   ! with the "name" taken from stdin.
      self :: INOUT

      name :: STR
      found :: BIN
      cif :: CIF*

      ! Read name from stdin
      stdin.read(name)

      ! Create and open the CIF
      cif.create(name)
      cif.open
      cif.find_crystal_data_block(found)
      ENSURE(found,"no crystal data block found")

      ! Read
      .read_CIF(cif)

      ! Clean
      cif.destroy

   end

   read_CIF(cif) ::: leaky
   ! Read information from a Crystallographic Information File "cif".
      self :: INOUT
      cif :: CIF, INOUT

      there :: BIN
      sval :: STR
      ival :: INT
      rval :: REAL

      ! Read reflections
      .reflections.read_CIF(cif)

      ! First prune I's and define F's
      if (.have_I_exp) then
         DIE_IF(NOT .have_I_sigma,"I_exp present but no I_sigma?")
         .prune_small_I_sigmas
         .reflections.reset_I_exp_I_sigma
      end

      ! Next prune F's
      if (.have_F_exp) then
         DIE_IF(NOT .have_F_sigma,"F_exp present but no F_sigma?")
         .prune_small_F_sigmas
         .reflections.reset_F_exp_F_sigma
      end

      ! Is there a wavelength in the CIF?
      cif.find_item("_diffrn_radiation_wavelength",there)

      ! If there, read wavelength and override existing
      if (there) then
      cif.read_item("_diffrn_radiation_wavelength",rval)
      rval = rval*BOHR_PER_ANGSTROM
      .set_wavelength(rval)
      end

      ! Read no of parameters
      cif.find_item("_refine_ls_number_parameters",there)
      if (there) then
      cif.read_item("_refine_ls_number_parameters",ival)
      .set_n_param(ival)
      end

      ! Read extinction
      cif.find_item("_refine_ls_extinction_method",there)
      if (there) then
      cif.read_item("_refine_ls_number_parameters",sval)
      if (sval=="none") .set_optimize_extinction(FALSE)
      end

      ! Read XCW
      cif.find_item("_refine_QCr_Psi_constraint",there)
      if (there) then
      cif.read_item("_refine_QCr_Psi_constraint",sval)
      if (sval=="lambda*chi2") .set_XCW(TRUE)
      end


   end


! =======
! Put CIF
! =======

   CIF_threshold_expression result (res) ::: pure
   ! Evaluate the CIF _reflns_threshhold_expression
   ! No refinement info. possible without reflections!
      self :: IN
      res :: STR

      cut,but :: REAL

      res = "F>0"

      cut = .F_sigma_cutoff
      if (cut>ZERO) &
      res = trim(res) // " & F/u(F)>"//trim(adjustl(cut.to_str("f5.1")))

      cut = .I_sigma_cutoff
      if (cut>ZERO) &
      res = trim(res) // " & F2/u(F2)>"//trim(adjustl(cut.to_str("f5.1")))

      cut = .F_z_cutoff
      if (cut>ZERO) & 
      res = trim(res) // " & |F_calc-F|/u(F)<"//trim(adjustl(cut.to_str("f5.1")))

      cut = .F_calc_cutoff
      if (cut>ZERO) & 
      res = trim(res) // " & |F_calc|>10^-3"

      cut = .F_pred_cutoff
      if (cut>ZERO) & 
      res = trim(res) // " & |F_pred|>10^-3"

      cut = .stl_high_cutoff
      if (cut>ZERO) then
      but = cut*BOHR_PER_ANGSTROM
      res = trim(res) // " & sin(theta)/lambda<"//trim(adjustl(but.to_str("f5.1")))
      end

      cut = .stl_low_cutoff
      if (cut>ZERO) then
      but = cut*BOHR_PER_ANGSTROM
      res = trim(res) // " & sin(theta)/lambda>"//trim(adjustl(but.to_str("f5.1")))
      end

      res = "'" // trim(res) // "'"

   end

   put_CIF_refinement
   ! Put refinement information in CIF format
   ! No refinement info. possible without reflections!
      self :: IN

      n :: INT
      R :: REAL
      val :: STR

      if (.reflections.disassociated) return

      stdout.flush
      stdout.text("# ===============")
      stdout.text("# Refinement data")
      stdout.text("# ===============")

      stdout.flush
      stdout.text("_refine_ls_kind                     'Hirshfeld atom refinement (HAR)'")
      stdout.text("_refine_ls_method_description")
      stdout.text(";")
      stdout.text("   S.C. Capelli, H.-B. Burgi, B. Dittrich, S.Grabowsky")
      stdout.text("   and Dylan Jayatilaka, IUCrJ (2014). 1, 361-379")
      stdout.text(";")
      if (.XCW) then                                
      stdout.text("_refine_QCr_Psi_constraint          'lambda*chi2'")
      stdout.text("_refine_QCr_method_description")
      stdout.text(";")
      stdout.text("  'The Significance of Ionic Bonding in Sulfur Dioxide: ")
      stdout.text("   Bond Orders from X-ray Diffraction Data' ")
      stdout.text("   S. Grabowsky,* P. Luger, J. Buschmann, T. Schneider")
      stdout.text("   T. Schirmeister, A.N. Sobolev, and D. Jayatilaka")
      stdout.text(";")
      else                                          
      stdout.text("_refine_QCr_Psi_constraint          'none'")
      end

      stdout.flush
      val = .tol_near_0.to_str("e9.1")
      stdout.text("_refine_ls_SVD_threshold            "//trim(val))
      stdout.text("_refine_ls_coordinate_system        cartesian")
      stdout.text("_refine_ls_structure_factor_coeff   F")
      stdout.text("_refine_ls_matrix_type              full")

      R   = .F_r_factor
      val = R.to_str("f10.4")
      stdout.text("_refine_ls_R_factor_gt              "//trim(val))
      stdout.text("_refine_ls_R_factor_all             "//trim(val))

      R   = .F_weighted_r_factor
      val = R.to_str("f10.4")
      stdout.text("_refine_ls_wR_factor_gt             "//trim(R.to_str("f10.4")))
      stdout.text("_refine_ls_wR_factor_all            "//trim(R.to_str("f10.4")))

      R   = .F2_r_factor
      val = R.to_str("f10.4")
      stdout.text("_refine_ls_R_Fsqd_factor            "//trim(R.to_str("f10.4")))

      R   = sqrt(.chi2)
      val = R.to_str("f10.4")
      stdout.text("_refine_ls_goodness_of_fit_gt       "//trim(val))
      stdout.text("_refine_ls_goodness_of_fit_all      "//trim(val))
    ! stdout.text("_refine_ls_restrained_S_all             "//trim(val))
      n   = .reflections.dim
      val = n.to_str
      stdout.text("_refine_ls_number_reflns            "//trim(val))
      stdout.text("_refine_ls_number_parameters        "//trim(.n_param.to_str))
      stdout.text("_refine_ls_number_restraints        0")
      val = .n_near_0.to_str
      stdout.text("_refine_ls_number_constraints       "//trim(val))

      if (.refine_H_ADPs) then
      if (.refine_positions_and_ADPs) then
      stdout.text("_refine_ls_hydrogen_treatment       refall")
      else if (.refine_ADPs_only) then
      stdout.text("_refine_ls_hydrogen_treatment       refU")
      end
      else
      stdout.text("_refine_ls_hydrogen_treatment       refxyz")
      end

      stdout.text("_refine_ls_weighting_scheme         sigma")
      stdout.text("_refine_ls_weighting_details        'w=1/\s(F)'")

      val = adjustl(.tol_for_shift_on_esd.to_str("f10.4"))
      stdout.text("_refine_ls_shift/su_conv_tol        "//trim(val))
      val = adjustl(.max_refshift_on_esd.to_str("f10.4"))
      stdout.text("_refine_ls_shift/su_max             "//trim(val))
      val = adjustl(.ave_refshift_on_esd.to_str("f10.4"))
      stdout.text("_refine_ls_shift/su_max_mean        "//trim(val))
      stdout.text("_refine_ls_shift/su_max_par         '"//trim(.max_refshift_on_esd_par)//"'")

      if (.optimize_extinction) then
      stdout.text("_refine_ls_extinction_method        Zachariasen/Larson")
      else
      stdout.text("_refine_ls_extinction_method        none")
      end

      stdout.flush
      val = adjustl(.max_residual.to_str("f10.4"))
      stdout.text("_refine_diff_density_max            "//trim(val))
      val = adjustl(.min_residual.to_str("f10.4"))
      stdout.text("_refine_diff_density_min            "//trim(val))
      val = adjustl(.rms_residual.to_str("f10.4"))
      stdout.text("_refine_diff_density_rms            "//trim(val))
      val = (.max_atom_residual.to_str("f10.4"))
      stdout.text("_refine_diff_density_max_atom       "//trim(val))
      stdout.text("_refine_diff_density_max_atom_tag   "//trim(.max_atom_residual_tag))
      val = (.min_atom_residual.to_str("f10.4"))
      stdout.text("_refine_diff_density_min_atom       "//trim(val))
      stdout.text("_refine_diff_density_min_atom_tag   "//trim(.min_atom_residual_tag))
      val = (.rms_atom_residual.to_str("f10.4"))
      stdout.text("_refine_diff_density_rms_atom       "//trim(val))

      stdout.flush
      stdout.text("_refine_special_details")
      stdout.text(";")
      stdout.text(". If constraints were applied they are defined by zero")
      stdout.text("  eigenvalues of the least-squares hessian, see the")
      stdout.text("  value of _refine_ls_SVD_threshold")
      stdout.text(";")


   end

   put_CIF_covariance_matrices(cif)
   ! Output the covariance matrix in CIF format
      self :: IN
      cif :: CIF, IN

      ! Asymmetric unit covariance
      if (cif.use_CIF2) then
      if (.covariance_matrix.associated) then
         ::put_CIF_covariance_matrix("asym_unit",.covariance_matrix,cif.use_CIF2)
      end
      end

      ! Fragment covariance?
      if (cif.use_CIF2) then
      if (.fragment_covariance_matrix.associated) then
         ::put_CIF_covariance_matrix("fragment",.fragment_covariance_matrix,cif.use_CIF2)
      end
      end

   end

   put_CIF_covariance_matrix(kind,covariance_matrix,CIF2) ::: selfless
   ! Output the covariance matrix in CIF format
      self :: IN
      kind :: STR, IN
      covariance_matrix :: MAT{REAL}, IN
      CIF2 :: BIN, IN

   ENSURE(covariance_matrix.is_square,"covariance is not square")

      ! Change defaults
      stdout.save
      stdout.set_real_style("e")
      stdout.set_real_width(16)
      stdout.set_real_precision(8)

      stdout.flush
      stdout.text("# NOTE: Cartesian 9Nx9N covariance matrix in BOHR units")
      stdout.text("# The order of the variables (per atom) is as follows:")
      stdout.text("# . Elements 1-3: positions: x y x")
      stdout.text("# . Elements 4-9: 2nd order ADPs:")
      stdout.text("#      U 11 22 33 12 13 23")
      stdout.text("# . Elements 10-19: 3rd order ADPs (if refined):")
      stdout.text("#      U 111 222 333 112 113 122 223 133 233 123")
      stdout.text("# . Elements 20-34: 4th order ADPs (if refined):")
      stdout.text("#      U 1112 1113 1222 2223 1333 2333")
      stdout.text("#        1122 1133 2233 1123 1223 1233")
      stdout.text("# . Matrix is output in (fortran) column order")

      stdout.flush
      stdout.text("_"//trim(kind)//"_covariance_matrix")

      ! Opening brace
      if (CIF2) then
      stdout.text("[")
      else
      stdout.text(";")
      end

      ! Matrix contents
      stdout.put(covariance_matrix,by_column=TRUE)
      stdout.flush

      ! Closing brace
      if (CIF2) then
      stdout.text("]")
      else
      stdout.text(";")
      end

      ! Put back defaults
      stdout.unsave

   end


! ===================
! Pruning reflections
! ===================

   is_prunable result (res) ::: PURE
   ! Return TRUE if there's something to prune via a set cutoff.
   ! NOTE: Zero F_sigma's and stl cutoff's are assumed already 
   !       pruned at input time.
      self :: IN
      res :: BIN

      res = FALSE

      if (.F_sigma_cutoff >ZERO) then
      if (.reflections.have_F_exp) then
         res = TRUE
      end
      end

      if (.F_z_cutoff     >ZERO) then
      if (.reflections.have_F_pred) then
         res = TRUE
      end
      end

      if (.F_calc_cutoff  >ZERO) then
      if (.reflections.have_F_calc) then
         res = TRUE
      end
      end

      if (.F_pred_cutoff  >ZERO) then
      if (.reflections.have_F_pred) then
         res = TRUE
      end
      end

      if (.I_sigma_cutoff >ZERO) then
      if (.reflections.have_I_exp) then
         res = TRUE
      end
      end

   end

   is_F_calc_prunable result (res) ::: PURE
   ! Return TRUE if there's something to prune via a set cutoff.
   ! where F_calc's are required.
      self :: IN
      res :: BIN

      res = FALSE

      if (.F_z_cutoff     >ZERO) then
      if (.reflections.have_F_pred) then
         res = TRUE
      end
      end

      if (.F_calc_cutoff  >ZERO) then
      if (.reflections.have_F_calc) then
         res = TRUE
      end
      end

      if (.F_pred_cutoff  >ZERO) then
      if (.reflections.have_F_pred) then
         res = TRUE
      end
      end

   end

   prune_reflections
   ! Zero negative reflections adding appropriate error to sigma
   ! Then prune all the reflections, as requested by cutoffs.
      self :: INOUT

      n_refl,n_prun :: INT

      ! Prune small I's and define F's
      if (.have_I_exp) then
         DIE_IF(NOT .have_I_sigma,"I_exp present but no I_sigma?")
         .prune_small_I_sigmas
         .reflections.reset_I_exp_I_sigma
      end

      ! Next prune small F's
      if (.have_F_exp) then
         DIE_IF(NOT .have_F_sigma,"F_exp present but no F_sigma?")
         .prune_small_F_sigmas
         .reflections.reset_F_exp_F_sigma
      end

      ! Prune small F_exp/F_sigma
      if (.F_sigma_cutoff >ZERO) then
         if (.have_F_exp AND .have_F_sigma) then
            .prune_weak_Fs
         else
            WARN("F_sigma_cutoff specified but no F_exp/F_sigma data") 
         end 
      end 
      
      ! NOTE if doing below, do it repeatedly
      ! because the scale factor will change
      if (.F_z_cutoff     >ZERO) then

         if (.have_F_exp AND .have_F_pred) then

            do

               n_refl = .reflections.dim

               ! Prune
               .prune_bad_F_reflections
               n_prun = .reflections.dim

               ! Redo?
               if (n_prun==n_refl) then; exit
               else;                     .make_F_predicted
               end

            end

         else

            WARN("F_z_cutoff specified but no F_exp/F_pred data")

         end

      end

      ! Prune F_calc's which are zero
      if (.F_calc_cutoff  >ZERO) then
      if (.have_F_calc) then
         .prune_zero_F_calcs
      end
      end

      ! Prune F_pred's which are zero
      if (.F_pred_cutoff  >ZERO) then
         if (.have_F_pred) then
            .prune_zero_F_preds
         else
            WARN("F_pred_cutoff specified but no F_pred data")
         end
      end

      ! There are no I's any more
    ! if (.I_sigma_cutoff >ZERO) then
    !    if (.have_I_exp) then
    !       .prune_weak_Is
    !    else
    !       WARN("I_sigma_cutoff specified but no I_exp data")
    !    end
    ! end

      if (.stl_high_cutoff>ZERO) then
         .prune_high_angle_reflections
      end

      if ( .stl_low_cutoff>ZERO) then
         .prune_low_angle_reflections
      end

   end


   prune ::: template
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
      self :: INOUT

   ENSURE(.reflections.associated,"No reflection data")

      new_reflections :: VEC{REFLECTION}*
      good,bad,h1,h2,h3 :: VEC{INT}*
      val :: VEC{REAL}*
      table :: VEC{TABLE_COLUMN}*
      n_refl,n,i,g,b :: INT
      title :: STR

      ! No. of old reflections
      n_refl = .reflections.n_refl

      ! Find out how many rejects "n" there are
      n = 0
      do i = 1,n_refl
         if (NOT .reflections(i).TEST?(CUTOFF?)) cycle
         n = n + 1
      end

      ! Are there any weak reflections?
      if (n==0) return

      ! Are there any weak reflections?
      if (n==n_refl) then
      DIE("All reflection data has been rejected!")
      end

      ! Create the "good" and "bad" lists and how many of each
      bad.create(n)
      good.create(n_refl-n)
      g = 0
      b = 0
      do i = 1,n_refl
         if (.reflections(i).TEST?(CUTOFF?)) then
            b = b + 1
            bad(b) = i
         else
            g = g + 1
            good(g) = i
         end
      end

      ! Print out
      stdout.flush
      title = "Reflections pruned"

      stdout.text(repeat("=",len_trim(title)))
      stdout.text(trim(title))
      stdout.text(repeat("=",len_trim(title)))

      ! Banner
      stdout.flush
      stdout.show("Rejection criteria      =","TEST?")
      stdout.flush
      stdout.show("No. of reflections      =",n_refl)
      stdout.show("No. of rejects          =",b)
      stdout.show("No. of kept reflections =",g)
      stdout.show("Wavelength (Bohr)       =",REFLECTION:wavelength())
      stdout.show("Wavelength (Angstrom)   =",REFLECTION:wavelength()*ANGSTROM_PER_BOHR)
      if ("SHOW?"=="stl") then
      stdout.show("Cutoff (Bohr^-1)        =",CUTOFF?)
      stdout.show("Cutoff (Angstrom^-1)    =",CUTOFF?/ANGSTROM_PER_BOHR)
      else
      stdout.show("Cutoff                  =",CUTOFF?)
      end

      if (.show_rejects) then

         stdout.flush
         stdout.text("Rejects:")

         ! Get data
         n_refl = bad.dim
         h1.create(n_refl);       h1  = .reflections(bad(:)).h
         h2.create(n_refl);       h2  = .reflections(bad(:)).k
         h3.create(n_refl);       h3  = .reflections(bad(:)).l
         val.create(n_refl);      val = REFLECTION:SHOW?(.reflections(bad(:)))

         ! Table
         table.create(4)
         table(1).set_heading("h");     table(1).set_values(h1)
         table(2).set_heading("k");     table(2).set_values(h2)
         table(3).set_heading("l");     table(3).set_values(h3)
         table(4).set_heading("SHOW?"); table(4).set_values(val)
         table.put

         ! Clean
         table.clear_columns
         table.destroy
         h3.destroy
         h2.destroy
         h1.destroy
         val.destroy

         stdout.flush
         stdout.text("Kept:")

         ! Get data
         n_refl = good.dim
         h1.create(n_refl);       h1  = .reflections(good(:)).h
         h2.create(n_refl);       h2  = .reflections(good(:)).k
         h3.create(n_refl);       h3  = .reflections(good(:)).l
         val.create(n_refl);      val = REFLECTION:SHOW?(.reflections(good(:)))

         ! Table
         table.create(4)
         table(1).set_heading("h");     table(1).set_values(h1)
         table(2).set_heading("k");     table(2).set_values(h2)
         table(3).set_heading("l");     table(3).set_values(h3)
         table(4).set_heading("SHOW?"); table(4).set_values(val)
         table.put

         ! Clean
         table.clear_columns
         table.destroy
         h3.destroy
         h2.destroy
         h1.destroy
         val.destroy

      end

      ! Copy the non-rejects
      new_reflections.create(g)
      new_reflections.copy(.reflections(good))
      .reflections.destroy
      .reflections => new_reflections
      !!!!!!!!!!!!!!!!!!!!!!

      ! Clean
      bad.destroy
      good.destroy

   end

   prune_bad_F_reflections ::: get_from(prune, TEST?=>has_large_abs_F_z, CUTOFF?=>.F_z_cutoff, SHOW?=>abs_F_z), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_high_angle_reflections ::: get_from(prune, TEST?=>has_high_stl, CUTOFF?=>.stl_high_cutoff, SHOW?=>stl), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_low_angle_reflections ::: get_from(prune, TEST?=>has_low_stl, CUTOFF?=>.stl_low_cutoff SHOW?=>stl), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_weak_Fs ::: get_from(prune, TEST?=>has_weak_F_exp, CUTOFF?=>.F_sigma_cutoff, SHOW?=>F_exp_on_sigma), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_weak_Is ::: get_from(prune, TEST?=>has_weak_I_exp, CUTOFF?=>.I_sigma_cutoff, SHOW?=>I_exp_on_sigma), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_zero_F_preds ::: get_from(prune, TEST?=>has_small_F_pred, CUTOFF?=>TOL(3), SHOW?=>F_pred), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_zero_F_calcs ::: get_from(prune, TEST?=>has_zero_F_calc_abs, CUTOFF?=>TOL(3), SHOW?=>F_calc_abs), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_small_F_sigmas ::: get_from(prune, TEST?=>has_small_F_sigma, CUTOFF?=>TOL(3), SHOW?=>F_sigma), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_small_I_sigmas ::: get_from(prune, TEST?=>has_small_I_sigma, CUTOFF?=>TOL(3), SHOW?=>I_sigma), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

!  ==============
!  Debug printing
!  ==============

   read_debug_on ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and add it to the list.
   end

   read_debug_off ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and remove it from the list.
   end

   debugging(name) result (res) ::: get_from(DEBUG)
   ! Return TRUE if the debug switch "name" has been set.
   end

   put_debug_list ::: get_from(DEBUG)
   ! Put of the list of debug switches
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>REAL)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>VEC{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>MAT{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end


!  ===========
!  Intensities
!  ===========

   lp_factor result (res)
   ! Return the array of the Lorentz Polarization factors for all the
   ! reflections
      res :: VEC{REAL}(size(.reflections))
   ENSURE(.reflections.associated,"no reflection data")
      n :: INT
      c,s,two_theta :: REAL
      do n=1, .reflections.n_refl
       two_theta = TWO*.reflections(n).theta
       c = cos(two_theta)
       s = sin(two_theta)
       if (s.is_zero(TOL(8))) then
         res(n) = ZERO
         WARN("lp_factor for (000) reflection set to zero")
       else
         res(n) = (1+c*c)/(TWO*s)
       end
      end
   end

!   I_calc result (res)
!   ! Return the array of calculated intensities *without* extinction
!   ! (but including dispersion if requested).
!      res :: VEC{REAL}(size(.reflections))
!
!   ENSURE(.reflections.associated,"no reflection data")
!   ENSURE(.reflections.have_F_exp, "no calculated structure factors")
!
!      n :: INT
!      F :: REAL
!
!      do n = 1,.reflections.n_refl
!         F      = abs(.reflections(n).F_calc)
!         res(n) = F*F
!      end
!
!   end
!
!   I_pred result (res)
!   ! Return the array of predicted Intensities *with* extinction and
!   ! and with dispersion effects if requested.
!      res :: VEC{REAL}(size(.reflections))
!
!   ENSURE(.reflections.associated,"no reflection data")
!   ENSURE(.reflections.have_F_exp, "no calculated structure factors")
!
!      n :: INT
!      F :: REAL
!
!      do n = 1,.reflections.n_refl
!         F      = .reflections(n).F_pred
!         res(n) = F*F
!      end
!
!   end
!
!   I_exp result (res)
!   ! Return the array of experimental Intensities. Only the Lorentz Polarization
!   ! factor and the angular velocity factor for a single crystal are used.
!   ! Fundamental constants appearing in front of this are not calculated
!   ! NOTE: extinction factors, dispersion, multiple scattering corrections
!   ! are not included. These are the experimental intensities with these effects
!   ! removed.
!      res :: VEC{REAL}(size(.reflections))
!   ENSURE(.reflections.associated,"no reflection data")
!   ENSURE(.reflections.have_F_exp, "no calculated structure factors")
!      n :: INT
!      c,s,two_theta,F2 :: REAL
!      do n=1, .reflections.n_refl
!       two_theta = TWO*.reflections(n).theta
!       c = cos(two_theta)
!       s = sin(two_theta)
!       F2 = abs(.reflections(n).F_exp)
!       F2 = F2*F2
!       if (s.is_zero(TOL(8))) then
!          res(n) = F2
!       else
!          res(n) = (1+c*c)/(TWO*s)*F2
!       end
!      end
!   end
!
!   I_sigma result (res)
!   ! Return the array of experimental sigma's in the Intensities.
!      res :: VEC{REAL}(size(.reflections))
!   ENSURE(.reflections.associated,"no reflection data")
!   ENSURE(.reflections.have_I_pred OR .reflections.have_F_exp, "no structure factors")
!      n :: INT
!      c,s,two_theta,F2 :: REAL
!      if (NOT .reflections.have_F_exp AND NOT .synthesize_sigma_I) then
!       WARN("The synthesize_sigma_I flag was not set; it is now set")
!       .synthesize_sigma_I = TRUE
!      end
!      if (.synthesize_sigma_I) then
!       res = .reflections.I_pred
!       res = sqrt(res/.reflections.equivalence_factor)
!      else
!       do n=1, .reflections.n_refl
!         two_theta = TWO*.reflections(n).theta
!         c = cos(two_theta)
!         s = sin(two_theta)
!         F2 = abs(.reflections(n).F_exp)
!         if (s.is_zero(TOL(8))) then
!           res(n) = F2
!         else
!           res(n) = TWO*(1+c*c)/(TWO*s)*F2
!         end
!       end
!      end
!   end


!  ======================================
!  Scale & extinction factor optimisation
!  ======================================

   make_F_predicted
   ! Make the predicted magnitude of the structure factors, including
   ! possibly an overall scale factor and extinction correction.
      self :: INOUT

   DIE_IF(NOT .reflections.associated,"no reflection data")

      F_pred :: VEC{REAL}*
      n_r,n_p :: INT

      if (NOT .reflections.have_F_exp) then

         ! No experimental data ...
         F_pred.create(.reflections.n_refl)
         if (.data_kind=="pnd") then; F_pred = REALIFY(.reflections.F_calc)
         else;                        F_pred =     abs(.reflections.F_calc)
         end

         ! Set F_predicted
         .reflections.set_F_pred(F_pred)
         F_pred.destroy
      
      else

         ! Experimental data exists ...
         ! Add parameters for scale/extinction
         .update_n_param
   
         ! Get optimum scale factors, extinction, etc.
         if (.optimize_extinction OR .optimize_scale) .get_F_optimum_parameters
   
         ! Make F_predicted
         F_pred.create(.reflections.n_refl)
         if (.data_kind=="pnd") then; F_pred = REALIFY(.reflections.F_calc) * .F_extinction_correction
         else;                        F_pred =     abs(.reflections.F_calc) * .F_extinction_correction
         end
   
         ! Mix in some F_exp
         if (.SF_mixing_parameter>ZERO) then
         if (.have_F_exp) then
            F_pred = (ONE-.SF_mixing_parameter)* F_pred &
                   + .SF_mixing_parameter      * .reflections.F_exp
         end
         end
   
         ! Set F_predicted
         .reflections.set_F_pred(F_pred)
         F_pred.destroy
   
         ! Calculate the chi^2; reset denominator
         n_r = .reflections.dim - 1
         n_p = .reflections.dim - .n_param
         .chi2      = max(n_r,1)*.reflections.F_chi2/max(n_p,1)
         .chi2_fit0 = .chi2_fit
         .chi2_fit  = .chi2

      end

   end

   make_I_predicted
   ! Make the predicted squared magnitude of the structure factors, including
   ! possibly an overall scale factor and extinction correction.
      self :: INOUT

   DIE_IF(NOT .reflections.associated,"no reflection data")
   DIE_IF(.data_kind=="pnd", "sorry, no PND yet")

      I_pred :: VEC{REAL}*
      n_r,n_p :: INT

      ! Add on parameters for scale/extinction
      .update_n_param

      ! Get optimum scale factors, extinction, etc.
      if (.optimize_extinction OR .optimize_scale) .get_I_optimum_parameters

      ! Make I_predicted
      I_pred.create(.reflections.n_refl)
      I_pred = .reflections.I_calc * .I_extinction_correction

      ! Mix in some F_exp
      if (.SF_mixing_parameter>ZERO) then
      if (.have_I_exp) then
         I_pred = (ONE-.SF_mixing_parameter)* I_pred &
                + .SF_mixing_parameter * .reflections.I_exp
      end
      end

      ! Set I_predicted
      .reflections.set_I_pred(I_pred)
      I_pred.destroy

      ! Calculate the chi^2; reset denominator
      n_r = .reflections.dim - 1
      n_p = .reflections.dim - .n_param
      .chi2      = max(n_r,1)*.reflections.I_chi2/max(n_p,1)
      .chi2_fit0 = .chi2_fit
      .chi2_fit  = .chi2

   end

   update_n_param_and_chi2
   ! Update the number of parameters and recalculate the chi2
      self :: INOUT

      .update_n_param
      .update_chi2

   end

   update_n_param
   ! Update the number of parameters to include scale
   ! and extinction factors.
      self :: INOUT

      if (NOT .n_param_manually_set) then

         ! The number of params is assumed set in a refinement
         ! So only initialize n_param if this isn't going on
         ! or if not manually set by readinf a CIF
         if (NOT (.refine_structure OR .fit_structure)) then
            .n_param = 0
         end

         ! Add on extra parameters for scale/extinction
         if (.optimize_extinction) then

            DIE_IF(.use_multiple_scale_factors,"must use optimize_extinction= no")
            .n_param = .n_param + 2

         else if (.optimize_scale) then

            if (.use_multiple_scale_factors) then
               .n_param = .n_param + maxval(.reflections.group)
            else
               .n_param = .n_param + 1
            end

         end

         if (.XCW) then
        
            ! Add lambda as an extra parameter
            ! Not correct - but better than nothing?
            .n_param = .n_param + 1
        
         end

      end

   end

   update_chi2
   ! Update the number of parameters and recalculate the chi2
      self :: INOUT

   DIE_IF(.n_param<=0,"n_param must be +ve")

      n_r,n_p :: INT

      ! Update the chi2
      n_r = .reflections.dim - 1
      n_p = .reflections.dim - .n_param
      .chi2      = max(n_r,1)*.reflections.F_chi2/max(n_p,1)
      .chi2_fit  = .chi2

   end

   get_F_optimum_parameters ::: private
   ! Get the scale factors, extinction parameters, etc, which minimise the chi2.
   ! (To get the corrections cooresponding to these parameters see routine
   ! .extinction_correction)

      if (.optimize_extinction) then

         DIE_IF(.use_multiple_scale_factors,"must use optimize_extinction= no")
         .optimize_F_extinction_factor

      else if (.optimize_scale) then

         if (.use_multiple_scale_factors) then; .optimize_F_scale_factors
         else;                                  .optimize_F_scale_factor
         end

      end

   end

   get_I_optimum_parameters ::: private
   ! Get the scale factors, extinction parameters, etc, which minimise the chi2.
   ! (To get the corrections cooresponding to these parameters see routine
   ! .extinction_correction)

      if (.optimize_extinction) then

         DIE_IF(.use_multiple_scale_factors,"must use optimize_extinction= no")
         .optimize_I_extinction_factor

      else if (.optimize_scale) then

         if (.use_multiple_scale_factors) then; .optimize_I_scale_factors
         else;                                  .optimize_I_scale_factor
         end

      end

   end

   F_extinction_correction result (res) ::: PURE
   ! Return the extinction correction  factors "res" to the calculated
   ! individual structure factors. NOTE: also does scale factor
      self :: IN
      res :: VEC{REAL}(size(.reflections))

      if (.use_multiple_scale_factors) then
         res = .F_extinction_correction(.scale_factors,.extinction_factor)
      else
         res = .F_extinction_correction(.scale_factor ,.extinction_factor)
      end

   end

   I_extinction_correction result (res) ::: private
   ! Return the I extinction correction  factors "res" to the calculated
   ! individual structure factors. NOTE: also does scale factor
      res :: VEC{REAL}(size(.reflections))

      if (.use_multiple_scale_factors) then
         res = .I_extinction_correction(.scale_factors,.extinction_factor)
      else
         res = .I_extinction_correction(.scale_factor,.extinction_factor)
      end

   end

   F_extinction_correction(scale_factor,extinction_factor) result (res) ::: PURE
   ! Return the F extinction correction  factors "res" to the calculated
   ! individual structure factors. NOTE: this routine also does scaling
   ! corrections without extinction.
      self :: IN
      scale_factor,extinction_factor :: REAL, IN
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflections.associated,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")

      F_calc :: CPX
      F_abs2,val :: REAL
      angle_part :: VEC{REAL}*
      n_refl,n :: INT

      n_refl = .reflections.n_refl

      if (extinction_factor.is_zero(TOL(9))) then

         res = scale_factor

      else

         angle_part.create(n_refl)
         angle_part = .extinction_angle_part

         do n=1, n_refl
            F_calc = .reflections(n).F_calc
            F_abs2 = REALIFY(F_calc*conjg(F_calc))
            val    = ONE + extinction_factor*F_abs2*angle_part(n)
            res(n) = scale_factor/sqrt(sqrt(val))
         end

         angle_part.destroy

      end

   end

   I_extinction_correction(scale_factor,extinction_factor) result (res) ::: private
   ! Return the extinction correction  factors "res" to the calculated
   ! individual structure factors. NOTE: this routine also does scaling
   ! corrections without extinction.
      scale_factor,extinction_factor :: REAL, IN
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflections.associated,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")

      n_refl :: INT

      n_refl = .reflections.n_refl

      if (extinction_factor.is_zero(TOL(9))) then

         res = scale_factor

      else

         DIE("sorry, not yet ...")

      end

   end

   F_extinction_correction(scale_factors,extinction_factor) result (res) ::: PURE
   ! Return the F extinction correction factors "res" to the calculated
   ! individual structure factors. WARNING: this routine in fact does no
   ! extinction correction, only multiple scale factors.
      self :: IN
      scale_factors :: VEC{REAL}, IN
      extinction_factor :: REAL, IN
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflections.associated,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(scale_factors.dim==maxval(.reflections.group),"wrong # of groups")

      F_calc :: CPX
      angle_part :: VEC{REAL}*
      g,n,n_refl,n_group :: INT

      n_refl = .reflections.n_refl
      n_group = scale_factors.dim

      if (extinction_factor.is_zero(TOL(9))) then

         do g = 1,n_group
            do n = 1, n_refl
              if (.reflections(n).group/=g) cycle
              res(n) = scale_factors(g)
            end
         end

      else

         angle_part.create(n_refl)
         angle_part = .extinction_angle_part
         do g = 1,n_group
            do n = 1, n_refl
              if (.reflections(n).group/=g) cycle
              F_calc = .reflections(n).F_calc
              res(n) = scale_factors(g) / sqrt(sqrt(ONE + &
                  extinction_factor*REALIFY(F_calc*conjg(F_calc))*angle_part(n)))
            end
         end
         angle_part.destroy

      end

   end

   I_extinction_correction(scale_factors,extinction_factor) result (res) ::: private
   ! Return the extinction correction factors "res" to the calculated
   ! individual structure factors. WARNING: this routine in fact does no
   ! extinction correction, only multiple scale factors.
      scale_factors :: VEC{REAL}, IN
      extinction_factor :: REAL, IN
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflections.associated,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(scale_factors.dim==maxval(.reflections.group),"wrong # of groups")

      g,n,n_refl,n_group :: INT

      n_refl = .reflections.n_refl
      n_group = scale_factors.dim

      if (extinction_factor.is_zero(TOL(9))) then

       do g = 1,n_group
          do n = 1, n_refl
            if (.reflections(n).group/=g) cycle
            res(n) = scale_factors(g)
          end
       end

      else

       DIE("sorry, not yet ...")

      end

   end

   extinction_angle_part result (res) ::: private, pure
   ! Return the angular part of the extinction correction.
      self :: IN
      res :: VEC{REAL}(size(.reflections))

      n :: INT
      twotheta,c,s :: REAL

      do n = 1, .reflections.n_refl
         twotheta=TWO*.reflections(n).theta
         c = cos(twotheta)
         s = sin(twotheta)
         res(n) = (ONE+c*c)/(ONE+c*s)
      end

   end

   optimize_F_scale_factor ::: private
   ! Determine the structure factor scale factor to scale the calculated
   ! structure factors .F_calc by in order to minimise the chi2. (But it does
   ! not do any scaling; see .extinction_correction routine for that)
      self :: INOUT

   DIE_IF(NOT .reflections.associated,"no reflection data")
   DIE_IF(NOT .reflections.have_F_calc, "no calculated structure factors")
   DIE_IF(NOT .reflections.have_F_exp, "no experimental structure factors")
   DIE_IF(NOT .reflections.have_F_sigma, "no structure factor errors")

      top,bot,sg2,F_pred :: REAL
      n,n_refl :: INT
      ref :: REFLECTION*

      n_refl = .reflections.n_refl

      top = ZERO
      bot = ZERO

      do n = 1,n_refl

         ref => .reflections(n)

         if (.data_kind=="pnd") then; F_pred = REALIFY(ref.F_calc)
         else;                        F_pred = abs(ref.F_calc)
         end
         ENSURE(ref.F_sigma/=ZERO,"Structure factor has zero error!")

         sg2 = ONE / (ref.F_sigma * ref.F_sigma)
         top = top + F_pred * ref.F_exp * sg2
         bot = bot + F_pred * F_pred * sg2

      end

      .scale_factor = top/bot

   end

   optimize_I_scale_factor ::: private
   ! Determine the structure factor scale factor to scale the calculated
   ! structure factors .F_calc by in order to minimise the chi2. (But it does
   ! not do any scaling; see .extinction_correction routine for that)
   DIE_IF(NOT .reflections.associated,"no reflection data")
   DIE_IF(NOT .reflections.have_I_calc, "no calculated I's")
   DIE_IF(NOT .reflections.have_I_exp, "no experimental I's")
   DIE_IF(NOT .reflections.have_I_sigma, "no I sigma's")
   DIE_IF(.data_kind=="pnd", "sorry, noy yet ...")

      top,bot,sg2,I_pred :: REAL
      n,n_refl :: INT
      ref :: REFLECTION*

      n_refl = .reflections.n_refl

      top = ZERO
      bot = ZERO

      do n = 1,n_refl

         ref => .reflections(n)

         I_pred = ref.I_calc

         ENSURE(ref.I_sigma/=ZERO,"Structure factor has zero error!")

         sg2 = ONE / (ref.I_sigma * ref.I_sigma)
         top = top + I_pred * ref.I_exp * sg2
         bot = bot + I_pred * I_pred * sg2

      end

      .scale_factor = top/bot

   end

   optimize_F_scale_factors ::: private, leaky
   ! Multiple scale factors are determined here ...
   ! Determine the structure factor scale factors to scale the calculated
   ! structure factors .F_calc by in order to minimise the chi2. (But it does
   ! not do any scaling; see .extinction_correction routine for that)
      self :: INOUT

   DIE_IF(NOT .reflections.associated,"no reflection data")
   DIE_IF(NOT .reflections.have_F_calc, "no calculated structure factors")
   DIE_IF(NOT .reflections.have_F_exp, "no experimental structure factors")
   DIE_IF(NOT .reflections.have_F_sigma, "no structure factor errors")
   DIE_IF(NOT .use_multiple_scale_factors, "no reflection group numbers")

      top,bot,F_pred :: REAL
      g,n,n_refl,n_group :: INT
      ref :: REFLECTION*

      n_group = maxval(.reflections.group)
      n_refl = .reflections.n_refl

      .scale_factors.destroy
      .scale_factors.create(n_group)

      do g = 1,n_group

         top = ZERO
         bot = ZERO

         do n = 1,n_refl

            ref => .reflections(n)

            if (ref.group/=g) cycle

            if (.data_kind=="pnd") then; F_pred = REALIFY(ref.F_calc)
            else;                        F_pred = abs(ref.F_calc)
            end

            ENSURE(ref.F_sigma/=ZERO,"Structure factor has zero error!")

            top = top + F_pred * ref.F_exp  / (ref.F_sigma * ref.F_sigma)
            bot = bot + F_pred * F_pred / (ref.F_sigma * ref.F_sigma)

         end

         .scale_factors(g) = top/bot

      end

   end

   optimize_I_scale_factors ::: private, leaky
   ! Multiple scale factors are determined here ...
   ! Determine I scale factors to scale the calculated
   ! .I_calc by in order to minimise the chi2I. (But it does
   ! not do any scaling; see .extinction_correction routine for that)
      self :: INOUT

   DIE_IF(NOT .reflections.associated,"no reflection data")
   DIE_IF(NOT .reflections.have_I_calc, "no calculated structure factors")
   DIE_IF(NOT .reflections.have_I_exp, "no experimental structure factors")
   DIE_IF(NOT .reflections.have_I_sigma, "no structure factor errors")
   DIE_IF(NOT .use_multiple_scale_factors, "no reflection group numbers")
   DIE_IF(.data_kind=="pnd", "sorry, no polarized neutron diffraction")

      top,bot,I_pred :: REAL
      g,n,n_refl,n_group :: INT
      ref :: REFLECTION*

      n_group = maxval(.reflections.group)
      n_refl = .reflections.n_refl

      .scale_factors.destroy
      .scale_factors.create(n_group)

      do g = 1,n_group
        top = ZERO
        bot = ZERO
        do n = 1,n_refl
          ref => .reflections(n)
          if (ref.group/=g) cycle
          I_pred = ref.I_calc
          ENSURE(ref.I_sigma/=ZERO,"Structure factor has zero error!")
          top = top + I_pred * ref.I_exp  / (ref.I_sigma * ref.I_sigma)
          bot = bot + I_pred * I_pred / (ref.I_sigma * ref.I_sigma)
        end
        .scale_factors(g) = top/bot
      end

   end

   optimize_F_extinction_factor ::: private
   ! Optimize the .scale_factor and .extinction_factor parameter of Larson's
   ! method.
   ! NOTE: the corrections are not applied to .F_pred; use the routine
   ! .extinction_corrections to do that.
   ! Reference: Larson, A. C., in Crystallographic Computing
   !            Ed. Ahmed, F. R. (Copenhagen, Munksgaard 1970), pp. 291-294.
      self :: target
      p :: VEC{REAL}(2)
      chi2_min :: REAL

      ! Get starting scale factor
      .optimize_F_scale_factor

      ! Do a 2-variable minimisation
      ! p(2) is the .extinction_factor
      p(1) = .scale_factor
      p(2) = ZERO          

      saved_self => self
      VEC{REAL}:minimiZe_BFGS(::chi2,::d_chi2,p,chi2_min,tol=TOL(7),gtol=TOL(7),step=TOL(4))

      .scale_factor      = p(1)
      .extinction_factor = p(2)

   end

   optimize_I_extinction_factor ::: private
   ! Optimize the .scale_factor and .extinction_factor parameter of Larson's
   ! method.
   ! NOTE: the corrections are not applied to .F_pred; use the routine
   ! .extinction_corrections to do that.
   ! Reference: Larson, A. C., in <I>Crystallographic Computing</I>
   !            Ed. Ahmed, F. R. (Copenhagen, Munksgaard 1970), pp. 291-294.
      self :: target
      p :: VEC{REAL}(2)
      chi2_min :: REAL

      ! Get starting scale factor
      .optimize_I_scale_factor

      ! Do a 2-variable minimisation
      ! p(2) is the .extinction_factor
      p(1) = .scale_factor
      p(2) = ZERO

      saved_self => self
      VEC{REAL}:minimize_BFGS(::chi2I,::d_chi2I,p,chi2_min,tol=TOL(7),gtol=TOL(7),step=TOL(6))

      .scale_factor = p(1)
      .extinction_factor = p(2)

   end

   chi2(p) result (res) ::: private, selfless
   ! Make the chi2 between the calculated and experimental structure factors
   ! with extinction and scale parameters stored in vector p.
      p :: VEC{REAL}, IN
      res :: REAL

   ENSURE(saved_self.reflections.associated,"no reflection data")
   ENSURE(saved_self.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(saved_self.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(saved_self.reflections.have_F_sigma, "no structure factor errors")
   ENSURE(size(p)==2, "wrong size, p")

      tmp,tmp1 :: REAL
      ext :: VEC{REAL}*
      ref :: REFLECTION*
      n,n_refl :: INT
      self :: DIFFRACTION_DATA*

      self => saved_self

      n_refl = .reflections.n_refl

      ext.create(n_refl)
      ext = .F_extinction_correction(p(1),p(2))

      tmp = ZERO
      do n=1,n_refl
       ref => .reflections(n)
       tmp1 = (abs(ref.F_calc) * ext(n) - ref.F_exp) / ref.F_sigma
       tmp = tmp + tmp1 * tmp1
      end
      res = tmp / max(n_refl-.n_param,1)
      ext.destroy

   end

   chi2I(p) result (res) ::: private, selfless
   ! Make the chi2 between the calculated and experimental squared
   ! structure factors
   ! with extinction and scale parameters stored in vector p.
      p :: VEC{REAL}, IN
      res :: REAL

   ENSURE(saved_self.reflections.associated,"no reflection data")
   ENSURE(saved_self.reflections.have_I_calc, "no calculated structure factors")
   ENSURE(saved_self.reflections.have_I_exp, "no experimental structure factors")
   ENSURE(saved_self.reflections.have_I_sigma, "no structure factor errors")
   ENSURE(size(p)==2, "wrong size, p")

      tmp,tmp1 :: REAL
      ext :: VEC{REAL}*
      ref :: REFLECTION*
      n,n_refl :: INT
      self :: DIFFRACTION_DATA*

      self => saved_self
      n_refl = .reflections.n_refl

      ext.create(n_refl)
      ext = .I_extinction_correction(p(1),p(2))

      tmp = ZERO
      do n=1,n_refl
         ref => .reflections(n)
         tmp1 = (ref.I_calc * ext(n) - ref.I_exp) / ref.I_sigma
         tmp = tmp + tmp1 * tmp1
      end
      res = tmp / max(n_refl-.n_param,1)

      ext.destroy

   end

   d_chi2(p) result (res) ::: private, selfless
   ! Return the derivative of the chi2 with respect to the .scale_factor in
   ! p(1), and with respect to .extinction_factor in p(2). This routine is for
   ! use in the BFGS minimiser.
      p :: VEC{REAL}, IN
      res :: VEC{REAL}(size(p))

   ENSURE(size(p)==2, "wrong size, p")

      self :: DIFFRACTION_DATA*

      self => saved_self
      res(1) = .d_chi2_d_scale(p)
      res(2) = .d_chi2_d_ext(p)

   end

   d_chi2I(p) result (res) ::: private, selfless
   ! Return the derivative of the chi2 with respect to the .scale_factor in
   ! p(1), and with respect to .extinction_factor in p(2). This routine is for
   ! use in the BFGS minimiser.
      p :: VEC{REAL}, IN
      res :: VEC{REAL}(size(p))

   ENSURE(size(p)==2, "wrong size, p")

      self :: DIFFRACTION_DATA*

      self => saved_self
      res(1) = .d_chi2I_d_scale(p)
      res(2) = .d_chi2I_d_ext(p)

   end

   d_chi2_d_scale(p) result (res)   ::: private
   ! Derivative of the chi^2 for F with respect to the scale factor
      p :: VEC{REAL}, IN
      res :: REAL

   ENSURE(.reflections.associated,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
   ENSURE(size(p)==2, "wrong size, p")

      tmp,F_pred :: REAL
      ext :: VEC{REAL}*
      ref :: REFLECTION*
      n,n_refl :: INT

      n_refl = .reflections.n_refl

      ext.create(n_refl)
      ext = .F_extinction_correction(p(1),p(2))

      tmp = ZERO
      do n=1,n_refl
       ref => .reflections(n)
       F_pred = abs(ref.F_calc) * ext(n)
       tmp = tmp + F_pred * (F_pred - ref.F_exp) / (ref.F_sigma*ref.F_sigma)
      end
      res = TWO*tmp/(p(1)*max(n_refl-.n_param,1))

      ext.destroy

   end

   d_chi2I_d_scale(p) result (res) ::: private
   ! Derivative of the chi^2 for I with respect to the scale factor
      p :: VEC{REAL}, IN
      res :: REAL

   ENSURE(.reflections.associated,"no reflection data")
   ENSURE(.reflections.have_I_calc, "no calculated structure factors")
   ENSURE(.reflections.have_I_exp, "no experimental structure factors")
   ENSURE(.reflections.have_I_sigma, "no structure factor errors")
   ENSURE(size(p)==2, "wrong size, p")

      tmp,I_pred :: REAL
      ext :: VEC{REAL}*
      ref :: REFLECTION*
      n,n_refl :: INT

      n_refl = .reflections.n_refl

      ext.create(n_refl)
      ext = .I_extinction_correction(p(1),p(2))

      tmp = ZERO
      do n=1,n_refl
       ref => .reflections(n)
       I_pred = ref.I_calc * ext(n)
       tmp = tmp + I_pred * (I_pred - ref.I_exp) / (ref.I_sigma*ref.I_sigma)
      end
      res = FOUR*tmp/max(n_refl-.n_param,1)

      ext.destroy

   end

   d_chi2_d_ext(p) result (res) ::: private
   ! Derivative of the chi^2 for F with respect to the extinction parameter.
      p :: VEC{REAL}, IN
      res :: REAL

   ENSURE(.reflections.associated,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
   ENSURE(size(p)==2, "wrong size, p")

      tmp,extn,p1 :: REAL
      angle_bit,ext :: VEC{REAL}*
      ref :: REFLECTION*
      n,n_refl :: INT

      n_refl = .reflections.n_refl

      angle_bit.create(n_refl)
      ext.create(n_refl)

      angle_bit = .extinction_angle_part

      p1 = p(1)
      ext = .F_extinction_correction(ONE,p(2))

      tmp = ZERO
      do n = 1,n_refl
       ref => .reflections(n)
       extn = ext(n)
       tmp = tmp + (p1 * abs(ref.F_calc) * extn - ref.F_exp) * &
           extn*extn*extn*extn*extn* &
           REALIFY(ref.F_calc*ref.F_calc*ref.F_calc) * &
           angle_bit(n) / (ref.F_sigma * ref.F_sigma)
      end
      res = -p1*tmp/(TWO * max(n_refl-.n_param,1))

      ext.destroy
      angle_bit.destroy

   end

   d_chi2I_d_ext(p) result (res) ::: private
   ! Derivative of the chi^2 for I with respect to the extinction parameter.
      p :: VEC{REAL}, IN
      res :: REAL

   DIE("Sorry...")

      self = self
      res = ZERO * p(1)

   end


!   d_chi2_dX(res,dFdX) ::: private
!   ! Evaluate "res", the derivative of the chi^2 with respect to some
!   ! parameters X (e.g. thermal parameters) given "dFdX", the
!   ! derivatives of the complex structure factors w.r.t. the X
!   ! parameters.  NOTE: this routine assumes the .extinction_factor
!   ! is fixed.
!      self :: INOUT
!      res :: VEC{REAL}, OUT
!      dFdX :: MAT{CPX}, IN
!
!   ENSURE(.reflections.associated,"no reflection data")
!   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
!   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
!   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
!   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dF")
!   ENSURE(dFdX.dim2==res.dim, "incompatible dFdX and res")
!
!      Fcd_conjgFcalc :: VEC{CPX}*
!      ref :: REFLECTION*
!      ext,angle_bit,d_scale :: VEC{REAL}*
!      Fcd,Fca,fac,extn,ext5,sg2,sdk,nrinv :: REAL
!      n_refl,n_p,p,n :: INT
!
!      n_refl = .reflections.n_refl
!      n_p = dFdX.dim2
!
!      Fcd_conjgFcalc.create(n_refl)
!
!      ext.create(n_refl)
!      ext = .F_extinction_correction(ONE,.extinction_factor)
!
!      angle_bit.create(n_refl)
!      angle_bit = .extinction_angle_part
!
!      sdk = ZERO
!      do n = 1,n_refl
!         ref => .reflections(n)
!         extn = ext(n)
!         ext5 = extn*extn*extn*extn*extn*.extinction_factor
!         Fca = abs(ref.F_calc)
!         sg2 = ONE/(ref.F_sigma*ref.F_sigma)
!         fac = (.scale_factor*extn*Fca - ref.F_exp)*sg2
!         Fcd = fac * (extn/Fca - HALF*ext5*angle_bit(n))
!         Fcd_conjgFcalc(n) = Fcd * conjg(ref.F_calc)
!         sdk = sdk + fac*extn*Fca
!      end
!
!      angle_bit.destroy
!      ext.destroy
!
!      d_scale.create(n_p)
!      .d_scale_dX(d_scale,dFdX)
!
!      nrinv = ONE/max(n_refl-.n_param,1)
!      sdk = TWO*nrinv*sdk
!      fac = TWO*.scale_factor*nrinv
!
!      do p = 1,n_p
!         res(p) = sdk*d_scale(p) + fac * VEC{REAL}:sum_elements( REALIFY(Fcd_conjgFcalc * dFdX(:,p)) )
!      end
!      d_scale.destroy
!      Fcd_conjgFcalc.destroy
!
!   end

!   d_chi2I_dX(res,dIdX) ::: private
!   ! Evaluate "res", the derivative of the chi^2 with respect to some
!   ! parameters X (e.g. thermal parameters) given "dIdX", the
!   ! derivatives of the square structure factors w.r.t. the X
!   ! parameters.  NOTE: this routine assumes the .extinction_factor
!   ! is fixed.
!      self :: INOUT
!      res :: VEC{REAL}, OUT
!      dIdX :: MAT{CPX}, IN
!
!   DIE("Sorry...")
!
!      self = self
!      res = ZERO*RE(dIdX(1,1))
!
!   end

!   d_chi2_dX_plus_se(res,dFdX) ::: private
!   ! Evaluate "res", the derivative of the chi^2 with respect to some
!   ! parameters X (e.g. thermal parameters) given "dFdX", the
!   ! derivatives of the complex structure factors w.r.t. the X
!   ! parameters. Two extra derivatives are included, w.r.t. the
!   ! extinction parameter and the scale factor.
!      res :: VEC{REAL}, OUT
!      dFdX :: MAT{CPX}, IN
!
!   ENSURE(.reflections.associated,"no reflection data")
!   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
!   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
!   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
!   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dF")
!   ENSURE(dFdX.dim2==res.dim-2, "incompatible dFdX and res")
!
!      Fcd_conjgFcalc :: VEC{CPX}*
!      ref :: REFLECTION*
!      ext,angle_bit :: VEC{REAL}*
!      Fcd,Fca,fac,extn,ext5,extf, Fe,Fs :: REAL
!      n_refl,n_p,p,n :: INT
!
!      ! Constants
!      n_refl = .reflections.n_refl
!      n_p = dFdX.dim2
!
!      ! Temporaries
!      angle_bit.create(n_refl)
!      ext.create(n_refl)
!      Fcd_conjgFcalc.create(n_refl)
!
!      ! Different parts of the extinction
!      angle_bit = .extinction_angle_part
!      ext = .F_extinction_correction(ONE,.extinction_factor)
!
!      ! Make parameter prefactor derivative
!      Fe = ZERO
!      Fs = ZERO
!      do n = 1,n_refl
!         ref => .reflections(n)
!         extn = ext(n)
!         ext5 = extn*extn*extn*extn*extn
!         extf = ext5*.extinction_factor
!         Fca = abs(ref.F_calc)
!         fac = (.scale_factor*extn*Fca - ref.F_exp)/(ref.F_sigma*ref.F_sigma)
!         Fcd = fac * (extn/Fca - HALF*extf*angle_bit(n))
!         Fcd_conjgFcalc(n) = Fcd * conjg(ref.F_calc)
!         ! Extinction part
!         Fe = Fe - fac*QUARTER*.scale_factor*ext5*Fca*Fca*Fca*angle_bit(n)
!         ! Scale part
!         Fs = Fs + fac*extn*Fca
!      end
!
!      ! Parameter derivatives
!      fac = TWO*.scale_factor/max(n_refl-.n_param,1)
!      do p = 1,n_p
!         res(p) = fac * VEC{REAL}:sum_elements( REALIFY(Fcd_conjgFcalc * dFdX(:,p)) )
!      end
!
!      ! Extinction and scale derivatives
!      res(n_p+1) = fac*Fe
!      res(n_p+2) = fac*Fs
!
!      ! Cleanup
!      Fcd_conjgFcalc.destroy
!      ext.destroy
!      angle_bit.destroy
!
!   end

!   d_chi2I_dX_plus_se(res,dIdX) ::: private
!   ! Evaluate "res", the derivative of the chi^2 with respect to some
!   ! parameters X (e.g. thermal parameters) given "dIdX", the
!   ! derivatives of the complex structure factors w.r.t. the X
!   ! parameters. Two extra derivatives are included, w.r.t. the
!   ! extinction parameter and the scale factor.
!      res :: VEC{REAL}, OUT
!      dIdX :: MAT{CPX}, IN
!
!   DIE("Sorry...")
!
!      self = self
!      res = ZERO*RE(dIdX(1,1))
!
!   end

!   d_scale_dX(res,dFdX) ::: private
!   ! Return "res" the derivative of the scale factor with respect to
!   ! parameters X, where the *complex* structure factor parameter
!   ! derivatives are given in "dFdX". This takes into account an
!   ! existing extinction factor.
!      res :: VEC{REAL}, OUT
!      dFdX :: MAT{CPX}, IN
!
!   DIE_IF(NOT .reflections.associated,"no reflection data")
!   DIE_IF(NOT .reflections.have_F_calc, "no calculated structure factors")
!   DIE_IF(NOT .reflections.have_F_exp, "no experimental structure factors")
!   DIE_IF(NOT .reflections.have_F_sigma, "no structure factor errors")
!   ENSURE(.data_kind=="x-ray","only valie for X-ray data, so far")
!   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dFdX")
!   ENSURE(dFdX.dim2==res.dim, "incompatible res, dFdX")
!   ENSURE(all(.reflections(:).F_sigma/=ZERO),"A structure factor has zero error F_sigma!")
!
!      top,bot,fac,sg2,F_abs,F_exp,F_sig,extn,val1,val2 :: REAL
!      dt,db :: VEC{CPX}*
!      ext   :: VEC{REAL}*
!      F_cal,dF :: CPX
!      n,n_refl,p :: INT
!      ref :: REFLECTION*
!
!      n_refl = .reflections.n_refl
!
!      dt.create(n_refl)
!      db.create(n_refl)
!
!      ext.create(n_refl)
!      ext = .F_extinction_correction(ONE,.extinction_factor)
!
!      top = ZERO
!      bot = ZERO
!      do n = 1,n_refl
!       ref => .reflections(n)
!       extn = ext(n)
!       F_cal = extn*conjg(ref.F_calc)
!       F_abs = abs(F_cal)
!       F_exp = abs(ref.F_exp)
!       F_sig = ref.F_sigma
!       sg2 = ONE / (F_sig * F_sig)
!       dt(n) = extn * F_exp * sg2 * F_cal / F_abs
!       db(n) = extn * sg2 * F_cal
!       F_abs = extn * F_abs
!       top = top + F_abs * F_exp * sg2
!       bot = bot + F_abs * F_abs * sg2
!      end
!      ext.destroy
!
!      bot = ONE/bot
!      fac = -TWO*top*bot*bot
!      do p = 1,dFdX.dim2
!         val1 = ZERO
!         val2 = ZERO
!         do n = 1,n_refl
!            dF = dFdX(n,p)
!            val1 = val1 + REALIFY(dt(n)*dF)
!            val2 = val2 + REALIFY(db(n)*dF)
!         end
!         res(p) = bot*val1 + fac*val2
!      end
!
!      db.destroy
!      dt.destroy
!
!   end


!  ===============================================
!  Structure factors without extinction correction
!  ===============================================

   make_phased_dF(dF) ::: PURE
   ! Get phased structure factor differences from experimental values
   ! (without extinction/scale factor correction) for residual map.
      self :: IN
      dF :: VEC{CPX}, OUT

   ENSURE(.reflections.associated, "no structure factors")
   ENSURE(dF.dim==.reflections.dim, "incorrect size, dF")

      phase :: VEC{CPX}*
      ext   :: VEC{REAL}*
      n_refl :: INT

      n_refl = .reflections.dim

      phase.create(n_refl)
      ext.create(n_refl)

      ! Phases should not include dispersion (if added)
      phase = .reflections.F_calc/abs(.reflections.F_calc)

      ! These are the scale factors & extinction
      ext   = .F_extinction_correction

      ! Subtract the predicted value (which includes dispersion)
      ! Also, place F_exp on an absolute scale
      dF = (.reflections.F_exp - .reflections.F_pred) * phase / ext

      ext.destroy
      phase.destroy

   end

   make_phased_dF(dF) ::: PURE
   ! Get phased structure factor differences from experimental values
   ! (without extinction/scale factor correction) for residual map.
      self :: IN
      dF :: MAT3{CPX}*, OUT

   ENSURE(.reflections.associated, "no structure factors")

      phase :: VEC{CPX}*
      ext   :: VEC{REAL}*
      n_refl :: INT
      r,h,k,l :: INT

      n_refl = .reflections.dim

      phase.create(n_refl)
      ext.create(n_refl)

      ! Phases should not include dispersion (if added)
      phase = .reflections.F_calc/abs(.reflections.F_calc)

      ! These are the scale factors & extinction
      ext   = .F_extinction_correction

      ! Subtract the predicted value (which includes dispersion)
      ! Also, place F_exp on an absolute scale
      dF = ZERO

      do r = 1,n_refl

         h = .reflections(r).h
         k = .reflections(r).k
         l = .reflections(r).l

         dF(h,k,l) = (.reflections(r).F_exp - .reflections(r).F_pred) * phase(r) / ext(r)

      end
      
      ! Clean
      ext.destroy
      phase.destroy

   end


!  ====================
!  Structure refinement
!  ====================

   refine_positions_and_ADPs result (res) ::: PURE
   ! A refinement of all positions and ADP's
      self :: IN
      res :: BIN

      res =   NOT .refine_positions_only &
          AND NOT .refine_ADPs_only

   end

   refine_3rd_order result (res) ::: PURE
   ! Refineme third-order anharmonicity for any atoms?
      self :: IN
      res :: BIN

      res =  .refine_3rd_order_for_atom.associated

   end

   refine_4th_order result (res) ::: PURE
   ! Refineme fourth-order anharmonicity for any atoms?
      self :: IN
      res :: BIN

      res =  .refine_4th_order_for_atom.associated

   end

   no_of_3rd_order_atoms result (res) ::: PURE
   ! The number of atoms on which there are third-order anharmonicity
   ! parameters
      self :: IN
      res :: INT

      res = 0

      if (.refine_3rd_order_for_atom.associated) res = .refine_3rd_order_for_atom.dim

   end

   no_of_4th_order_atoms result (res) ::: PURE
   ! The number of atoms on which there are third-order anharmonicity
   ! parameters
      self :: IN
      res :: INT

      res = 0
      if (.refine_4th_order_for_atom.associated) res = .refine_4th_order_for_atom.dim

   end

!  Fit/refinement initialization

   initialize_fit_data(n_p,n_f,labels) ::: leaky
   ! Create the fit data arrays & initialize if needed.
   ! "n_p" is the number of unique pADP's to refine.
   ! "n_f" is the number of non-unique fragment atom pADP's.
   ! Some of these arrays will already be created if refining.
      n_p,n_f :: INT, IN
      labels :: VEC{STR}, IN

      ! Reset fit data
      .destroy_fit_data
      .set_fit_data

      ! Set fitting
      if (NOT .refine_structure) .set_fit_structure(TRUE)

      ! Initially chi^2 is as big as you can get
      .chi2_fit0 = huge(ONE)

      ! Set the uique # of parameters. Used for getting the correct
      ! chi^2 statistic. Note: zero eigenvalues in the least squares
      ! will modify this value.
      .n_param = n_p
      .n_param_manually_set = FALSE ! Ignore manually set n_p

      ! Create parameter vectors & shifts (leaky)
      .dX.create(n_p)
      .X_fit.create(n_p)
      .X_fit0.create(n_p)

      ! Create esd's and covariances
      .esd.create(n_p)
      .covariance_matrix.create(n_p,n_p)
      .correlation_matrix.create(n_p,n_p)
      .fragment_covariance_matrix.create(n_f,n_f)

      ! Set esd's to zero
      .esd = ZERO

      ! Create the table (leaky)
      .fit_table.create(8)

      ! Fit table headings
      .fit_table(1).set_heading("Fit")
      .fit_table(1).set_subhead("Iter")
      .fit_table(2).set_heading("chi2")
      .fit_table(3).set_heading("R")
      .fit_table(4).set_heading("R_w")
      .fit_table(5).set_heading("Max.")
      .fit_table(5).set_subhead("Shift")
      .fit_table(5).set_sb3head("/esd")
      .fit_table(6).set_heading("Max.")
      .fit_table(6).set_subhead("Shift")
      .fit_table(6).set_sb3head("param")
      .fit_table(7).set_heading("No. of")
      .fit_table(7).set_subhead("params")
      .fit_table(8).set_heading("No. of")
      .fit_table(8).set_subhead("eig's")
      .fit_table(8).set_sb3head("near 0")

      ! Table widths (needs to be here because of label width)
      .fit_table(1).set_width_from(.max_iterations) ! Iter
      .fit_table(2).set_width_from(TEN**3)          ! chi2
      .fit_table(3).set_width_from(ONE)             ! R
      .fit_table(4).set_width_from(ONE)             ! Rw
      .fit_table(5).set_width_from(TEN*TEN)         ! Max shift/esd
      .fit_table(6).set_width_from(labels)          ! Max shift par
      .fit_table(7).set_width(3)                    ! n_param
      .fit_table(8).set_width(3)                    ! n_near_0

   end

   initialize_refinement_data(n_p,labels) ::: leaky
   ! Create the refinement data arrays & initialize if needed
   ! "n_p" is the number of unique pADP's to refine.
      n_p :: INT, IN
      labels :: VEC{STR}, IN

   ENSURE(.ref_iteration==0,"ref_iteration is not 0!")

      ! Destroy existing data (leaky)
      .destroy_refinement_data
      .set_refinement_data

      ! Initially chi^2 is as big as you can get
      .chi2_ref0 = huge(ONE)

      ! Create parameter vectors (leaky)
      .X_ref.create(n_p)
      .X_ref0.create(n_p)

      ! Refinement table headings
      .ref_table.create(10)
      .ref_table(1).set_heading("Ref.")
      .ref_table(1).set_subhead("Iter")
      .ref_table(2).set_heading("No of")
      .ref_table(2).set_subhead("  Fit")
      .ref_table(2).set_sb3head("iters")
      .ref_table(3).set_heading("chi2")
      .ref_table(3).set_subhead("initial")
      .ref_table(4).set_heading("chi2")
      .ref_table(4).set_subhead("final")
      .ref_table(5).set_heading("R")
      .ref_table(6).set_heading("R_w")
      .ref_table(7).set_heading("Max.")
      .ref_table(7).set_subhead("Shift")
      .ref_table(7).set_sb3head(" /esd")
      .ref_table(8).set_heading("Max.")
      .ref_table(8).set_subhead("Shift")
      .ref_table(8).set_sb3head("param")
      .ref_table(9).set_heading("No. of")
      .ref_table(9).set_subhead("params")
      .ref_table(10).set_heading("No. of")
      .ref_table(10).set_subhead("eig's")
      .ref_table(10).set_sb3head("near 0")

      ! Table widths (needs to be here because of label width)
      .ref_table(1).set_width_from(.max_iterations) ! Iter
      .ref_table(2).set_width_from(.max_iterations) ! # of fit iters
      .ref_table(3).set_width_from(TEN**3)          ! chi2 initial
      .ref_table(4).set_width_from(TEN**3)          ! chi2 final
      .ref_table(5).set_width_from(ONE)             ! R
      .ref_table(6).set_width_from(ONE)             ! Rw
      .ref_table(7).set_width_from(TEN*TEN)         ! Max shift/esd
      .ref_table(8).set_width_from(labels)          ! Max shift par
      .ref_table(9).set_width(3)                    ! n_param
      .ref_table(10).set_width(3)                    ! n_param

   end

!  Fit/refinement: Normal equations

   solve_normal_equations(dFdX) ::: leaky
   ! Get the ".dX" in some parameter vector by solving the normal
   ! equations, given "dFdX", the derivatives of the absolute
   ! structure factors w.r.t. those parameters. Also set:
   ! For the refinement against F^2 dFdX contains the derivatives
   ! of F^2 w.r.t. the parameters.
   ! * the ".covariance_matrix"
   ! * the ".correlation_matrix"
   ! * ".n_near_0", the no of eigenvalues of the LSM nearly equal
   !   to zero (as determined by ".tol_near_0").
   ! * ".eval_near_0" and ".evec_near_0", the eigenvalues and
   !   eigenvectors of the LSM nearly equal to zero
      self :: INOUT
      dFdX :: MAT{REAL}, IN

      ! Solve the normal equations
      if (.refine_F) then; .solve_F_normal_equations(dFdX)
      else;                .solve_I_normal_equations(dFdX)
      end

   end

   solve_F_normal_equations(dFdX) ::: leaky
   ! Get the ".dX" in some parameter vector by solving the F-normal
   ! equations, given "dFdX", the derivatives of the absolute
   ! structure factors w.r.t. those parameters.
      self :: INOUT
      dFdX :: MAT{REAL}, IN

   ENSURE(.reflections.associated,"no reflection data")
   ENSURE(.reflections.have_F_pred, "no predicted structure factors")
   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dFdX")
   ENSURE(dFdX.dim2==.dX.dim, "incompatible .dX and dFdX")

      A,dF :: MAT{REAL}*
      rhs,sig,del, eval :: VEC{REAL}*
      n_refl,n_p,i,j :: INT
    ! fac :: REAL
    ! table :: VEC{TABLE_COLUMN}*

      ! Constants
      n_refl = .reflections.n_refl
      n_p    = dFdX.dim2

      ! Arrays
      A.create(n_p,n_p)
      rhs.create(n_p)
      del.create(n_refl)
      dF.create(n_refl,n_p)
      sig.create(n_refl)

      ! Make derivatives of F_pred
      .d_F_pred_dX(dF,sig,del,dFdX)

      ! Checked using FD, setting optimize extinction
      ! and optimize scale OFF
      if (.debugging("solve_normal_equations")) then
         stdout.text("dF:")
         stdout.put(dF)
      end

      ! Make the normal matrix
      do i = 1,n_p
      do j = 1,n_p
         A(i,j) = sum(sig*dF(:,i)*dF(:,j))
      end
      end
      sig.destroy

      ! Make the rhs
      do i = 1,n_p
         rhs(i) = sum(del*dF(:,i))
      end

      dF.destroy
      del.destroy

      if (.debugging("solve_normal_equations")) then
         stdout.text("A:")
         stdout.put(A)
         stdout.text("rhs:")
         stdout.put(rhs)
      end

      ! Solve for the shifts .dX (leaky)
      A.solve_ill_linear_equations(rhs,.dX,.tol_near_0,.n_near_0 &
                                  ,.near_0_eigenvalues,.near_0_eigenvectors,eval &
                                  ,.covariance_matrix,.correlation_matrix)

      if (.debugging("solve_normal_equations")) then
         stdout.text("shifts:")
         stdout.put(.dX)
         stdout.set_real_style("e")
         stdout.show("Normal equations check =",maxval(abs(matmul(A,.dX)-rhs)))
         stdout.show("Smallest eigenvalue    =",minval(abs(.near_0_eigenvalues)))
         stdout.show("tol_near_0             =",.tol_near_0)
         stdout.show("n_near_0               =",.n_near_0)
         stdout.flush
         stdout.set_real_style("f")
         stdout.text("Distribution of values:")
       ! table.put_log_table(eval,.tol_near_0)
         if (.n_near_0>0) then
         stdout.set_real_style("e")
         stdout.flush
         stdout.text("All eigenvalues:")
         stdout.put(eval,by_column=TRUE)
         stdout.flush
         stdout.text("Near_0 eigenvalues:")
         stdout.put(.near_0_eigenvalues,by_column=TRUE)
         stdout.set_real_style("f")
         stdout.flush
         stdout.text("Near_0 eigenvectors:")
         stdout.put(.near_0_eigenvectors)
         end
      end
      
      eval.destroy

      ! Get the maximum shift
      where (abs(.dX)<DIFFRACTION_DATA_SMALLEST_SHIFT) 
         .dX = ZERO
      end
      .max_shift = maxval(abs(.dX))

      ! Set the number of parameters
      .n_param = n_p - .n_0 - .n_near_0

      ! Update chi2
      .update_n_param_and_chi2

      ! Set the full covariance matrix
      .covariance_matrix = .chi2*.covariance_matrix

      if (.debugging("solve_normal_equations:cov")) then
         stdout.text("shifts after zeroing:")
         stdout.put(.dX)
         stdout.show("chi2  = ",.chi2)
         stdout.text("covariance matrix:")
         stdout.put(.covariance_matrix)
      end

      ! Set the fit errors e.g. max(.dX/esd)
      ! Parameter ordering is unique fragment atom order.
      .update_fit_esds

      rhs.destroy
      A.destroy

      if (.debugging("solve_normal_equations")) then
         stdout.text("shifts before renormalisation:")
         stdout.put(.dX)
      end

      ! Renormalise shift if too big
    ! if (.max_shift>.max_allowed_param_shift) then
    !    fac = .max_allowed_param_shift/.max_shift
    !    .dX = fac * .dX
    ! end

    ! if (.debugging("solve_normal_equations")) then
    ! stdout.text("shifts after renormalisation:")
    ! stdout.put(.dX)
    ! end

   end

   solve_I_normal_equations(dIdX) ::: leaky
   ! Get the ".dX" in some parameter vector by solving the F-normal
   ! equations, given "dFdX", the derivatives of the square absolute
   ! structure factors w.r.t. those parameters.
      dIdX :: MAT{REAL}, IN

   ENSURE(.reflections.associated,"no reflection data")
!   ENSURE(.reflections.have_F_pred, "no predicted structure factors")
   ENSURE(.reflections.have_I_pred, "no predicted structure factors")
   ENSURE(.reflections.have_I_exp, "no experimental structure factors")
   ENSURE(.reflections.have_I_sigma, "no structure factor errors")
   ENSURE(dIdX.dim1==.reflections.n_refl, "wrong size, dFdX")
   ENSURE(dIdX.dim2==.dX.dim, "incompatible .dX and dIdX")

      A,dI :: MAT{REAL}*
      rhs,sig,del, eval :: VEC{REAL}*
      n_refl,n_p,i,j :: INT

      ! Constants
      n_refl = .reflections.n_refl
      n_p    = dIdX.dim2

      ! Arrays
      A.create(n_p,n_p)
      rhs.create(n_p)
      del.create(n_refl)
      dI.create(n_refl,n_p)
      sig.create(n_refl)

      ! Make derivatives of I_pred
      .d_I_pred_dX(dI,sig,del,dIdX)

      ! Checked using FD, setting optimize extinction
      ! and optimise scale OFF
      if (.debugging("solve_normal_equations")) then
      stdout.text("dI:")
      stdout.put(dI)
      end

      ! Make the normal matrix
      do i = 1,n_p
      do j = 1,n_p
         A(i,j) = sum(sig*dI(:,i)*dI(:,j))
      end
      end
      sig.destroy

      ! Make the rhs
      do i = 1,n_p
         rhs(i) = sum(del*dI(:,i))
      end

      dI.destroy
      del.destroy

      if (.debugging("solve_normal_equations")) then
      stdout.text("A:")
      stdout.put(A)
      stdout.text("rhs:")
      stdout.put(rhs)
      end

      ! Solve for the shifts .dX (leaky)
      eval.create(n_p)
      A.solve_ill_linear_equations(rhs,.dX,.tol_near_0,.n_near_0 &
                                  ,.near_0_eigenvalues,.near_0_eigenvectors,eval &
                                  ,.covariance_matrix,.correlation_matrix)

      if (.debugging("solve_normal_equations")) then
      stdout.text("shifts:")
      stdout.put(.dX)
      stdout.show("Normal equations check =",maxval(abs(matmul(A,.dX)-rhs)))
      stdout.show("Smallest eigenvalue    =",minval(abs(.near_0_eigenvalues)))
      stdout.show("tol_near_0             =",.tol_near_0)
      stdout.show("n_near_0               =",.n_near_0)
      if (.n_near_0>0) then
      stdout.text("Near_0 eigenvalues:")
      stdout.put(.near_0_eigenvalues,by_column=TRUE)
      end
      end

      eval.destroy

      ! Get the maximum shift
      where (abs(.dX)<DIFFRACTION_DATA_SMALLEST_SHIFT) 
         .dX = ZERO
      end
      .max_shift = maxval(abs(.dX))

      ! Set the number of parameters
      .n_param = n_p - .n_near_0

      ! Update chi2
      .update_n_param_and_chi2

      ! Set the full covariance matrix
      .covariance_matrix = .chi2*.covariance_matrix

      ! Set the fit errors e.g. max(.dX/esd)
      ! Parameter ordering is unique fragment atom order.
      .update_fit_esds

      rhs.destroy
      A.destroy

      if (.debugging("solve_normal_equations")) then
      stdout.text("shifts before renormalisation:")
      stdout.put(.dX)
      end

      ! Renormalise shift if too big
    ! if (.max_shift>.max_allowed_param_shift) then
    !    fac = .max_allowed_param_shift/.max_shift
    !    .dX = fac * .dX
    ! end

    ! if (.debugging("solve_normal_equations")) then
    ! stdout.text("shifts after renormalisation:")
    ! stdout.put(.dX)
    ! end

   end

   update_fit_esds
   ! Set the esd's for the current fit.
   ! WARNING: The order of the parameters is not always the same
   ! between calls of this routine. You *must* call this if the
   ! covariance matrix has been transformed from a unique-fragment
   ! atom ordering to asymmetric-unit ordering.

   ENSURE(.covariance_matrix.associated,"no covariance_matrix")
   ENSURE(.esd.associated,"no esd")
   ENSURE(.dX.associated,"no dX")
   ENSURE(.esd.dim==.covariance_matrix.dim1,"esd, covariance_mx mismatch")
   ENSURE(.esd.dim==.dX.dim,                "esd, dX mismatch")

      indmax,p :: INT
      dX,val,valmax :: REAL
      W :: VEC{REAL}*

      ! Set variances
      .covariance_matrix.put_diagonal_to(.esd)

      if (.debugging("update_fit_esds:variances")) then
         stdout.text("variances:")
         stdout.put(.esd,by_column=TRUE)
      end

      ! Set ESD's
      .esd = sqrt(.esd)

      if (.debugging("update_fit_esds")) then

         stdout.text("esd:")
         stdout.put(.esd,by_column=TRUE)

         stdout.text("dX:")
         stdout.put(.dX,by_column=TRUE)

         W.create(.esd.dim)
         where (abs(.esd)<DIFFRACTION_DATA_SMALLEST_SHIFT); W = ZERO
         elsewhere;                                         W = .dX/.esd
         end
         stdout.text("dX/esd:")
         stdout.put(W,by_column=TRUE)
         W.destroy

      end

      ! Get the location of the maximum shift on esd
      indmax = 1
      valmax = ZERO
      do p = 1,.esd.dim

         dX  = .dX(p)
         val = .esd(p)

         ! Ignore symmetry zero's
         ! WARNING: don't know if this is right
         if (abs(val)<DIFFRACTION_DATA_SMALLEST_SHIFT) cycle
         if (abs(dX )<DIFFRACTION_DATA_SMALLEST_SHIFT) cycle

         ! Shift on esd
         val = abs(.dX(p)/val)

         ! Set shift on esd if larger ...
         if (val<=valmax) cycle
         valmax = val
         indmax = p

      end

      ! Assign maximum index
      .max_shift_on_esd_ind = indmax
      .max_shift_on_esd     = valmax

      ! Debug
      if (.debugging("update_fit_esds")) then
         stdout.show("max_shift_on_esd_ind  =",indmax)
         stdout.show("max_shift_on_esd      =",valmax)
      end

   end

   update_refinement_ESDs
   ! Update the esd's for the current fit.
   ! NOTE: must have updated X_ref and X_ref0

   ENSURE(.covariance_matrix.associated,"no covariance_matrix")
   ENSURE(.esd.associated,"no esd")
   ENSURE(.dX.associated, "no dX")
   ENSURE(.esd.dim==.covariance_matrix.dim1,"esd, covariance_mx mismatch")
   ENSURE(.esd.dim==.dX.dim,                "esd, dX mismatch")
   ENSURE(.X_ref.associated, "no X_ref")
   ENSURE(.X_ref0.associated,"no X_ref0")

      n_p,indmax,p,n :: INT
      val,valmax,valsum :: REAL
      dX :: VEC{REAL}*

      ! Constants
      n_p = .esd.dim

      ! Set the change in paramters between fits
      dX.create(n_p)
      dX = .X_ref - .X_ref0

      ! Get the location of the maximum shift on esd
      n = 0
      indmax = DIFFRACTION_DATA_INDMAX_INIT
      valmax = ZERO
      valsum = ZERO
      do p = 1,n_p

         val = .esd(p)
         if (val==ZERO) cycle

         val = abs(dX(p)/val)

         n      = n + 1
         valsum = valsum + val

         if (val<=valmax) cycle

         valmax = val
         indmax = p

      end

      ! Assign maximum index
    ! DIE_IF(indmax==0,"no maximum index found!")
      .max_refshift_on_esd_ind = indmax
      .ave_refshift_on_esd     = valsum/n
      .max_refshift_on_esd     = valmax

      ! Debug
      if (.debugging("update_refinement_errors")) then
      stdout.show("max_refshift_on_esd_ind  =",indmax)
      stdout.show("max_refshift_on_esd      =",valmax)
      .max_refshift_on_esd     = valmax
      stdout.text(".esd:")
      stdout.put(.esd,by_column=TRUE)
      end

      ! Clean
      dX.destroy

   end

   d_F_pred_dX(res,sig,del,dFdX) ::: PURE
   ! Evaluate "res", the derivative of the F_pred with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the absolute structure factors  w.r.t. the X
   ! parameters. Includes derivatives w.r.t. the scale factor, but
   ! extinction is treated as a constant and should be OFF for exact
   ! results. Also makes "sig" and "del" required for the normal
   ! equations.
      self :: IN
      res :: MAT{REAL}, OUT
      sig,del :: VEC{REAL}, OUT
      dFdX :: MAT{REAL}, IN

   ENSURE(.reflections.associated,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
   ENSURE( del.dim1==.reflections.n_refl, "wrong size, del")
   ENSURE( res.dim1==.reflections.n_refl, "wrong size, res")
   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dF")
   ENSURE(dFdX.dim2==res.dim2, "incompatible res, dFdX")

      ref :: REFLECTION
      Ft,Fx,dt,db,ext,angle_bit,d_scale :: VEC{REAL}*
      top,bot,extn,F_exp,F_sig,F_abs,F_til,sig2,F_es2,F_ts2,fac,dsp,ext4,dX,val1,val2,dF :: REAL
      n_refl,n_p,p,n :: INT

      ! Constants
      n_refl = .reflections.n_refl
      n_p = dFdX.dim2

      ! Temporaries
      Ft.create(n_refl)
      Fx.create(n_refl)
      dt.create(n_refl)
      db.create(n_refl)

      ! Extinction factor part
      ext.create(n_refl)
      ext = .F_extinction_correction(ONE,.extinction_factor)

      ! Angle bit, extinction factor folded in
      angle_bit.create(n_refl)
      angle_bit = .extinction_factor*.extinction_angle_part

      ! Make temporaries for derivative of scale, extinction, F_abs
      top = ZERO
      bot = ZERO

      do n = 1,n_refl

         extn   = ext(n)
         ref    = .reflections(n)

         F_exp  = ref.F_exp
         F_sig  = ref.F_sigma
         F_abs  = abs(ref.F_calc)
         F_til  = extn*F_abs
         sig2   = ONE/(F_sig*F_sig)

         F_es2  = F_exp*sig2
         F_ts2  = F_til*sig2

         top    = top + F_til*F_es2
         bot    = bot + F_til*F_ts2

         ext4   = extn*extn
         ext4   = ext4*ext4
         dX     = -HALF*ext4*angle_bit(n)*F_abs
         dX     = ONE + F_abs*dX

         dt(n)  = F_es2*extn*dX
         db(n)  = extn*F_ts2*dX
         Ft(n)  = F_til
         Fx(n)  = .scale_factor*extn*dX

         ! Return these
         sig(n) = sig2
         del(n) = (F_exp - ref.F_pred)*sig2

      end

      angle_bit.destroy
      ext.destroy

    ! stdout.text("db:")
    ! stdout.put(db)

    ! stdout.text("dt:")
    ! stdout.put(dt)

    ! stdout.text("Ft:")
    ! stdout.put(Ft)

    ! stdout.text("Fx:")
    ! stdout.put(Fx)

    ! stdout.text("sig:")
    ! stdout.put(sig)

    ! stdout.text("del:")
    ! stdout.put(del)

    ! stdout.show("top = ",top)
    ! stdout.show("bot = ",bot)

    ! stdout.text("dFdX:")
    ! stdout.put(dFdX)

      ! Derivative of the scale factor
      d_scale.create(n_p)
      bot = ONE/bot
      fac = -TWO*top*bot*bot
      do p = 1,n_p
         val1 = ZERO
         val2 = ZERO
         do n = 1,n_refl
            dF = dFdX(n,p)
            val1 = val1 + dt(n)*dF
            val2 = val2 + db(n)*dF
         end
         d_scale(p) = bot*val1 + fac*val2
      end

      db.destroy
      dt.destroy

    ! stdout.text("d_scale:")
    ! stdout.put(d_scale)

      ! Derivative of F_pred or F^m
      do p = 1,n_p
         dsp = d_scale(p)
         do n = 1,n_refl
            res(n,p) = dsp*Ft(n) + Fx(n) * dFdX(n,p)
         end
      end

    ! stdout.text("res:")
    ! stdout.put(res)

      ! Clean up
      d_scale.destroy
      Fx.destroy
      Ft.destroy

   end

   d_I_pred_dX(res,sig,del,dIdX)
   ! Evaluate "res", the derivative of the I_pred with respect to some
   ! parameters X (e.g. thermal parameters) given "dIdX", the
   ! derivatives of the square absolute structure factors  w.r.t. the X
   ! parameters. Includes derivatives w.r.t. the scale factor, but
   ! extinction is treated as a constant and should be OFF for exact
   ! results. Also makes "sig" and "del" required for the normal
   ! equations.
      res :: MAT{REAL}, OUT
      sig,del :: VEC{REAL}, OUT
      dIdX :: MAT{REAL}, IN

   ENSURE(.reflections.associated,"no reflection data")
   ENSURE(.reflections.have_I_calc, "no calculated structure factors")
   ENSURE(.reflections.have_I_exp, "no experimental structure factors")
   ENSURE(.reflections.have_I_sigma, "no structure factor errors")
   ENSURE( del.dim1==.reflections.n_refl, "wrong size, del")
   ENSURE( res.dim1==.reflections.n_refl, "wrong size, res")
   ENSURE(dIdX.dim1==.reflections.n_refl, "wrong size, dF")
   ENSURE(dIdX.dim2==res.dim2, "incompatible res, dFdX")

      ref :: REFLECTION*
      It,dt,db,d_scale :: VEC{REAL}*
      I_clc,top,bot,I_exp,I_sig,sig2,I_es2,I_ts2,fac,dsp,val1,val2,dI :: REAL
      n_refl,n_p,p,n :: INT

      ! Constants
      n_refl = .reflections.n_refl
      n_p = dIdX.dim2

      ! Temporaries
      It.create(n_refl)
      dt.create(n_refl)
      db.create(n_refl)


      ! Make temporaries for derivative of scale, extinction, F_abs
      top = ZERO
      bot = ZERO

      do n = 1,n_refl

         ref    => .reflections(n)

         I_exp  = ref.I_exp
         I_sig  = ref.I_sigma
         I_clc  = ref.I_calc
         sig2   = ONE/(I_sig*I_sig)

         I_es2  = I_exp*sig2
         I_ts2  = I_clc*sig2

         top    = top + I_clc*I_es2
         bot    = bot + I_clc*I_ts2

         dt(n)  = I_es2
         db(n)  = I_ts2
         It(n)  = I_clc

         ! Return these
         sig(n) = sig2
         del(n) = (I_exp - ref.I_pred)*sig2

      end

      ! Derivative of the scale factor
      d_scale.create(n_p)
      bot = ONE/bot
      fac = -TWO*top*bot*bot
      do p = 1,n_p
         val1 = ZERO
         val2 = ZERO
         do n = 1,n_refl
            dI = dIdX(n,p)
            val1 = val1 + dt(n)*dI
            val2 = val2 + db(n)*dI
         end
         d_scale(p) = bot*val1 + fac*val2
      end

      db.destroy
      dt.destroy

      ! Derivative of I_pred
      do p = 1,n_p
         dsp = d_scale(p)
         do n = 1,n_refl
            res(n,p) = dsp*It(n) + .scale_factor * dIdX(n,p)
         end
      end

      ! Clean up
      d_scale.destroy
      It.destroy
   end

   d_F_abs_dX(res,dFdX)
   ! Evaluate "res", the derivative of the F_abs with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the *complex* structure factors  w.r.t. the X
   ! parameters.
      res :: MAT{REAL}, OUT
      dFdX :: MAT{CPX}, IN

   ENSURE(.reflections.associated,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE( res.dim1==.reflections.n_refl, "wrong size, res")
   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dFdX")
   ENSURE(dFdX.dim2==res.dim2, "incompatible res, dFdX")

      F_con :: VEC{CPX}*
      F_abi :: VEC{REAL}*
      F_cal :: CPX
      n_refl,n_p,p,n :: INT

      n_refl = .reflections.n_refl
      n_p = dFdX.dim2

      F_con.create(n_refl)
      F_abi.create(n_refl)

      do n = 1,n_refl
         F_cal    = .reflections(n).F_calc
         F_con(n) = conjg(F_cal)
         F_abi(n) = ONE/abs(F_cal)
      end

      do p = 1,n_p
      do n = 1,n_refl
         res(n,p) = F_abi(n) * REALIFY(F_con(n) * dFdX(n,p))
      end
      end

      F_abi.destroy
      F_con.destroy

   end

   d_F_abs_2_dX(res,dFdX)
   ! Evaluate "res", the derivative of the F_abs_2 with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the *complex* structure factors  w.r.t. the X
   ! parameters.
      res :: MAT{REAL}, OUT
      dFdX :: MAT{CPX}, IN

   ENSURE(.reflections.associated,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE( res.dim1==.reflections.n_refl, "wrong size, res")
   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dFdX")
   ENSURE(dFdX.dim2==res.dim2, "incompatible res, dFdX")

      F_con :: VEC{CPX}*   !conjugated structure factors
      F_cal :: CPX         !calculated structure factors
      n_refl,n_p,p,n :: INT

      n_refl = .reflections.n_refl
      n_p = dFdX.dim2

      F_con.create(n_refl)

      do n = 1,n_refl
         F_cal    = .reflections(n).F_calc
         F_con(n) = conjg(F_cal)
      end

      do p = 1,n_p
      do n = 1,n_refl
         res(n,p) = TWO * REALIFY(F_con(n) * dFdX(n,p))
      end
      end

      F_con.destroy

   end

!  Fit/refinement iteration control

   update_fit_parameters
   ! Update i.e. increment the fit parameters
      self :: INOUT

      ! Next iteration
      .fit_iteration = .fit_iteration + 1

      ! Save and increment parameters
      .X_fit0 = .X_fit
      .X_fit  = .X_fit + .dX

   end

   update_refinement_parameters
   ! Update the refinement parameters
      self :: INOUT

      ! Increment
      .ref_iteration = .ref_iteration + 1

      ! Transfer parameters
      .X_ref0 = .X_ref ! From previous or 1st iteration
      .X_ref  = .X_fit ! This iteration

   end

!  Fit/refinement iteration control


   fit_finished result (res)
   ! Return whether the (rigid) HA refinement has finished
      self :: INOUT
      res :: BIN

      ! Converged?
      .fit_converged = .max_shift_on_esd<.tol_for_shift_on_esd &
                       AND .fit_iteration>=.min_iterations

      ! chi2 inceased?
      .chi2_increased = .chi2_fit>.chi2_fit0 AND .fit_iteration>.min_iterations

      ! Roll back the parameters is chi2 increases
      ! WARNING: covariances are not rolled back ...
    ! if (.chi2_increased) then
    !    .X_fit    = .X_fit0
    !    .chi2_fit = .chi2_fit0
    ! end

      ! Too many fit iterations?
      .too_many_fit_iterations = .fit_iteration>.max_iterations

      ! Set finished
      res = .fit_converged OR .chi2_increased OR .too_many_fit_iterations

      ! If refining, store initial & final chi2
      if (.refine_structure) then
         if (.fit_iteration==1) .chi2_ref0 = .chi2_fit ! Store initial chi2
         if (res)               .chi2_ref  = .chi2_fit ! Stoire final chi2
      end

      ! Fix the number of parameters
      if (res) .n_param_manually_set = TRUE

   end

   refinement_finished result (res)
   ! Return whether the refinement has finished
      self :: INOUT
      res :: BIN

      ! Has fit finished?
      .refinement_converged = .max_refshift_on_esd<.tol_for_shift_on_esd &
                            AND .ref_iteration>=.min_iterations

      ! chi2 inceased?
      .chi2_increased = .chi2_ref > .chi2_ref0 + TOL(2)

      ! Too many refinement iterations?
      .too_many_ref_iterations = .ref_iteration>.max_iterations

      ! Set finished; finish also if chi2 increases 
      res = .refinement_converged OR .chi2_increased OR .too_many_ref_iterations

   end

!  Fit/refinement output

   put_fit_header ::: selfless
   ! Put the fit header

      stdout.flush
      stdout.text("===================================")
      stdout.text("Crystal structure fit (rigid atoms)")
      stdout.text("===================================")
      stdout.flush
      stdout.text("A single SCF/rigid hirshfeld atom fit is performed.")
      stdout.flush
      stdout.text("Consider non-rigid hirshfeld_atom_refinement instead.")

   end

   put_refinement_header ::: selfless
   ! Put the fit header

      stdout.flush
      stdout.text("==============================================")
      stdout.text("Crystal structure refinement (non-rigid atoms)")
      stdout.text("==============================================")
      
      stdout.flush
      stdout.text("Repeated SCF/rigid hirshfeld atom fits are performed")
      stdout.text("which eventually removes the rigid atom constraint.")
      
      stdout.flush
      stdout.text("Agreement statistics are shown at the start and end")
      stdout.text("of each 'micro' rigid fit cycle.")
      
      stdout.flush
      stdout.text("Convergence criteria for each fit-cycle are the same")
      stdout.text("as for convergence of the overall refinement")

   end

   put_refinement_switches
   ! Put the fit/refinement switches
      self :: IN

      list :: STR

      stdout.flush
      if (.use_KM_atoms) then
      stdout.text("Koritsanszky-Michael atom refinement")
      end
   
      stdout.flush
      stdout.show("Refine hydrogen ADP's       =",.refine_H_ADPs)
      stdout.show("Refine hydrogen U_iso       =",.refine_H_U_iso)
      stdout.show("Refine only ADP's           =",.refine_ADPs_only)
      stdout.show("Refine only positions       =",.refine_positions_only)
   
      if (.refine_anharmonicity) then
      stdout.flush
      stdout.show("Refine anharmonicity        =",TRUE)
      stdout.show("Refine 4th order only?      =",.refine_4th_order_only)
      list = .refine_4th_order_for_atom.to_concatenated_str
      stdout.show("Anharmonic atoms            =",trim(list))
      end
   
      stdout.flush
      stdout.show("Refine scale factor         =",.optimize_scale)
      stdout.show("Refine multiple scales      =",.use_multiple_scale_factors)
      stdout.show("Refine extinction parameter =",.optimize_extinction)
      stdout.show("Use dispersion correction   =",.correct_dispersion)
   
      stdout.flush
      stdout.show("Max allowed parameter shift =",.max_allowed_param_shift)
      stdout.show("Max iterations              =",.max_iterations)
      stdout.show("Min iterations              =",.min_iterations)
   
      stdout.flush
      stdout.show("Conv. tol. for shift on esd =",.tol_for_shift_on_esd)
      stdout.show("Nearly zero tolerance       =",.tol_near_0)

   end

   put_fit_table_headings
   ! Put the fit table header
      self :: IN

      stdout.flush
      stdout.text("====================")
      stdout.text("Begin rigid-atom fit")
      stdout.text("====================")
      stdout.flush
      
      ! Put table headings
      .fit_table.put_headings

   end

   put_refinement_table_headings
   ! Put the refinement table header
      self :: IN

      stdout.flush
      stdout.text("================")
      stdout.text("Begin refinement")
      stdout.text("================")
      stdout.flush
      
      ! Put table headings
      .ref_table.put_headings

   end

   put_fit_table_body
   ! Print the current iterations results
      self :: IN

      ! Set table body (leaky)
      .fit_table(1).create_values([.fit_iteration])
      .fit_table(2).create_values([.chi2_fit])
      .fit_table(3).create_values([.F_r_factor])
      .fit_table(4).create_values([.F_weighted_r_factor])
      .fit_table(5).create_values([.max_shift_on_esd])
      .fit_table(6).create_values([.max_shift_on_esd_par])
      .fit_table(7).create_values([.n_param])
      .fit_table(8).create_values([.n_near_0])
      
      ! Put out the body
      .fit_table.put_body
      
      ! Clear thje columns for next time (UNleaky!)
      .fit_table.clear_columns

   end

   put_refinement_table_body
   ! Print the current iterations results
      self :: IN

      ! Set table body (leaky)
      .ref_table(1).create_values([.ref_iteration])
      .ref_table(2).create_values([.fit_iteration])
      .ref_table(3).create_values([.chi2_ref0])
      .ref_table(4).create_values([.chi2_ref])
      .ref_table(5).create_values([.F_r_factor])
      .ref_table(6).create_values([.F_weighted_r_factor])
      .ref_table(7).create_values([.max_refshift_on_esd])
      .ref_table(8).create_values([.max_refshift_on_esd_par])
      .ref_table(9).create_values([.n_param])
      .ref_table(10).create_values([.n_near_0])
      
      ! Put out the body
      .ref_table.put_body
      
      ! Clear thje columns for next time (UNleaky!)
      .ref_table.clear_columns

   end

   put_fit_results
   ! Put the fit results
      self :: IN

      ! Results
      stdout.flush
      stdout.text("======================")
      stdout.text("Rigid-atom fit results")
      stdout.text("======================")
      stdout.flush
      
      ! Print how it finished
      if      (.fit_converged)            then; stdout.text("Structure fit converged.")
      else if (.chi2_increased)           then; stdout.text("WARNING: fit stopped: chi2 has increased.")
                                                stdout.text("WARNING: fit results are unreliable.")
      else if (.too_many_fit_iterations)  then; stdout.text("WARNING: fit stopped: too many iterations.")
      end
      
      ! Put final fitting statistics
      .put_F_statistics

   end

   put_refinement_results
   ! Put the refinement results
      self :: IN

      ! Results
      stdout.flush
      stdout.text("============================")
      stdout.text("Structure refinement results")
      stdout.text("============================")
      stdout.flush
      
      ! Print how it finished
      if      (.refinement_converged)     then; stdout.text("Structure refinement converged.")
      else if (.chi2_increased)           then; stdout.text("WARNING: refinement stopped: chi2 has increased.")
      else if (.too_many_ref_iterations)  then; stdout.text("WARNING: refinement stopped: too many iterations.")
      end
      
      ! Put final fitting statistics
      .put_F_statistics

   end

   put_near_0_eigenvectors(n_p)
   ! Put the near zero (linearly dependent) parameter eigenvectors
      self :: IN
      n_p :: INT, IN

         stdout.flush
         stdout.text("=======================================")
         stdout.text("Near 0 eigenvalues of the normal matrix")
         stdout.text("=======================================")
         stdout.flush
         stdout.show("No. of redundant parameters   =",n_p)
         stdout.show("No. of unique parameters      =",.n_param)
         stdout.flush
         stdout.show("Near-zero tolerance           =",.tol_near_0)
         stdout.show("No. of near-zero eigenvalues  =",.n_near_0)


      if (.near_0_eigenvectors.associated) then
      if (.n_near_0>0) then

         stdout.flush
         stdout.text("Near-zero eigenvalues:")
         stdout.flush
         stdout.save
         stdout.set_real_style("e")
         stdout.put(.near_0_eigenvalues)
         stdout.unsave

         stdout.flush
         if (.n_near_0<=10 OR .display_near_0_eigenvectors) then
         stdout.text("Near-zero eigenvectors:")
         stdout.flush
         stdout.put(.near_0_eigenvectors)
         else
         stdout.text("Too many near-zero eigenvectors to write out")
         end

      end
      end

   end


!  ==============
!  Output methods
!  ==============

   put
   ! Put out the diffraction data to file "out"
      self :: IN

      stdout.flush
      stdout.text("================")
      stdout.text("Diffraction data")
      stdout.text("================")
      stdout.flush
      stdout.show("Data kind                     =",.data_kind)
      stdout.show("Wavelength                    =",.wavelength.to_units("angstrom"))
      stdout.show("Temperature                   =",.temperature)
      stdout.show("NKA T sequence no.            =",.NKA_T_sequence_no)
      stdout.flush
      stdout.show("F_sigma_cutoff                =",.F_sigma_cutoff)
      stdout.show("F_sigma_cutoff                =",.I_sigma_cutoff)
      stdout.show("F_z_cutoff                    =",.F_z_cutoff)
      stdout.show("I_z_cutoff                    =",.I_z_cutoff)
      stdout.show("F_calc_cutoff                 =",.F_calc_cutoff)
      stdout.show("F_pred_cutoff                 =",.F_pred_cutoff)
      stdout.show("I_pred_cutoff                 =",.I_pred_cutoff)
      stdout.show("stl_high_cutoff               =",.stl_high_cutoff)
      stdout.show("stl_low_cutoff                =",.stl_low_cutoff)
      stdout.show("stl_limit                     =",.stl_limit)
      stdout.show("show_rejects?                 =",.show_rejects)
      stdout.flush
      stdout.show("partition_model               =",.partition_model)
      stdout.show("thermal_smearing_model        =",.thermal_smearing_model)
      stdout.show("use_Voronoi_atoms?            =",.use_Voronoi_atoms)
      stdout.show("use_IAM_density?              =",.use_IAM_density)   
      stdout.show("use_IAM_ITC_FFs?              =",.use_IAM_ITC_FFs)   
      stdout.show("use_KM_atoms?                 =",.use_KM_atoms)   
      stdout.show("use_zero_overlap?             =",.use_zero_overlap)   
      stdout.flush
      stdout.show("optimize_scale?               =",.optimize_scale)
      stdout.show("scale_factor                  =",.scale_factor)
      stdout.show("optimize_extinction?          =",.optimize_extinction)
      stdout.show("extinction_factor             =",.extinction_factor)
      stdout.show("correct_dispersion?           =",.correct_dispersion)
      stdout.flush
      stdout.show("n_param                       =",.n_param)
      stdout.show("n_param_manually_set?         =",.n_param_manually_set)
      stdout.show("chi2                          =",.chi2)
      stdout.flush
      stdout.show("fit_structure?                =",.fit_structure)
      stdout.show("refine_structure?             =",.refine_structure)
      stdout.show("refine_F?                     =",.refine_F)
      stdout.show("refine_positions_only?        =",.refine_positions_only)
      stdout.show("refine_H_pos                  =",.refine_H_pos)  !test refine_H_pos Lorraine
      stdout.show("refine_ADPs_only?             =",.refine_ADPs_only)
      stdout.show("refine_H_ADPs?                =",.refine_H_ADPs)
      stdout.show("refine_H_U_iso?               =",.refine_H_U_iso)
      stdout.show("refine_anharmonicity?         =",.refine_anharmonicity)
      stdout.show("restart_HAR_with_promolecule? =",.restart_HAR_with_promolecule)
      stdout.show("XCW?                          =",.XCW)
      stdout.flush
      stdout.show("min_iterations                =",.min_iterations)
      stdout.show("max_iterations                =",.max_iterations)
      stdout.show("max_allowed_param_shift       =",.max_allowed_param_shift)
      stdout.show("tol_for_shift_on_esd          =",.tol_for_shift_on_esd)
      stdout.show("tol_near_0                    =",.tol_near_0)
      stdout.flush
      stdout.show("show_fit_output?              =",.show_fit_output)
      stdout.show("display_near_0_eigenvectors?  =",.display_near_0_eigenvectors)
      stdout.show("display_correlation_matrix?   =",.display_correlation_matrix)
      stdout.show("min_correlation               =",.min_correlation)
      stdout.flush
      stdout.show("fit_iteration                 =",.fit_iteration)
      stdout.show("chi2_fit                      =",.chi2_fit)
      stdout.show("chi2_fit0                     =",.chi2_fit0)
      stdout.show("max_shift                     =",.max_shift)
      stdout.show("max_shift_on_esd              =",.max_shift_on_esd)
      stdout.show("max_shift_on_esd_ind          =",.max_shift_on_esd_ind)
      stdout.show("max_shift_on_esd_par          =",.max_shift_on_esd_par)
      stdout.show("fit_converged?                =",.fit_converged)
      stdout.show("chi2_increased?               =",.chi2_increased)
      stdout.show("too_many_fit_iterations?      =",.too_many_fit_iterations)
      stdout.flush
      stdout.show("ref_iteration                 =",.ref_iteration)
      stdout.show("chi2_ref                      =",.chi2_ref)
      stdout.show("chi2_ref0                     =",.chi2_ref0)
      stdout.show("max_refshift                  =",.max_refshift)
      stdout.show("max_refshift_on_esd           =",.max_refshift_on_esd)
      stdout.show("ave_refshift_on_esd           =",.ave_refshift_on_esd)
      stdout.show("max_refshift_on_esd_ind       =",.max_refshift_on_esd_ind)
      stdout.show("max_refshift_on_esd_par       =",.max_refshift_on_esd_par)
      stdout.show("refinement_converged?         =",.refinement_converged)
      stdout.show("too_many_ref_iterations?      =",.too_many_ref_iterations)
      stdout.show("max_residual                  =",.max_residual)
      stdout.show("min_residual                  =",.min_residual)
      stdout.show("rms_residual                  =",.rms_residual)
      stdout.show("max_atom_residual             =",.max_atom_residual)
      stdout.show("min_atom_residual             =",.min_atom_residual)
      stdout.show("min_atom_residual_tag         =",.min_atom_residual_tag)
      stdout.show("rms_atom_residual             =",.rms_atom_residual)
      stdout.show("n_0                           =",.n_0)
      stdout.show("n_near_0                      =",.n_near_0)

      if (.reflections.associated) then
      stdout.flush
      stdout.text("===========")
      stdout.text("Reflections")
      stdout.text("===========")
      stdout.flush
      .put_reflection_data
      end

   end

   put_wavelength
   ! Put out the wavelength - for testing
      self :: IN

      stdout.show("DIFFRACTION_DATA wavelength =", .wavelength.to_units("angstrom"))
      stdout.show("REFLECTION       wavelength =", REFLECTION:wavelength()*ANGSTROM_PER_BOHR)

   end

   put_sin_theta_on_lambda
   ! Output sin(theta)/lambda for all reflections.
      self :: IN

   ENSURE(.reflections.associated,"No list of reflections")
   ENSURE(.reflections.have_indices,"No list of reflections")

      n :: INT

      stdout.text("sin(theta)/lambda for the reflections")
      stdout.dash(int_fields=3,real_fields=1)
      stdout.put("h",int_width=TRUE)
      stdout.put("k",int_width=TRUE)
      stdout.put("l",int_width=TRUE)
      stdout.put("stl")
      stdout.flush
      stdout.dash(int_fields=3,real_fields=1)
      do n=1,size(.reflections)
         stdout.put(.reflections(n).h)
         stdout.put(.reflections(n).k)
         stdout.put(.reflections(n).l)
         stdout.put(.reflections(n).stl)
         stdout.flush
      end
      stdout.dash(int_fields=3,real_fields=1)

   end

   put_F_statistics
   ! Output the structure factor goodness of fit statistics.
      self :: IN

      ! Show stats without chi2(N=1)
      .reflections.put_F_statistics(show_chi2=FALSE)

      ! No. of eflections/parameters
      stdout.show("# of reflections,    N_r       =", .reflections.n_refl)
      stdout.show("# of fit parameters, N_p       =", .n_param)

      ! GOF statistics
      stdout.show("chi^2(N_p)                     =", .chi2)
      stdout.show("Goodness of fit (N_p)          =", sqrt(.chi2))
      stdout.show("Effective (mean) sigma^2       =", .reflections.sigma2_eff)

      ! Extinction?
      if (.optimize_extinction) then;
      stdout.show("Secondary extinction factor    =", .extinction_factor)
      end

      ! Optimize scale
      if (.optimize_scale) then
      if (.use_multiple_scale_factors) then
      stdout.show("Scale factors                  =", .scale_factors)
      else
      stdout.show("Scale factor                   =", .scale_factor)
      end
      end

   end

   put_F_free_stats
   ! Output the structure factor goodness of fit statistics.
      self :: IN

      .reflections.put_F_free_stats

   end

   put_I_free_stats
   ! Output the intensity goodness of fit statistics
      self :: IN

      .reflections.put_I_free_stats
      .put_correction_data

   end

   put_correction_data
   ! Output the correction data
      self :: IN

      stdout.flush
      stdout.show("Using scale factor(s)          =", .optimize_scale)
      stdout.show("Using extinction               =", .optimize_extinction)
      stdout.show("Thermal smearing model         =", .thermal_smearing_model)
      stdout.show("Fragment partition model       =", .partition_model)
      stdout.show("Correct dispersion?            =", .correct_dispersion)

      if (.optimize_extinction) then;
      stdout.show("Optimize extinction            =", TRUE)
      stdout.show("Secondary extinction factor    =", .extinction_factor)
      else
      stdout.show("Optimize extinction            =", FALSE)
      end

      if (.optimize_scale) then

        if (.use_multiple_scale_factors) then
      stdout.show("Using multiple scale factors   =", TRUE)
      stdout.show("Scale factors                  =", .scale_factors)
        else
      stdout.show("Using single scale factor      =", TRUE)
      stdout.show("Scale factor                   =", .scale_factor)
        end

      else
      stdout.show("Optimize scale factor          =", FALSE)
      end

   end


   put_reflection_data
   ! Output the reflection data and corresponding fit statistic,
   ! if available
      self :: IN

      .put_N_worst_reflections

      .put_reflections

   end

   put_worst_reflections
   ! Put out a selection of the worst-fitting reflections
      self :: IN

      n :: INT

      if (stdin.n_line_items==2) then

         stdin.read(n)
         DIE_IF(n.is_odd,"must have an even number reflections")
         .put_N_worst_reflections(n)

      else

         .put_N_worst_reflections

      end

   end

   put_N_worst_reflections
   ! Put out a salection of the worst-fitting reflections
      self :: IN

   ENSURE(.reflections.associated,"no reflections")

      n_refl,n :: INT

      if (.have_F_pred) then
      if (.have_F_exp) then

         n_refl = .reflections.dim

         if (.n_worst_reflections<0) then

            ! Put out a reasonable no. of bad reflections
            if      (n_refl>1000) then; .put_N_worst_reflections(n=40)
            else if (n_refl>100)  then; .put_N_worst_reflections(n=20)
            else if (n_refl>50)   then; .put_N_worst_reflections(n=10)
            end

         else

            ! Make sure users no. of reflections is reasonable
            n = min(.n_worst_reflections,n_refl)
            n = 2 * (n/2)
            .put_N_worst_reflections(n)

         end

      end
      end

   end

   put_N_worst_reflections(n)
   ! Show the "n" worst reflections, with "n" even
      self :: IN
      n :: INT

   ENSURE(.reflections.associated,"No reflection data")
   ENSURE(.reflections.have_F_exp,"No experimental data")
   ENSURE(n.is_even,"no. of reflections n is not even")

      F_z :: VEC{REAL}*
      ind :: VEC{INT}*
      n_refl,n2 :: INT

      ! No. of old reflections
      n_refl = .reflections.n_refl
      if (n_refl<n) return
      n2 = n/2

      ! Get the F_z values
      F_z.create(n_refl)
      F_z = REFLECTION:F_z(.reflections)

      ! Sort
      ind.create(n_refl)
      F_z.quick_sort(ind,decreasing_order=TRUE)

      ! Header
      stdout.flush
      stdout.text("=================")
      stdout.text("Worst reflections")
      stdout.text("=================")
      stdout.flush
      stdout.text(". Below are the "//trim(n.to_str)//" worst-fitted reflections")
      stdout.text(". The criteria is F_z = (F_calc-F_pred)/sigma, in sigma units")
      stdout.text(". The full list of reflections is in the produced CIF file")
      stdout.flush

      ! Put worst from either end
      ind(n2+1:n) = ind(n_refl-n2+1:)
      .reflections(ind(1:n)).put

      ! Clean
      ind.destroy
      F_z.destroy

   end

   put_reflections
   ! Show all the reflections
      self :: IN

   ENSURE(.reflections.associated,"No reflection data")

      ! Header
      stdout.flush
      stdout.text("=================")
      stdout.text("X-ray reflections")
      stdout.text("=================")

      ! Put
      .reflections.put

   end


   put_reflection_intensities
   ! Show all the reflections
      self :: IN

   ENSURE(.reflections.associated,"No reflection data")

      ! Header
      stdout.flush
      stdout.text("=================")
      stdout.text("X-ray intensities")
      stdout.text("=================")

      ! Put
      .reflections.put_intensities

   end

   put_reflection_intensities_XD
   ! Show all the reflections
      self :: IN

   ENSURE(.reflections.associated,"No reflection data")

      ! Header
      stdout.flush
      stdout.text("=================")
      stdout.text("X-ray intensities")
      stdout.text("=================")

      ! Put
      .reflections.put_intensities_XD

   end


   put_qq_plot
   ! Output a qq plot to stdout.
   ! It is a plot of the experimental quantile vs expected quantile.
      self :: IN

   ENSURE(.reflections.associated, "no reflection data")

      .reflections.put_F_qq_plot

   end

   put_labelled_qq_plot
   ! Output a qq plot to stdout.
   ! It is a plot of the experimental quantile vs expected quantile.
      self :: IN

   ENSURE(.reflections.associated, "no reflection data")

      .reflections.put_labelled_F_qq_plot

   end


   put_GOF_vs_STL_table
   ! Output GOF and ratio vs. sin(theta)/lambda bins.
      self :: IN

      n_sections,i :: INT
      stl,bin,GOF,ratio,RF,RwF,RF2,RwF2, dF,Fexp,Fz,Feos :: VEC{REAL}*
      C :: VEC{INT}*
      X_min,X_max,X_bin :: REAL
      table :: VEC{TABLE_COLUMN}*

      n_sections = 20

      ! Sin theta on lambda
      stl.create(.reflections.dim)
      stl = REFLECTION:stl(.reflections)

      ! Bin size ...
      X_min = minval(stl)
      X_max = maxval(stl)
      X_bin = (X_max - X_min)/n_sections

      ! Sin theta on lambda bins array for table
      bin.create(n_sections)
      bin = [ (X_min + i*X_bin, i=1,n_sections) ]

      ! GOF
      GOF.create(n_sections)
      C.create(n_sections)
      GOF.to_histogram_from_data(REFLECTION:F_z2(.reflections),stl,X_min,X_max,X_bin,C)
      GOF = sqrt(GOF/max(C-.n_param,1))

      ! ratio
      ratio.create(n_sections)
      ratio.to_histogram_from_data(REFLECTION:F_ratio(.reflections),stl,X_min,X_max,X_bin)
      ratio = ratio/max(C,1)

      ! R(F)
      RF.create(n_sections)
      dF.create(n_sections)
      Fexp.create(n_sections)
        dF.to_histogram_from_data(REFLECTION:abs_delta_F(.reflections),stl,X_min,X_max,X_bin)
      Fexp.to_histogram_from_data(REFLECTION:F_exp(.reflections)      ,stl,X_min,X_max,X_bin)
      RF = dF/Fexp
      Fexp.destroy
      dF.destroy

      ! R(F2)
      RF2.create(n_sections)
      dF.create(n_sections)
      Fexp.create(n_sections)
        dF.to_histogram_from_data(REFLECTION:abs_delta_F2(.reflections),stl,X_min,X_max,X_bin)
      Fexp.to_histogram_from_data(REFLECTION:F2_exp(.reflections)      ,stl,X_min,X_max,X_bin)
      RF2 = dF/Fexp
      Fexp.destroy
      dF.destroy

      ! Rw(F)
      RwF.create(n_sections)
      Fz.create(n_sections)
      Feos.create(n_sections)
        Fz.to_histogram_from_data(REFLECTION:F_z2(.reflections)            ,stl,X_min,X_max,X_bin)
      Feos.to_histogram_from_data(REFLECTION:F_exp_on_sigma_2(.reflections),stl,X_min,X_max,X_bin)
      RwF = sqrt(Fz/Feos)
      Feos.destroy
      Fz.destroy

      ! Rw(F2)
      RwF2.create(n_sections)
      Fz.create(n_sections)
      Feos.create(n_sections)
        Fz.to_histogram_from_data(REFLECTION:F2_z2(.reflections)           ,stl,X_min,X_max,X_bin)
      Feos.to_histogram_from_data(REFLECTION:F_exp_on_sigma_4(.reflections),stl,X_min,X_max,X_bin)
      RwF2 = sqrt(Fz/Feos)
      Feos.destroy
      Fz.destroy

      ! Header
      stdout.flush
      stdout.text("========================")
      stdout.text("Fit statistics vs. angle")
      stdout.text("========================")
      stdout.flush
      stdout.text("An analysis of the fit versus sin(theta)/lambda.")
      stdout.flush

      ! Table
      bin = bin*BOHR_PER_ANGSTROM
      table.create(8)
      table(1).set_heading("sin(th)/lambda"); table(1).set_values(bin)
      table(1).set_subhead("max value/A^-1")
      table(2).set_heading("# of");           table(2).set_values(C)
      table(2).set_subhead("refl")
      table(3).set_heading("GOF");            table(3).set_values(GOF)
      table(4).set_heading("F_exp");          table(4).set_values(ratio)
      table(4).set_subhead("/F_pred")
      table(5).set_heading("R(F)");           table(5).set_values(RF)
      table(6).set_heading("Rw(F)");          table(6).set_values(RwF)
      table(7).set_heading("R(F2)");          table(7).set_values(RF2)
      table(8).set_heading("Rw(F2)");         table(8).set_values(RwF2)
      table.put

      ! Clean
      table.clear_columns
      RwF2.destroy
      RF2.destroy
      RwF.destroy
      RF.destroy
      ratio.destroy
      C.destroy
      GOF.destroy
      bin.destroy
      stl.destroy

   end

   put_GOF_vs_F_exp_table
   ! Output GOF and ratio vs. F_exp bins.
      self :: IN

      n_sections,i :: INT
      stl,bin,GOF,ratio,RF,RwF,RF2,RwF2, dF,Fexp,Fz,Feos :: VEC{REAL}*
      C :: VEC{INT}*
      X_min,X_max,X_bin :: REAL
      table :: VEC{TABLE_COLUMN}*

      n_sections = 20

      ! F_exp
      stl.create(.reflections.dim)
      stl = REFLECTION:F_exp(.reflections)

      ! Bin size ...
      X_min = minval(stl)
      X_max = maxval(stl)
      X_bin = (X_max - X_min)/n_sections

      ! Sin theta on lambda bins array for table
      bin.create(n_sections)
      bin = [ (X_min + i*X_bin, i=1,n_sections) ]

      ! GOF
      GOF.create(n_sections)
      C.create(n_sections)
      GOF.to_histogram_from_data(REFLECTION:F_z2(.reflections),stl,X_min,X_max,X_bin,C)
      GOF = sqrt(GOF/max(C-.n_param,1))

      ! ratio
      ratio.create(n_sections)
      ratio.to_histogram_from_data(REFLECTION:F_ratio(.reflections),stl,X_min,X_max,X_bin)
      ratio = ratio/max(C,1)

      ! R(F)
      RF.create(n_sections)
      dF.create(n_sections)
      Fexp.create(n_sections)
      dF.to_histogram_from_data(REFLECTION:abs_delta_F(.reflections),stl,X_min,X_max,X_bin)
      Fexp.to_histogram_from_data(REFLECTION:F_exp(.reflections),stl,X_min,X_max,X_bin)
      RF = ZERO
      where (abs(Fexp)>TOL(6))
         RF = dF/Fexp
      end
      Fexp.destroy
      dF.destroy

      ! R(F2)
      RF2.create(n_sections)
      dF.create(n_sections)
      Fexp.create(n_sections)
      dF.to_histogram_from_data(REFLECTION:abs_delta_F2(.reflections),stl,X_min,X_max,X_bin)
      Fexp.to_histogram_from_data(REFLECTION:F2_exp(.reflections),stl,X_min,X_max,X_bin)
      RF2 = ZERO
      where (abs(Fexp)>TOL(6))
         RF2 = dF/Fexp
      end
      Fexp.destroy
      dF.destroy

      ! Rw(F)
      RwF.create(n_sections)
      Fz.create(n_sections)
      Feos.create(n_sections)
      Fz.to_histogram_from_data(REFLECTION:F_z2(.reflections),stl,X_min,X_max,X_bin)
      Feos.to_histogram_from_data(REFLECTION:F_exp_on_sigma_2(.reflections),stl,X_min,X_max,X_bin)
      RwF = ZERO
      where (abs(Feos)>TOL(6))
         RwF = sqrt(Fz/Feos)
      end
      Feos.destroy
      Fz.destroy

      ! Rw(F2)
      RwF2.create(n_sections)
      Fz.create(n_sections)
      Feos.create(n_sections)
      Fz.to_histogram_from_data(REFLECTION:F2_z2(.reflections),stl,X_min,X_max,X_bin)
      Feos.to_histogram_from_data(REFLECTION:F_exp_on_sigma_4(.reflections),stl,X_min,X_max,X_bin)
      RwF2 = ZERO
      where (abs(Feos)>TOL(6))
         RwF2 = sqrt(Fz/Feos)
      end
      Feos.destroy
      Fz.destroy

      ! Header
      stdout.flush
      stdout.text("============================")
      stdout.text("Fit statistics vs. intensity")
      stdout.text("============================")
      stdout.flush
      stdout.text("An analysis of the fit versus F_exp is shown in the table below.")
      stdout.flush

      ! Table
      table.create(8)
      table(1).set_heading("F_exp");          table(1).set_values(bin)
      table(1).set_subhead("max value")
      table(2).set_heading("# of");           table(2).set_values(C)
      table(2).set_subhead("refl")
      table(3).set_heading("GOF");            table(3).set_values(GOF)
      table(4).set_heading("F_exp");          table(4).set_values(ratio)
      table(4).set_subhead("/F_pred")
      table(5).set_heading("R(F)");           table(5).set_values(RF)
      table(6).set_heading("Rw(F)");          table(6).set_values(RwF)
      table(7).set_heading("R(F2)");          table(7).set_values(RF2)
      table(8).set_heading("Rw(F2)");         table(8).set_values(RwF2)
      table.put

      ! Clean
      table.clear_columns
      RwF2.destroy
      RF2.destroy
      RwF.destroy
      RF.destroy
      ratio.destroy
      C.destroy
      GOF.destroy
      bin.destroy
      stl.destroy

   end


   put_GOF_vs_STL_plot
   ! Output GOF vs. sin(theta)/lambda bins.
      self :: IN

      n_sections,i :: INT
      H :: VEC{REAL}*
      C :: VEC{INT}*
      X_min,X_max,X_bin,mid :: REAL

      n_sections = 20

      X_min = minval(REFLECTION:stl(.reflections))
      X_max = maxval(REFLECTION:stl(.reflections))
      X_bin = (X_max - X_min)/n_sections

      H.create(n_sections)
      C.create(n_sections)
      H.to_histogram_from_data(REFLECTION:F_z2(.reflections),REFLECTION:stl(.reflections),X_min,X_max,X_bin,C)
      H = sqrt(H/max(C-.n_param,1))

      stdout.flush
      stdout.text("Chi^2 vs angle plot")
      stdout.flush
      stdout.put("sin(T)/L")
      stdout.put("GOF")
      stdout.flush
      stdout.dash(real_fields=2)
      do i = 1,n_sections
         mid = (i-1)*X_min + HALF*X_bin
         stdout.put(mid)
         stdout.put(H(i))
         stdout.flush
      end
      stdout.flush
      C.destroy
      H.destroy
   end

   put_ratio_vs_STL_plot
   ! Output ratio vs. sin(theta)/lambda bins.
      self :: IN

      n_sections,i :: INT
      H :: VEC{REAL}*
      C :: VEC{INT}*
      X_min,X_max,X_bin,mid :: REAL

      n_sections = 20

      X_min = minval(REFLECTION:stl(.reflections))
      X_max = maxval(REFLECTION:stl(.reflections))
      X_bin = (X_max - X_min)/n_sections

      H.create(n_sections)
      C.create(n_sections)
      H.to_histogram_from_data(REFLECTION:F_ratio(.reflections),REFLECTION:stl(.reflections),X_min,X_max,X_bin,C)
      H = H/max(C-.n_param,1)

      stdout.flush
      stdout.text("Ratio (F_exp/F_pred) vs. angle")
      stdout.flush
      stdout.put("sin(T)/L")
      stdout.put("exp/pred")
      stdout.flush
      stdout.dash(real_fields=2)
      do i = 1,n_sections
         mid = (i-1)*X_min + HALF*X_bin
         stdout.put(mid)
         stdout.put(H(i))
         stdout.flush
      end
      stdout.flush
      C.destroy
      H.destroy

   end

   put_GOF_vs_F_exp_plot
   ! Output GOF vs. F_pred bins.
      self :: IN

      n_sections,i :: INT
      H :: VEC{REAL}*
      C :: VEC{INT}*
      X_min,X_max,X_bin,mid :: REAL

      n_sections = 20

      X_min = minval(REFLECTION:F_exp(.reflections))
      X_max = maxval(REFLECTION:F_exp(.reflections))
      X_bin = (X_max - X_min)/n_sections

      H.create(n_sections)
      C.create(n_sections)
      H.to_histogram_from_data(REFLECTION:F_z2(.reflections),REFLECTION:F_exp(.reflections),X_min,X_max,X_bin,C)
      H = sqrt(H/max(C-.n_param,1))

      stdout.flush
      stdout.text("Chi^2 vs F_exp")
      stdout.flush
      stdout.put("sin(T)/L")
      stdout.put("GOF")
      stdout.flush
      stdout.dash(real_fields=2)
      do i = 1,n_sections
         mid = (i-1)*X_min + HALF*X_bin
         stdout.put(mid)
         stdout.put(H(i))
         stdout.flush
      end
      stdout.flush
      C.destroy
      H.destroy
   end

   put_ratio_vs_F_exp_plot
   ! Output ratio vs. F_exp bins.
      self :: IN

      n_sections,i :: INT
      H :: VEC{REAL}*
      C :: VEC{INT}*
      X_min,X_max,X_bin,mid :: REAL

      n_sections = 20

      X_min = minval(REFLECTION:F_exp(.reflections))
      X_max = maxval(REFLECTION:F_exp(.reflections))
      X_bin = (X_max - X_min)/n_sections

      H.create(n_sections)
      C.create(n_sections)
      H.to_histogram_from_data(REFLECTION:F_ratio(.reflections),REFLECTION:F_exp(.reflections),X_min,X_max,X_bin,C)
      H = H/max(C-.n_param,1)

      stdout.flush
      stdout.text("Ratio (F_exp/F_pred) vs. F_exp")
      stdout.flush
      stdout.put("sin(T)/L")
      stdout.put("exp/pred")
      stdout.flush
      stdout.dash(real_fields=2)
      do i = 1,n_sections
         mid = (i-1)*X_min + HALF*X_bin
         stdout.put(mid)
         stdout.put(H(i))
         stdout.flush
      end
      stdout.flush

      C.destroy
      H.destroy

   end

   put_fcalc_plots
   ! Output some different plots about the calculated structure factors.
      self :: IN

      ext :: VEC{REAL}*
      ext_refs :: VEC{REFLECTION}*
      n,n_refl :: INT
      y,w :: REAL

      n_refl = .reflections.n_refl

      stdout.flush
      stdout.text("Scatter plot of F_z = (Fexp-Fpred)/F_sigma vs sin(theta)/lambda :")
      stdout.flush

      do n = 1,n_refl
         stdout.put(.reflections(n).stl)
         stdout.put(.reflections(n).F_z)
         stdout.flush
      end

      stdout.flush
      stdout.text("Scatter plot of Delta F = (Fexp-Fpred) vs sin(theta)/lambda :")
      stdout.flush

      do n = 1,n_refl
         stdout.put(.reflections(n).stl)
         stdout.put(.reflections(n).delta_F)
         stdout.flush
      end

      stdout.flush
      stdout.text("Scatter plot of F_z = (Fexp-Fpred)/F_sigma vs Fexp :")
      stdout.flush

      do n = 1,n_refl
         stdout.put(.reflections(n).F_exp)
         stdout.put(.reflections(n).F_z)
         stdout.flush
      end


      if (.optimize_extinction) then

      ext_refs.create(n_refl)
      ext.create(n_refl)
      ext = .F_extinction_correction
      ext_refs.set_F_exp(.reflections.F_pred)
      ext_refs.set_F_pred(.reflections.F_pred * ext)
      ext_refs.set_F_sigma(.reflections.F_sigma)
      ext.destroy

      stdout.flush
      stdout.text("The effects of extinction:")
      stdout.flush

      w = ZERO
      y = ZERO
      do n=1,n_refl
       y = y + abs(ext_refs(n).F_z)
       w = w + abs(ext_refs(n).F_r)
      end
      y = y / n_refl
      w = w / n_refl
      stdout.show("Average value of abs[Fcalc(with ext)-Fcalc(without ext)]/F_sigma is ",y)
      stdout.show("Average value of abs(extinction correction) is ",w)
      stdout.flush

      stdout.flush
      stdout.text("The effects of intensity on extinction:")
      stdout.flush

      stdout.text("Scatter plot of [Fcalc(with ext)-Fcalc(without ext)]/F_sigma vs F_pred:")
      do n=1,n_refl
       stdout.put(ext_refs(n).F_pred)
       stdout.put(ext_refs(n).F_z)
       stdout.flush
      end

      stdout.flush
      stdout.text("The effects of scattering angle on extinction:")
      stdout.flush

      stdout.text("Scatter plot of [Fcalc(with ext)-Fcalc(without ext)]/F_sigma vs sin(theta)/lambda:")
      do n = 1,n_refl
         stdout.put(.reflections(n).stl)
         stdout.put(ext_refs(n).F_z)
         stdout.flush
      end

      ext_refs.destroy

      end

   end

   put_PND_sf(name)
   ! Output the magnetic structure factors
      self :: IN
      name :: STR, IN

      FM_s,FM_l :: VEC{CPX}*
      arch :: ARCHIVE
      n :: INT

      FM_s.create(.reflections.n_refl)

      arch.set(name,"PND_spin_sf")
      arch.read(FM_s)

      FM_l.create(.reflections.n_refl)
      arch.set(name,"PND_nabla_sf")
      arch.read(FM_l)

      stdout.text("PND magnetic structure factors:")
      stdout.flush
      stdout.dash(int_fields=3,real_fields=3)
      stdout.put("h", int_width=TRUE)
      stdout.put("k", int_width=TRUE)
      stdout.put("l", int_width=TRUE)
      stdout.put("FM_s")
      stdout.put("FM_l")
      stdout.put("FM")
      stdout.flush
      stdout.dash(int_fields=3,real_fields=3)
      do n = 1, .reflections.n_refl
         stdout.put(.reflections(n).h)
         stdout.put(.reflections(n).k)
         stdout.put(.reflections(n).l)
         stdout.put(real(FM_s(n)) )
         stdout.put(real(FM_l(n)) )
         stdout.put(real(FM_s(n)+FM_l(n)) )
         stdout.flush
      end
      stdout.dash(int_fields=3,real_fields=3)

      FM_l.destroy
      FM_s.destroy

   end


!  ===================
!  Tests for existence
!  ===================

   have_set_wavelength result (res) ::: pure
   ! Return TRUE if the wavelength was set i.e. is +ve
      self :: IN
      res :: BIN

      res = .wavelength > ZERO

   end

   reflection_data_exists result (res) ::: pure
   ! Return TRUE if reflection data exists
      self :: IN
      res :: BIN
      res = associated(.reflections)
   end

   have_F_exp result (res) ::: pure
   ! Return TRUE if have some experimental structure factors
      self :: IN
      res :: BIN

      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_exp

   end

   have_F_sigma result (res) ::: pure
   ! Return TRUE if have some F_sigma's
      self :: IN
      res :: BIN

      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_sigma

   end

   have_I_exp result (res) ::: pure
   ! Return TRUE if have some I_exp's
      self :: IN
      res :: BIN

      res = FALSE
      if (associated(.reflections)) res = .reflections.have_I_exp

   end

   have_I_sigma result (res) ::: pure
   ! Return TRUE if have some I_sigma's
      self :: IN
      res :: BIN

      res = FALSE
      if (associated(.reflections)) res = .reflections.have_I_sigma

   end

   have_F_calc result (res) ::: pure
   ! Return TRUE if have some calculated structure factors
      self :: IN
      res :: BIN

      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_calc

   end

   have_F_pred result (res) ::: pure
   ! Return TRUE if have some predicted structure factors
      self :: IN
      res :: BIN

      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_pred

   end


   use_multiple_scale_factors result (res) ::: pure
   ! Return TRUE if we are supposed to use multiple scale factors.
      self :: IN
      res :: BIN

      res = FALSE
      if (associated(.reflections)) res = any(.reflections.group>0)

   end


!  =============================
!  Inherited reflection routines
!  =============================

   n_refl result (res) ::: PURE
   ! The number of reflections
      self :: IN
      res :: INT

   ENSURE(.reflections.associated, "no reflection data")

      res = .reflections.n_refl

   end


   F2_calc_abs result (res) ::: PURE
   ! The calculated structure factors magnitude, squared
      self :: IN
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.F2_calc_abs

   end

   F_calc result (res) ::: PURE
   ! The calculated structure factors
      self :: IN
      res :: VEC{CPX}(size(.reflections))

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.F_calc

   end

   I_calc result (res) ::: PURE
   ! The calculated intensities
      self :: IN
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.I_calc

   end


   F_pred result (res) ::: PURE
   ! The predicted structure factors
      self :: IN
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.F_pred

   end

   F_pred_complex(optimize) result (res)
   ! The predicted structure factors including the complex phase.
   ! NOTE: this routine does *not* reset .chi2
      self :: INOUT
      optimize :: BIN, optional
      res :: VEC{CPX}(size(.reflections))

   ENSURE(.reflections.associated,"no reflection data")

      opt :: BIN

      opt = FALSE
      if (present(optimize)) opt = optimize

      ! Get optimum corrections if asked ...
      if (opt) .get_F_optimum_parameters
   
      ! Multiply scale factor
      res = .reflections.F_calc * .F_extinction_correction
   
   end

   I_pred result (res) ::: PURE
   ! The predicted intensities
      self :: IN
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.I_pred

   end


   F2_sigma result (res) ::: PURE
   ! The structure factor errors squared
      self :: IN
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.F2_sigma

   end

   F_sigma result (res) ::: PURE
   ! The structure factor errors
      self :: IN
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.F_sigma

   end

   I_sigma result (res) ::: PURE
   ! The intensity errors
      self :: IN
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.I_sigma

   end


   F2_exp result (res) ::: PURE
   ! The experimental structure factors squared
      self :: IN
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.F2_exp

   end

   F_exp result (res) ::: PURE
   ! The experimental structure factors
      self :: IN
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.F_exp

   end

   F_exp_on_absolute_scale result (res) ::: PURE
   ! The experimental structure factors F_exp corrected by the
   ! scale_factor(s) and extinction, to be on an absolute scale.
   ! NOTE: Dispersion *not* removed, see F_exp_scaled_corrected in CRYSTAL.
      self :: IN
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflection_data_exists,"no reflection data")

      fac :: VEC{REAL}@

      ! Correction factors
      if (.use_multiple_scale_factors) then
         fac = .F_extinction_correction(.scale_factors,.extinction_factor)
      else
         fac = .F_extinction_correction(.scale_factor,.extinction_factor)
      end

      ! Apply
      res = .reflections.F_exp/fac

   end


   I_exp result (res) ::: PURE
   ! The experimental intensities
      self :: IN
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.I_exp

   end


   F_chi2 result (res) ::: PURE
   ! Returns data
      self :: IN
      res :: REAL

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.F_chi2

   end

   I_chi2 result (res) ::: PURE
   ! Returns data
      self :: IN
      res :: REAL

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.I_chi2

   end


   F_goodness_of_fit result (res) ::: PURE
   ! Returns data
      self :: IN
      res :: REAL

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.F_goodness_of_fit

   end

   I_goodness_of_fit result (res) ::: PURE
   ! Returns data
      self :: IN
      res :: REAL

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.I_goodness_of_fit

   end


   F_r_factor result (res) ::: PURE
   ! Returns data
      self :: IN
      res :: REAL

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.F_r_factor

   end

   I_r_factor result (res) ::: PURE
   ! Returns data
      self :: IN
      res :: REAL

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.I_r_factor

   end


   F_weighted_r_factor result (res) ::: PURE
   ! Returns data
      self :: IN
      res :: REAL

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.F_weighted_r_factor

   end

   I_weighted_r_factor result (res) ::: PURE
   ! Returns data
      self :: IN
      res :: REAL

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.I_weighted_r_factor

   end

   F2_r_factor result (res) ::: PURE
   ! Returns data
      self :: IN
      res :: REAL

   ENSURE(.reflection_data_exists,"no reflection data")

      res = .reflections.F2_r_factor

   end


   simulate_new_F_exp
   ! Simulate a new experiment by adding normally distributed experimental
   ! errors the the F_exp.
      self :: INOUT

   ENSURE(.reflection_data_exists,"no reflection data")
   ENSURE(.have_F_exp,"no experimental structure factors")
   ENSURE(.have_F_sigma,"no experimental structure factor errors")

      F_exp :: VEC{REAL}*
      n :: INT
      chi2,z :: REAL

      stdout.flush
      stdout.text("Adding simulated errors to F_exp using F_sigma.")

      F_exp.create(.n_refl)
      F_exp = .reflections.F_exp

      .reflections.simulate_new_F_exp

      chi2 = ZERO
      do n = 1,.n_refl
         z = (F_exp(n)-.reflections(n).F_exp)/.reflections(n).F_sigma
         chi2 = chi2 + z*z
      end
      chi2 = chi2 / max(.n_refl - 1,1)

      stdout.text("chi^2 of old F_exp to new F_exp is " // trim(chi2.to_str))
      stdout.flush
      stdout.dash(real_fields=4)
      stdout.put("F_exp (old)")
      stdout.put("F_exp (new)")
      stdout.put("F_sigma")
      stdout.put("dF/sigma")
      stdout.flush
      stdout.dash(real_fields=4)

      do n=1,.n_refl
         z = (F_exp(n)-.reflections(n).F_exp)/.reflections(n).F_sigma
         stdout.put(F_exp(n))
         stdout.put(.reflections(n).F_exp)
         stdout.put(.reflections(n).F_sigma)
         stdout.put(z)
         stdout.flush
      end

      stdout.dash(real_fields=4)
      F_exp.destroy

   end

end
