!-------------------------------------------------------------------------------
!
! DIFFRACTION_DATA: Diffraction data structure for crystals
!
! $Id: diffraction_data.foo 4379 2014-05-19 08:49:50Z dylan_ $
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module DIFFRACTION_DATA

   implicit none

   saved_self :: DIFFRACTION_DATA*, private

   debug_list :: VEC{STR}*, private  DEFAULT_NULL

contains

!  ==========================
!  Create and destroy methods
!  ==========================

   create ::: get_from(OBJECT), leaky
   ! Create an object
      self :: PTR
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the diffraction data object

      nullify(.reflections)

      nullify(.scale_factors)

      nullify(.refine_U_iso_for_atom)
      nullify(.refine_3rd_order_for_atom)
      nullify(.refine_4th_order_for_atom)
      nullify(.refine_atom_parameters)

      nullify(.fit_table)
      nullify(.ref_table)

      nullify(.dX)
      nullify(.X_fit)
      nullify(.X_fit0)
      nullify(.X_ref)
      nullify(.X_ref0)

      nullify(.near_0_eigenvalues)
      nullify(.near_0_eigenvectors)

      nullify(.esd)
      nullify(.covariance_matrix)
      nullify(.correlation_matrix)
      nullify(.fragment_covariance_matrix)

   end

   destroy_ptr_part ::: leaky
   ! Erase all pointer information

      ! Reflection related data
      .destroy_reflection_data

      .refine_U_iso_for_atom.destroy 
      ! Refinement/fit related data
      
      .refine_3rd_order_for_atom.destroy 
      .refine_4th_order_for_atom.destroy 
      .refine_atom_parameters.destroy 
      .destroy_fit_data
      .destroy_refinement_data

   end

   destroy_reflection_data ::: leaky
   ! Erase all reflection data

      if (.reflection_data_exists) then

         .scale_factor = ONE
         .exp_scale_factor = ONE
         .extinction_factor = ZERO
         .reflections.destroy
         .scale_factors.destroy

      end

   end

   destroy_fit_data ::: leaky
   ! Erase all generated fit arrays

      .fit_table.destroy

      .dX.destroy
      .X_fit.destroy
      .X_fit0.destroy

      .near_0_eigenvalues.destroy
      .near_0_eigenvectors.destroy

      .esd.destroy
      .covariance_matrix.destroy
      .correlation_matrix.destroy
      .fragment_covariance_matrix.destroy

   end

   destroy_refinement_data ::: leaky
   ! Erase all generated refinement arrays

      .ref_table.destroy

      .X_ref.destroy
      .X_ref0.destroy

   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(data) ::: leaky
   ! Set self to be crystal.
      data :: DIFFRACTION_DATA, IN

      self = data

      .nullify_ptr_part

      ! Reflection-related data
      if (data.reflections.created)                .reflections.create_copy(data.reflections)
      if (data.scale_factors.created)              .scale_factors.create_copy(data.scale_factors)

      if (data.refine_U_iso_for_atom.created)      .refine_U_iso_for_atom.create_copy(data.refine_U_iso_for_atom)
      ! Refinement/fit related data

      if (data.refine_3rd_order_for_atom.created)  .refine_3rd_order_for_atom.create_copy(data.refine_3rd_order_for_atom)
      if (data.refine_4th_order_for_atom.created)  .refine_4th_order_for_atom.create_copy(data.refine_4th_order_for_atom)
      if (data.refine_atom_parameters.created)     .refine_atom_parameters.create_copy(data.refine_atom_parameters)

      if (data.fit_table.created)                  .fit_table.create_copy(data.fit_table)
      if (data.ref_table.created)                  .ref_table.create_copy(data.ref_table)

      if (data.dX.created)                         .dX.create_copy(data.dX)
      if (data.X_fit.created)                      .X_fit.create_copy(data.X_fit)
      if (data.X_fit0.created)                     .X_fit0.create_copy(data.X_fit0)
      if (data.X_ref.created)                      .X_ref.create_copy(data.X_ref)
      if (data.X_ref0.created)                     .X_ref0.create_copy(data.X_ref0)

      if (data.near_0_eigenvalues.created)         .near_0_eigenvalues.create_copy(data.near_0_eigenvalues)
      if (data.near_0_eigenvectors.created)        .near_0_eigenvectors.create_copy(data.near_0_eigenvectors)

      if (data.esd.created)                        .esd.create_copy(data.esd)
      if (data.covariance_matrix.created)          .covariance_matrix.create_copy(data.covariance_matrix)
      if (data.correlation_matrix.created)         .correlation_matrix.create_copy(data.correlation_matrix)
      if (data.fragment_covariance_matrix.created) .fragment_covariance_matrix.create_copy(data.fragment_covariance_matrix)
   
   end

!  ===========
!  Set methods
!  ===========

   set_defaults ::: leaky
   ! Set up a default diffraction_data object

      .destroy_reflection_data

      .data_kind              = DIFFRACTION_DATA_DATA_KIND

      ! Experimental data
      .wavelength             = DIFFRACTION_DATA_WAVELENGTH
      .temperature            = ZERO
      .NKA_T_sequence_no      = 0

      ! Data treatment options
      .F_sigma_cutoff         = DIFFRACTION_DATA_F_SIGMA_CUTOFF
      .I_sigma_cutoff         = DIFFRACTION_DATA_I_SIGMA_CUTOFF
      .F_z_cutoff             = -ONE
      .stl_cutoff             = -ONE
      .show_rejects           = TRUE
      .synthesize_sigma_I     = DIFFRACTION_DATA_SYNTHESIZE_SIGMA_I
      .SF_mixing_parameter    = ZERO

      ! Structure factor calculation parameters
      .partition_model        = DIFFRACTION_DATA_PARTITION_MODEL
      .thermal_smearing_model = DIFFRACTION_DATA_THERMAL_SMEARING_MODEL
      .use_Voronoi_atoms      = FALSE

      ! Experimental corrections
      .optimise_scale         = DIFFRACTION_DATA_OPTIMISE_SCALE
      .scale_factor           = DIFFRACTION_DATA_SCALE_FACTOR
      .exp_scale_factor       = DIFFRACTION_DATA_EXP_SCALE_FACTOR
      .optimise_extinction    = DIFFRACTION_DATA_OPTIMISE_EXTINCTION
      .extinction_factor      = DIFFRACTION_DATA_EXTINCTION_FACTOR
      .correct_dispersion     = DIFFRACTION_DATA_CORRECT_DISPERSION

      ! Agreement statistics
      .n_param                  = 0
      .chi2                     = ZERO

      ! Refine/fit switches
      .fit_structure            = FALSE
      .refine_structure         = FALSE
      .refine_F                 = TRUE 
      .refine_positions_only    = FALSE
      .refine_ADPs_only         = FALSE
      .refine_H_ADPs            = TRUE
      .refine_H_U_iso           = FALSE
      .refine_anharmonicity     = FALSE
      .restart_HAR_with_promolecule = FALSE

      ! Refine/fit iteration termination
      .max_iterations           = DIFFRACTION_DATA_MAX_ITER
      .min_iterations           = DIFFRACTION_DATA_MIN_ITER  
      .max_allowed_param_shift  = DIFFRACTION_DATA_MAX_ALLOWED_SHIFT

      ! Least squares options (zero/near zero eigenvalues)
      .tol_for_shift_on_esd     = DIFFRACTION_DATA_TOL_FOR_SHIFT_ON_ESD
      .tol_0                    = DIFFRACTION_DATA_TOL_0
      .tol_near_0               = DIFFRACTION_DATA_TOL_NEAR_0

      ! Refinement/fit output control
      .show_fit_output             = FALSE
      .display_near_0_eigenvectors = FALSE
      .display_correlation_matrix  = FALSE
      .min_correlation             = DIFFRACTION_DATA_MIN_CORRELATION

      ! Set the internal variables for a refine/fit data
      .destroy_fit_data
      .set_fit_data

      .destroy_refinement_data
      .set_refinement_data

   end

   set_fit_data 
   ! Set the defaults internal variables for a fit

      ! Refinement/fit iteration data
      .fit_iteration           = 0
      .chi2_fit                = ZERO
      .chi2_fit0               = ZERO
      .max_shift               = ZERO
      .max_shift_on_esd        = ZERO
      .max_shift_on_esd_ind    = 0
      .max_shift_on_esd_par    = " "
      .fit_converged           = FALSE
      .chi2_increased          = FALSE
      .too_many_fit_iterations = FALSE

      ! Near zero eigenvalues in the least-squares
      .n_0                 = 0
      .n_near_0            = 0

   end

   set_refinement_data 
   ! Set the defaults internal variables for a refinement

      ! Refinement/fit iteration data
      .ref_iteration           = 0
      .chi2_ref                = ZERO
      .chi2_ref0               = ZERO
      .max_refshift            = ZERO
      .max_refshift_on_esd     = ZERO
      .max_refshift_on_esd_ind = 0
      .max_refshift_on_esd_par = " "
      .refinement_converged    = FALSE
      .too_many_ref_iterations = FALSE

   end

   update(unit_cell,spacegroup)
   ! Update the crystal information after setting values. If the
   ! "unit_cell" is provided, then that is used to define the reflection
   ! .theta values.
      unit_cell :: UNIT_CELL, optional
      spacegroup :: SPACEGROUP, optional
 
      if (.reflections.destroyed) return
 
      if (.reflections.have_F_exp) then
         .reflections.scale_F_exp(.exp_scale_factor)
      else
         .optimise_scale = FALSE
         .optimise_extinction = FALSE
      end

      if (.reflections.have_F_sigma) then
         .reflections.scale_F_sigma(.exp_scale_factor)
      else
         .optimise_scale = FALSE
         .optimise_extinction = FALSE
      end

      .exp_scale_factor = ONE

      if (present(unit_cell))  .set_theta_angles(unit_cell.reciprocal_matrix)

      if (present(spacegroup)) .set_equivalence_factors(spacegroup)

   end

   set_equivalence_factors(spacegroup) 
   ! Set the equivalence factors, the number of distinct reflections
   ! which are symmetry equivalent to a particular (hkl) triple, for all
   ! the reflections.
      spacegroup :: SPACEGROUP 

   ENSURE(.reflections.created,"no reflection data")

      hkl,new :: VEC{INT}(3)
      n,s,u,n_refl :: INT

      n_refl = .reflections.n_refl

      do n = 1,n_refl

         hkl = .reflections.indices(n)

         u = 1
         do s = 2,spacegroup.n_seitz
            new = int(matmul(REALIFY(hkl),spacegroup.seitz(1:3,1:3,s)))
            if (hkl(1)/=new(1) OR hkl(2)/=new(2) OR hkl(3)/=new(3)) u = u + 1
         end

         .reflections(n).equivalence_factor = u

      end
   
   end

   set_theta_angles(reciprocal_matrix)
   ! This routine is called after the reflections are read in, in order to set
   ! all the .theta values, which are used later all over the place ...
      reciprocal_matrix :: MAT{REAL}(3,3)

      hkl :: VEC{INT}(3)
      kx,ky,kz,sin_theta :: REAL
      n :: INT

      do n = 1,.reflections.n_refl

         hkl = .reflections.indices(n)
 
         kx = dot_product(reciprocal_matrix(1,:),hkl(:))
         ky = dot_product(reciprocal_matrix(2,:),hkl(:))
         kz = dot_product(reciprocal_matrix(3,:),hkl(:))
 
         sin_theta = HALF*sqrt(kx*kx+ky*ky+kz*kz)*.wavelength
         .reflections(n).theta = asin(sin_theta)

      end

   end

   set_refine_structure(val)
   ! Generic set
      val :: BIN

      .refine_structure = val

      ! If refining you can't be fitting
      if (val) .fit_structure = NOT val 

   end

   set_fit_structure(val)
   ! Generic set
      val :: BIN

      .fit_structure = val

      ! If fitting, you can't be refining
      if (NOT val) .refine_structure = NOT val

   end

!  ============
!  Read methods
!  ============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
      self :: PTR
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      self :: PTR
      keyword :: STR

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)

         case ("}                             ")  ! exit read_loop

         case ("correct_dispersion=           "); .read_correct_dispersion

         case ("debug_off                     "); .read_debug_off
         case ("debug_on                      "); .read_debug_on
         case ("destroy_reflection_data       "); .destroy_reflection_data
         case ("display_correlation_matrix=   "); .read_display_corr_matrix
         case ("display_near_0_eigenvectors=  "); .read_display_near_0_evecs

         case ("exp_scale_factor=             "); .read_exp_scale_factor

         case ("f_sigma_cutoff=               "); .read_F_sigma_cutoff
         case ("f_z_cutoff=                   "); .read_F_z_cutoff

         case ("i_z_cutoff=                   "); .read_I_z_cutoff

         case ("junk=                         "); .read_junk

         case ("kind=                         "); .read_data_kind

         case ("make_f_predicted              "); .make_F_predicted
         case ("max_allowed_param_shift=      "); .read_max_allowed_param_shift
         case ("max_iterations=               "); .read_max_iterations
         case ("min_iterations=               "); .read_min_iterations

         case ("nka_t_sequence_no=            "); .read_NKA_T_seq_no

         case ("optimise_extinction=          "); .read_optimise_extinction
         case ("optimize_extinction=          "); .read_optimise_extinction
         case ("optimise_scale_factor=        "); .read_optimise_scale
         case ("optimize_scale_factor=        "); .read_optimise_scale
         case ("optimise_scale_factors=       "); .read_optimise_scale
         case ("optimize_scale_factors=       "); .read_optimise_scale

         case ("partition_model=              "); .read_partition_model
         case ("prune_bad_f_reflections       "); .prune_bad_F_reflections
         case ("prune_high_angle_reflections  "); .prune_high_angle_reflections
         case ("prune_low_angle_reflections   "); .prune_low_angle_reflections
         case ("prune_negative_f_exp          "); .prune_negative_F_exp       
         case ("prune_negative_i_exp          "); .prune_negative_I_exp       
         case ("prune_weak_reflections        "); .prune_weak_reflections
         case ("put                           "); .put
         case ("put_debug_list                "); .put_debug_list
         case ("put_sin_theta_on_lambda       "); .put_sin_theta_on_lambda

         case ("read_cif                      "); .read_CIF
         case ("redirect                      "); .redirect
         case ("refine_3rd_order_for_atoms=   "); .read_refine_3rd_order
         case ("refine_4th_order_for_atoms=   "); .read_refine_4th_order
         case ("refine_adps_only=             "); .read_refine_ADPs_only
         case ("refine_f=                     "); .read_refine_F
         case ("refine_h_adps=                "); .read_refine_H_ADPs
         case ("refine_h_u_iso=               "); .read_refine_H_U_iso
         case ("refine_positions_only=        "); .read_refine_positions_only
         case ("refine_u_iso_for_atoms=       "); .read_refine_U_iso_atoms
         case ("reflection_data=              "); .read_reflection_data
         case ("restart_har_with_promolecule= "); .read_restart_with_promolecule
         case ("revert                        "); .revert

         case ("sf_mixing_parameter=          "); .read_SF_mixing_parameter
         case ("show_fit_output=              "); .read_show_fit_output
         case ("show_rejects=                 "); .read_show_rejects
         case ("stl_cutoff=                   "); .read_stl_cutoff
         case ("synthesize_sigma_i=           "); .read_synthesize_sigma_I

         case ("thermal_smearing_model=       "); .read_thermal_smearing_model
         case ("temperature=                  "); .read_temperature
         case ("tolerance_0=                  "); .read_tol_0
         case ("tolerance_near_0=             "); .read_tol_near_0
         case ("tol_for_shift_on_esd=         "); .read_tol_for_shift_on_esd

         case ("units=                        "); .read_units
         case ("use_voronoi_atoms=            "); .read_use_Voronoi_atoms

         case ("wavelength=                   "); .read_wavelength

         case ("zero_negative_f_exp           "); .zero_negative_F_exp       

         case default;                       UNKNOWN(word)

      end

   end

! Reading

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input
   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file
   end

   read_data_kind
   ! Read the data kind of crystal experiment

      stdin.read(.data_kind)

      .data_kind.to_lower_case

      select case (.data_kind)
         case("x-ray")
         case("pnd  ")
         case default; UNKNOWN(.data_kind)
      end

   end

   read_F_sigma_cutoff ::: private
   ! Read the maximum acceptable value for F_cutoff

      stdin.read(.F_sigma_cutoff)

      ENSURE(.F_sigma_cutoff>ZERO,"cutoff must be positive")

   end

   read_I_sigma_cutoff ::: private
   ! Read the maximum acceptable value for I_cutoff

      stdin.read(.I_sigma_cutoff)

      ENSURE(.I_sigma_cutoff>ZERO,"cutoff must be positive")

   end

   read_F_z_cutoff ::: private
   ! Read the F_z cutoff for prune_bad_reflections

      stdin.read(.F_z_cutoff)

      ENSURE(.F_z_cutoff>=ZERO,"must be positive")

   end

   read_I_z_cutoff ::: private
   ! Read the I_z cutoff for prune_bad_reflections

      stdin.read(.I_z_cutoff)

      ENSURE(.I_z_cutoff>=ZERO,"must be positive")

   end

   read_stl_cutoff ::: private
   ! Read the stl_cutoff for prune_high_angle_reflections

      stdin.read(.stl_cutoff)

      ENSURE(.stl_cutoff>=ZERO,"must be positive")

   end

   read_show_fit_output ::: private
   ! Read wether to show the rejected reflections
      stdin.read(.show_fit_output)
   end

   read_show_rejects ::: private
   ! Read wether to show the rejected reflections
      stdin.read(.show_rejects)
   end

   read_exp_scale_factor ::: private
   ! Read the structure factor multiplier
      stdin.read(.exp_scale_factor)
   end

   read_wavelength ::: private
   ! Read the experimental wavelength
      stdin.read_quantity(.wavelength)
   end

   read_optimise_scale ::: private
   ! Read the switch whether to use and overall scale factor to minimise
   ! the chi2 statistic when calculating the structure factors.
   ! NOTE: this is not the same at the overall .scale_factor which is applied
   ! to the experimental structure factors.
      stdin.read(.optimise_scale)
   end

   read_SF_mixing_parameter ::: private
   ! Read the SF mixining parameter which inlcudes some percentage of
   ! the experimental structure factors into the predicted structure
   ! factors. This may help convergence in constrained HF problems.
      stdin.read(.SF_mixing_parameter)
   end

   read_synthesize_sigma_I ::: private
   ! Read the switch whether to artificially create sigma(I) errors when
   ! evaluating the chi2 statistics based on intensities. Refer to routine
   ! .I_sigma
      stdin.read(.synthesize_sigma_I)
   end

   read_optimise_extinction ::: private
   ! Read the switch whether to correct extinction or not, according to the
   ! Larson formula
      stdin.read(.optimise_extinction)
   end

   read_correct_dispersion ::: private
   ! Read the switch whether to correct dispersion or not, according to the
   ! atomic dispersion factors
      stdin.read(.correct_dispersion)
   end

   read_thermal_smearing_model ::: private
   ! Read the thermal smearing model to use to correct for thermal vibration
   ! in the calculated structure factors
      stdin.read(.thermal_smearing_model)
      .thermal_smearing_model.to_lower_case
      select case (.thermal_smearing_model)
         case("         ")
         case("none     ")
         case("coppens  ")
         case("hirshfeld")
         case("stewart  ")
         case("tanaka   ")
         case default;    UNKNOWN(.thermal_smearing_model)
      end
   end

   read_partition_model ::: private
   ! Read the partition model to used to correct for oversampled fragments
   ! of the unit cell when calculating the structure factors
      stdin.read(.partition_model)
      .partition_model.to_lower_case
      select case(.partition_model)
         case("        ")
         case("none    ")
         case("mulliken")
         case("gaussian")
         case default;    UNKNOWN(.partition_model)
      end
   end

   zero_negative_F_exp ::: leaky
   ! This routine zero negative F_exp value 
      self :: PTR

   DIE_IF(NOT .reflections.created,"no reflection data")
   DIE_IF(NOT .reflections.have_F_exp,"no experimental data")

      i :: INT

      do i = 1,.reflections.n_refl
        if (.reflections(i).F_exp < ZERO) then
           .reflections(i).F_exp = ZERO
           .reflections(i).F_sigma = .reflections(i).F_sigma + abs(.reflections(i).F_exp)
        end
      end

   end

   read_temperature
   ! Read the temperature
      stdin.read(.temperature)
      ENSURE(.temperature>=0,"temperature is not positive!")
   end

   read_NKA_T_seq_no
   ! Read the temperature sequence no for NKA output file
      stdin.read(.NKA_T_sequence_no)
      ENSURE(.NKA_T_sequence_no>0,"sequence no is not positive!")
   end

!  Refinement options

   read_max_allowed_param_shift
   ! Read the maximum allowed shift in a structure refinement
   ! parameter
      stdin.read(.max_allowed_param_shift)
      ENSURE(.max_allowed_param_shift>ZERO,"convergence_tolerance is positive")
   end

   read_max_iterations
   ! Read the maximum number of iterations
      stdin.read(.max_iterations)
      ENSURE(.max_iterations>-1,"max_iterations must be non-negative")
      ENSURE(.max_iterations>.min_iterations,"max_iterations must be greater than min_iterations")
   end

   read_min_iterations
   ! Read the minimum number of iterations
      stdin.read(.min_iterations)
      ENSURE(.min_iterations>-1,"min_iterations must be non-negative")
      ENSURE(.max_iterations>.min_iterations,"min_iterations must be smaller than max_iterations")
   end

   read_reflection_data ::: leaky, private
   ! Read in reflection data in the standard order from "stdin".
      .reflections.read_list_keywords
   end

   read_refine_ADPs_only
   ! Read whether to refine only the ADP's
      stdin.read(.refine_ADPs_only)
   end

   read_refine_F
   ! Read in whether to refine F's instead of I's
      stdin.read(.refine_F)
   end

   read_refine_H_ADPs
   ! Read whether to refine only the H atom ADP's
      stdin.read(.refine_H_ADPs)
   end

   read_refine_H_U_iso
   ! Read whether to refine only the H atom U_iso's
      stdin.read(.refine_H_U_iso)
   end

   read_refine_positions_only
   ! Read whether to refine only the atom positions
      stdin.read(.refine_positions_only)
   end

   read_refine_3rd_order ::: leaky
   ! Read the list of atoms for which third-order anharmonicty
   ! parameters are to be refined.
      stdin.read_ptr(.refine_3rd_order_for_atom)
      .refine_anharmonicity = TRUE
   end

   read_refine_4th_order ::: leaky
   ! Read the list of atoms for which fourth-order anharmonicty
   ! parameters are to be refined.
      stdin.read_ptr(.refine_4th_order_for_atom)
      .refine_anharmonicity = TRUE
   end

   read_refine_U_iso_atoms ::: leaky
   ! Read the list of atoms refined isotropically
      stdin.read_ptr(.refine_U_iso_for_atom)
      stdout.text("Check input")
      stdout.put(.refine_U_iso_for_atom)
   end

   read_use_Voronoi_atoms
   ! Read whether to use Voronoi atoms in refinement
      stdin.read(.use_Voronoi_atoms)
   end

   read_restart_with_promolecule ::: leaky
   ! Read whether to restart with promolecule initial guess.
      stdin.read(.restart_HAR_with_promolecule)
   end

   read_tol_0
   ! Read the tolerance for deciding on zero eigenvalues in solving
   ! the normal equations.
      stdin.read(.tol_0)
      ENSURE(.tol_0>ZERO,"tol_0 must be positive")
      ENSURE(.tol_0<.tol_near_0,"tol_0 must be smaller than tol_near_0")
   end

   read_tol_near_0
   ! Read the tolerance for deciding on *near* zero eigenvalues in
   ! solving the normal equations.
      stdin.read(.tol_near_0)
      ENSURE(.tol_near_0>ZERO,"tol_near_0 must be positive")
      ENSURE(.tol_0<.tol_near_0,"tol_near_0 must be bigger than tol_0")
   end

   read_tol_for_shift_on_esd
   ! Read the tolerance for the shift on esd to decide on convergence.
      stdin.read(.tol_for_shift_on_esd)
      ENSURE(.tol_for_shift_on_esd>ZERO,"must be positive")
   end

   read_display_corr_matrix
   ! Read whether to display the correlation matrix.
      stdin.read(.display_correlation_matrix)
   end

   read_display_near_0_evecs
   ! Read whether to display the near 0 eigenvectros of the correlation matrix.
      stdin.read(.display_near_0_eigenvectors)
   end


! ========
! Read CIF
! ========

   read_CIF ::: leaky
   ! Read information from a Crystallographic Information File
   ! with the "name" taken from stdin.

      name :: STR
      found :: BIN
      cif :: CIF*

      ! Read name from stdin
      stdin.read(name)

      ! Create and open the CIF
      cif.create(name)
      cif.open
      cif.find_crystal_data_block(found)
      ENSURE(found,"no crystal data block found") 

      ! Read
      .read_CIF(cif)

      ! Clean
      cif.destroy

   end

   read_CIF(cif) ::: leaky
   ! Read information from a Crystallographic Information File "cif".
      cif :: CIF, IN

      ! Read reflections
      .read_CIF_reflections(cif)

   end

   read_CIF_reflections(cif) ::: leaky
   ! Read information from a Crystallographic Information File "cif".
      cif :: CIF, IN

      there :: VEC{BIN}(5)
      h,k,l :: VEC{INT}*
      Fm,Sg,cov :: VEC{REAL}*

      ! Find reflections
      cif.find_looped_item("_diffrn_refln_index_h",there(1))
      cif.find_looped_item("_diffrn_refln_index_k",there(2))
      cif.find_looped_item("_diffrn_refln_index_l",there(3))
      cif.find_looped_item("_diffrn_refln_F_meas" ,there(4))
      cif.find_looped_item("_diffrn_refln_F_sigma",there(5))

      ! Read reflections
      if (all(there)) then

         ! Read
         cif.read_looped_item("_diffrn_refln_index_h",h)
         cif.read_looped_item("_diffrn_refln_index_h",k)
         cif.read_looped_item("_diffrn_refln_index_h",l)
         cif.read_looped_item("_diffrn_refln_F_meas" ,Fm)
         cif.read_looped_item("_diffrn_refln_F_sigma",Sg)

         ! Create and assign
         .reflections.create(h.dim)
         .reflections.set_h(h)
         .reflections.set_k(k)
         .reflections.set_l(l)
         .reflections.set_F_exp(Fm)
         .reflections.set_F_sigma(Sg)

         ! Clean
         Sg.destroy; Fm.destroy
         l.destroy; k.destroy; h.destroy

      end

   end

   read_CIF_covariance(cif,kind,covariance_matrix) ::: leaky
   ! Read information from a Crystallographic Information File "cif".
      cif :: CIF, IN
      kind :: STR, IN
      covariance_matrix :: MAT{REAL}

      cov :: VEC{REAL}*
      np :: INT
      there :: BIN

      ! Find appropriate kind of covariance matrix
      cif.find_item(trim(kind)//"_covariance_matrix",there)

      if (there) then

         ! Size
         np = covariance_matrix.dim1

         ! Read and set it
         cov.create(np*np)
         cif.read_item(trim(kind)//"_covariance_matrix",cov)
         covariance_matrix = reshape(cov,[np,np])
         cov.destroy

      end

   end


! =======
! Put CIF
! =======

   put_CIF_refinement(psi)
   ! Put refinement information in CIF format
   ! No refinement info. possible without reflections!
      psi :: VEC{STR}, IN

      n :: INT
      R :: REAL
      val :: STR

      if (.reflections.destroyed) return

      stdout.flush
      stdout.text("# ------------------")
      stdout.text("# Refinement details")
      stdout.text("# ------------------")

      stdout.flush
      n   = .reflections.dim
      val = n.to_str
      stdout.text("_reflns_number_gt                  "//trim(val))
      val = "F>"//trim(adjustl(.F_sigma_cutoff.to_str("f5.1")))//"u(F)"
      stdout.text("_reflns_threshold_expression       "//trim(val))

      stdout.flush
      stdout.text("# Tonto-specific keys and data")

      stdout.flush
      stdout.text("_refine_ls_software                'Tonto'")
      stdout.text("_refine_ls_software_version        '"//TONTO_VERSION//" v. "//SVN_VERSION//"'")
      stdout.text("_refine_ls_software_platform       '"//TONTO_PLATFORM//"'")
      stdout.text("_refine_ls_software_build_date     '"//TONTO_BUILD_DATE//"'")
      stdout.text("_refine_ls_kind                    'Hirshfeld atom refinement (HAR)'")

      stdout.flush
      stdout.text("_refine_ls_QM_calc_method          '"//trim(psi(1))//"'")
      stdout.text("_refine_ls_QM_calc_ao_kind         '"//trim(psi(2))//"'")
      stdout.text("_refine_ls_QM_calc_basis           '"//trim(psi(3))//"'")
      stdout.text("_refine_ls_QM_calc_basis_kind      '"//trim(psi(4))//"'")
      stdout.text("_refine_ls_QM_calc_basis_max_l     '"//trim(psi(5))//"'")
      stdout.text("_refine_ls_QM_calc_unit            'As listed in _atom_site[] block'")

      stdout.flush
      val = .tol_near_0.to_str("e9.1")
      stdout.text("_refine_ls_SVD_threshold           "//trim(val))
      stdout.text("_refine_ls_coordinate_system       cartesian")

      stdout.flush
      stdout.text("# Standard CIF keys and data")

      stdout.flush
      stdout.text("_refine_ls_structure_factor_coeff  F")
      stdout.text("_refine_ls_matrix_type             full")
      R   = .F_r_factor
      val = R.to_str("f10.4")
      stdout.text("_refine_ls_R_factor_gt             "//trim(val))
      R   = .F_weighted_r_factor
      val = R.to_str("f10.4")
      stdout.text("_refine_ls_wR_factor_gt            "//trim(R.to_str("f10.4")))
      val = .chi2.to_str("f10.1")
      stdout.text("_refine_ls_goodness_of_fit_ref     "//trim(val))
    ! stdout.text("_refine_ls_restrained_S_all             "//trim(val))
      n   = .reflections.dim
      val = n.to_str
      stdout.text("_refine_ls_number_reflns           "//trim(val))
      stdout.text("_refine_ls_number_parameters       "//trim(.n_param.to_str))
      stdout.text("_refine_ls_number_restraints       0")
      val = .n_near_0.to_str
      stdout.text("_refine_ls_number_constraints      "//trim(val))

      if (.refine_H_ADPs) then
      if (.refine_positions_and_ADPs) then
      stdout.text("_refine_ls_hydrogen_treatment      refall")
      else if (.refine_ADPs_only) then
      stdout.text("_refine_ls_hydrogen_treatment      refU")
      end
      else if (.refine_positions_only) then
      stdout.text("_refine_ls_hydrogen_treatment      refxyz")
      else
      stdout.text("_refine_ls_hydrogen_treatment      ?")
      end

      stdout.text("_refine_ls_weighting_scheme        sigma")
      stdout.text("_refine_ls_weighting_details       'w=1/\s(F)'")

      val = adjustl(.tol_for_shift_on_esd.to_str("f10.4"))
      stdout.text("_refine_ls_shift/su_max            "//trim(val))
    ! stdout.text("_refine_ls_shift/su_mean            ?")

      if (.optimise_extinction) then
      stdout.text("_refine_ls_extinction_method       Zachariasen")
      else
      stdout.text("_refine_ls_extinction_method       none")
      end


   end

   put_CIF_covariance_matrices
   ! Output the covariance matrix in CIF format

      if (.covariance_matrix.created) &
         .put_CIF_covariance_matrix("asym_unit",.covariance_matrix)

      if (.fragment_covariance_matrix.created) &
         .put_CIF_covariance_matrix("fragment", .fragment_covariance_matrix)

   end

   put_CIF_covariance_matrix(kind,covariance_matrix)
   ! Output the covariance matrix in CIF format
      kind :: STR, IN
      covariance_matrix :: MAT{REAL}, IN

   ENSURE(covariance_matrix.is_square,"covariance is not square")

      ! Change defaults
      stdout.save
      stdout.set_real_style("e")
      stdout.set_real_width(15)
      stdout.set_real_precision(8)

      ! Output
      stdout.flush
      stdout.text("# Tonto-specific key and data")

      stdout.flush
      stdout.text("# ")
      stdout.flush
      stdout.text("# NOTE: Cartesian 9Nx9N covariance matrix in BOHR units")
      stdout.text("# The order of the variables (per atom) is as follows:")
      stdout.text("# . Elements 1-3: positions: x y x")
      stdout.text("# . Elements 4-9: 2nd order ADPs:")
      stdout.text("#      U 11 22 33 12 13 23")
      stdout.text("# . Elements 10-19: 3rd order ADPs (if refined):")
      stdout.text("#      U 111 222 333 112 113 122 223 133 233 123")
      stdout.text("# . Elements 20-34: 4th order ADPs (if refined):")
      stdout.text("#      U 1112 1113 1222 2223 1333 2333")
      stdout.text("#        1122 1133 2233 1123 1223 1233")

      stdout.flush
      stdout.text("_"//trim(kind)//"_covariance_matrix")
      stdout.put(covariance_matrix,by_row=TRUE)

      ! Put back defaults
      stdout.unsave

   end


! ===================
! Pruning reflections
! ===================

   prune ::: template
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
      self :: PTR

   ENSURE(.created,"No data")
   ENSURE(.reflections.created,"No reflection data")
   ENSURE(.reflections.have_F_exp,"No experimental data")

      old_reflections :: VEC{REFLECTION}*
      good,bad :: VEC{INT}*
      n_refl,n,i,ib,g,b :: INT
      title :: STR

      ! No. of old reflections
      n_refl = .reflections.n_refl

      ! Find out how many rejects "n" there are
      n = 0
      do i = 1,n_refl
         if (NOT .reflections(i).TEST?(CUTOFF?)) cycle
         n = n + 1
      end

      ! Are there any weak reflections?
      if (n==0) return

      ! Create the "good" and "bad" lists and how many of each
      bad.create(n)
      good.create(n_refl-n)
      g = 0
      b = 0
      do i = 1,n_refl
         if (.reflections(i).TEST?(CUTOFF?)) then
            b = b + 1
            bad(b) = i
         else
            g = g + 1
            good(g) = i
         end
      end

      ! Copy the non-rejects
      old_reflections => .reflections
      .reflections.create(g)
      .reflections.copy(old_reflections(good))

      ! Print out
      stdout.flush
      title = "Reflections pruned"

      stdout.text(repeat("=",len_trim(title)))
      stdout.text(trim(title))
      stdout.text(repeat("=",len_trim(title)))

      ! Banner
      stdout.flush
      stdout.show("Rejection criteria      =","TEST?")
      stdout.show("Cutoff                  =",CUTOFF?)
      stdout.flush
      stdout.show("No. of reflections      =",n_refl)
      stdout.show("No. of rejects          =",b)
      stdout.show("No. of kept reflections =",g)

      if (.show_rejects) then

         stdout.flush
         stdout.text("Table of rejects:")
         stdout.dash(int_fields=3,real_fields=1)
         stdout.put("h",int_width=TRUE)
         stdout.put("k",int_width=TRUE)
         stdout.put("l",int_width=TRUE)
         stdout.put("SHOW?")
         stdout.flush
         stdout.dash(int_fields=3,real_fields=1)
         stdout.flush
         do i = 1,b
            ib = bad(i)
            stdout.put(old_reflections(ib).h)
            stdout.put(old_reflections(ib).k)
            stdout.put(old_reflections(ib).l)
            stdout.put(old_reflections(ib).SHOW?)
            stdout.flush
         end
         stdout.dash(int_fields=3,real_fields=1)

      end

      ! Clean
      old_reflections.destroy
      bad.destroy
      good.destroy

   end

   prune_bad_F_reflections ::: get_from(DIFFRACTION_DATA:prune, TEST?=>has_large_F_z, CUTOFF?=>.F_z_cutoff, SHOW?=>F_z), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_bad_I_reflections ::: get_from(DIFFRACTION_DATA:prune, TEST?=>has_large_I_z, CUTOFF?=>.I_z_cutoff, SHOW?=>I_z), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_high_angle_reflections ::: get_from(DIFFRACTION_DATA:prune, TEST?=>has_high_stl, CUTOFF?=>.stl_cutoff, SHOW?=>stl), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_low_angle_reflections ::: get_from(DIFFRACTION_DATA:prune, TEST?=>has_low_stl, CUTOFF?=>.stl_cutoff SHOW?=>stl), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_negative_F_exp ::: get_from(DIFFRACTION_DATA:prune, TEST?=>has_small_F_exp, CUTOFF?=>ZERO, SHOW?=>F_exp), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_negative_I_exp ::: get_from(DIFFRACTION_DATA:prune, TEST?=>has_small_I_exp, CUTOFF?=>ZERO, SHOW?=>I_exp), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_weak_reflections ::: leaky
   ! This routine eliminates all the reflections which have 
   ! F_exp/F_sigma less than .F_sigma_cutoff or I_exp/I_sigma less
   ! than .I_sigma_cutoff for intensities
      self :: PTR
      if (.refine_F) then; .prune_weak_Fs
      else;                .prune_weak_Is
      end
   end

   prune_weak_Fs ::: get_from(DIFFRACTION_DATA:prune, TEST?=>has_weak_F_exp, CUTOFF?=>.F_sigma_cutoff, SHOW?=>F_exp_on_sigma), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_weak_Is ::: get_from(DIFFRACTION_DATA:prune, TEST?=>has_weak_I_exp, CUTOFF?=>.I_sigma_cutoff, SHOW?=>I_exp_on_sigma), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end


!  ==============
!  Debug printing
!  ==============

   read_debug_on ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and add it to the list.
   end

   read_debug_off ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and remove it from the list.
   end

   debugging(name) result (res) ::: get_from(DEBUG)
   ! Return TRUE if the debug switch "name" has been set.
   end

   put_debug_list ::: get_from(DEBUG)
   ! Put of the list of debug switches
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>REAL)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>VEC{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>MAT{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end


!  ===========
!  Intensities
!  ===========

   lp_factor result (res)
   ! Return the array of the Lorentz Polarization factors for all the
   ! reflections
      res :: VEC{REAL}(size(.reflections))
   ENSURE(.reflections.created,"no reflection data")
      n :: INT
      c,s,two_theta :: REAL
      do n=1, .reflections.n_refl
       two_theta = TWO*.reflections(n).theta
       c = cos(two_theta)
       s = sin(two_theta)
       if (s.is_zero(TOL(8))) then
         res(n) = ZERO
         WARN("lp_factor for (000) reflection set to zero")
       else
         res(n) = (1+c*c)/(TWO*s)
       end
      end
   end

!   I_calc result (res)
!   ! Return the array of calculated intensities *without* extinction
!   ! (but including dispersion if requested). 
!      res :: VEC{REAL}(size(.reflections))
!
!   ENSURE(.reflections.created,"no reflection data")
!   ENSURE(.reflections.have_F_exp, "no calculated structure factors")
!
!      n :: INT
!      F :: REAL
!
!      do n = 1,.reflections.n_refl
!         F      = abs(.reflections(n).F_calc)
!         res(n) = F*F
!      end
!
!   end
!
!   I_pred result (res)
!   ! Return the array of predicted Intensities *with* extinction and
!   ! and with dispersion effects if requested.
!      res :: VEC{REAL}(size(.reflections))
!
!   ENSURE(.reflections.created,"no reflection data")
!   ENSURE(.reflections.have_F_exp, "no calculated structure factors")
!
!      n :: INT
!      F :: REAL
!
!      do n = 1,.reflections.n_refl
!         F      = .reflections(n).F_pred
!         res(n) = F*F
!      end
!
!   end
!
!   I_exp result (res)
!   ! Return the array of experimental Intensities. Only the Lorentz Polarization
!   ! factor and the angular velocity factor for a single crystal are used.
!   ! Fundamental constants appearing in front of this are not calculated
!   ! NOTE: extinction factors, dispersion, multiple scattering corrections
!   ! are not included. These are the experimental intensities with these effects
!   ! removed.
!      res :: VEC{REAL}(size(.reflections))
!   ENSURE(.reflections.created,"no reflection data")
!   ENSURE(.reflections.have_F_exp, "no calculated structure factors")
!      n :: INT
!      c,s,two_theta,F2 :: REAL
!      do n=1, .reflections.n_refl
!       two_theta = TWO*.reflections(n).theta
!       c = cos(two_theta)
!       s = sin(two_theta)
!       F2 = abs(.reflections(n).F_exp)
!       F2 = F2*F2
!       if (s.is_zero(TOL(8))) then
!          res(n) = F2
!       else
!          res(n) = (1+c*c)/(TWO*s)*F2
!       end
!      end
!   end
!
!   I_sigma result (res)
!   ! Return the array of experimental sigma's in the Intensities.
!      res :: VEC{REAL}(size(.reflections))
!   ENSURE(.reflections.created,"no reflection data")
!   ENSURE(.reflections.have_I_pred OR .reflections.have_F_exp, "no structure factors")
!      n :: INT
!      c,s,two_theta,F2 :: REAL
!      if (NOT .reflections.have_F_exp AND NOT .synthesize_sigma_I) then
!       WARN("The synthesize_sigma_I flag was not set; it is now set")
!       .synthesize_sigma_I = TRUE
!      end
!      if (.synthesize_sigma_I) then
!       res = .reflections.I_pred
!       res = sqrt(res/.reflections.equivalence_factor)
!      else
!       do n=1, .reflections.n_refl
!         two_theta = TWO*.reflections(n).theta
!         c = cos(two_theta)
!         s = sin(two_theta)
!         F2 = abs(.reflections(n).F_exp)
!         if (s.is_zero(TOL(8))) then
!           res(n) = F2
!         else
!           res(n) = TWO*(1+c*c)/(TWO*s)*F2
!         end
!       end
!      end
!   end


!  ======================================
!  Scale & extinction factor optimisation
!  ======================================

   make_F_predicted
   ! Make the predicted magnitude of the structure factors, including
   ! possibly an overall scale factor and extinction correction.
      self :: INOUT

   DIE_IF(NOT .reflections.created,"no reflection data")

      F_pred :: VEC{REAL}*
      n_r,n_p :: INT

      ! The number of parameters is assumed set before a refinement
      ! e.g. during get_parameter_shifts in a least-squares
      ! So only fiddle with n_param if this isn't going on.
      if (NOT (.refine_structure OR .fit_structure)) .n_param = 0

      ! Get optimum scale factors, extinction, etc.
      if (.optimise_extinction OR .optimise_scale) .get_F_optimum_parameters

      ! Make F_predicted
      F_pred.create(.reflections.n_refl)
      if (.data_kind=="pnd") then; F_pred = REALIFY(.reflections.F_calc) * .F_extinction_correction
      else;                        F_pred = abs(.reflections.F_calc) * .F_extinction_correction
      end

      ! Mix in some F_exp
      if (.SF_mixing_parameter>ZERO) then
      if (.have_F_exp) then
         F_pred = (ONE-.SF_mixing_parameter)* F_pred &
                + .SF_mixing_parameter      * .reflections.F_exp
      end 
      end 

      ! Set F_predicted
      .reflections.set_F_pred(F_pred)
      F_pred.destroy

      ! Calculate the chi^2; reset denominator
      n_r = .reflections.dim - 1
      n_p = .reflections.dim - .n_param
      .chi2      = max(n_r,1)*.reflections.F_chi2/max(n_p,1)
      .chi2_fit0 = .chi2_fit
      .chi2_fit  = .chi2

      ! Debug
      if (.debugging("make_F_predicted")) then
         stdout.text("chi2_fit0 ="//trim(.chi2_fit0.to_str))
         stdout.text("chi2_fit  ="//trim(.chi2_fit.to_str ))
         .reflections.put
      end

   end

!magda_beginning

   make_I_predicted
   ! Make the predicted squared magnitude of the structure factors, including
   ! possibly an overall scale factor and extinction correction.
      self :: INOUT

   DIE_IF(NOT .reflections.created,"no reflection data")
   DIE_IF(.data_kind=="pnd", "sorry, no PND yet")

      I_pred :: VEC{REAL}*
      n_r,n_p :: INT

      ! The number of parameters is assumed set before a refinement
      ! e.g. during get_parameter_shifts in a least-squares
      ! So only fiddle with n_param if this isn't going on.
      if (NOT (.refine_structure OR .fit_structure)) .n_param = 0

      ! Get optimum scale factors, extinction, etc.
      if (.optimise_extinction OR .optimise_scale) .get_I_optimum_parameters

      ! Make I_predicted
      I_pred.create(.reflections.n_refl)
      I_pred = .reflections.I_calc * .I_extinction_correction

      ! Mix in some F_exp
      if (.SF_mixing_parameter>ZERO) then
      if (.have_I_exp) then
         I_pred = (ONE-.SF_mixing_parameter)* I_pred &
                + .SF_mixing_parameter * .reflections.I_exp
      end 
      end 

      ! Set I_predicted
      .reflections.set_I_pred(I_pred)
      I_pred.destroy

      ! Calculate the chi^2; reset denominator
      n_r = .reflections.dim - 1
      n_p = .reflections.dim - .n_param
      .chi2      = max(n_r,1)*.reflections.I_chi2/max(n_p,1)
      .chi2_fit0 = .chi2_fit
      .chi2_fit  = .chi2

      ! Debug
      if (.debugging("make_I_predicted")) then
         stdout.text("chi2_fit0 ="//trim(.chi2_fit0.to_str))
         stdout.text("chi2_fit  ="//trim(.chi2_fit.to_str ))
         .reflections.put
      end

   end

!magda_end

   update_n_param_and_chi2 ::: private
   ! Update the number of parameters and recalculate the chi2
   DIE_IF(NOT (.refine_structure OR .fit_structure),"must be doing a structure fit/refinement")
   DIE_IF(.n_param<=0,"n_param must be +ve")

      n_r,n_p :: INT

      ! Add on extra parameters
      if (.optimise_extinction) then

         DIE_IF(.use_multiple_scale_factors,"must use optimize_extinction= no")
         .n_param = .n_param + 2

      else if (.optimise_scale) then

         if (.use_multiple_scale_factors) then
            .n_param = .n_param + maxval(.reflections.group)
         else
            .n_param = .n_param + 1
         end

      end

      ! Update the chi2
      n_r = .reflections.dim - 1
      n_p = .reflections.dim - .n_param
      .chi2      = max(n_r,1)*.reflections.F_chi2/max(n_p,1)
      .chi2_fit  = .chi2

      ! Debug
      if (.debugging("update_n_param_and_chi2")) then
         stdout.text("chi2_fit0 ="//trim(.chi2_fit0.to_str))
         stdout.text("chi2_fit  ="//trim(.chi2_fit.to_str ))
         .reflections.put
      end

   end

!!magda_beginning
!
!   update_n_param_and_chi2I ::: private
!   ! Update the number of parameters and recalculate the chi2 for
!   ! refinement against F^2
!   DIE_IF(NOT (.refine_structure OR .fit_structure),"must be doing a structure fit/refinement")
!   DIE_IF(.n_param<=0,"n_param must be +ve")
!
!      n_r,n_p :: INT
!
!      ! Add on extra parameters
!      if (.optimise_extinction) then
!
!         DIE_IF(.use_multiple_scale_factors,"must use optimize_extinction= no")
!         .n_param = .n_param + 2
!
!      else if (.optimise_scale) then
!
!         if (.use_multiple_scale_factors) then
!            .n_param = .n_param + maxval(.reflections.group)
!         else
!            .n_param = .n_param + 1
!         end
!
!      end
!
!      ! Update the chi2
!      n_r = .reflections.dim - 1
!      n_p = .reflections.dim - .n_param
!      .chi2I      = max(n_r,1)*.reflections.I_chi2/max(n_p,1)
!      .chi2I_fit  = .chi2I
!
!      ! Debug
!      if (.debugging("update_n_param_and_chi2")) then
!         stdout.text("chi2I_fit0 ="//trim(.chi2I_fit0.to_str))
!         stdout.text("chi2I_fit  ="//trim(.chi2I_fit.to_str ))
!         .reflections.put
!      end
!
!   end
!
!!magda_end

   get_F_optimum_parameters ::: private
   ! Get the scale factors, extinction parameters, etc, which minimise the chi2.
   ! (To get the corrections cooresponding to these parameters see routine
   ! .extinction_correction)

      if (.optimise_extinction) then

         DIE_IF(.use_multiple_scale_factors,"must use optimize_extinction= no")
         .optimise_F_extinction_factor

      else if (.optimise_scale) then

         if (.use_multiple_scale_factors) then; .optimise_F_scale_factors
         else;                                  .optimise_F_scale_factor
         end

      end

   end

!magda_beginning

   get_I_optimum_parameters ::: private
   ! Get the scale factors, extinction parameters, etc, which minimise the chi2.
   ! (To get the corrections cooresponding to these parameters see routine
   ! .extinction_correction)

      if (.optimise_extinction) then

         DIE_IF(.use_multiple_scale_factors,"must use optimize_extinction= no")
         .optimise_I_extinction_factor

      else if (.optimise_scale) then

         if (.use_multiple_scale_factors) then; .optimise_I_scale_factors
         else;                                  .optimise_I_scale_factor
         end

      end

   end

!magda_end

   F_extinction_correction result (res)
   ! Return the extinction correction  factors "res" to the calculated
   ! individual structure factors. NOTE: also does scale factor
      res :: VEC{REAL}(size(.reflections))

      if (.use_multiple_scale_factors) then
        res = .F_extinction_correction(.scale_factors,.extinction_factor)
      else
        res = .F_extinction_correction(.scale_factor,.extinction_factor)
      end

   end

   I_extinction_correction result (res)
   ! Return the I extinction correction  factors "res" to the calculated
   ! individual structure factors. NOTE: also does scale factor
      res :: VEC{REAL}(size(.reflections))

      if (.use_multiple_scale_factors) then
         res = .I_extinction_correction(.scale_factors,.extinction_factor)
      else
         res = .I_extinction_correction(.scale_factor,.extinction_factor)
      end

   end

   F_extinction_correction(scale_factor,extinction_factor) result (res)
   ! Return the F extinction correction  factors "res" to the calculated
   ! individual structure factors. NOTE: this routine also does scaling
   ! corrections without extinction.
      scale_factor,extinction_factor :: REAL, IN
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")

      F_calc :: CPX
      F_abs2,val :: REAL
      angle_part :: VEC{REAL}*
      n_refl,n :: INT

      n_refl = .reflections.n_refl

      if (extinction_factor.is_zero(TOL(9))) then

        res = scale_factor

      else

         angle_part.create(n_refl)
         angle_part = .extinction_angle_part
         do n=1, n_refl
           F_calc = .reflections(n).F_calc
           F_abs2 = REALIFY(F_calc*conjg(F_calc))
           val    = ONE + extinction_factor*F_abs2*angle_part(n)
           res(n) = scale_factor/sqrt(sqrt(val))
         end
         angle_part.destroy

      end

   end

   I_extinction_correction(scale_factor,extinction_factor) result (res)
   ! Return the extinction correction  factors "res" to the calculated
   ! individual structure factors. NOTE: this routine also does scaling
   ! corrections without extinction.
      scale_factor,extinction_factor :: REAL, IN
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")

      n_refl :: INT

      n_refl = .reflections.n_refl

      if (extinction_factor.is_zero(TOL(9))) then

         res = scale_factor

      else

         DIE("sorry, not yet ...")

      end

   end

   F_extinction_correction(scale_factors,extinction_factor) result (res)
   ! Return the F extinction correction factors "res" to the calculated
   ! individual structure factors. WARNING: this routine in fact does no
   ! extinction correction, only multiple scale factors.
      scale_factors :: VEC{REAL}, IN
      extinction_factor :: REAL, IN
      res :: VEC{REAL}(size(.reflections))

      ENSURE(.reflections.created,"no reflection data")
      ENSURE(.reflections.have_F_calc, "no calculated structure factors")
      ENSURE(scale_factors.dim==maxval(.reflections.group),"no. of scale factors does not match no. of groups")

      F_calc :: CPX
      angle_part :: VEC{REAL}*
      g,n,n_refl,n_group :: INT

      n_refl = .reflections.n_refl
      n_group = scale_factors.dim

      if (extinction_factor.is_zero(TOL(9))) then

       do g = 1,n_group
          do n = 1, n_refl
            if (.reflections(n).group/=g) cycle
            res(n) = scale_factors(g) 
          end
       end

      else

       angle_part.create(n_refl)
       angle_part = .extinction_angle_part
       do g = 1,n_group
          do n = 1, n_refl
            if (.reflections(n).group/=g) cycle
            F_calc = .reflections(n).F_calc
            res(n) = scale_factors(g) / sqrt(sqrt(ONE + &
                extinction_factor*REALIFY(F_calc*conjg(F_calc))*angle_part(n)))
          end
       end
       angle_part.destroy

      end

   end

   I_extinction_correction(scale_factors,extinction_factor) result (res)
   ! Return the extinction correction factors "res" to the calculated
   ! individual structure factors. WARNING: this routine in fact does no
   ! extinction correction, only multiple scale factors.
      scale_factors :: VEC{REAL}, IN
      extinction_factor :: REAL, IN
      res :: VEC{REAL}(size(.reflections))

      ENSURE(.reflections.created,"no reflection data")
      ENSURE(.reflections.have_F_calc, "no calculated structure factors")
      ENSURE(scale_factors.dim==maxval(.reflections.group),"no. of scale factors does not match no. of groups")

      F_calc :: CPX
      angle_part :: VEC{REAL}*
      g,n,n_refl,n_group :: INT

      n_refl = .reflections.n_refl
      n_group = scale_factors.dim

      if (extinction_factor.is_zero(TOL(9))) then

       do g = 1,n_group
          do n = 1, n_refl
            if (.reflections(n).group/=g) cycle
            res(n) = scale_factors(g) 
          end
       end

      else

       DIE("sorry, not yet ...")

      end

   end

   extinction_angle_part result (res) ::: private
   ! Return the angular part of the extinction correction.
      res :: VEC{REAL}(size(.reflections))
      n :: INT
      twotheta,c,s :: REAL
      do n = 1, .reflections.n_refl
       twotheta=TWO*.reflections(n).theta
       c = cos(twotheta)
       s = sin(twotheta)
       res(n) = (ONE+c*c)/(ONE+c*s)
      end
   end

!   optimise_scale_factor
!   ! Determine the best scale factor to apply
!      if (.refine_F) then; .optimise_F_scale_factor
!      else;                .optimise_I_scale_factor
!      end
!   end

   optimise_F_scale_factor
   ! Determine the structure factor scale factor to scale the calculated
   ! structure factors .F_calc by in order to minimise the chi2. (But it does
   ! not do any scaling; see .extinction_correction routine for that)
   DIE_IF(NOT .reflections.created,"no reflection data")
   DIE_IF(NOT .reflections.have_F_calc, "no calculated structure factors")
   DIE_IF(NOT .reflections.have_F_exp, "no experimental structure factors")
   DIE_IF(NOT .reflections.have_F_sigma, "no structure factor errors")

      top,bot,sg2,F_pred :: REAL
      n,n_refl :: INT
      ref :: REFLECTION*

      n_refl = .reflections.n_refl

      top = ZERO
      bot = ZERO
      do n = 1,n_refl
       ref => .reflections(n)
       if (.data_kind=="pnd") then; F_pred = REALIFY(ref.F_calc)
       else;                        F_pred = abs(ref.F_calc)
       end
       ENSURE(ref.F_sigma/=ZERO,"Structure factor has zero error!")
       sg2 = ONE / (ref.F_sigma * ref.F_sigma)
       top = top + F_pred * ref.F_exp * sg2
       bot = bot + F_pred * F_pred * sg2
      end

      .scale_factor = top/bot

      ! The number of parameters is assumed set before a refinement
      ! e.g. during get_parameter_shifts in a least-squares
      ! So only fiddle with n_param if this isn't going on.
      if (NOT (.refine_structure OR .fit_structure)) .n_param = .n_param + 1

   end

   optimise_I_scale_factor
   ! Determine the structure factor scale factor to scale the calculated
   ! structure factors .F_calc by in order to minimise the chi2. (But it does
   ! not do any scaling; see .extinction_correction routine for that)
   DIE_IF(NOT .reflections.created,"no reflection data")
   DIE_IF(NOT .reflections.have_I_calc, "no calculated I's")
   DIE_IF(NOT .reflections.have_I_exp, "no experimental I's")
   DIE_IF(NOT .reflections.have_I_sigma, "no I sigma's")
   DIE_IF(.data_kind=="pnd", "sorry, noy yet ...")

      top,bot,sg2,I_pred :: REAL
      n,n_refl :: INT
      ref :: REFLECTION*

      n_refl = .reflections.n_refl

      top = ZERO
      bot = ZERO

      do n = 1,n_refl

         ref => .reflections(n)

         I_pred = ref.I_calc

         ENSURE(ref.I_sigma/=ZERO,"Structure factor has zero error!")

         sg2 = ONE / (ref.I_sigma * ref.I_sigma)
         top = top + I_pred * ref.I_exp * sg2
         bot = bot + I_pred * I_pred * sg2

      end

      .scale_factor = top/bot

      ! The number of parameters is assumed set before a refinement
      ! e.g. during get_parameter_shifts in a least-squares
      ! So only fiddle with n_param if this isn't going on.
      if (NOT (.refine_structure OR .fit_structure)) .n_param = .n_param + 1

   end

!magda_end

   optimise_F_scale_factors ::: leaky
   ! Multiple scale factors are determined here ...
   ! Determine the structure factor scale factors to scale the calculated
   ! structure factors .F_calc by in order to minimise the chi2. (But it does
   ! not do any scaling; see .extinction_correction routine for that)
   DIE_IF(NOT .reflections.created,"no reflection data")
   DIE_IF(NOT .reflections.have_F_calc, "no calculated structure factors")
   DIE_IF(NOT .reflections.have_F_exp, "no experimental structure factors")
   DIE_IF(NOT .reflections.have_F_sigma, "no structure factor errors")
   DIE_IF(NOT .use_multiple_scale_factors, "no reflection group numbers")

      top,bot,F_pred :: REAL
      g,n,n_refl,n_group :: INT
      ref :: REFLECTION*

      n_group = maxval(.reflections.group)
      n_refl = .reflections.n_refl

      .scale_factors.destroy
      .scale_factors.create(n_group)

      do g = 1,n_group
        top = ZERO
        bot = ZERO
        do n = 1,n_refl
          ref => .reflections(n)
          if (ref.group/=g) cycle
          if (.data_kind=="pnd") then; F_pred = REALIFY(ref.F_calc)
          else;                        F_pred = abs(ref.F_calc)
          end
          ENSURE(ref.F_sigma/=ZERO,"Structure factor has zero error!")
          top = top + F_pred * ref.F_exp  / (ref.F_sigma * ref.F_sigma)
          bot = bot + F_pred * F_pred / (ref.F_sigma * ref.F_sigma)
        end
        .scale_factors(g) = top/bot
      end

      ! The number of parameters is assumed set before a refinement
      ! e.g. during get_parameter_shifts in a least-squares
      ! So only fiddle with n_param if this isn't going on.
      if (NOT (.refine_structure OR .fit_structure)) .n_param = .n_param + n_group

   end

   optimise_I_scale_factors ::: leaky
   ! Multiple scale factors are determined here ...
   ! Determine I scale factors to scale the calculated
   ! .I_calc by in order to minimise the chi2I. (But it does
   ! not do any scaling; see .extinction_correction routine for that)
   DIE_IF(NOT .reflections.created,"no reflection data")
   DIE_IF(NOT .reflections.have_I_calc, "no calculated structure factors")
   DIE_IF(NOT .reflections.have_I_exp, "no experimental structure factors")
   DIE_IF(NOT .reflections.have_I_sigma, "no structure factor errors")
   DIE_IF(NOT .use_multiple_scale_factors, "no reflection group numbers")
   DIE_IF(.data_kind=="pnd", "sorry, no polarized neutron diffraction")

      top,bot,I_pred :: REAL
      g,n,n_refl,n_group :: INT
      ref :: REFLECTION*

      n_group = maxval(.reflections.group)
      n_refl = .reflections.n_refl

      .scale_factors.destroy
      .scale_factors.create(n_group)

      do g = 1,n_group
        top = ZERO
        bot = ZERO
        do n = 1,n_refl
          ref => .reflections(n)
          if (ref.group/=g) cycle
          I_pred = ref.I_calc
          ENSURE(ref.I_sigma/=ZERO,"Structure factor has zero error!")
          top = top + I_pred * ref.I_exp  / (ref.I_sigma * ref.I_sigma)
          bot = bot + I_pred * I_pred / (ref.I_sigma * ref.I_sigma)
        end
        .scale_factors(g) = top/bot
      end

      ! The number of parameters is assumed set before a refinement
      ! e.g. during get_parameter_shifts in a least-squares
      ! So only fiddle with n_param if this isn't going on.
      if (NOT (.refine_structure OR .fit_structure)) .n_param = .n_param + n_group

   end

!magda_end

   optimise_F_extinction_factor
   ! Optimize the .scale_factor and .extinction_factor parameter of Larson's
   ! method.
   ! NOTE: the corrections are not applied to .F_pred; use the routine
   ! .extinction_corrections to do that.
   ! Reference: Larson, A. C., in <I>Crystallographic Computing</I>
   !            Ed. Ahmed, F. R. (Copenhagen, Munksgaard 1970), pp. 291-294.
      self :: target
      p :: VEC{REAL}(2)
      chi2_min :: REAL

      ! Get starting scale factor
      .optimise_F_scale_factor

      ! Do a 2-variable minimisation
      p(1) = .scale_factor
      p(2) = ZERO          ! This is the .extinction_factor
      saved_self => self
      VEC{REAL}:minimise_BFGS(::chi2,::d_chi2,p,chi2_min,tol=TOL(7),gtol=TOL(7),step=TOL(4))
      .scale_factor = p(1)
      .extinction_factor = p(2)

      ! The number of parameters is assumed set before a refinement
      ! e.g. during get_parameter_shifts in a least-squares
      ! So only fiddle with n_param if this isn't going on.
      ! NOTE: one was already added to .n_param when getting the initial scale
      if (NOT (.refine_structure OR .fit_structure)) .n_param = .n_param + 1

   end

   optimise_I_extinction_factor
   ! Optimize the .scale_factor and .extinction_factor parameter of Larson's
   ! method.
   ! NOTE: the corrections are not applied to .F_pred; use the routine
   ! .extinction_corrections to do that.
   ! Reference: Larson, A. C., in <I>Crystallographic Computing</I>
   !            Ed. Ahmed, F. R. (Copenhagen, Munksgaard 1970), pp. 291-294.
      self :: target
      p :: VEC{REAL}(2)
      chi2_min :: REAL

      ! Get starting scale factor
      .optimise_I_scale_factor

      ! Do a 2-variable minimisation
      p(1) = .scale_factor
      p(2) = ZERO          ! This is the .extinction_factor
      saved_self => self
      VEC{REAL}:minimise_BFGS(::chi2I,::d_chi2I,p,chi2_min,tol=TOL(7),gtol=TOL(7),step=TOL(6))
      .scale_factor = p(1)
      .extinction_factor = p(2)

      ! The number of parameters is assumed set before a refinement
      ! e.g. during get_parameter_shifts in a least-squares
      ! So only fiddle with n_param if this isn't going on.
      ! NOTE: one was already added to .n_param when getting the initial scale
      if (NOT (.refine_structure OR .fit_structure)) .n_param = .n_param + 1

   end

   chi2(p) result (res) ::: selfless
   ! Make the chi2 between the calculated and experimental structure factors
   ! with extinction and scale parameters stored in vector p.
      p :: VEC{REAL}, IN
      res :: REAL

   ENSURE(saved_self.reflections.created,"no reflection data")
   ENSURE(saved_self.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(saved_self.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(saved_self.reflections.have_F_sigma, "no structure factor errors")
   ENSURE(size(p)==2, "wrong size, p")

      tmp,tmp1 :: REAL
      ext :: VEC{REAL}*
      ref :: REFLECTION*
      n,n_refl :: INT
      self :: DIFFRACTION_DATA*

      self => saved_self

      n_refl = .reflections.n_refl

      ext.create(n_refl)
      ext = .F_extinction_correction(p(1),p(2))

      tmp = ZERO
      do n=1,n_refl
       ref => .reflections(n)
       tmp1 = (abs(ref.F_calc) * ext(n) - ref.F_exp) / ref.F_sigma
       tmp = tmp + tmp1 * tmp1
      end
      res = tmp / max(n_refl-.n_param,1)
      ext.destroy

   end

!magda_beginning

   chi2I(p) result (res) ::: selfless
   ! Make the chi2 between the calculated and experimental squared
   ! structure factors
   ! with extinction and scale parameters stored in vector p.
      p :: VEC{REAL}, IN
      res :: REAL

   ENSURE(saved_self.reflections.created,"no reflection data")
   ENSURE(saved_self.reflections.have_I_calc, "no calculated structure factors")
   ENSURE(saved_self.reflections.have_I_exp, "no experimental structure factors")
   ENSURE(saved_self.reflections.have_I_sigma, "no structure factor errors")
   ENSURE(size(p)==2, "wrong size, p")

      tmp,tmp1 :: REAL
      ext :: VEC{REAL}*
      ref :: REFLECTION*
      n,n_refl :: INT
      self :: DIFFRACTION_DATA*

      self => saved_self
      n_refl = .reflections.n_refl

      ext.create(n_refl)
      ext = .I_extinction_correction(p(1),p(2))

      tmp = ZERO
      do n=1,n_refl
         ref => .reflections(n)
         tmp1 = (ref.I_calc * ext(n) - ref.I_exp) / ref.I_sigma
         tmp = tmp + tmp1 * tmp1
      end
      res = tmp / max(n_refl-.n_param,1)

      ext.destroy

   end

!magda_end
   d_chi2(p) result (res) ::: selfless
   ! Return the derivative of the chi2 with respect to the .scale_factor in
   ! p(1), and with respect to .extinction_factor in p(2). This routine is for
   ! use in the BFGS minimiser.
      p :: VEC{REAL}, IN
      res :: VEC{REAL}(size(p))
   ENSURE(size(p)==2, "wrong size, p")
      self :: DIFFRACTION_DATA*
      self => saved_self
      res(1) = .d_chi2_d_scale(p)
      res(2) = .d_chi2_d_ext(p)
   end

!skonczylismy tutaj
   d_chi2I(p) result (res) ::: selfless
   ! Return the derivative of the chi2 with respect to the .scale_factor in
   ! p(1), and with respect to .extinction_factor in p(2). This routine is for
   ! use in the BFGS minimiser.
      p :: VEC{REAL}, IN
      res :: VEC{REAL}(size(p))
   ENSURE(size(p)==2, "wrong size, p")
      self :: DIFFRACTION_DATA*
      self => saved_self
      res(1) = .d_chi2I_d_scale(p)
      res(2) = .d_chi2I_d_ext(p)
   end

   d_chi2_d_scale(p) result (res)
   ! Derivative of the chi^2 for F with respect to the scale factor
      p :: VEC{REAL}, IN
      res :: REAL

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
   ENSURE(size(p)==2, "wrong size, p")

      tmp,F_pred :: REAL
      ext :: VEC{REAL}*
      ref :: REFLECTION*
      n,n_refl :: INT

      n_refl = .reflections.n_refl

      ext.create(n_refl)
      ext = .F_extinction_correction(p(1),p(2))

      tmp = ZERO
      do n=1,n_refl
       ref => .reflections(n)
       F_pred = abs(ref.F_calc) * ext(n)
       tmp = tmp + F_pred * (F_pred - ref.F_exp) / (ref.F_sigma*ref.F_sigma)
      end
      res = TWO*tmp/(p(1)*max(n_refl-.n_param,1))

      ext.destroy

   end

   !magda_beginnning
   d_chi2I_d_scale(p) result (res)
   ! Derivative of the chi^2 for I with respect to the scale factor
      p :: VEC{REAL}, IN
      res :: REAL

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_I_calc, "no calculated structure factors")
   ENSURE(.reflections.have_I_exp, "no experimental structure factors")
   ENSURE(.reflections.have_I_sigma, "no structure factor errors")
   ENSURE(size(p)==2, "wrong size, p")

      tmp,I_pred :: REAL
      ext :: VEC{REAL}*
      ref :: REFLECTION*
      n,n_refl :: INT

      n_refl = .reflections.n_refl

      ext.create(n_refl)
      ext = .I_extinction_correction(p(1),p(2))

      tmp = ZERO
      do n=1,n_refl
       ref => .reflections(n)
       I_pred = ref.I_calc * ext(n)
       tmp = tmp + I_pred * (I_pred - ref.I_exp) / (ref.I_sigma*ref.I_sigma)
      end
      res = FOUR*tmp/max(n_refl-.n_param,1)

      ext.destroy

   end
   !magda_end

   d_chi2_d_ext(p) result (res)
   ! Derivative of the chi^2 for F with respect to the extinction parameter.
      p :: VEC{REAL}, IN
      res :: REAL

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
   ENSURE(size(p)==2, "wrong size, p")

      tmp,extn,p1 :: REAL
      angle_bit,ext :: VEC{REAL}*
      ref :: REFLECTION*
      n,n_refl :: INT

      n_refl = .reflections.n_refl

      angle_bit.create(n_refl)
      ext.create(n_refl)

      angle_bit = .extinction_angle_part

      p1 = p(1)
      ext = .F_extinction_correction(ONE,p(2))

      tmp = ZERO
      do n = 1,n_refl
       ref => .reflections(n)
       extn = ext(n)
       tmp = tmp + (p1 * abs(ref.F_calc) * extn - ref.F_exp) * &
           extn*extn*extn*extn*extn* &
           REALIFY(ref.F_calc*ref.F_calc*ref.F_calc) * &
           angle_bit(n) / (ref.F_sigma * ref.F_sigma)
      end
      res = -p1*tmp/(TWO * max(n_refl-.n_param,1))

      ext.destroy
      angle_bit.destroy

   end

!magda_beginning
   d_chi2I_d_ext(p) result (res)
   ! Derivative of the chi^2 for I with respect to the extinction parameter.
      p :: VEC{REAL}, IN
      res :: REAL
   DIE("Sorry...")
!   ENSURE(.reflections.created,"no reflection data")
!   ENSURE(.reflections.have_I_calc, "no calculated structure factors")
!   ENSURE(.reflections.have_I_exp, "no experimental structure factors")
!   ENSURE(.reflections.have_I_sigma, "no structure factor errors")
!   ENSURE(size(p)==2, "wrong size, p")
!
!      tmp,extn,p1 :: REAL
!      angle_bit,ext :: VEC{REAL}*
!      ref :: REFLECTION*
!      n,n_refl :: INT
!
!      n_refl = .reflections.n_refl
!
!      angle_bit.create(n_refl)
!      ext.create(n_refl)
!
!      angle_bit = .extinction_angle_part
!
!      p1 = p(1)
!      ext = .I_extinction_correction(ONE,p(2))
!
!      tmp = ZERO
!      do n = 1,n_refl
!       ref => .reflections(n)
!       extn = ext(n)
!       tmp = tmp + (p1 * ref.I_calc * extn - ref.I_exp) * &
!           extn*extn*extn*extn*extn* &
!           ref.I_calc*ref.I_calc*ref.I_calc * &
!           angle_bit(n) / (ref.I_sigma * ref.I_sigma)
!      end
!      res = -p1*tmp/(TWO * max(n_refl-.n_param,1))
!
!      ext.destroy
!      angle_bit.destroy
!
   end
   !magda_end

   d_chi2_dX(res,dFdX)
   ! Evaluate "res", the derivative of the chi^2 with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the complex structure factors w.r.t. the X
   ! parameters.  NOTE: this routine assumes the .extinction_factor
   ! is fixed.
      res :: VEC{REAL}, OUT
      dFdX :: MAT{CPX}, IN

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dF")
   ENSURE(dFdX.dim2==res.dim, "incompatible dFdX and res")

      Fcd_conjgFcalc :: VEC{CPX}*
      ref :: REFLECTION*
      ext,angle_bit,d_scale :: VEC{REAL}*
      Fcd,Fca,fac,extn,ext5,sg2,sdk,nrinv :: REAL
      n_refl,n_p,p,n :: INT
 
      n_refl = .reflections.n_refl
      n_p = dFdX.dim2

      Fcd_conjgFcalc.create(n_refl)

      ext.create(n_refl)
      ext = .F_extinction_correction(ONE,.extinction_factor)

      angle_bit.create(n_refl)
      angle_bit = .extinction_angle_part

      sdk = ZERO
      do n = 1,n_refl
         ref => .reflections(n)
         extn = ext(n)
         ext5 = extn*extn*extn*extn*extn*.extinction_factor
         Fca = abs(ref.F_calc)
         sg2 = ONE/(ref.F_sigma*ref.F_sigma)
         fac = (.scale_factor*extn*Fca - ref.F_exp)*sg2
         Fcd = fac * (extn/Fca - HALF*ext5*angle_bit(n))
         Fcd_conjgFcalc(n) = Fcd * conjg(ref.F_calc)
         sdk = sdk + fac*extn*Fca
      end

      angle_bit.destroy
      ext.destroy

      d_scale.create(n_p)
      .d_scale_dX(d_scale,dFdX)

      nrinv = ONE/max(n_refl-.n_param,1)
      sdk = TWO*nrinv*sdk
      fac = TWO*.scale_factor*nrinv

      do p = 1,n_p
         res(p) = sdk*d_scale(p) + fac * VEC{REAL}:sum( REALIFY(Fcd_conjgFcalc * dFdX(:,p)) )
      end
      d_scale.destroy
      Fcd_conjgFcalc.destroy

   end
   
   !magda_beginning
   d_chi2I_dX(res,dIdX)
   ! Evaluate "res", the derivative of the chi^2 with respect to some
   ! parameters X (e.g. thermal parameters) given "dIdX", the
   ! derivatives of the square structure factors w.r.t. the X
   ! parameters.  NOTE: this routine assumes the .extinction_factor
   ! is fixed.
      res :: VEC{REAL}, OUT
      dIdX :: MAT{CPX}, IN
   DIE("Sorry...")
!   ENSURE(.reflections.created,"no reflection data")
!   ENSURE(.reflections.have_I_calc, "no calculated I")
!   ENSURE(.reflections.have_I_exp, "no experimental I")
!   ENSURE(.reflections.have_I_sigma, "no I errors")
!   ENSURE(dIdX.dim1==.reflections.n_refl, "wrong size, dI")
!   ENSURE(dIdX.dim2==res.dim, "incompatible dIdX and res")
!
!      Icd_Icalc :: VEC{CPX}*
!      ref :: REFLECTION*
!      ext,angle_bit,d_scale :: VEC{REAL}*
!      Icd,Ica,fac,extn,ext5,sg2,sdk,nrinv :: REAL
!      n_refl,n_p,p,n :: INT
! 
!      n_refl = .reflections.n_refl
!      n_p = dIdX.dim2
!
!      Icd_Icalc.create(n_refl)
!
!      ext.create(n_refl)
!      ext = .I_extinction_correction(ONE,.extinction_factor)
!
!      angle_bit.create(n_refl)
!      angle_bit = .extinction_angle_part
!
!      sdk = ZERO
!      do n = 1,n_refl
!         ref => .reflections(n)
!         extn = ext(n)
!         ext5 = extn*extn*extn*extn*extn*.extinction_factor
!         Ica = ref.I_calc
!         sg2 = ONE/(ref.I_sigma*ref.I_sigma)
!         fac = (.scale_factor*extn*Ica - ref.I_exp)*sg2
!         Icd = fac * (extn/Ica - HALF*ext5*angle_bit(n))
!         Icd_Icalc(n) = Icd * ref.I_calc
!         sdk = sdk + fac*extn*Ica
!      end
!
!      angle_bit.destroy
!      ext.destroy
!
!      d_scale.create(n_p)
!      .d_scale_dX(d_scale,dIdX)
!
!      nrinv = ONE/max(n_refl-.n_param,1)
!      sdk = TWO*nrinv*sdk
!      fac = TWO*.scale_factor*nrinv
!
!      do p = 1,n_p
!         res(p) = sdk*d_scale(p) + fac * sum( REALIFY(Icd_Icalc * dIdX(:,p)) )
!      end
!      d_scale.destroy
!      Icd_Icalc.destroy

   end
   !magda_end

   d_chi2_dX_plus_se(res,dFdX)
   ! Evaluate "res", the derivative of the chi^2 with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the complex structure factors w.r.t. the X
   ! parameters. Two extra derivatives are included, w.r.t. the
   ! extinction parameter and the scale factor.
      res :: VEC{REAL}, OUT
      dFdX :: MAT{CPX}, IN

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dF")
   ENSURE(dFdX.dim2==res.dim-2, "incompatible dFdX and res")

      Fcd_conjgFcalc :: VEC{CPX}*
      ref :: REFLECTION*
      ext,angle_bit :: VEC{REAL}*
      Fcd,Fca,fac,extn,ext5,extf, Fe,Fs :: REAL
      n_refl,n_p,p,n :: INT
 
      ! Constants
      n_refl = .reflections.n_refl
      n_p = dFdX.dim2

      ! Temporaries
      angle_bit.create(n_refl)
      ext.create(n_refl)
      Fcd_conjgFcalc.create(n_refl)

      ! Different parts of the extinction
      angle_bit = .extinction_angle_part
      ext = .F_extinction_correction(ONE,.extinction_factor)

      ! Make parameter prefactor derivative
      Fe = ZERO
      Fs = ZERO
      do n = 1,n_refl
         ref => .reflections(n)
         extn = ext(n)
         ext5 = extn*extn*extn*extn*extn
         extf = ext5*.extinction_factor
         Fca = abs(ref.F_calc)
         fac = (.scale_factor*extn*Fca - ref.F_exp)/(ref.F_sigma*ref.F_sigma)
         Fcd = fac * (extn/Fca - HALF*extf*angle_bit(n))
         Fcd_conjgFcalc(n) = Fcd * conjg(ref.F_calc)
         ! Extinction part
         Fe = Fe - fac*QUARTER*.scale_factor*ext5*Fca*Fca*Fca*angle_bit(n)
         ! Scale part
         Fs = Fs + fac*extn*Fca
      end

      ! Parameter derivatives
      fac = TWO*.scale_factor/max(n_refl-.n_param,1)
      do p = 1,n_p
         res(p) = fac * VEC{REAL}:sum( REALIFY(Fcd_conjgFcalc * dFdX(:,p)) )
      end

      ! Extinction and scale derivatives
      res(n_p+1) = fac*Fe
      res(n_p+2) = fac*Fs

      ! Cleanup
      Fcd_conjgFcalc.destroy
      ext.destroy
      angle_bit.destroy

   end
   
   !magda_beginning
   d_chi2I_dX_plus_se(res,dIdX)
   ! Evaluate "res", the derivative of the chi^2 with respect to some
   ! parameters X (e.g. thermal parameters) given "dIdX", the
   ! derivatives of the complex structure factors w.r.t. the X
   ! parameters. Two extra derivatives are included, w.r.t. the
   ! extinction parameter and the scale factor.
      res :: VEC{REAL}, OUT
      dIdX :: MAT{CPX}, IN
   DIE("Sorry...")
!   ENSURE(.reflections.created,"no reflection data")
!   ENSURE(.reflections.have_I_calc, "no calculated structure factors")
!   ENSURE(.reflections.have_I_exp, "no experimental structure factors")
!   ENSURE(.reflections.have_I_sigma, "no structure factor errors")
!   ENSURE(dIdX.dim1==.reflections.n_refl, "wrong size, dI")
!   ENSURE(dIdX.dim2==res.dim-2, "incompatible dIdX and res")
!
!      Icd_Icalc :: VEC{CPX}*
!      ref :: REFLECTION*
!      ext,angle_bit :: VEC{REAL}*
!      Icd,Ica,fac,extn,ext5,extf, Ie,Is :: REAL
!      n_refl,n_p,p,n :: INT
! 
!      ! Constants
!      n_refl = .reflections.n_refl
!      n_p = dIdX.dim2
!
!      ! Temporaries
!      angle_bit.create(n_refl)
!      ext.create(n_refl)
!      Icd_Icalc.create(n_refl)
!
!      ! Different parts of the extinction
!      angle_bit = .extinction_angle_part
!      ext = .I_extinction_correction(ONE,.extinction_factor)
!
!      ! Make parameter prefactor derivative
!      Ie = ZERO
!      Is = ZERO
!      do n = 1,n_refl
!         ref => .reflections(n)
!         extn = ext(n)
!         ext5 = extn*extn*extn*extn*extn
!         extf = ext5*.extinction_factor
!         Ica = ref.I_calc
!         fac = (.scale_factor*extn*Ica - ref.I_exp)/(ref.I_sigma*ref.I_sigma)
!         Icd = fac * (extn/Ica - HALF*extf*angle_bit(n))
!         Icd_Icalc(n) = Icd * ref.I_calc
!         ! Extinction part
!         Ie = Ie - fac*QUARTER*.scale_factor*ext5*Ica*Ica*Ica*angle_bit(n)
!         ! Scale part
!         Is = Is + fac*extn*Ica
!      end
!
!      ! Parameter derivatives
!      fac = TWO*.scale_factor/max(n_refl-.n_param,1)
!      do p = 1,n_p
!         res(p) = fac * sum( Icd_Icalc * dIdX(:,p) )
!      end
!
!      ! Extinction and scale derivatives
!      res(n_p+1) = fac*Ie
!      res(n_p+2) = fac*Is
!
!      ! Cleanup
!      Icd_Icalc.destroy
!      ext.destroy
!      angle_bit.destroy

   end
!magda_end

   d_scale_dX(res,dFdX)
   ! Return "res" the derivative of the scale factor with respect to
   ! parameters X, where the *complex* structure factor parameter
   ! derivatives are given in "dFdX". This takes into account an
   ! existing extinction factor.
      res :: VEC{REAL}, OUT
      dFdX :: MAT{CPX}, IN

   DIE_IF(NOT .reflections.created,"no reflection data")
   DIE_IF(NOT .reflections.have_F_calc, "no calculated structure factors")
   DIE_IF(NOT .reflections.have_F_exp, "no experimental structure factors")
   DIE_IF(NOT .reflections.have_F_sigma, "no structure factor errors")
   ENSURE(.data_kind=="x-ray","only valie for X-ray data, so far")
   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dFdX")
   ENSURE(dFdX.dim2==res.dim, "incompatible res, dFdX")

      top,bot,fac,sg2,F_abs,F_exp,F_sig,extn,val1,val2 :: REAL
      dt,db :: VEC{CPX}*
      ext   :: VEC{REAL}*
      F_cal,dF :: CPX
      n,n_refl,p :: INT
      ref :: REFLECTION*

      n_refl = .reflections.n_refl

      dt.create(n_refl)
      db.create(n_refl)

      ext.create(n_refl)
      ext = .F_extinction_correction(ONE,.extinction_factor)

      top = ZERO
      bot = ZERO
      do n = 1,n_refl
       ref => .reflections(n)
       extn = ext(n)
       F_cal = extn*conjg(ref.F_calc)
       F_abs = abs(F_cal)
       F_exp = abs(ref.F_exp)
       F_sig = ref.F_sigma
       ENSURE(F_sig/=ZERO,"Structure factor has zero error!")
       sg2 = ONE / (F_sig * F_sig)
       dt(n) = extn * F_exp * sg2 * F_cal / F_abs
       db(n) = extn * sg2 * F_cal
       F_abs = extn * F_abs
       top = top + F_abs * F_exp * sg2
       bot = bot + F_abs * F_abs * sg2
      end
      ext.destroy

      bot = ONE/bot
      fac = -TWO*top*bot*bot
      do p = 1,dFdX.dim2
         val1 = ZERO
         val2 = ZERO
         do n = 1,n_refl
            dF = dFdX(n,p)
            val1 = val1 + REALIFY(dt(n)*dF) 
            val2 = val2 + REALIFY(db(n)*dF)
         end
         res(p) = bot*val1 + fac*val2
      end

      db.destroy
      dt.destroy

   end


!  ====================
!  Structure refinement
!  ====================
 
   refine_positions_and_ADPs result (res)
   ! A refinement of all positions and ADP's
      res :: BIN
      res =   NOT .refine_positions_only &
          AND NOT .refine_ADPs_only 
   end
 
   refine_3rd_order result (res)
   ! Refineme third-order anharmonicity for any atoms?
      res :: BIN
      res =  .refine_3rd_order_for_atom.created
   end
 
   refine_4th_order result (res)
   ! Refineme fourth-order anharmonicity for any atoms?
      res :: BIN
      res =  .refine_4th_order_for_atom.created
   end
 
   no_of_3rd_order_atoms result (res)
   ! The number of atoms on which there are third-order anharmonicity
   ! parameters
      res :: INT
      res = 0
      if (.refine_3rd_order_for_atom.created) res = .refine_3rd_order_for_atom.dim
   end
 
   no_of_4th_order_atoms result (res)
   ! The number of atoms on which there are third-order anharmonicity
   ! parameters
      res :: INT
      res = 0
      if (.refine_4th_order_for_atom.created) res = .refine_4th_order_for_atom.dim
   end

!  Fit/refinement initialization

   initialize_fit_data(n_p,n_f,labels) ::: leaky
   ! Create the fit data arrays & initialize if needed.
   ! "n_p" is the number of unique pADP's to refine.
   ! "n_f" is the number of non-unique fragment atom pADP's.
   ! Some of these arrays will already be created if refining.
      n_p,n_f :: INT, IN
      labels :: VEC{STR}, IN

      ! Reset fit data 
      .destroy_fit_data
      .set_fit_data

      ! Set fitting
      if (NOT .refine_structure) .set_fit_structure(TRUE)

      ! Initially chi^2 is as big as you can get
      .chi2_fit0 = huge(ONE)

      ! Set the uique # of parameters. Used for getting the correct
      ! chi^2 statistic. Note: zero eigenvalues in the least squares
      ! will modify this value.
      .n_param = n_p

      ! Create parameter vectors & shifts (leaky)
      .dX.create(n_p)
      .X_fit.create(n_p)
      .X_fit0.create(n_p)

      ! Create esd's and covariances
      .esd.create(n_p)
      .covariance_matrix.create(n_p,n_p)
      .correlation_matrix.create(n_p,n_p)
      .fragment_covariance_matrix.create(n_f,n_f)

      ! Set esd's to zero
      .esd = ZERO

      ! Create the table (leaky)
      .fit_table.create(8)

      ! Fit table headings
      .fit_table(1).set_heading("Fit")
      .fit_table(1).set_subhead("Iter")
      .fit_table(2).set_heading("chi2")
      .fit_table(3).set_heading("R")
      .fit_table(4).set_heading("R_w")
      .fit_table(5).set_heading("Max.")
      .fit_table(5).set_subhead("Shift")
      .fit_table(5).set_sb3head("/esd")
      .fit_table(6).set_heading("Max.")
      .fit_table(6).set_subhead("Shift")
      .fit_table(6).set_sb3head("param")
      .fit_table(7).set_heading("No. of")
      .fit_table(7).set_subhead("params")
      .fit_table(8).set_heading("No. of")
      .fit_table(8).set_subhead("eig's")
      .fit_table(8).set_sb3head("near 0")

      ! Table widths (needs to be here because of label width)
      .fit_table(1).set_width_from(.max_iterations) ! Iter
      .fit_table(2).set_width_from(TEN**3)          ! chi2
      .fit_table(3).set_width_from(ONE)             ! R
      .fit_table(4).set_width_from(ONE)             ! Rw
      .fit_table(5).set_width_from(TEN*TEN)         ! Max shift/esd
      .fit_table(6).set_width_from(labels)          ! Max shift par
      .fit_table(7).set_width(3)                    ! n_param
      .fit_table(8).set_width(3)                    ! n_near_0

   end

   initialize_refinement_data(n_p,labels) ::: leaky
   ! Create the refinement data arrays & initialize if needed
   ! "n_p" is the number of unique pADP's to refine.
      n_p :: INT, IN
      labels :: VEC{STR}, IN

   ENSURE(.ref_iteration==0,"ref_iteration is not 0!")

      ! Destroy existing data (leaky)
      .destroy_refinement_data
      .set_refinement_data

      ! Initially chi^2 is as big as you can get
      .chi2_ref0 = huge(ONE)

      ! Create parameter vectors (leaky)
      .X_ref.create(n_p)
      .X_ref0.create(n_p)

      ! Refinement table headings
      .ref_table.create(9)
      .ref_table(1).set_heading("Ref.")
      .ref_table(1).set_subhead("Iter")
      .ref_table(2).set_heading("No of")
      .ref_table(2).set_subhead("  Fit")
      .ref_table(2).set_sb3head("iters")
      .ref_table(3).set_heading("chi2")
      .ref_table(3).set_subhead("initial")
      .ref_table(4).set_heading("chi2")
      .ref_table(4).set_subhead("final")
      .ref_table(5).set_heading("R")
      .ref_table(6).set_heading("R_w")
      .ref_table(7).set_heading("Max.")
      .ref_table(7).set_subhead("Shift")
      .ref_table(7).set_sb3head(" /esd")
      .ref_table(8).set_heading("Max.")
      .ref_table(8).set_subhead("Shift")
      .ref_table(8).set_sb3head("param")
      .ref_table(9).set_heading("No. of")
      .ref_table(9).set_subhead("params")

      ! Table widths (needs to be here because of label width)
      .ref_table(1).set_width_from(.max_iterations) ! Iter
      .ref_table(2).set_width_from(.max_iterations) ! # of fit iters
      .ref_table(3).set_width_from(TEN**3)          ! chi2 initial
      .ref_table(4).set_width_from(TEN**3)          ! chi2 final
      .ref_table(5).set_width_from(ONE)             ! R
      .ref_table(6).set_width_from(ONE)             ! Rw
      .ref_table(7).set_width_from(TEN*TEN)         ! Max shift/esd
      .ref_table(8).set_width_from(labels)          ! Max shift par
      .ref_table(9).set_width(3)                    ! n_param

   end

!  Fit/refinement: Normal equations

   solve_normal_equations(dFdX) ::: leaky
   ! Get the ".dX" in some parameter vector by solving the normal
   ! equations, given "dFdX", the derivatives of the absolute
   ! structure factors w.r.t. those parameters. Also set:
!magda_beginning
   ! For the refinement against F^2 dFdX contains the derivatives
   ! of F^2 w.r.t. the parameters.
!magda_end
   ! * the ".covariance_matrix"
   ! * the ".correlation_matrix"
   ! * ".n_0", the number of eigenvalues of the LSM equal to zero 
   !   (as determined by ".tol_0")
   ! * ".n_near_0", the no of eigenvalues of the LSM nearly equal
   !   to zero (as determined by ".tol_near_0").
   ! * ".eval_near_0" and ".evec_near_0", the eigenvalues and
   !   eigenvectors of the LSM nearly equal to zero

      dFdX :: MAT{REAL}, IN

      ! Solve the normal equations
      if (.refine_F) then; .solve_F_normal_equations(dFdX)
      !magda_beginning
      else;                .solve_I_normal_equations(dFdX)
      !magda_end
      end

   end

   solve_F_normal_equations(dFdX) ::: leaky
   ! Get the ".dX" in some parameter vector by solving the F-normal
   ! equations, given "dFdX", the derivatives of the absolute
   ! structure factors w.r.t. those parameters. 
      dFdX :: MAT{REAL}, IN

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_pred, "no predicted structure factors")
   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dFdX")
   ENSURE(dFdX.dim2==.dX.dim, "incompatible .dX and dFdX")

      A,dF :: MAT{REAL}*
      rhs,sig,del :: VEC{REAL}*
      n_refl,n_p,i,j :: INT
      fac :: REAL
 
      ! Constants
      n_refl = .reflections.n_refl
      n_p    = dFdX.dim2
 
      ! Arrays
      A.create(n_p,n_p)
      rhs.create(n_p)
      del.create(n_refl)
      dF.create(n_refl,n_p)
      sig.create(n_refl)

      ! Make derivatives of F_pred
      .d_F_pred_dX(dF,sig,del,dFdX)

      ! Checked using FD, setting optimise extinction 
      ! and optimise scale OFF
      if (.debugging("solve_normal_equations")) then 
      stdout.text("dF:")
      stdout.put(dF)
      end

      ! Make the normal matrix
      do i = 1,n_p
      do j = 1,n_p
         A(i,j) = VEC{REAL}:sum(sig*dF(:,i)*dF(:,j))
      end
      end
      sig.destroy

      ! Make the rhs
      do i = 1,n_p
         rhs(i) = VEC{REAL}:sum(del*dF(:,i))
      end

      dF.destroy
      del.destroy

      if (.debugging("solve_normal_equations")) then 
      stdout.text("A:")
      stdout.put(A)
      stdout.text("rhs:")
      stdout.put(rhs)
      end

      ! Solve for the shifts .dX (leaky)
      A.solve_ill_linear_equations(rhs,.dX,.tol_0,.n_0,.tol_near_0,.n_near_0 &
                                  ,.near_0_eigenvalues,.near_0_eigenvectors &
                                  ,.covariance_matrix,.correlation_matrix)

      if (.debugging("solve_normal_equations")) then 
      stdout.text("shifts:")
      stdout.put(.dX)
      stdout.show("Normal equations check =",maxval(abs(matmul(A,.dX)-rhs)))
      stdout.show("Smallest eigenvalue    =",minval(abs(.near_0_eigenvalues)))
      stdout.show("tol_0                  =",.tol_0)
      stdout.show("n_0                    =",.n_0)
      stdout.show("tol_near_0             =",.tol_near_0)
      stdout.show("n_near_0               =",.n_near_0)
      stdout.text("Near_0 eigenvalues:")
      stdout.put(.near_0_eigenvalues,by_column=TRUE)
      end

      ! Get the maximum shift
      .max_shift = maxval(abs(.dX))

      ! Set the number of parameters
      .n_param = n_p - .n_near_0 

      ! Update chi2
      .update_n_param_and_chi2

      ! Set the full covariance matrix
      .covariance_matrix = .chi2*.covariance_matrix

      ! Set the fit errors e.g. max(.dX/esd)
      ! Parameter ordering is unique fragment atom order.
      .update_fit_esds

      rhs.destroy
      A.destroy

      if (.debugging("solve_normal_equations")) then 
      stdout.text("shifts before renormalisation:")
      stdout.put(.dX)
      end

      ! Renormalise shift if too big
      if (.max_shift>.max_allowed_param_shift) then
         fac = .max_allowed_param_shift/.max_shift
         .dX = fac * .dX
      end

      if (.debugging("solve_normal_equations")) then 
      stdout.text("shifts after renormalisation:")
      stdout.put(.dX)
      end

   end

!magda_beginning

   solve_I_normal_equations(dIdX) ::: leaky
   ! Get the ".dX" in some parameter vector by solving the F-normal
   ! equations, given "dFdX", the derivatives of the square absolute
   ! structure factors w.r.t. those parameters. 
      dIdX :: MAT{REAL}, IN

   ENSURE(.reflections.created,"no reflection data")
!   ENSURE(.reflections.have_F_pred, "no predicted structure factors")
   ENSURE(.reflections.have_I_pred, "no predicted structure factors")
   ENSURE(.reflections.have_I_exp, "no experimental structure factors")
   ENSURE(.reflections.have_I_sigma, "no structure factor errors")
   ENSURE(dIdX.dim1==.reflections.n_refl, "wrong size, dFdX")
   ENSURE(dIdX.dim2==.dX.dim, "incompatible .dX and dIdX")

      A,dI :: MAT{REAL}*
      rhs,sig,del :: VEC{REAL}*
      n_refl,n_p,i,j :: INT
      fac :: REAL
 
      ! Constants
      n_refl = .reflections.n_refl
      n_p    = dIdX.dim2
 
      ! Arrays
      A.create(n_p,n_p)
      rhs.create(n_p)
      del.create(n_refl)
      dI.create(n_refl,n_p)
      sig.create(n_refl)

      ! Make derivatives of I_pred
      .d_I_pred_dX(dI,sig,del,dIdX)

      ! Checked using FD, setting optimise extinction 
      ! and optimise scale OFF
      if (.debugging("solve_normal_equations")) then 
      stdout.text("dI:")
      stdout.put(dI)
      end

      ! Make the normal matrix
      do i = 1,n_p
      do j = 1,n_p
         A(i,j) = sum(sig*dI(:,i)*dI(:,j))
      end
      end
      sig.destroy

      ! Make the rhs
      do i = 1,n_p
         rhs(i) = sum(del*dI(:,i))
      end

      dI.destroy
      del.destroy

      if (.debugging("solve_normal_equations")) then 
      stdout.text("A:")
      stdout.put(A)
      stdout.text("rhs:")
      stdout.put(rhs)
      end

      ! Solve for the shifts .dX (leaky)
      A.solve_ill_linear_equations(rhs,.dX,.tol_0,.n_0,.tol_near_0,.n_near_0 &
                                  ,.near_0_eigenvalues,.near_0_eigenvectors &
                                  ,.covariance_matrix,.correlation_matrix)

      if (.debugging("solve_normal_equations")) then 
      stdout.text("shifts:")
      stdout.put(.dX)
      stdout.show("Normal equations check =",maxval(abs(matmul(A,.dX)-rhs)))
      stdout.show("Smallest eigenvalue    =",minval(abs(.near_0_eigenvalues)))
      stdout.show("tol_0                  =",.tol_0)
      stdout.show("n_0                    =",.n_0)
      stdout.show("tol_near_0             =",.tol_near_0)
      stdout.show("n_near_0               =",.n_near_0)
      stdout.text("Near_0 eigenvalues:")
      stdout.put(.near_0_eigenvalues,by_column=TRUE)
      end

      ! Get the maximum shift
      .max_shift = maxval(abs(.dX))

      ! Set the number of parameters
      .n_param = n_p - .n_near_0 

      ! Update chi2
      .update_n_param_and_chi2

      ! Set the full covariance matrix
      .covariance_matrix = .chi2*.covariance_matrix

      ! Set the fit errors e.g. max(.dX/esd)
      ! Parameter ordering is unique fragment atom order.
      .update_fit_esds

      rhs.destroy
      A.destroy

      if (.debugging("solve_normal_equations")) then 
      stdout.text("shifts before renormalisation:")
      stdout.put(.dX)
      end

      ! Renormalise shift if too big
      if (.max_shift>.max_allowed_param_shift) then
         fac = .max_allowed_param_shift/.max_shift
         .dX = fac * .dX
      end

      if (.debugging("solve_normal_equations")) then 
      stdout.text("shifts after renormalisation:")
      stdout.put(.dX)
      end

   end

   !magda_end

   update_fit_esds
   ! Set the esd's for the current fit. 
   ! WARNING: The order of the parameters is not always the same
   ! between calls of this routine. You *must* call this if the
   ! covariance matrix has been transformed from a unique-fragment
   ! atom ordering to asymmetric-unit ordering.

   ENSURE(.covariance_matrix.created,"no covariance_matrix")
   ENSURE(.esd.created,"no esd")
   ENSURE(.dX.created,"no dX")
   ENSURE(.esd.dim==.covariance_matrix.dim1,"esd: incompatible with covariance_matrix")
   ENSURE(.esd.dim==.dX.dim,"esd: incompatible with dX")

      indmax,p :: INT
      val,valmax :: REAL
      W :: VEC{REAL}*

      ! Set variances
      .covariance_matrix.put_diagonal_to(.esd)

      if (.debugging("update_fit_esds:variances")) then
         stdout.text("variances:")
         stdout.put(.esd,by_column=TRUE)
      end

      ! Set ESD's
      .esd = sqrt(.esd)

      if (.debugging("update_fit_esds")) then

         stdout.text("esd:")
         stdout.put(.esd,by_column=TRUE)

         stdout.text("dX:")
         stdout.put(.dX,by_column=TRUE)

         W.create(.esd.dim)
         where (abs(.esd)<TOL(8)); W = ZERO
         elsewhere;                W = .dX/.esd
         end
         stdout.text("dX/esd:")
         stdout.put(W,by_column=TRUE)
         W.destroy

      end

      ! Get the location of the maximum shift on esd
      indmax = 0
      valmax = ZERO
      do p = 1,.esd.dim

         val = .esd(p)

         ! Ignore symmetry zero's
         if (abs(val)<TOL(8)) cycle

         ! Shift on esd
         val = abs(.dX(p)/val)

         ! Set shift on esd if larger ...
         if (val<=valmax) cycle
         valmax = val
         indmax = p

      end

      ! Assign maximum index
      DIE_IF(indmax==0,"no maximum index found!")
      .max_shift_on_esd_ind = indmax
      .max_shift_on_esd     = valmax

      ! Debug
      if (.debugging("update_fit_esds")) then 
         stdout.show("max_shift_on_esd_ind  =",indmax)
         stdout.show("max_shift_on_esd      =",valmax)
      end

   end

   update_refinement_esds
   ! Update the esd's for the current fit. 
   ! NOTE: must have updated X_ref and X_ref0

   ENSURE(.covariance_matrix.created,"no covariance_matrix")
   ENSURE(.esd.created,"no esd")
   ENSURE(.dX.created,"no dX")
   ENSURE(.esd.dim==.covariance_matrix.dim1,"esd: incompatible with covariance_matrix")
   ENSURE(.esd.dim==.dX.dim,"esd: incompatible with dX")
   ENSURE(.X_ref.created,"no X_ref")
   ENSURE(.X_ref0.created,"no X_ref0")

      n_p,indmax,p :: INT
      val,valmax :: REAL
      dX :: VEC{REAL}*
 
      ! Constants
      n_p = .esd.dim

      ! Set the change in paramts between fits
      dX.create(n_p)
      dX = .X_ref - .X_ref0

      ! Get the location of the maximum shift on esd
      indmax = 0
      valmax = ZERO
      do p = 1,n_p

         val = .esd(p)
         if (val==ZERO) cycle

         val = abs(dX(p)/val)
         if (val<=valmax) cycle

         valmax = val
         indmax = p

      end

      ! Assign maximum index
      DIE_IF(indmax==0,"no maximum index found!")
      .max_refshift_on_esd_ind = indmax
      .max_refshift_on_esd     = valmax

      ! Debug
      if (.debugging("update_refinement_errors")) then 
      stdout.show("max_refshift_on_esd_ind  =",indmax)
      stdout.show("max_refshift_on_esd      =",valmax)
      .max_refshift_on_esd     = valmax
      stdout.text(".esd:")
      stdout.put(.esd,by_column=TRUE)
      end

      ! Clean
      dX.destroy

   end

   d_F_pred_dX(res,sig,del,dFdX)
   ! Evaluate "res", the derivative of the F_pred with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the absolute structure factors  w.r.t. the X
   ! parameters. Includes derivatives w.r.t. the scale factor, but
   ! extinction is treated as a constant and should be OFF for exact
   ! results. Also makes "sig" and "del" required for the normal
   ! equations.
      res :: MAT{REAL}, OUT
      sig,del :: VEC{REAL}, OUT
      dFdX :: MAT{REAL}, IN

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
   ENSURE( del.dim1==.reflections.n_refl, "wrong size, del")
   ENSURE( res.dim1==.reflections.n_refl, "wrong size, res")
   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dF")
   ENSURE(dFdX.dim2==res.dim2, "incompatible res, dFdX")

      ref :: REFLECTION*
      Ft,Fx,dt,db,ext,angle_bit,d_scale :: VEC{REAL}*
      top,bot,extn,F_exp,F_sig,F_abs,F_til,sig2,F_es2,F_ts2,fac,dsp,ext4,dX,val1,val2,dF :: REAL
      n_refl,n_p,p,n :: INT
 
      ! Constants
      n_refl = .reflections.n_refl
      n_p = dFdX.dim2

      ! Temporaries
      Ft.create(n_refl)
      Fx.create(n_refl)
      dt.create(n_refl)
      db.create(n_refl)
 
      ! Extinction factor part
      ext.create(n_refl)
      ext = .F_extinction_correction(ONE,.extinction_factor)

      ! Angle bit, extinction factor folded in
      angle_bit.create(n_refl)
      angle_bit = .extinction_factor*.extinction_angle_part

      ! Make temporaries for derivative of scale, extinction, F_abs
      top = ZERO
      bot = ZERO

      do n = 1,n_refl

         extn   = ext(n)
         ref    => .reflections(n)

         F_exp  = ref.F_exp
         F_sig  = ref.F_sigma
         F_abs  = abs(ref.F_calc)
         F_til  = extn*F_abs
         sig2   = ONE/(F_sig*F_sig)

         F_es2  = F_exp*sig2
         F_ts2  = F_til*sig2

         top    = top + F_til*F_es2
         bot    = bot + F_til*F_ts2

         ext4   = extn*extn
         ext4   = ext4*ext4
         dX     = -HALF*ext4*angle_bit(n)*F_abs
         dX     = ONE + F_abs*dX

         dt(n)  = F_es2*extn*dX
         db(n)  = extn*F_ts2*dX
         Ft(n)  = F_til
         Fx(n)  = .scale_factor*extn*dX

         ! Return these
         sig(n) = sig2
         del(n) = (F_exp - ref.F_pred)*sig2

      end

      angle_bit.destroy
      ext.destroy
 
      ! Derivative of the scale factor
      d_scale.create(n_p)
      bot = ONE/bot
      fac = -TWO*top*bot*bot
      do p = 1,n_p
         val1 = ZERO
         val2 = ZERO
         do n = 1,n_refl
            dF = dFdX(n,p) 
            val1 = val1 + dt(n)*dF
            val2 = val2 + db(n)*dF
         end
         d_scale(p) = bot*val1 + fac*val2
      end

      db.destroy
      dt.destroy

      ! Derivative of F_pred or F^m
      do p = 1,n_p
         dsp = d_scale(p)
         do n = 1,n_refl
            res(n,p) = dsp*Ft(n) + Fx(n) * dFdX(n,p) 
         end
      end

      ! Clean up
      d_scale.destroy
      Fx.destroy; Ft.destroy

   end

!magda_beginning

   d_I_pred_dX(res,sig,del,dIdX)
   ! Evaluate "res", the derivative of the I_pred with respect to some
   ! parameters X (e.g. thermal parameters) given "dIdX", the
   ! derivatives of the square absolute structure factors  w.r.t. the X
   ! parameters. Includes derivatives w.r.t. the scale factor, but
   ! extinction is treated as a constant and should be OFF for exact
   ! results. Also makes "sig" and "del" required for the normal
   ! equations.
      res :: MAT{REAL}, OUT
      sig,del :: VEC{REAL}, OUT
      dIdX :: MAT{REAL}, IN

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_I_calc, "no calculated structure factors")
   ENSURE(.reflections.have_I_exp, "no experimental structure factors")
   ENSURE(.reflections.have_I_sigma, "no structure factor errors")
   ENSURE( del.dim1==.reflections.n_refl, "wrong size, del")
   ENSURE( res.dim1==.reflections.n_refl, "wrong size, res")
   ENSURE(dIdX.dim1==.reflections.n_refl, "wrong size, dF")
   ENSURE(dIdX.dim2==res.dim2, "incompatible res, dFdX")

      ref :: REFLECTION*
      It,dt,db,d_scale :: VEC{REAL}*
      I_clc,top,bot,I_exp,I_sig,sig2,I_es2,I_ts2,fac,dsp,val1,val2,dI :: REAL
      n_refl,n_p,p,n :: INT
 
      ! Constants
      n_refl = .reflections.n_refl
      n_p = dIdX.dim2

      ! Temporaries
      It.create(n_refl)
      dt.create(n_refl)
      db.create(n_refl)
 

      ! Make temporaries for derivative of scale, extinction, F_abs
      top = ZERO
      bot = ZERO

      do n = 1,n_refl

         ref    => .reflections(n)

         I_exp  = ref.I_exp
         I_sig  = ref.I_sigma
         I_clc  = ref.I_calc
         sig2   = ONE/(I_sig*I_sig)

         I_es2  = I_exp*sig2
         I_ts2  = I_clc*sig2

         top    = top + I_clc*I_es2
         bot    = bot + I_clc*I_ts2

         dt(n)  = I_es2
         db(n)  = I_ts2
         It(n)  = I_clc

         ! Return these
         sig(n) = sig2
         del(n) = (I_exp - ref.I_pred)*sig2

      end

      ! Derivative of the scale factor
      d_scale.create(n_p)
      bot = ONE/bot
      fac = -TWO*top*bot*bot
      do p = 1,n_p
         val1 = ZERO
         val2 = ZERO
         do n = 1,n_refl
            dI = dIdX(n,p) 
            val1 = val1 + dt(n)*dI
            val2 = val2 + db(n)*dI
         end
         d_scale(p) = bot*val1 + fac*val2
      end

      db.destroy
      dt.destroy

      ! Derivative of I_pred
      do p = 1,n_p
         dsp = d_scale(p)
         do n = 1,n_refl
            res(n,p) = dsp*It(n) + .scale_factor * dIdX(n,p) 
         end
      end

      ! Clean up
      d_scale.destroy
      It.destroy
   end

!magda_end

   d_F_abs_dX(res,dFdX)
   ! Evaluate "res", the derivative of the F_abs with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the *complex* structure factors  w.r.t. the X
   ! parameters. 
      res :: MAT{REAL}, OUT
      dFdX :: MAT{CPX}, IN

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE( res.dim1==.reflections.n_refl, "wrong size, res")
   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dFdX")
   ENSURE(dFdX.dim2==res.dim2, "incompatible res, dFdX")

      F_con :: VEC{CPX}*
      F_abi :: VEC{REAL}*
      F_cal :: CPX
      n_refl,n_p,p,n :: INT
 
      n_refl = .reflections.n_refl
      n_p = dFdX.dim2

      F_con.create(n_refl)
      F_abi.create(n_refl)

      do n = 1,n_refl
         F_cal    = .reflections(n).F_calc
         F_con(n) = conjg(F_cal)
         F_abi(n) = ONE/abs(F_cal)
      end

      do p = 1,n_p
      do n = 1,n_refl
         res(n,p) = F_abi(n) * REALIFY(F_con(n) * dFdX(n,p))
      end
      end

      F_abi.destroy
      F_con.destroy

   end

!magda_beginning
   d_F_abs_2_dX(res,dFdX)
   ! Evaluate "res", the derivative of the F_abs_2 with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the *complex* structure factors  w.r.t. the X
   ! parameters. 
      res :: MAT{REAL}, OUT
      dFdX :: MAT{CPX}, IN

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE( res.dim1==.reflections.n_refl, "wrong size, res")
   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dFdX")
   ENSURE(dFdX.dim2==res.dim2, "incompatible res, dFdX")

      F_con :: VEC{CPX}*   !conjugated structure factors
      F_cal :: CPX         !calculated structure factors
      n_refl,n_p,p,n :: INT
 
      n_refl = .reflections.n_refl
      n_p = dFdX.dim2

      F_con.create(n_refl)

      do n = 1,n_refl
         F_cal    = .reflections(n).F_calc
         F_con(n) = conjg(F_cal)
      end

      do p = 1,n_p
      do n = 1,n_refl
         res(n,p) = TWO * REALIFY(F_con(n) * dFdX(n,p))
      end
      end

      F_con.destroy

   end
!magda_end

!  Fit/refinement iteration control

   update_fit_parameters
   ! Update i.e. increment the fit parameters

      ! Next iteration
      .fit_iteration = .fit_iteration + 1

      ! Save and increment parameters
      .X_fit0 = .X_fit
      .X_fit  = .X_fit + .dX

   end

   update_refinement_parameters
   ! Update the refinement parameters

      ! Increment 
      .ref_iteration = .ref_iteration + 1
 
      ! Transfer parameters
      .X_ref0 = .X_ref ! From previous or 1st iteration
      .X_ref  = .X_fit ! This iteration

   end

!  Fit/refinement iteration control

 
   fit_finished result (res)
   ! Return whether the (rigid) HA refinement has finished
      res :: BIN

      ! Converged?
      .fit_converged = .max_shift_on_esd<.tol_for_shift_on_esd &
                       AND .fit_iteration>=.min_iterations

      ! chi2 inceased?
      .chi2_increased = .chi2_fit>.chi2_fit0 AND .fit_iteration>.min_iterations

      ! debug
      if (.debugging("fit_finished")) then
         stdout.text("In fit finished:")
         stdout.text("chi2_fit0 ="//trim(.chi2_fit0.to_str))
         stdout.text("chi2_fit  ="//trim(.chi2_fit.to_str ))
      end

      ! Roll back the parameters is chi2 increases
      ! WARNING: covariances are not rolled back ...
    ! if (.chi2_increased) then
    !    .X_fit    = .X_fit0
    !    .chi2_fit = .chi2_fit0
    ! end

      ! Too many fit iterations?
      .too_many_fit_iterations = .fit_iteration>.max_iterations

      ! Set finished
      res = .fit_converged OR .chi2_increased OR .too_many_fit_iterations

      ! If refining, store initial & final chi2
      if (.refine_structure) then
         if (.fit_iteration==1) .chi2_ref0 = .chi2_fit ! Store initial chi2
         if (res)               .chi2_ref  = .chi2_fit ! Stoire final chi2
      end

   end
 
   refinement_finished result (res)
   ! Return whether the refinement has finished
      res :: BIN

      ! Has fit finished?
      .refinement_converged = .max_refshift_on_esd<.tol_for_shift_on_esd &
                            AND .ref_iteration>=.min_iterations

      ! Too many refinement iterations?
      .too_many_ref_iterations = .ref_iteration>.max_iterations

      ! Set finished; finish also if chi2 increases in fit iteration
      res = .refinement_converged OR .chi2_increased OR .too_many_ref_iterations

   end

!  Fit/refinement output

   put_fit_header ::: selfless
   ! Put the fit header
      stdout.flush
      stdout.text("===================================")
      stdout.text("Crystal structure fit (rigid atoms)")
      stdout.text("===================================")
      stdout.flush
      stdout.text("A single SCF/rigid hirshfeld atom fit is performed.")
      stdout.flush
      stdout.text("Consider non-rigid hirshfeld_atom_refinement instead.")
   end

   put_refinement_header ::: selfless
   ! Put the fit header

      stdout.flush
      stdout.text("==============================================")
      stdout.text("Crystal structure refinement (non-rigid atoms)")
      stdout.text("==============================================")

      stdout.flush
      stdout.text("Repeated SCF/rigid hirshfeld atom fits are performed")
      stdout.text("which eventually removes the rigid atom constraint.")

      stdout.flush
      stdout.text("Agreement statistics are shown at the start and end")
      stdout.text("of each 'micro' rigid fit cycle.")

      stdout.flush
      stdout.text("Convergence criteria for each fit-cycle are the same")
      stdout.text("as for convergence of the overall refinement")

   end

   put_refinement_switches
   ! Put the refinement switches

      stdout.flush
      stdout.show("Refine hydrogen ADP's       =",.refine_H_ADPs)
      stdout.show("Refine hydrogen U_iso       =",.refine_H_U_iso)
      stdout.show("Refine only ADP's           =",.refine_ADPs_only)
      stdout.show("Refine only positions       =",.refine_positions_only)

      if (.refine_anharmonicity) then
      stdout.flush
      stdout.show("Refine anharmonicity        =",TRUE)
      stdout.show("Anharmonic atoms            =",TRUE)
      end

      stdout.flush
      stdout.show("Refine scale factor         =",.optimise_scale)
      stdout.show("Refine multiple scales      =",.use_multiple_scale_factors)
      stdout.show("Refine extinction parameter =",.optimise_extinction)

      stdout.flush
      stdout.show("Max allowed parameter shift =",.max_allowed_param_shift)
      stdout.show("Max iterations              =",.max_iterations)
      stdout.show("Min iterations              =",.min_iterations)

      stdout.flush
      stdout.show("Conv. tol. for shift on esd =",.tol_for_shift_on_esd)
      stdout.show("Zero eigenvalue tolerance   =",.tol_0)
      stdout.show("Nearly zero tolerance       =",.tol_near_0)

   end

   put_fit_table_headings
   ! Put the fit table header

      stdout.flush
      stdout.text("====================")
      stdout.text("Begin rigid-atom fit")
      stdout.text("====================")
      stdout.flush

      ! Put table headings
      .fit_table.put_headings

   end

   put_refinement_table_headings
   ! Put the refinement table header

      stdout.flush
      stdout.text("================")
      stdout.text("Begin refinement")
      stdout.text("================")
      stdout.flush

      ! Put table headings
      .ref_table.put_headings

   end

   put_fit_table_body
   ! Print the current iterations results

      ! Set table body (leaky)
      .fit_table(1).create_values([.fit_iteration])
      .fit_table(2).create_values([.chi2_fit])
      .fit_table(3).create_values([.F_r_factor])
      .fit_table(4).create_values([.F_weighted_r_factor])
      .fit_table(5).create_values([.max_shift_on_esd])
      .fit_table(6).create_values([.max_shift_on_esd_par])
      .fit_table(7).create_values([.n_param])
      .fit_table(8).create_values([.n_near_0])

      ! Put out the body
      .fit_table.put_body

      ! Clear thje columns for next time (UNleaky!)
      .fit_table.clear_columns

   end

   put_refinement_table_body
   ! Print the current iterations results

      ! Set table body (leaky)
      .ref_table(1).create_values([.ref_iteration])
      .ref_table(2).create_values([.fit_iteration])
      .ref_table(3).create_values([.chi2_ref0])
      .ref_table(4).create_values([.chi2_ref])
      .ref_table(5).create_values([.F_r_factor])
      .ref_table(6).create_values([.F_weighted_r_factor])
      .ref_table(7).create_values([.max_refshift_on_esd])
      .ref_table(8).create_values([.max_refshift_on_esd_par])
      .ref_table(9).create_values([.n_param])

      ! Put out the body
      .ref_table.put_body

      ! Clear thje columns for next time (UNleaky!)
      .ref_table.clear_columns

   end

   put_fit_results
   ! Put the fit-iteration footer and fit results

      ! Table footer
      .fit_table.put_footer

      ! Results
      stdout.flush
      stdout.text("======================")
      stdout.text("Rigid-atom fit results")
      stdout.text("======================")
      stdout.flush

      ! Print how it finished
      if      (.fit_converged)            then; stdout.text("Structure fit converged.")
      else if (.chi2_increased)           then; stdout.text("WARNING: fit stopped: chi2 has increased.")
                                                stdout.text("WARNING: fit results are unreliable.")
      else if (.too_many_fit_iterations)  then; stdout.text("WARNING: fit stopped: too many iterations.")
      end

      ! Put final fitting statistics
      .reflections.put_F_statistics(show_chi2=FALSE)
      stdout.show("# of fit parameters, N_p    =", .n_param)
      stdout.show("chi^2(N_p)                  =",.chi2)
      stdout.show("Goodness of fit (N_p)       =", sqrt(.chi2))
      stdout.show("Effective (mean) sigma^2    =",.reflections.sigma2_eff)

      ! Analysis
      stdout.flush
      stdout.text("An analysis of the fit is in the file 'stdout.fit_analysis'")

   end

   put_refinement_results
   ! Put the iteration footer and refinement results

      ! Table footer
      .ref_table.put_footer

      ! Results
      stdout.flush
      stdout.text("============================")
      stdout.text("Structure refinement results")
      stdout.text("============================")
      stdout.flush

      ! Print how it finished
      if      (.refinement_converged)     then; stdout.text("Structure refinement converged.")
      else if (.chi2_increased)           then; stdout.text("WARNING: refinement stopped: chi2 has increased.")
      else if (.too_many_ref_iterations)  then; stdout.text("WARNING: refinement stopped: too many iterations.")
      end

      ! Put final fitting statistics
      .reflections.put_F_statistics(show_chi2=FALSE)
      stdout.show("# of fit parameters, N_p    =", .n_param)
      stdout.show("chi^2(N_p)                  =",.chi2)
      stdout.show("Goodness of fit (N_p)       =", sqrt(.chi2))
      stdout.show("Effective (mean) sigma^2    =",.reflections.sigma2_eff)

      ! Analysis
      stdout.flush
      stdout.text("An analysis of the fit is in the file 'stdout.fit_analysis'")

   end

   put_near_0_eigenvectors
   ! Put the near zero (linearly dependent) parameter eigenvectors

      if (.near_0_eigenvectors.created) then
      if (.near_0_eigenvectors.dim>0) then

         stdout.flush
         stdout.text("Near 0 eigenvalues of the normal matrix:")
         stdout.put(.near_0_eigenvalues)
         stdout.flush
         stdout.text("Near 0 eigenvectors of the normal matrix:")
         stdout.put(.near_0_eigenvectors)

      end
      end

   end


!  ==============
!  Output methods
!  ==============

   put
   ! Put out the diffraction data to file "out"

      stdout.flush
      stdout.text("Diffraction information:")
      stdout.show("data_kind                     =", .data_kind)

      if (.reflections.created) then
      stdout.text("Reflection data:")
      stdout.flush
      .put_reflection_data
      end

   end

   put_sin_theta_on_lambda
   ! Output sin(theta)/lambda for all reflections.
   ENSURE(.reflections.created,"No list of reflections")
   ENSURE(.reflections.have_indices,"No list of reflections")
      n :: INT

      REFLECTION:set_wavelength(.wavelength)

      stdout.text("sin(theta)/lambda for the reflections")
      stdout.dash(int_fields=3,real_fields=1)
      stdout.put("h",int_width=TRUE)
      stdout.put("k",int_width=TRUE)
      stdout.put("l",int_width=TRUE)
      stdout.put("stl")
      stdout.flush
      stdout.dash(int_fields=3,real_fields=1)
      do n=1,size(.reflections)
         stdout.put(.reflections(n).h)
         stdout.put(.reflections(n).k)
         stdout.put(.reflections(n).l)
         stdout.put(.reflections(n).sin_theta_on_lambda)
         stdout.flush
      end
      stdout.dash(int_fields=3,real_fields=1)

   end

   put_F_statistics
   ! Output the structure factor goodness of fit statistics.
      .reflections.put_F_statistics
   end

   put_F_free_stats
   ! Output the structure factor goodness of fit statistics.
      .reflections.put_F_free_stats
   end

   put_I_statistics
   ! Output the intensity goodness of fit statistics
      .reflections.put_I_statistics
    ! .put_correction_data
   end

   put_I_free_stats
   ! Output the intensity goodness of fit statistics
      .reflections.put_I_free_stats
      .put_correction_data
   end

   put_correction_data
   ! Output the correction data

      stdout.flush
      stdout.show("Using scale factor(s)          =", .optimise_scale)
      stdout.show("Using extinction               =", .optimise_extinction)
      stdout.show("Thermal smearing model         =", .thermal_smearing_model)
      stdout.show("Fragment partition model       =", .partition_model)
      stdout.show("Correct dispersion?            =", .correct_dispersion)

      if (.optimise_extinction) then;
      stdout.show("Optimize extinction            =", TRUE)
      stdout.show("Secondary extinction factor    =", .extinction_factor)
      else
      stdout.show("Optimize extinction            =", FALSE)
      end

      if (.optimise_scale) then

        if (.use_multiple_scale_factors) then
      stdout.show("Using multiple scale factors   =", TRUE)
      stdout.show("Scale factors                  =", .scale_factors)
        else
      stdout.show("Using single scale factor      =", TRUE)
      stdout.show("Scale factor                   =", .scale_factor)
        end

      else
      stdout.show("Optimize scale factor          =", FALSE)
      end

   end

!   put_gof_data
!   ! Output the goodness-of-fit data
!      stdout.show("chi2                         =", .F_chi2)
!      stdout.show("Goodness of fit in F         =", .F_goodness_of_fit)
!      stdout.show("R factor in F                =", .F_r_factor)
!      stdout.show("Weighted R factor in F       =", .F_weighted_r_factor)
!   end
!
!   put_free_gof_data
!   ! Output the free goodness-of-fit data
!      stdout.show("Free chi2 in F               =", .F_chi2)
!      stdout.show("Free goodness of fit in F    =", .F_goodness_of_fit)
!      stdout.show("Free R factor in F           =", .F_r_factor)
!      stdout.show("Free weighted R factor in F  =", .F_weighted_r_factor)
!   end

   put_reflection_data(core_reflection)
   ! Output the reflection data and corresponding fit statistic, 
   ! if available
      core_reflection :: VEC{REFLECTION}*, optional

   ENSURE(.reflections.created,"no reflections")

      if (.have_F_calc OR .have_F_pred) then
         .put_correction_data
      end

      .reflections.put(core_reflection)

   end

   put_qq_plot
   ! Output a qq plot to stdout.
   ! It is a plot of the experimental quantile vs expected quantile.
   ENSURE(.reflections.created, "no reflection data")
      .reflections.put_F_qq_plot
   end

   put_labelled_qq_plot
   ! Output a qq plot to stdout.
   ! It is a plot of the experimental quantile vs expected quantile.
   ENSURE(.reflections.created, "no reflection data")
      .reflections.put_labelled_F_qq_plot
   end

   put_chi2_vs_angle_plot
   ! Output a table with the chi^2 for the structure factor data set broken
   ! into sections.
   ! Reads from stdin the number of divisions in the plot.
      num_sections :: INT
      n,num,k,n_refl :: INT
      section_for :: VEC{INT}*
      stl,stl_min,stl_max,chi2,width,stl_mean :: REAL

      num_sections = 20
      n_refl = .reflections.n_refl
      REFLECTION:set_wavelength(.wavelength)

      ! Work out the limits of the sin(theta)/lambda.
      stl_min = 1000
      stl_max = ZERO
      do n =1,n_refl
         stl = .reflections(n).sin_theta_on_lambda
         if (stl < stl_min) stl_min = stl
         if (stl > stl_max) stl_max = stl
      end
      width = (TOL(3) + stl_max - stl_min)/num_sections

      section_for.create(n_refl)
      ! Determine which section each reflection belongs to.
      do n = 1,n_refl
         stl = .reflections(n).sin_theta_on_lambda
         section_for(n) = ceiling((TOL(3) + stl - stl_min) / width)
      end

      stdout.flush
      stdout.text("Chi^2 vs angle plot")
      stdout.flush
      stdout.text("sin(theta)/lambda in Angstrom^(-1)")
      stdout.show("Smallest sin(theta)/lambda  =",stl_min)
      stdout.show("Largest sin(theta)/lambda   =",stl_max)
      stdout.flush
      stdout.put("stl")
      stdout.put("chi^2")
      stdout.flush
      stdout.dash(real_fields=2)
      do n = 1, num_sections
         chi2 = ZERO
         num = 0
         stl_mean = stl_min + (n - HALF) * width
         do k = 1, n_refl
           if (n==section_for(k)) then
             chi2 = chi2 + .reflections(k).F_z2
             num = num + 1
           end
         end
         stdout.put(stl_mean)
         if (num==0) then
           stdout.flush
           cycle
         else
           chi2 = chi2 / max(num - .n_param,1)
           stdout.put(chi2)
           stdout.flush
         end
      end
      stdout.flush
      section_for.destroy
   end

   put_fcalc_plots
   ! Output some different plots about the calculated structure factors.
      ext :: VEC{REAL}*
      ext_refs :: VEC{REFLECTION}*
      n,n_refl :: INT
      y,w :: REAL

      n_refl = .reflections.n_refl
      REFLECTION:set_wavelength(.wavelength)

      stdout.text("The effects of angle.")
      stdout.text("Scatter plot of F_z = (Fexp-Fpred)/F_sigma vs sin(theta)/lambda")
      do n = 1,n_refl
         stdout.put(.reflections(n).sin_theta_on_lambda)
         stdout.put(.reflections(n).F_z)
         stdout.flush
      end
      stdout.flush

      stdout.text("The effects of angle.")
      stdout.text("Scatter plot of Delta F = (Fexp-Fpred) vs sin(theta)/lambda")
      do n = 1,n_refl
         stdout.put(.reflections(n).sin_theta_on_lambda)
         stdout.put(.reflections(n).delta_F)
         stdout.flush
      end
      stdout.flush

      stdout.text("The effects of intensity.")
      stdout.text("Scatter plot of F_z = (Fexp-Fpred)/F_sigma vs Fexp")
      do n = 1,n_refl
         stdout.put(.reflections(n).F_exp)
         stdout.put(.reflections(n).F_z)
         stdout.flush
      end
      stdout.flush

      ext_refs.create(n_refl)
      ext.create(n_refl)
      ext = .F_extinction_correction
      ext_refs.set_F_exp(.reflections.F_pred)
      ext_refs.set_F_pred(.reflections.F_pred * ext)
      ext_refs.set_F_sigma(.reflections.F_sigma)
      ext.destroy

      if (NOT .optimise_extinction) return

      stdout.text("The effects of extinction.")

      w = ZERO
      y = ZERO
      do n=1,n_refl
       y = y + abs(ext_refs(n).F_z)
       w = w + abs(ext_refs(n).F_r)
      end
      y = y / n_refl
      w = w / n_refl
      stdout.show("Average value of abs[Fcalc(with ext)-Fcalc(without ext)]/F_sigma is ",y)
      stdout.show("Average value of abs(extinction correction) is ",w)
      stdout.flush

      stdout.text("The effects of intensity on extinction.")
      stdout.text("Scatter plot of [Fcalc(with ext)-Fcalc(without ext)]/F_sigma vs F_pred")
      do n=1,n_refl
       stdout.put(ext_refs(n).F_pred)
       stdout.put(ext_refs(n).F_z)
       stdout.flush
      end
      stdout.flush

      stdout.text("The effects of scattering angle on extinction.")
      stdout.text("Scatter plot of [Fcalc(with ext)-Fcalc(without ext)]/F_sigma vs sin(theta)/lambda")
      do n = 1,n_refl
         stdout.put(.reflections(n).sin_theta_on_lambda)
         stdout.put(ext_refs(n).F_z)
         stdout.flush
      end
      ext_refs.destroy

      stdout.flush
   end

   put_PND_sf(name)
   ! Output the magnetic structure factors
       name :: STR
       FM_s,FM_l :: VEC{CPX}*
       arch :: ARCHIVE
        n :: INT
       FM_s.create(.reflections.n_refl)
       arch.set(name,"PND_spin_sf")
       arch.read(FM_s)
       FM_l.create(.reflections.n_refl)
       arch.set(name,"PND_nabla_sf")
       arch.read(FM_l)
       stdout.text("PND magnetic structure factors:")
       stdout.flush
       stdout.dash(int_fields=3,real_fields=3)
       stdout.put("h", int_width=TRUE)
       stdout.put("k", int_width=TRUE)
       stdout.put("l", int_width=TRUE)
       stdout.put("FM_s")
       stdout.put("FM_l")
       stdout.put("FM")
       stdout.flush
       stdout.dash(int_fields=3,real_fields=3)
       do n = 1, .reflections.n_refl
          stdout.put(.reflections(n).h)
          stdout.put(.reflections(n).k)
          stdout.put(.reflections(n).l)
          stdout.put(real(FM_s(n)) )
          stdout.put(real(FM_l(n)) )
          stdout.put(real(FM_s(n)+FM_l(n)) )
          stdout.flush
       end
       stdout.dash(int_fields=3,real_fields=3)
       FM_l.destroy
       FM_s.destroy
   end


!  ===================
!  Tests for existence
!  ===================

   reflection_data_exists result (res)
   ! Return TRUE if reflection data exists
      res :: BIN
      res = associated(.reflections)
   end

   have_F_exp result (res)
   ! Return TRUE if have some experimental structure factors
      res :: BIN
      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_exp
   end

!magda_beginning
   have_I_exp result (res)
   ! Return TRUE if have some experimental structure factors
      res :: BIN
      res = FALSE
      if (associated(.reflections)) res = .reflections.have_I_exp
   end
!magda_end
   have_F_calc result (res)
   ! Return TRUE if have some calculated structure factors
      res :: BIN
      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_calc
   end

   have_F_pred result (res)
   ! Return TRUE if have some predicted structure factors
      res :: BIN
      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_pred
   end

   have_F_sigma result (res)
   ! Return TRUE if have some structure factor errors
      res :: BIN
      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_sigma
   end

   use_multiple_scale_factors result (res)
   ! Return TRUE if we are supposed to use multiple scale factors.
      res :: BIN
      res = FALSE
      if (associated(.reflections)) res = any(.reflections.group>0)
   end


!  =============================
!  Inherited reflection routines
!  =============================

   n_refl result (res)
   ! The number of reflections
      self :: IN
      res :: INT
   ENSURE(.reflections.created, "no reflection data")
      res = .reflections.n_refl
   end

   F_calc result (res)
   ! The calculated structure factors
      res :: VEC{CPX}(size(.reflections))
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.F_calc
   end

   I_calc result (res)
   ! The calculated intensities
      res :: VEC{REAL}(size(.reflections))
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.I_calc
   end

   F_pred result (res)
   ! The predicted structure factors
      res :: VEC{REAL}(size(.reflections))
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.F_pred
   end

   I_pred result (res)
   ! The predicted intensities
      res :: VEC{REAL}(size(.reflections))
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.I_pred
   end

   F_sigma result (res)
   ! The structure factor errors
      res :: VEC{REAL}(size(.reflections))
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.F_sigma
   end

   I_sigma result (res)
   ! The intensity errors
      res :: VEC{REAL}(size(.reflections))
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.I_sigma
   end

   F_exp result (res)
   ! The experimental structure factors
      res :: VEC{REAL}(size(.reflections))
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.F_exp
   end

   I_exp result (res)
   ! The experimental intensities
      res :: VEC{REAL}(size(.reflections))
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.I_exp
   end

   set_F_calc(F_calc)
   ! Set the calculated structure factors
      F_calc :: VEC{CPX}, IN
   ENSURE(.reflection_data_exists,"no reflection data")
      .reflections.set_F_calc(F_calc)
   end

   set_I_calc(I_calc)
   ! Set the calculated intensities
      I_calc :: VEC{REAL}, IN
   ENSURE(.reflection_data_exists,"no reflection data")
      .reflections.set_I_calc(I_calc)
   end

   F_chi2 result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.F_chi2
   end

   I_chi2 result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.I_chi2
   end

   F_goodness_of_fit result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.F_goodness_of_fit
   end

   I_goodness_of_fit result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.I_goodness_of_fit
   end

   F_r_factor result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.F_r_factor
   end

   I_r_factor result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.I_r_factor
   end

   F_weighted_r_factor result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.F_weighted_r_factor
   end

   I_weighted_r_factor result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.I_weighted_r_factor
   end

   F_val_r_factor(core_reflection) result (res) 
   ! Valence r factor . The set of "core_reflections" must be supplied.
      self :: IN
      core_reflection :: VEC{REFLECTION}
      res :: REAL
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.F_val_r_factor(core_reflection)
   end

   simulate_new_F_exp
   ! Simulate a new experiment by adding normally distributed experimental
   ! errors the the F_exp.

   ENSURE(.reflection_data_exists,"no reflection data")
   ENSURE(.have_F_exp,"no experimental structure factors")
   ENSURE(.have_F_sigma,"no experimental structure factor errors")

      F_exp :: VEC{REAL}*
      n :: INT
      chi2,z :: REAL

      stdout.flush
      stdout.text("Adding simulated errors to F_exp using F_sigma.")

      F_exp.create(.n_refl)
      F_exp = .reflections.F_exp

      .reflections.simulate_new_F_exp

      chi2 = ZERO
      do n = 1,.n_refl
         z = (F_exp(n)-.reflections(n).F_exp)/.reflections(n).F_sigma
         chi2 = chi2 + z*z
      end
      chi2 = chi2 / max(.n_refl - 1,1)

      stdout.text("chi^2 of old F_exp to new F_exp is " // trim(chi2.to_str))
      stdout.flush
      stdout.dash(real_fields=4)
      stdout.put("F_exp (old)")
      stdout.put("F_exp (new)")
      stdout.put("F_sigma")
      stdout.put("dF/sigma")
      stdout.flush
      stdout.dash(real_fields=4)

      do n=1,.n_refl
         z = (F_exp(n)-.reflections(n).F_exp)/.reflections(n).F_sigma
         stdout.put(F_exp(n))
         stdout.put(.reflections(n).F_exp)
         stdout.put(.reflections(n).F_sigma)
         stdout.put(z)
         stdout.flush
      end

      stdout.dash(real_fields=4)
      F_exp.destroy

   end

end
