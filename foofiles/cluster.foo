!-------------------------------------------------------------------------------
!
! CLUSTER:
!
! An object to store information pertaining to a cluster of atoms or molecules
! generated from an underlying crystal structure.
!
! A lot of information regarding the cluster is generated -- like the unit cell
! connection table, the atom connection table, the occupation list (unit cell
! atom numbers plus cell translation vectors), and the unit cell atom numbers.
! The symmetry operators for each atom are also available from the unit cell
! numbers if the crystal information is available (it should be, otherwise
! we can't generate a cluster!).
!
! NOTE: an associated crystal and atom list should be supplied. It is intended
! that these will come from the molecule which generates the cluster (perhaps a
! cluster should contain a molecule?).
!
! Copyright (C) Dylan Jayatilaka, 2002
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: cluster.foo 4398 2014-06-01 06:55:30Z dylan_ $
!-------------------------------------------------------------------------------

module CLUSTER

   implicit none

   debug_list :: VEC{STR}*, private  DEFAULT_NULL

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Create an object. This version does not set defaults.
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Destroy an object
   end

   nullify_ptr_part ::: pure
   ! Nullify the pointer parts
      self :: INOUT

      nullify(.crystal)
      nullify(.asymmetric_unit_atom)
      nullify(.fragment_geometry)

      nullify(.geometry)
      nullify(.shift)
      nullify(.shift_for_atom)
      nullify(.is_fragment_atom)
      nullify(.occupation_list)
      nullify(.molecule_for_atom)
      nullify(.molecule)
      nullify(.molecule_centroid)
      nullify(.unique_molecule_for)
      nullify(.unique_symcode_for)
      nullify(.atom_connection)

   end

   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts
      self :: INOUT

      ! Never destroy these, they are always pointer assigned
      nullify(.crystal)
      nullify(.asymmetric_unit_atom)
      nullify(.fragment_geometry)

      .geometry.destroy
      .shift.destroy
      .shift_for_atom.destroy
      .is_fragment_atom.destroy
      .occupation_list.destroy
      .molecule_for_atom.destroy
      .molecule.destroy
      .molecule_centroid.destroy
      .unique_molecule_for.destroy
      .unique_symcode_for.destroy
      .atom_connection.destroy

   end

   destroy_cluster_info_ptr_part ::: leaky, PURE
   ! Destroy the non-symop informational ptr parts. These incclude the actual
   ! .geometry of the cluster as wellas information relating to the .symop's
   ! used to generate the cluster.
      self :: INOUT

      .geometry.destroy
      .shift.destroy
      .shift_for_atom.destroy
      .is_fragment_atom.destroy
      .occupation_list.destroy
      .molecule_for_atom.destroy
      .molecule.destroy
      .molecule_centroid.destroy
      .unique_molecule_for.destroy
      .unique_symcode_for.destroy
      .atom_connection.destroy

   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(cluster) ::: leaky
   ! Copy the contents of "cluster" to self. NOTE: ensure you destroy all the
   ! parts you need to before calling this.
      self :: INOUT
      cluster :: CLUSTER, IN

      self = cluster

      .nullify_ptr_part

      if (cluster.geometry.associated)                .geometry.create_copy(cluster.geometry)
      if (cluster.crystal.associated)                 .crystal.create_copy(cluster.crystal)
      if (cluster.asymmetric_unit_atom.associated)    .asymmetric_unit_atom.create_copy(cluster.asymmetric_unit_atom)
      if (cluster.shift.associated)                   .shift.create_copy(cluster.shift)
      if (cluster.shift_for_atom.associated)          .shift_for_atom.create_copy(cluster.shift_for_atom)
      if (cluster.is_fragment_atom.associated)        .is_fragment_atom.create_copy(cluster.is_fragment_atom)
      if (cluster.occupation_list.associated)         .occupation_list.create_copy(cluster.occupation_list)
      if (cluster.molecule_for_atom.associated)       .molecule_for_atom.create_copy(cluster.molecule_for_atom)
      if (cluster.molecule.associated)                .molecule.create_copy(cluster.molecule)
      if (cluster.molecule_centroid.associated)       .molecule_centroid.create_copy(cluster.molecule_centroid)
      if (cluster.unique_molecule_for.associated)     .unique_molecule_for.create_copy(cluster.unique_molecule_for)
      if (cluster.unique_symcode_for.associated)      .unique_symcode_for.create_copy(cluster.unique_symcode_for)
      if (cluster.atom_connection.associated)         .atom_connection.create_copy(cluster.atom_connection)

   end

   create(crystal) ::: leaky
   ! Create the object from the supplied "crystal".
      self :: PTR
      crystal :: CRYSTAL*

   ENSURE(crystal.associated,"no crystal created!")
   ENSURE(crystal.asymmetric_unit_atom.associated,"no crystal asymmetric unit atoms!")

      .create
      .set_defaults(crystal)

   end

!  ===========
!  Set methods
!  ===========

   set_defaults(crystal) ::: leaky
   ! Set up defaults. The "crystal" is pointer assigned. The cluster
   ! is essentially a crystal with additional operations based on the
   ! .fragment_geometry. Thus we must keep the crystal.fragment_geometry
   ! in sync with the cluster.fragment geometry.
      self :: INOUT
      crystal :: CRYSTAL*

   ENSURE(crystal.associated,"no crystal created!")
   ENSURE(crystal.asymmetric_unit_atom.associated,"no crystal asymmetric unit atoms!")
   ENSURE(crystal.fragment_geometry.associated,"no crystal fragment geometry!")

      .destroy_ptr_part

      .generation_method   = CLUSTER_GENERATION_METHOD
      .radius              = CLUSTER_RADIUS
      .atom_density_cutoff = CLUSTER_ATOM_DENSITY_CUTOFF
      .defragment          = CLUSTER_DEFRAGMENT
      .info_made           = FALSE
      .n_atoms = 0
      .h_min = 0
      .h_max = 0
      .n_fragment_atoms = 0
      .fragment_offset = 0
      .unit_cell_offset = ZERO

      ! Pointer assign these; we use them a lot
      .crystal => crystal
      .asymmetric_unit_atom => .crystal.asymmetric_unit_atom

      ! Set the basis type: slater trumps gaussians for cluster
      ! generation ...
      if      (.asymmetric_unit_atom.has_all_slater_bases)   then; .asymmetric_unit_atom.set_basis_kind("slater")
      else if (.asymmetric_unit_atom.has_all_coppens_bases)  then; .asymmetric_unit_atom.set_basis_kind("coppens")
      else if (.asymmetric_unit_atom.has_all_gaussian_bases) then; .asymmetric_unit_atom.set_basis_kind("gaussian")
      end

      ! Set the fragment geometry in fractionals & offset from the supplied crystal
      .fragment_geometry => crystal.fragment_geometry
      .n_fragment_atoms = crystal.n_fragment_atoms
      .fragment_offset  = int(crystal.fragment_geometry.mean_column_vector)

   end

   set_fragment_geometry(fragment_geometry,cartesian) ::: leaky
   ! Point assign the fragment_geometry in sync with the crystal one
   ! Set "cartesian" TRUE if the fragment atoms are in xyz coord frame
   ! WARNING: doesn't seem in sync to me -- dylan
      self :: INOUT
      fragment_geometry :: MAT{REAL}
      cartesian :: BIN, optional, IN

   ENSURE(.crystal.associated,"no crystal created!")
   ENSURE(.crystal.asymmetric_unit_atom.associated,"no crystal asymmetric unit atoms!")

      ! Set crystal fragment geometry (must be fractional)
      .crystal.set_fragment_geometry(fragment_geometry,cartesian)

      ! Point to crystal fragment geometry
      .fragment_geometry => .crystal.fragment_geometry
      .n_fragment_atoms  =  .crystal.n_fragment_atoms

      ! Set fragment offset (center) from the supplied crystal
      .fragment_offset   = int(.crystal.fragment_geometry.mean_column_vector)

   end

   set_generation_method(method)
   ! Set the generation method, which tells how to generate the cluster e.g.
   ! whether to add atoms to the cluster within a certain radius of the starting
   ! fragment, or whether to use the unit cell ad the cluster, or just the
   ! initial starting fragment (i.e. the null cluster) or the initial fragment
   ! and the unit cell.
      self :: INOUT
      method :: STR, IN

      .generation_method = method
      .generation_method.to_lower_case

      select case (.generation_method)
      case("for_hirshfeld_surface     ")
      case("fragment                  ")
      case("unit_cell                 ")
      case("unit_cell_plus            ")
      case("for_unit_cell_density     ")
      case("offset_unit_cell          ")
      case("offset_unit_cell_density  ")
      case("within_radius             ")
      case default;   UNKNOWN(.generation_method)
      end

   end

   set_unit_cell_offset(offset)
   ! Set the unit_cell_offset to use when making an offset unit cell.
      self :: INOUT
      offset :: VEC{REAL}(3)

   DIE_IF(any(offset>HALF) OR any(offset<-HALF),"offset must be between -1/2 and +1/2")

      .unit_cell_offset = offset

   end

   set_defragment(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.defragment), PURE
   ! Generic set
   end

!  =============
!  Input methods
!  =============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      self :: INOUT
      keyword :: STR, IN

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
      case ("}                             ")  ! exit case
      case ("add_criteria=                 "); .read_generation_method
      case ("atoms=                        "); .read_atoms
      case ("atom_density_cutoff=          "); .read_atom_density_cutoff
      case ("debug_on                      "); .read_debug_on
      case ("debug_off                     "); .read_debug_off
      case ("defragment=                   "); .read_defragment
      case ("fractional_fragment=          "); .read_fractional_fragment
      case ("generation_method=            "); .read_generation_method
      case ("make_info                     "); .make_info
      case ("unit_cell_atoms_to_suppress=  "); .read_unit_cell_atoms_to_suppress
      case ("unit_cell_offset=             "); .read_unit_cell_offset
      case ("put                           "); .put
      case ("put_averaged_lff_l_tensors    "); .put_averaged_LFF_tensors
      case ("put_centroid_lff_l_tensors    "); .put_centroid_LFF_tensors
      case ("put_centroid_lff_l_tensors_old"); .put_centroid_LFF_tensors_old
      case ("put_debug_list                "); .put_debug_list
      case ("put_lff_info                  "); .put_LFF_info
      case ("put_tonto_input               "); .put_tonto_input
      case ("radius=                       "); .read_radius
      case ("reset_site_occupancies        "); .reset_site_occupancies
      case ("units=                        "); .read_units
      case default;     UNKNOWN(word)
      end

   end

   reset_site_occupancies
   ! Sets all the site occupancies of asymmetric to 1.0
      self :: INOUT

   ENSURE(.crystal.associated,"no crystal defined")
   ENSURE(.crystal.asymmetric_unit_atom.associated,"no asymmetric atoms!")

      occ :: VEC{REAL}*

      occ.create(.asymmetric_unit_atom.dim)
      occ = 1.0
      .asymmetric_unit_atom.set_site_occupancies(occ)

      occ.destroy

   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_unit_cell_atoms_to_suppress
   ! Read in a list of indices into the unit cell atom list
   ! In make_info these atoms are removed from unit_cell_geometry
   ! thus suppressing them from cluster generation methods
   ! that use the unit cell geometry
      self :: INOUT

      stdin.read_ptr(.unit_cell_atoms_to_suppress)

   end

   read_unit_cell_offset
   ! Read the add criteria, whether to add atoms by whole clusters within a
   ! certain radius of the starting fragment, or by individual atoms within a
   ! certain distance of the starting fragment.
      self :: INOUT

      offset :: VEC{REAL}(3)

      stdin.read(offset)

      .set_unit_cell_offset(offset)

   end

   read_generation_method
   ! Read the add criteria, whether to add atoms by whole clusters within a
   ! certain radius of the starting fragment, or by individual atoms within a
   ! certain distance of the starting fragment.
      self :: INOUT

      generation_method :: STR

      stdin.read(generation_method)

      .set_generation_method(generation_method)

   end

   read_defragment
   ! Read whether to defragment the cluster at the boundaries. If set TRUE, the
   ! cluster ends are defragmented, i.e. any atoms which are bonded at the ends
   ! of the cluster are included into the cluster.
      self :: INOUT

      stdin.read(.defragment)

   end

   read_radius
   ! Read the radius of the cluster. Usually, all atoms with this distance of
   ! any atom in the fragment_geometry will appear in the cluster.
      self :: INOUT

      stdin.read_quantity(.radius)

   end

   read_atom_density_cutoff
   ! This number is used to define a cluster radius (see above). The radius is
   ! defined from it, as the *largest* distance from any atom in the
   ! asymmetric_cell_atom list where the atomic electron density becomes smaller
   ! than this number. It requires that slater or coppens bases are defined for
   ! the asymmetric_cell_atom's, and it requires that the generation method be
   ! set to "for_hirshfeld_surface". It is primarily used for clusters generated
   ! from a fragment, which will correctly produce the Hirshfeld surface.
      self :: INOUT

      stdin.read_quantity(.atom_density_cutoff)

   end

   read_fractional_fragment ::: leaky
   ! Read in the fragment geometry, in fractional coordinates.
   ! NOTE: All fragment atom positions must correspond to the
   ! positions of actual atoms in the crystal lattice.
      self :: INOUT

   ENSURE(.crystal.associated,"no crystal defined")

      fragment_geometry :: MAT{REAL}*
      tmp :: VEC{REAL}*
      n :: INT

      stdin.read_ptr(tmp)
      ENSURE(mod(tmp.dim,3)==0,"# of elements not divisible by 3")

      n = tmp.dim/3
      fragment_geometry.create(3,n)
      fragment_geometry = reshape(tmp,[3,n])
      .set_fragment_geometry(fragment_geometry)

      fragment_geometry.destroy; tmp.destroy

   end

   read_atoms ::: leaky
   ! Modify the atom list information
      self :: INOUT

   DIE_IF(.asymmetric_unit_atom.disassociated,"atom list not created!")

      .asymmetric_unit_atom.read_list_keywords

      ! Change coordinates to cartesian
      ! Errors (if any) are changed straightforwardly
      if (associated(.crystal)) &
      .asymmetric_unit_atom.change_axis_system_to("cartesian",.crystal.unit_cell,FALSE)

   end

!  ===========================
!  Cluster generation routines
!  ===========================

   make_info ::: leaky
   ! Make all the cluster information from an arbitrary .fragment_geometry.
   ! NOTE: .set_defaults must be called before this.

   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.unit_cell_connection.associated,"no unit cell connection table")
   ENSURE(.fragment_geometry.associated,"no fragment_geometry")

      if (.info_made) return

      ! Depending on the generation_method, make starting cluster
      .make_occupation_list

      ! Generate the cluster
      select case (.generation_method)

         case ("within_radius")
            .make_within_radius

         case ("for_hirshfeld_surface")
            .make_HS_radius
            .make_within_radius
            .defragment = FALSE

         case ("for_unit_cell_density")
          ! .do_defragment
            .make_HS_radius
            .make_within_radius
            .defragment = FALSE

         case ("offset_unit_cell_density")
            .make_HS_radius
            .make_within_radius
            .defragment = FALSE

      end

      ! Defragment/find molecules in the cluster
      if (.defragment) then; .do_defragment
      else;                  .do_connectify
      end

      ! Extract cordinates from occupation list
      .extract_geometry

      ! Finished ...
      .info_made = TRUE

   end

   make_occupation_list ::: leaky
   ! Codify which atoms in the crystal are fragment atoms i.e. make
   ! the ".occupation_list". If atom "u" in the unit cell "(h1,h2,h3)"
   ! is occupied then the macro CLUSTER_AT_CODE(h1,h2,h3,u) appears in
   ! the array "list". The maximum value allowed for any h is
   ! CLUSTER_H_MAX i.e. we can't consider fragments atoms which lie in
   ! cells outside this range. This list allows easy comparison of
   ! which atoms are in the fragment by an integer equality test.
   ! NOTE: Also make the ".molecule_for_atom" list which tells which
   ! molecule the atom belongs to.

   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.unit_cell_geometry.associated,"no crystal unit cell")
   ENSURE(.fragment_geometry.associated,"no fragment_geometry")

      h :: VEC{INT}(3)
      radius,two_angstrom :: REAL
      pos,b,t :: VEC{REAL}(3)
      f,u,h000,uc :: INT
      fragment_geometry :: MAT{REAL}*

      select case (.generation_method)

         case ("within_radius","for_hirshfeld_surface","fragment")

            ENSURE(.fragment_geometry.associated,"no fragment_geometry")
            ENSURE(.crystal.fragment_info_made,"no crystal fragment info")
            ENSURE(.crystal.unit_cell_atom_for_frag_atom.associated,"no cell-frag_atom array")
            ENSURE(.crystal.unit_cell_shift_for_frag_atom.associated,"no cell-frag_atom array")

            ! Get fragment offset i.e. center
            pos = .fragment_geometry.mean_column_vector
            .fragment_offset = int(pos)

            ! Create occupation list
            .occupation_list.destroy
            .occupation_list.create(.n_fragment_atoms)

            ! Loop on fragment atom
            do f = 1,.n_fragment_atoms

               ! Get unit cell atom & shift
               u = .crystal.unit_cell_atom_for_frag_atom(f)
               h = .crystal.unit_cell_shift_for_frag_atom(:,f)

               ! Shift relative to recentered unit cell
               h = h + .fragment_offset

               DIE_IF(any(h<-CLUSTER_H_MAX),"frag too wide, h = "//trim(h.to_concatenated_str))
               DIE_IF(any(h> CLUSTER_H_MAX),"frag too wide, h = "//trim(h.to_concatenated_str))

               ! Sanity check
               if (u==0) then
                  WARN("position of fragment atom "//f.to_str.trim//" not found in unit cell")
                  stdout.show("fragment pos =",pos)
                  stdout.text("unit cell geometry:")
                  stdout.put(transpose(.crystal.unit_cell_geometry))
                  DIE("position of fragment atom "//f.to_str.trim//" not found in unit cell")
               end

               ! Offset h to apply to "u" to get frag atom "f".
               ! Must reverse h. See above.
               h = -h

               ! Get occ code ...
               .occupation_list(f) = CLUSTER_AT_CODE(h(1),h(2),h(3),u)

            end

         case ("unit_cell")

            ! Create occupation list
            .occupation_list.destroy
            .occupation_list.create(.crystal.n_unit_cell_atoms)

            ! Temporary
            fragment_geometry.create(3,.crystal.n_unit_cell_atoms)

            ! Set central cell
            h000 = CLUSTER_H_CODE(0,0,0)

            do u = 1,.crystal.n_unit_cell_atoms

               ! Encode central cell
               .occupation_list(u) = h000 + CLUSTER_UA_CODE(u)

               ! Set fragment to unit cell
               pos = .crystal.unit_cell_geometry(:,u)
               fragment_geometry(:,u) = pos

            end

            ! Set fragment and make sure there is no offset
            .set_fragment_geometry(fragment_geometry)
            .fragment_offset = 0

            ! Clean
            fragment_geometry.destroy

         case ("unit_cell_plus","for_unit_cell_density")

            ! Create occupation list
            .occupation_list.destroy
            .occupation_list.create(.crystal.n_unit_cell_atoms)

            ! Temporary
            fragment_geometry.create(3,.crystal.n_unit_cell_atoms)

            ! Set central cell
            h000 = CLUSTER_H_CODE(0,0,0)

            do u = 1,.crystal.n_unit_cell_atoms

               ! Encode central cell
               .occupation_list(u) = h000 + CLUSTER_UA_CODE(u)

               ! Set fragment to unit cell
               pos = .crystal.unit_cell_geometry(:,u)
               fragment_geometry(:,u) = pos

            end

            ! Set fragment and make sure there is no offset
            .set_fragment_geometry(fragment_geometry)
            .fragment_offset = 0

            ! Clean
            fragment_geometry.destroy

            ! Go two angstrom from unit cell edges for unit cell densities
            ! if the setting is "for_unit_cell_density"
            two_angstrom = TWO
            two_angstrom = two_angstrom.from_units("angstrom")
            if (.generation_method=="unit_cell_plus") then; radius = .radius
            else;                                           radius = max(TWO,.radius)
            end

            ! Fractions "b" along cell axes; and complements "t"
            b = radius/.crystal.unit_cell.length
            DIE_IF(any(b>ONE),"radius around unit cell exceeds at least one cell dimension")
            t = ONE - b

            ! Unit cell code
            uc = 0

            do u = 1,.crystal.n_unit_cell_atoms

               pos = .crystal.unit_cell_geometry(:,u)

               uc = CLUSTER_UA_CODE(u)

               ! FIX h1
               if (pos(1)<b(1)) .occupation_list.append(CLUSTER_H_CODE( 1, 0, 0)+uc)
               if (pos(2)<b(2)) .occupation_list.append(CLUSTER_H_CODE( 0, 1, 0)+uc)
               if (pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE( 0, 0, 1)+uc)
               if (pos(1)>t(1)) .occupation_list.append(CLUSTER_H_CODE(-1, 0, 0)+uc)
               if (pos(2)>t(2)) .occupation_list.append(CLUSTER_H_CODE( 0,-1, 0)+uc)
               if (pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE( 0, 0,-1)+uc)

               if (pos(1)<b(1) AND pos(2)<b(2)) .occupation_list.append(CLUSTER_H_CODE( 1, 1, 0)+uc)
               if (pos(1)<b(1) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE( 1, 0, 1)+uc)
               if (pos(2)<b(2) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE( 0, 1, 1)+uc)
               if (pos(1)>t(1) AND pos(2)<b(2)) .occupation_list.append(CLUSTER_H_CODE(-1, 1, 0)+uc)
               if (pos(1)>t(1) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE(-1, 0, 1)+uc)
               if (pos(2)>t(2) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE( 0,-1, 1)+uc)
               if (pos(1)<b(1) AND pos(2)>t(2)) .occupation_list.append(CLUSTER_H_CODE( 1,-1, 0)+uc)
               if (pos(1)<b(1) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE( 1, 0,-1)+uc)
               if (pos(2)<b(2) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE( 0, 1,-1)+uc)
               if (pos(1)>t(1) AND pos(2)>t(2)) .occupation_list.append(CLUSTER_H_CODE(-1,-1, 0)+uc)
               if (pos(1)>t(1) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE(-1, 0,-1)+uc)
               if (pos(2)>t(2) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE( 0,-1,-1)+uc)

               if (pos(1)<b(1) AND pos(2)<b(2) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE( 1, 1, 1)+uc)
               if (pos(1)>t(1) AND pos(2)<b(2) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE(-1, 1, 1)+uc)
               if (pos(1)<b(1) AND pos(2)>t(2) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE( 1,-1, 1)+uc)
               if (pos(1)>t(1) AND pos(2)>t(2) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE(-1,-1, 1)+uc)
               if (pos(1)<b(1) AND pos(2)<b(2) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE( 1, 1,-1)+uc)
               if (pos(1)>t(1) AND pos(2)<b(2) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE(-1, 1,-1)+uc)
               if (pos(1)<b(1) AND pos(2)>t(2) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE( 1,-1,-1)+uc)
               if (pos(1)>t(1) AND pos(2)>t(2) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE(-1,-1,-1)+uc)

            end

         case ("offset_unit_cell","offset_unit_cell_density")

            ! Create occupation list
            .occupation_list.destroy
            .occupation_list.create(.crystal.n_unit_cell_atoms)

            ! Temporary
            fragment_geometry.create(3,.crystal.n_unit_cell_atoms)

            do u = 1,.crystal.n_unit_cell_atoms

               ! Unit cell position
               pos = .crystal.unit_cell_geometry(:,u)

               ! Set central cell
               h = 0

               ! Apply the offset
               if (pos(1)<    .unit_cell_offset(1)) h(1) = +1
               if (pos(2)<    .unit_cell_offset(2)) h(2) = +1
               if (pos(3)<    .unit_cell_offset(3)) h(3) = +1
               if (pos(1)>ONE+.unit_cell_offset(1)) h(1) = -1
               if (pos(2)>ONE+.unit_cell_offset(2)) h(2) = -1
               if (pos(3)>ONE+.unit_cell_offset(3)) h(3) = -1

               ! Get occ code ...
               .occupation_list(u) = CLUSTER_AT_CODE(h(1),h(2),h(3),u)

               ! Set frag geometry with offset
               fragment_geometry(:,u) = pos + h

            end

            ! Set fragment and make sure there is no offset
            .set_fragment_geometry(fragment_geometry)
            .fragment_offset = 0

            ! Clean
            fragment_geometry.destroy

         case default
            UNKNOWN(.generation_method)

      end

   end

   make_HS_radius
   ! This routine makes an appropriate value for the cluster .radius in the
   ! case where the .generation_method is "for_hirshfeld_surface". The radius is
   ! made so that the accuracy of any atomic term neglected is smaller than
   ! .atom_density_cutoff. The radius is defined to the nearest 0.02 bohr (or
   ! whatever is set as the default for the interpolator table spacing). Likewise,
   ! we can't cope with atom density cutoffs where the distances are larger than
   ! 30 bohr (or whatever is set as the default interpolator table length). To
   ! do this properly we'd have to solve numerical equations for exactly where
   ! the atom density equals the desired cutoff; that seems like too much
   ! effort.

   ENSURE(.asymmetric_unit_atom.associated,"no asymmetric cell atoms")
   ENSURE(.atom_density_cutoff>ZERO,"atom density cutoff must be positve")

      .radius = .asymmetric_unit_atom.max_interpolator_table_length(.atom_density_cutoff)

   end

   make_within_radius ::: leaky
   ! Make the maximum unit cell offsets so that we get all atoms within a
   ! certain radius of the fragment geometry.

   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.fragment_geometry.associated,"no fragment_geometry")
   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.unit_cell_geometry.associated,"no crystal unit_cell_geometry")

      geom0,frag :: MAT{REAL}*
      rcm :: MAT{REAL}(3,3)
      pos,off,d,frac_radius :: VEC{REAL}(3)
      hlist,ulist,match :: VEC{INT}*
      uskip :: VEC{BIN}*
      d2,radius2 :: REAL
      within_radius,has_frag_atoms,not000,offset, has_atoms_to_suppress :: BIN
      n_unit_cell_atoms, h0,h1,h2,h3, hcode,code, k,u :: INT

      ! Constants
      n_unit_cell_atoms = .crystal.n_unit_cell_atoms
      radius2           = .radius*.radius
      rcm               = .crystal.unit_cell.direct_matrix
      has_atoms_to_suppress = .unit_cell_atoms_to_suppress.associated
      if (has_atoms_to_suppress) has_atoms_to_suppress = .unit_cell_atoms_to_suppress.dim > 0

      ! Cartesian fragment geometry
      frag.create(3,.n_fragment_atoms)
      frag.to_product_of(rcm,.fragment_geometry)

      ! Calculate offset to fragment
      offset = any(.fragment_offset/=0)
      if (offset) then
         off.to_product_of(rcm,REALIFY(.fragment_offset))
      end

      ! Look this many cells away for cluster atoms ...
      frac_radius = .radius/.crystal.unit_cell.length
      .h_max = ceiling( frac_radius+maxval(.fragment_geometry,dim=2) - .fragment_offset)
      .h_min =   floor(-frac_radius+minval(.fragment_geometry,dim=2) - .fragment_offset)

      ! Look at least one cell away ...
      .h_max = max(.h_max,[ 1, 1, 1])
      .h_min = min(.h_min,[-1,-1,-1])

      ! Maximum value of unit cell index
      ! and offset for unit cell coding
      h0 = CLUSTER_H_MAX
      DIE_IF(any(.h_min<-h0),"search too low, h_min = "//trim(.h_min.to_concatenated_str))
      DIE_IF(any(.h_max> h0),"search too high, h_max = "//trim(.h_max.to_concatenated_str))

      ! Get the (0,0,0) unit cell offset by .fragment_offset in cartesians
      geom0.create(3,n_unit_cell_atoms)
      geom0.to_product_of(rcm,.crystal.unit_cell_geometry)
      if (offset) &
      geom0 = geom0 + spread(off,2,n_unit_cell_atoms)

      ! Cells which fragment occupies
      match.create(.n_fragment_atoms)
      hlist.create(.n_fragment_atoms)
      hlist = CLUSTER_HC_FROM_CODE(.occupation_list)

      ! Unit cell atoms which correspond to the fragment atoms
      ulist.create(.n_fragment_atoms)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list)

      ! Skip fragment atoms in a particular unit cell
      uskip.create(n_unit_cell_atoms)

      ! Loop over allowed cells
      do h1 = .h_min(1),.h_max(1)
      do h2 = .h_min(2),.h_max(2)
      do h3 = .h_min(3),.h_max(3)

         ! Get cell displacement vector if needed
         not000 = h1/=0 OR h2/=0 OR h3/=0
         if (not000) off.to_product_of(rcm,REALIFY(([h1,h2,h3])))

         ! Get list of atoms in "match" which are in this cell
         hcode = CLUSTER_H_CODE(h1,h2,h3)
         match => hlist.indices_of_elements_matching(hcode)

         ! Are there any fragment atoms in this cell?
         ! Set the unit cell atoms corresponding to them
         has_frag_atoms = match.dim>0
         if (has_frag_atoms) then
            uskip = FALSE
            do k = 1,match.dim
               uskip(ulist(match(k))) = TRUE
            end
         end

         ! Loop over unit cell atoms in this cell
         do u = 1,n_unit_cell_atoms

            ! If there are fragment atoms here, skip them
            if (has_frag_atoms) then
               if (uskip(u)) cycle
            end

            if (has_atoms_to_suppress) then
              if (any(.unit_cell_atoms_to_suppress == u)) cycle
            end

            pos = geom0(:,u)
            if (not000) pos = pos + off

            ! Test if this atom pos is within .radius
            within_radius = FALSE
            do k = 1,.n_fragment_atoms

               d = frag(:,k) - pos

               ! Sequentially eliminate far points
               if (abs(d(1))>.radius) cycle
               if (abs(d(2))>.radius) cycle
               if (abs(d(3))>.radius) cycle

               ! Don't use square root
               d2 = d(1)*d(1)+d(2)*d(2)+d(3)*d(3)
               if (d2>radius2) cycle

               within_radius = TRUE
               exit

            end

            if (NOT within_radius) cycle

            ! New atom ... add it in ...
            code = hcode + CLUSTER_UA_CODE(u)
            .occupation_list.append(code)

         end

         ! Clean
         match.destroy

      end
      end
      end

      ! Clean
      uskip.destroy
      ulist.destroy
      hlist.destroy
      geom0.destroy
      frag.destroy

   end

   do_connectify ::: leaky
   ! Find the connected molecules in the "occupation_list" from the
   ! .crystal.unit_cell_connection table.

   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.unit_cell_connection.associated,"no unit cell connection table")

      i,c,code,h1,h2,h3,u,k1,k2,k3,t,old,mi,mo :: INT
      con,molecule_for_atom :: VEC{INT}*
      unit_cell_connection :: VEC{VEC_{VEC_{INT}}}*

      ! No. of atoms
      .n_atoms = .occupation_list.dim

      ! Connection table
      unit_cell_connection => .crystal.unit_cell_connection

      ! Clear info arrays
      .atom_connection.destroy
      .atom_connection.create(.n_atoms)
      .molecule_for_atom.destroy

      ! Assume every atom it's own molecule
      molecule_for_atom.create(.n_atoms)
      do i = 1,.n_atoms
         molecule_for_atom(i) = i
      end

      ! Loop on all atoms "i"
      i = 0

      do

         i = i + 1

         ! Finished atoms "i"?
         if (i>.n_atoms) exit

         ! Info about atom "i"
         mi   = molecule_for_atom(i)       ! Molecule "mi" for i
         code = .occupation_list(i)        ! Occupation code
         u    = CLUSTER_UA_FROM_CODE(code) ! Unit cell atom

         ! No connections? next ...
         if (unit_cell_connection(u).element.dim==0) cycle

         ! Get unit cell atom offset for atom "i"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)

         ! Find atoms which connect to u
         do c = 1,unit_cell_connection(u).element.dim

            ! List of connections
            con => unit_cell_connection(u)[c].element

            ! Get code for connected atom
            k1 = h1 + con(1)
            k2 = h2 + con(2)
            k3 = h3 + con(3)
            t  =      con(4)
            code = CLUSTER_AT_CODE(k1,k2,k3,t)

            ! Is it new in the occupation list?
            old = .occupation_list.index_of_value(code)

            if (old>0) then

               ! This is an old (found) atom. Replace the molecule
               ! index by the lower of  "mi" and "mo" everywhere.
               mo = molecule_for_atom(old)
               if (mo<mi) then
                  where (molecule_for_atom==mi) molecule_for_atom = mo
                  mi = mo
               else if (mo>mi) then
                  where (molecule_for_atom==mo) molecule_for_atom = mi
               end

               ! Atom "old" is connection to "i"
               .atom_connection(i).element.append(old)

            end

         end ! connections to u

      end ! atoms "i"

      ! Set (sorted) molecule index array
      .molecule_for_atom => molecule_for_atom

      ! Make molecule info
      .make_molecule_info

   end

   do_defragment ::: leaky
   ! Defragment the generated cluster and find the connected molecules using the
   ! .unit_cell_connection table.

   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.unit_cell_connection.associated,"no unit cell connection table")

      i,c,code,h1,h2,h3,u,k1,k2,k3,t,old,mi,mo :: INT
      con,molecule_for_atom :: VEC{INT}*
      unit_cell_connection :: VEC{VEC_{VEC_{INT}}}*

      ! Initial no. of atoms
      .n_atoms = .occupation_list.dim

      ! Connection table
      unit_cell_connection => .crystal.unit_cell_connection

      ! Clear info arrays
      .atom_connection.destroy
      .atom_connection.create(.n_atoms)
      .molecule_for_atom.destroy

      ! Assume every atom it's own molecule
      molecule_for_atom.create(.n_atoms)
      do i = 1,.n_atoms
         molecule_for_atom(i) = i
      end

      ! Loop on all atoms "i"
      i = 0

      do

         i = i + 1

         ! Any more atoms to connect?
         if (i>.n_atoms) exit

         ! Info about atom "i"
         mi   = molecule_for_atom(i)       ! Molecule "mi" for i
         code = .occupation_list(i)        ! Occupation code
         u    = CLUSTER_UA_FROM_CODE(code) ! Unit cell atom

         ! No connections to this atom? next ...
         if (unit_cell_connection(u).element.dim==0) cycle

         ! Get unit cell atom offset for atom "i"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)

         ! Loop on atoms "c" connected to "u"
         do c = 1,unit_cell_connection(u).element.dim

            ! List of connections
            con => unit_cell_connection(u)[c].element

            ! Get code for connected atom
            k1 = h1 + con(1)
            k2 = h2 + con(2)
            k3 = h3 + con(3)
            t  =      con(4)
            code = CLUSTER_AT_CODE(k1,k2,k3,t)

            ! Is it new in the occupation list?
            old = .occupation_list.index_of_value(code)

            if (old>0) then

               ! This is an old (found) atom. Replace the molecule
               ! index by the lower of  "mi" and "mo" everywhere.
               mo = molecule_for_atom(old)
               if (mo<mi) then
                  where (molecule_for_atom==mi) molecule_for_atom = mo
                  mi = mo
               else if (mo>mi) then
                  where (molecule_for_atom==mo) molecule_for_atom = mi
               end
               .atom_connection(i).element.append(old)

            else

               ! This is a new atom. Increment no. of atoms,
               ! store in the occ list and add new connection.
               .occupation_list.append(code)
               molecule_for_atom.append(mi)
               .n_atoms = .n_atoms + 1
               .atom_connection.expand(.n_atoms)
               .atom_connection(i).element.append(.n_atoms)

            end

         end

      end

      ! Set (sorted) molecule index array
      .molecule_for_atom => molecule_for_atom

      ! Make molecule info
      .make_molecule_info

   end

   do_defragment(occupation_list) ::: leaky
   ! Defragment the "occupation_list"
      occupation_list :: VEC{INT}*

   ENSURE(occupation_list.associated,"no occupation_list")
   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.unit_cell_connection.associated,"no unit cell connection table")

      n_atoms,i,c,code,h1,h2,h3,u,k1,k2,k3,t,old :: INT
      con :: VEC{INT}*
      unit_cell_connection :: VEC{VEC_{VEC_{INT}}}*

      ! Initial no. of atoms
      n_atoms = occupation_list.dim

      ! Connection table
      unit_cell_connection => .crystal.unit_cell_connection

      ! Loop on all atoms "i"
      i = 0

      do

         i = i + 1

         ! Any more atoms to connect?
         if (i>n_atoms) exit

         ! Info for atom "i"
         code = occupation_list(i)         ! Occupation code
         u    = CLUSTER_UA_FROM_CODE(code) ! Unit cell atom

         ! No connections to this atom? next ...
         if (unit_cell_connection(u).element.dim==0) cycle

         ! Get unit cell atom offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)

         ! Loop on atoms "c" connected to "u"
         do c = 1,unit_cell_connection(u).element.dim

            ! List of connections
            con => unit_cell_connection(u)[c].element

            ! Get code for connected atom
            k1 = h1 + con(1)
            k2 = h2 + con(2)
            k3 = h3 + con(3)
            t  =      con(4)
            code = CLUSTER_AT_CODE(k1,k2,k3,t)

            ! Is it new in the occupation list?
            old = occupation_list.index_of_value(code)

            if (old>0) cycle ! if old

            ! This is a new atom. Increment no. of atoms,
            ! store in the occ list.
            occupation_list.append(code)
            n_atoms = n_atoms + 1

         end

      end

   end

   do_defragment_uc_atom(u,geometry) ::: leaky
   ! Defragment a single atom "u" in the unit cell and produce a
   ! "geometry" in crystal coordinates.
      u :: INT, IN
      geometry :: MAT{REAL}*

      occupation_list :: VEC{INT}*

      ! Creat one-atom occ list
      occupation_list.create(1)
      occupation_list(1) = CLUSTER_AT_CODE(0,0,0,u)

      ! Defragment and extract geometry
      .do_defragment(occupation_list)
      .extract_geometry(occupation_list,geometry)

      ! Clean
      occupation_list.destroy

   end

   do_defragment_uc_atom(u,symop,par,pos,mass) ::: leaky
   ! Defragment a single atom "u" in the unit cell and produce the
   ! "symop" (index) which maps the asymmetric parent-atom "par" into
   ! "u", the *list* of cartesian positions in "pos",  and the list of
   ! corresponding atomic masses in "mass".  Needed for LFF refractive
   ! index calculations.
      u :: INT, IN
      symop :: INT, OUT
      par :: VEC{INT}, OUT
      pos :: MAT{REAL}, OUT
      mass   :: VEC{REAL}, OUT

      occupation_list :: VEC{INT}*

      ! Get symop for cell atom "u"
      symop = .crystal.asym_symop_for_unit_cell_atom(u)

      ! Make the coded occupation_list for this atom
      occupation_list.create(1)
      occupation_list(1) = CLUSTER_AT_CODE(0,0,0,u)

      ! Defragment this atom and get the info
      .do_defragment(occupation_list)
      .extract_atom_info(occupation_list,par,pos,mass)

      ! Clean up
      occupation_list.destroy

   end

   do_defragment_uc_atom(u,pos,charge,dipole,frag_atom) ::: leaky
   ! Defragment a single atom "u" in the unit cell and extract
   ! *cartesian* atom positions "pos", the atomic charges and dipoles
   ! "charge" and "dipole" in a *flat* array, and the frag atom for
   ! the atoms.  These properties are requited for LFF refractive
   ! index calculations.
      u :: INT, IN
      pos :: MAT{REAL}, OUT
      charge,dipole :: VEC{REAL}, OUT
      frag_atom :: VEC{INT}, optional

      occupation_list :: VEC{INT}*

      ! Make the coded occupation_list for this atom
      occupation_list.create(1)
      occupation_list(1) = CLUSTER_AT_CODE(0,0,0,u)

      ! Defragment this atom and get the info
      .do_defragment(occupation_list)
      .extract_atom_info(occupation_list,pos,charge,dipole,frag_atom)

      ! Clean up
      occupation_list.destroy

   end

   do_defragment_uc_atom(u,symop,par,pos,charge,mass,dipole,alpha_q,alpha_m) ::: leaky
   ! Defragment a single atom "u" in the unit cell and for the
   ! *molecule* produce the "symop" (3x3 matrix) which maps "u" into
   ! the *last* asymmetric parent-atom "par" in the *list* of
   ! defragged cartesian positions in "pos", the atomic "charge",
   ! "mass", and "dipole", and the atomic charge and dipole
   ! polarizabilities "alpha_q" and "alpha_m".
   ! NOTE: symop matrix seems strange cf. routine above.
      u :: INT, IN
      symop :: MAT{REAL}, OUT
      par :: VEC{INT}, OUT
      pos :: MAT{REAL}, OUT
      charge :: VEC{REAL}, OUT
      mass   :: VEC{REAL}, OUT
      dipole :: MAT{REAL}, OUT
      alpha_q :: MAT{REAL}, OUT
      alpha_m :: MAT3{REAL}, OUT

      occupation_list :: VEC{INT}*

      ! Make the coded occupation_list for this atom
      occupation_list.create(1)
      occupation_list(1) = CLUSTER_AT_CODE(0,0,0,u)

      ! Defragment this atom and get the *molecule* info
      .do_defragment(occupation_list)
      .extract_molecule_atom_info(occupation_list,symop,par,pos,charge,mass,dipole,alpha_q,alpha_m)

      ! Clean up
      occupation_list.destroy

   end

   make_molecule_info ::: private, leaky
   ! Sort the cluster into molecules whose indices appear in ascending
   ! order; also sort the atom indices in each molecule.

   ENSURE(.molecule_for_atom.associated,"no molecule_for_atom")

      .sort_molecule_indices

      if (.defragment) .reorder_molecules

   end

   sort_molecule_indices ::: private, leaky, PURE
   ! Sort cluster molecule indices into ascending order.
      self :: INOUT

   ENSURE(.molecule_for_atom.associated,"no molecule_for_atom")

      unique :: VEC{INT}@
      mi,mj, m,a :: INT

      ! Get molecule indices & sort ascdending
      unique.to_unique_elements_of(.molecule_for_atom)
      unique.sort

      ! Number of molecules in cluster
      .n_molecules = unique.dim

      ! Put .molecule_for_atom into ascending order
      do mi = 1,.n_molecules
         mj = unique(mi)
         if (mj==mi) cycle
         where (.molecule_for_atom==mj) .molecule_for_atom = mi
      end

      ! Now make the molecule list
      .molecule.create(.n_molecules)
      do a = 1,.n_atoms
         m = .molecule_for_atom(a)
         .molecule(m).element.append(a)
      end

   end

   reorder_molecules ::: private, leaky, PURE
   ! Sort the cluster molecules so that the atom order in
   ! each is consistent. This only works for defragmented
   ! clusters, and the molecules are *not* put consecutively
   ! here, that is done in extract_geometry.
      self :: INOUT

   ENSURE(.defragment,"not defragmented!")
   ENSURE(.molecule_for_atom.associated,"no molecule_for_atom")

      ni,s  :: INT
      mi,si :: INT
      mj,sj :: INT
      ic,i0,i1,i2,i3 :: INT
      jc,j0,j1,j2,j3 :: INT
      li,cj,uj,fj :: VEC{INT}@
      lj,ci,ui,fi :: VEC{INT}@
      perm,new :: VEC{INT}@
    ! geom :: MAT{REAL}@
      pi,pj,ps :: VEC{REAL}(3)
      shift :: VEC{INT}(3)
      related :: BIN

      ! Clean & get ready
      .unique_molecule_for.destroy
      .unique_molecule_for.create(.n_molecules)
      .unique_symcode_for.destroy
      .unique_symcode_for.create(.n_molecules)

      ! List of unique molecules for each cluster atom
      ! and their relating symops
      .n_unique_molecules     = 1
      .unique_molecule_for    = 0
      .unique_symcode_for     = 0

      ! Loop on molecules, mi.
      ! Make atom-order in matching molecules consistent
      do mi = 1,.n_molecules

         ! Processed?
         if (.unique_molecule_for(mi)>0) cycle

         ! Molecule "mi" indices
         li = .molecule(mi)[:]
         ni = li.dim

         fi.create(ni)
         ui.create(ni)
         ci.create(ni)

         ! Cluster codes for mi
         ci(:) = .occupation_list(li)

         ! Unit cell atom indices for mi
         ui(:) = CLUSTER_UA_FROM_CODE(ci)

         ! Parent fragment atom indices for mi
         fi(:) = .crystal.frag_atom_for_unit_cell_atom(ui)

         ! Symop which generate the molecule mi
         ! ACtually the inverse for later
         si = .crystal.frag_symop_for_unit_cell_atom(ui(1))
         si = .crystal.spacegroup.inverse_of_symops(si)

         ! Cluster symop for 1st atom in molecule mi
         ic = ci(1)
         i0 = CLUSTER_UA_FROM_CODE(ic)
         i1 = CLUSTER_H1_FROM_CODE(ic)
         i2 = CLUSTER_H2_FROM_CODE(ic)
         i3 = CLUSTER_H3_FROM_CODE(ic)

         ci.destroy
         ui.destroy

         ! Position of 1st atom in molecule mi
         pi = .crystal.unit_cell_geometry(:,i0) + [i1,i2,i3] + .fragment_offset

         ! Find matching molecules, mj
         do mj = mi+1,.n_molecules

            lj = .molecule(mj).element(:)

            ! Found?
            if (.unique_molecule_for(mj)>0) cycle

            ! Reject unless: same # on atoms?
            if (lj.dim/=ni) cycle

            fj.create(ni)
            uj.create(ni)
            cj.create(ni)

            ! Cluster codes for mj
            cj(:) = .occupation_list(lj)

            ! Unit cell atom indices for mi
            uj(:) = CLUSTER_UA_FROM_CODE(cj)

            ! Parent fragment atom indices for mj
            fj(:) = .crystal.frag_atom_for_unit_cell_atom(uj)

            ! Symop which generate the molecule mi
            sj  = .crystal.frag_symop_for_unit_cell_atom(uj(1))

            cj.destroy
            uj.destroy

            ! Match frag atoms
            perm.create(ni)
            fj.is_permutation_of(fi,related,perm)

            if (related) then

               ! New order
               new.create(ni)
               new(:) = lj(perm)

               ! First atom in mj (matched to mi)
               jc = .occupation_list(new(1))

               ! Cluster symop for matching 1st atom in molecule mj
               j0 = CLUSTER_UA_FROM_CODE(jc)
               j1 = CLUSTER_H1_FROM_CODE(jc)
               j2 = CLUSTER_H2_FROM_CODE(jc)
               j3 = CLUSTER_H3_FROM_CODE(jc)

               ! Position of 1st atom in mj
               pj = .crystal.unit_cell_geometry(:,j0) + [j1,j2,j3] + .fragment_offset

               ! Symop which maps mi->mj
               ! Symops act on coordinates to the right like matrices
               s = .crystal.spacegroup.product_of_symops(sj,si)

               ! Get shift
               ps = pi
               .crystal.spacegroup.transform_position(ps,s)

               ps    = pj - ps
               shift = nint(ps)

               ! Unique molecule
               .unique_molecule_for(mj) = mi

               ! New symcode
               .unique_symcode_for(mj) = CLUSTER_AT_CODE(shift(1),shift(2),shift(3),s)

               ! Reorder atoms in mj to be consistent with mi
               .occupation_list(new) = .occupation_list(lj)
               .molecule(mj).element = new

               new.destroy

               ! Check this geometry against occupation list
             ! geom = .fragment_geometry(:,fi)
             ! .transform_geometry(geom,s,translate=REALIFY(shift))
             ! stdout.text("geom:")
             ! stdout.put(transpose(geom))
             ! geom.destroy

            else

               ! Symmetry unique molecule
               .n_unique_molecules      = .n_unique_molecules + 1
               .unique_molecule_for(mi) = .n_unique_molecules

            end

            fj.destroy
            perm.destroy

         end

         fi.destroy
            
      end

   end


   make_pairs_within_radius_of(m, res, radius, min_radius) ::: public, leaky
   ! ???
      m :: INT
      radius :: REAL
      min_radius :: REAL, optional
      res :: VEC{PAIR_ENERGY}@, INOUT

      pe :: PAIR_ENERGY
      h_max, h_min :: VEC{INT}(3)
      rot :: MAT{REAL}(3,3)
      t_symop, t :: VEC{REAL}(3)
      symop_str :: STR
      unique_symops :: VEC{INT}@
      i,j,k,n, symop_id, n_symops :: INT
      central_atoms :: VEC{ATOM}*
      atoms_b :: VEC{ATOM}*
      positions_frac :: MAT{REAL}@
      molecule_bounds :: MAT{REAL}(3,2)
      frac_radius :: VEC{REAL}(3)
      seitz :: MAT{REAL}*
      lower, upper :: REAL
      old_n, n_atom, n_asym :: INT

      lower = ZERO

      if (present(min_radius)) then
          lower = min_radius + 0.00000001
      end
      upper = radius
      stdout.show("lower bound", lower)
      stdout.show("upper bound", upper)
      stdout.flush

      unique_symops = .crystal.asym_symop_for_unit_cell_atom.unique_elements
      n_symops = size(unique_symops)
      .create_mol_atom_list(central_atoms, m)

      n_atom = size(central_atoms)
      n_asym = size(.crystal.asymmetric_unit_atom)

      ! Calculated molecule bounds in fractional coordinates
      allocate(positions_frac(3, size(central_atoms, dim=1)))
      do i = 1, size(central_atoms, dim=1)
         positions_frac(:,1) = central_atoms(i).position
      end
      positions_frac = matmul(.crystal.unit_cell.inverse_matrix, positions_frac)
      molecule_bounds(:, 1) = minval(positions_frac, dim=2)
      molecule_bounds(:, 2) = maxval(positions_frac, dim=2)
      deallocate(positions_frac)

      frac_radius = radius / .crystal.unit_cell.length

      h_max = ceiling(frac_radius + molecule_bounds(:,2))
      h_min = floor(-frac_radius + molecule_bounds(:,1))
      h_max = max(h_max, [1,1,1])
      h_min = min(h_min, [-1,-1,-1])

      old_n = 0
      if (allocated(res)) old_n = size(res, dim=1)
      ! iterate through symops
      do n = 1, n_symops
          atoms_b.create_copy(central_atoms)
          symop_id = unique_symops(n)

          seitz => .crystal.spacegroup.seitz(:,:, symop_id)
          rot = seitz(1:3,1:3)
          rot = matmul(rot, .crystal.unit_cell.inverse_matrix)
          rot = matmul(.crystal.unit_cell.direct_matrix, rot)

          atoms_b.rotate_by(rot)
          t_symop = seitz(1:3, 4)
          .crystal.spacegroup.recode_Jones_Faithful_symbol(symop_str, seitz)

          do i = h_min(1), h_max(1)
          do j = h_min(2), h_max(2)
          do k = h_min(3), h_max(3)
             t = matmul(.crystal.unit_cell.direct_matrix, t_symop + [i,j,k])

             atoms_b.translate_by(t)
             pe.set_defaults
             pe.set_mol(m)
             pe.pos_a = central_atoms.center_of_mass
             pe.pos_b(:,1) = atoms_b.center_of_mass
             pe.set_center_separation(pe.pos_a.distance_to(pe.pos_b(:,1)))
             central_atoms.get_distance_to(atoms_b, pe.closest_distance)
             atoms_b.translate_by(-t)
             pe.set_symop_id(symop_id)
             pe.set_rot(rot)
             pe.set_trans(t)
             pe.set_symop_str(trim(symop_str))

             pe.unit_cell = [i,j,k]
             ! mols are in the same position
             if (pe.center_separation < 0.001) cycle
             ! mol_b not in the shell
             if (pe.closest_distance > upper) cycle
             if (pe.closest_distance < lower) cycle
             res.append_or_increment(pe.clone)

          end
          end
          end
      end do

      stdout.show("Generated pairs in shell, n = ", size(res, dim=1) - old_n)
      stdout.flush

   end

!  ==================================================
!  Extract geometry & info from coded occupation list
!  ==================================================

   extract_geometry ::: leaky
   ! Extract the .geometry (fractional) from the final .occupation list.
   ! . Place connected molecules in order
   ! . Set the .is_fragment_atom flag array

   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.unit_cell_geometry.associated,"no crystal unit cell geometry")

      a,m,i,code,h1,h2,h3,u :: INT
      atom_connection :: VEC{VEC_{INT}}*
      new_order :: VEC{INT}*
      connected :: BIN

      ! No of atoms to extract
      .n_atoms = .occupation_list.dim

      ! Extracted geometry
      .geometry.destroy
      .geometry.create(3,.n_atoms)

      ! Clear flags telling if fragment atom
      .is_fragment_atom.destroy
      .is_fragment_atom.create(.n_atoms)

      ! New ordering
      new_order.create(.n_atoms)

      a = 0

      ! Loop over molecules
      do m = 1,.n_molecules

          ! Loop over atoms "i"
          do i = 1,.n_atoms

             if (.molecule_for_atom(i)/=m) cycle

             ! Atom index
             a = a + 1
             new_order(i) = a

             ! Get occ code for this atom
             code = .occupation_list(i)

             ! Get unit cell atom "u" and cell offset "h"
             h1 = CLUSTER_H1_FROM_CODE(code)
             h2 = CLUSTER_H2_FROM_CODE(code)
             h3 = CLUSTER_H3_FROM_CODE(code)
             u  = CLUSTER_UA_FROM_CODE(code)

             ! Get the cluster atom coordinate
             .geometry(:,i) = .crystal.unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset

             ! Set flag if fragment atom
             if (i<=.n_fragment_atoms) then; .is_fragment_atom(i) = TRUE
             else;                           .is_fragment_atom(i) = FALSE
             end

          end

      end


      ! Now reorder
      .occupation_list(new_order)   = .occupation_list
      .geometry(:,new_order)        = .geometry
      .molecule_for_atom(new_order) = .molecule_for_atom
      .is_fragment_atom(new_order)  = .is_fragment_atom

     ! This needs to be here, we must update .molecule to
     ! be in a consistent state with the rest of the object
      .molecule.destroy
      .molecule.create(.n_molecules)
      do a = 1,.n_atoms
         m = .molecule_for_atom(a)
         .molecule(m).element.append(a)
      end


      ! Reorder connection table
      atom_connection.create(.n_atoms)
      do i = 1,.n_atoms
         connected = .atom_connection(i).element.associated
         if (NOT connected) cycle
         atom_connection(new_order(i)).element.create_copy(new_order(.atom_connection(i)[:]))
      end
      .atom_connection.destroy
      .atom_connection => atom_connection

      ! Clean
      new_order.destroy

   end

   extract_geometry(occupation_list,geometry) ::: leaky
   ! Extract the geometry (fractional) from an "occupation_list".
      occupation_list :: VEC{INT}, IN
      geometry :: MAT{REAL}*

   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.unit_cell_geometry.associated,"no crystal unit cell geometry")

      n_atoms,i,code,h1,h2,h3,u :: INT

      ! No. of atoms to extract
      n_atoms = occupation_list.dim

      ! Extracted geometry
      geometry.create(3,n_atoms)

      ! Loop over atoms "i"
      do  i = 1,n_atoms

         ! Get occ code for this atom
         code = occupation_list(i)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Get the cluster atom coordinate
         geometry(:,i) = .crystal.unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset

      end

   end

   extract_atom_info(occupation_list,par,pos,mass)
   ! From a "occupation_list", extract the *cartesian* atom positions
   ! "pos", the index of the asymmetric-parent-atom in "par" and the
   ! atomic "mass" for each atom.
      occupation_list :: VEC{INT}, IN
      par :: VEC{INT}, OUT
      pos :: MAT{REAL}, OUT
      mass :: VEC{REAL}, OUT

   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.unit_cell_geometry.associated,"no crystal unit cell geometry")
   ENSURE(.crystal.asym_atom_for_unit_cell_atom.associated,"no asym_atom_for_unit_cell_atom")
   ENSURE(.crystal.frag_atom_for_unit_cell_atom.associated,"no frag_atom_for_unit_cell_atom")
   ENSURE(.asymmetric_unit_atom.associated, "no asymmetric_cell_atom data")
   ENSURE(mass.dim==occupation_list.dim, "mass, wrong size")
   ENSURE(pos.dim1==3 AND pos.dim2==occupation_list.dim, "pos, wrong size")

      i,code,u,h1,h2,h3,p :: INT
      q :: VEC{REAL}(3)

      ! Loop over atoms "i"
      do  i = 1,occupation_list.dim

         ! Get occ code for this atom
         code = occupation_list(i)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Get the cluster atom position (cartesian)
         q = .crystal.unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
         pos(:,i).to_product_of(.crystal.unit_cell.direct_matrix,q)

         ! Get parent asymmetric atom and symop
         p = .crystal.asym_atom_for_unit_cell_atom(u)
         par(i) = p

         ! Atomic mass
         mass(i) = .asymmetric_unit_atom(p).mass

      end

   end

   extract_atom_info(occupation_list,pos,charge,dipole,frag_atom)
   ! From the "occupation_list", extract the *cartesian* atom
   ! positions "pos", the atomic charges and dipoles "charge" and
   ! "dipole" in a *flat* array, and the frag atom for the atoms.
   ! NOTE:
   ! . All the quantities are available and non-zero.
   ! . "pos" and "dipole" are in the cartesian frame.
      occupation_list :: VEC{INT}, IN
      pos :: MAT{REAL}, OUT
      charge,dipole :: VEC{REAL}, OUT
      frag_atom :: VEC{INT}, OUT, optional

   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.fragment_info_made,"no crystal fragment_info")
   ENSURE(.asymmetric_unit_atom.associated, "no asymmetric_cell_atom data")
   ENSURE(.asymmetric_unit_atom.has_dipoles,"no atomic dipoles, did you calc them?")
   ENSURE(pos.dim1==3 AND pos.dim2==occupation_list.dim, "pos, wrong size")
   ENSURE(charge.dim==occupation_list.dim, "charge, wrong size")
   ENSURE(dipole.dim==3*occupation_list.dim, "dipole, wrong size")

      seitz :: MAT3{REAL}*
      i,l,code,h1,h2,h3,u, p,s :: INT
      q :: VEC{REAL}(3)

      ! Symops
      seitz => .crystal.xyz_seitz_matrices

      ! Counter, dipole array
      l = 0

      ! Loop over atoms "i"
      do  i = 1,occupation_list.dim

         ! Get occ code for this atom
         code = occupation_list(i)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Get the cluster atom position (cartesian)
         q = .crystal.unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
         pos(:,i).to_product_of(.crystal.unit_cell.direct_matrix,q)

         ! Parent asymmetric atom and symop
         p = .crystal.asym_atom_for_unit_cell_atom(u)
         s = .crystal.asym_symop_for_unit_cell_atom(u)

         ! Parent and symop
         ! par(i) = p
         ! symop(i) = s

         ! Warning, the asymmetric_unit_atom's should be generated from
         ! the fragment on which the charge and dipole polarisability
         ! calculations (see below) have been done.

         ! Set the charges and dipoles
         charge(i) = .asymmetric_unit_atom(p).charge
         dipole(l+1:l+3).to_product_of(seitz(:,:,s),.asymmetric_unit_atom(p).dipole)
         l = l + 3

         ! Fragment atom list
         if (NOT present(frag_atom)) cycle
         frag_atom(i) = .crystal.frag_atom_for_unit_cell_atom(u)

      end

      ! Clean
      seitz.destroy

   end

   extract_molecule_atom_info(occupation_list,symop,par,pos,charge,mass,dipole,alpha_q,alpha_m)
   ! From a *molecule* "occupation_list", extract the *cartesian* atom
   ! positions "pos", the indiex of the asymmetric-parent-atom in
   ! "par", the corresponding 3x3 symop matrix which maps the unit
   ! cell atom into the asymmetric-parent-atom, the atomic charges and
   ! masses "charge" and "mass", atomic dipoles "dipole", charge
   ! polarisabilities "alpha_q" and dipole polarisabilities "alpha_m".
   ! NOTE:
   ! . This assumes that the quantities are available and non-zero.
   ! . "pos" and everything else are in *cartesians*.
   ! . The symop returned is the last one for "occupation_list"
   !   This is OK for a whole molecule
      occupation_list :: VEC{INT}, IN
      symop :: MAT{REAL}, OUT
      par :: VEC{INT}, OUT
      pos :: MAT{REAL}, OUT
      charge :: VEC{REAL}, OUT
      mass   :: VEC{REAL}, OUT
      dipole :: MAT{REAL}, OUT
      alpha_q :: MAT{REAL}, OUT
      alpha_m :: MAT3{REAL}, OUT

   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.fragment_info_made,"no crystal fragment info")
   ENSURE(.asymmetric_unit_atom.associated, "no asymmetric_cell_atom data")
   ENSURE(.asymmetric_unit_atom.has_dipoles,"no atomic dipoles, did you calc them?")
   ENSURE(.asymmetric_unit_atom.has_polarisabilities,"no atomic polarisabilities")
   ENSURE(charge.dim==occupation_list.dim, "charge, wrong size")
   ENSURE(mass.dim  ==occupation_list.dim, "mass, wrong size")
   ENSURE(all(shape(pos)    ==[3,occupation_list.dim]),"pos, wrong size")
   ENSURE(all(shape(dipole) ==[3,occupation_list.dim]),"dipole, wrong size")
   ENSURE(all(shape(alpha_q)==[3,occupation_list.dim]),"alpha_q, wrong size")
   ENSURE(all(shape(alpha_m)==[3,3,occupation_list.dim]), "alpha_m, wrong size")

      T  :: MAT{REAL}*
      inverse_seitz :: MAT3{REAL}*
      i,code,h1,h2,h3,u, p,s :: INT
      q :: VEC{REAL}(3)

      ! Transposed/Inverse symops
      inverse_seitz => .crystal.transposed_xyz_seitz_matrices

      ! Loop over atoms "i"
      do  i = 1,occupation_list.dim

         ! Get occ code for this atom
         code = occupation_list(i)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Set the cluster atom position (cartesian)
         q = .crystal.unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
         pos(:,i).to_product_of(.crystal.unit_cell.direct_matrix,q)

         ! Set parent asymmetric atom and symop
         p = .crystal.asym_atom_for_unit_cell_atom(u)
         s = .crystal.asym_symop_for_unit_cell_atom(u)
         T => inverse_seitz(:,:,s)
         par(i) = p

         ! Set the inverse 3x3 symop
         symop = T

         ! stdout.show("atom          = ",i)
         ! stdout.show("atomic number =",.asymmetric_unit_atom(p).atomic_number)
         ! stdout.show("asym parent   =",p)
         ! stdout.show("asym pos      =",.asymmetric_unit_atom(p).position)
         ! stdout.text("T:")
         ! stdout.put(T)

         ! Warning, the asymmetric_unit_atom's should be generated from
         ! the fragment on which the charge and dipole polarisability
         ! calculations (see below) have been done.

         ! Set atomic electronic charge.
         charge(i) = .asymmetric_unit_atom(p).charge &
                   - .asymmetric_unit_atom(p).atomic_number
         mass(i)   = .asymmetric_unit_atom(p).mass

         ! stdout.show("charge        =",charge(i))
         ! stdout.show("mass          =",mass(i))

         ! Set atomic dipole
         dipole(:,i).to_product_of(T,.asymmetric_unit_atom(p).dipole,transpose_a=TRUE)

         ! stdout.show("dipole parent =",.asymmetric_unit_atom(p).dipole)
         ! stdout.show("dipole        =",dipole(:,i))

         ! Set atomic charge polarisability
         alpha_q(:,i).to_product_of(T,.asymmetric_unit_atom(p).charge_polarisability,transpose_a=TRUE)

         ! stdout.show("alpha_q par   =",.asymmetric_unit_atom(p).charge_polarisability)
         ! stdout.show("alpha_q       =",alpha_q(:,i))

         ! Set atomic dipole polarisability
         alpha_m(:,:,i) = .asymmetric_unit_atom(p).dipole_polarisability
         alpha_m(:,:,i).change_basis_using(T)

         ! stdout.text("alpha_m:")
         ! stdout.put(alpha_m(:,:,i))

      end

      ! Clean
      inverse_seitz.destroy

   end

!  ===================
!  Cluster information
!  ===================

   cluster_width result (res)
   ! Return the width "res" of the cluster in each of the 3 axis directions.
   ! NOTE: using crystal axis system.
      res :: VEC{REAL}(3)
   ENSURE(.geometry.associated,"no fragment geometry")
      res = .geometry.max_abs_column_difference
   end


   create_fragment_atom_list(fragment_atom) ::: leaky
   ! Create the "fragment_atom" list.
      fragment_atom :: VEC{ATOM}*

   ENSURE(.n_fragment_atoms>0,"no fragment atoms")
   ENSURE(.is_fragment_atom.associated,"no fragment atoms")
   ENSURE(.crystal.associated,"no crystal info")

      fragment_atom.create(.n_fragment_atoms)

      .make_fragment_atom_list(fragment_atom)

   end

   make_fragment_atom_list(fragment_atom) ::: private
   ! Make the "fragment_atom" list, a VEC{ATOM}
   ! WARNING: set info_made to FALSE in "fragment_atom" parent
   !          molecule, if there is one.
      self :: IN
      fragment_atom :: VEC{ATOM}, target, OUT

   ENSURE(.n_atoms>0,"no atoms")
   ENSURE(.n_fragment_atoms>0,"no fragment atoms")
   ENSURE(.is_fragment_atom.associated,"no is_fragment_atom")
   ENSURE(count(.is_fragment_atom)==.n_fragment_atoms,"inconsistent is_fragment_atom")
   ENSURE(.geometry.associated,"no geometry")
   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.asymmetric_unit_atom.associated,"no asymmetric_cell_atom")
   ENSURE(.crystal.associated,"no crystal info")
   ENSURE(.crystal.asym_atom_for_unit_cell_atom.associated,"no asym_atom-cell_atom")
   ENSURE(.asymmetric_unit_atom.has_cartesian_axes, "pADPs must be in cartn axis system")

      ulist :: VEC{INT}*
      seitz :: MAT3{REAL}*
      a,f,u,p,s :: INT
      atom_f, atom_p :: ATOM*

      ! Unit cell atoms which correspond to the fragment atoms
      ulist.create(.n_atoms)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list)

      ! Seitz matrices
      seitz => .crystal.xyz_seitz_matrices

      ! Fragment atom
      f = 0

      ! Loop over cluster atoms "a"
      do a = 1,.n_atoms

         if (NOT .is_fragment_atom(a)) cycle

         ! Fragment atom
         f = f + 1

         ! Extract unit cell atom and asymmetric parent
         u = ulist(a)
         p = .crystal.asym_atom_for_unit_cell_atom(u)
         s = .crystal.asym_symop_for_unit_cell_atom(u)

         ! Cluster and asymmetric atom parent
         atom_f => fragment_atom(f)
         atom_p => .asymmetric_unit_atom(p)

         ! Copy the parent atom
         ! NOTE: .basis is a ptr copy
         atom_f.copy(atom_p)

         ! Transform the pADPs (which must be in cartesians)
         atom_f.transform_pADP_vector_with(seitz(:,:,s))

         ! Reset cluster atom pos from .geometry(:,a)
         atom_f.set_position(.geometry(:,a))
         atom_f.set_axis_system_to("crystal")

      end

      ! Clean
      ulist.destroy

      ! Change coordinates to cartesian
      ! Errors (if any) are changed straightforwardly
      ! WARNING: set info_made to FALSE in parent molecule, if any
      fragment_atom.change_axis_system_to("cartesian",.crystal.unit_cell,FALSE)

   end


   create_mol_atom_list(mol_atom,m) ::: leaky
   ! Create the "mol_atom" ATOM list for molecule "m".
      mol_atom :: VEC{ATOM}*
      m :: INT, IN

   ENSURE(.molecule.associated,"no molecule list")
   ENSURE(.molecule.dim>=m,"molecule m too large")
   ENSURE(.molecule(m).element.associated,"no molecule m atom indices")

      mol_atom.create(.molecule(m).element.dim)

      .make_mol_atom_list(mol_atom,m)

   end

   make_mol_atom_list(mol_atom,m)
   ! Make the "fragment_atom" list, a VEC{ATOM}
      self :: IN
      mol_atom :: VEC{ATOM}, target, OUT
      m :: INT, IN

   ENSURE(.geometry.associated,"no geometry")
   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.asymmetric_unit_atom.associated,"no asymmetric_cell_atom")
   ENSURE(.crystal.associated,"no crystal info")
   ENSURE(.crystal.asym_atom_for_unit_cell_atom.associated,"no asym_atom-cell_atom")
   ENSURE(.asymmetric_unit_atom.has_cartesian_axes, "pADPs must be in cartn axis system")

      ulist :: VEC{INT}*
      seitz :: MAT3{REAL}*
      f,a, u,p,s :: INT
      atom_f, atom_p :: ATOM*

      ! Unit cell atoms which correspond to the molecule's atoms
      ulist.create(.n_atoms)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list)

      ! Seitz matrices
      seitz => .crystal.xyz_seitz_matrices

      ! Loop over molecule m atoms "f"
      do f = 1,.molecule(m).element.dim

         a = .molecule(m).element(f)

         ! Extract unit cell atom and asymmetric parent
         u = ulist(a)
         p = .crystal.asym_atom_for_unit_cell_atom(u)
         s = .crystal.asym_symop_for_unit_cell_atom(u)

         ! Molecule and asymmetric atom parent
         atom_f => mol_atom(f)
         atom_p => .asymmetric_unit_atom(p)

         ! Copy the parent atom
         ! NOTE: .basis is a ptr copy
         atom_f.copy(atom_p)

         ! Transform the pADPs (which must be in cartesians)
         atom_f.transform_pADP_vector_with(seitz(:,:,s))

         ! Reset cluster atom pos from .geometry(:,a)
         atom_f.set_position(.geometry(:,a))
         atom_f.set_axis_system_to("crystal")

      end

      ! Clean
      ulist.destroy

      ! Change coordinates to cartesian
      ! Errors (if any) are changed straightforwardly
      mol_atom.change_axis_system_to("cartesian",.crystal.unit_cell,FALSE)

   end


   fragment_atom_indices result (res) ::: public
   ! Return the indices of the fragment atoms in the cluster.
      res :: VEC{INT}(.n_fragment_atoms)

   ENSURE(.n_fragment_atoms>0,"no fragment atoms")
   ENSURE(.is_fragment_atom.associated,"no fragment atoms")

      a,f :: INT

      ! Frag atom "f"
      f = 0

      ! Loop over cluster atoms "a"
      do a = 1,.n_atoms

         if (NOT .is_fragment_atom(a)) cycle

         ! Set the fragment atom index
         f = f + 1
         res(f) = a

      end

   end

   nonfragment_atom_indices result (res) ::: public
   ! Return the indices of the nonfragment atoms in the cluster.
      res :: VEC{INT}(.n_atoms-.n_fragment_atoms)

   ENSURE(.n_atoms>=.n_fragment_atoms,"no nonfragment atoms")
   ENSURE(.is_fragment_atom.associated,"no fragment atoms")

      a,f :: INT

      ! Frag atom "f"
      f = 0

      ! Loop over cluster atoms "a"
      do a = 1,.n_atoms

         if (.is_fragment_atom(a)) cycle

         ! Set the fragment atom index
         f = f + 1
         res(f) = a

      end

   end

   crystal_asym_unit_atom_indices result (res)
   ! Return the indices of the crystal asymmetric unit cell atoms
   ! corresponding to the fragment atoms of the *cluster*.
      self :: IN
      res :: VEC{INT}(.n_fragment_atoms)

   ENSURE(.n_fragment_atoms>0,      "no fragment atoms")
   ENSURE(.is_fragment_atom.associated,"no is_fragment_atom")
   ENSURE(.occupation_list.associated, "no occupation_list")
   ENSURE(.crystal.associated        , "no crystal")

      f,i,code,u,a :: INT

      f = 0

      ! Loop over atoms
      do  i = 1,.n_atoms

         if (NOT .is_fragment_atom(i)) cycle

         code = .occupation_list(i)
         u    = CLUSTER_UA_FROM_CODE(code)
         a    = .crystal.asym_atom_for_unit_cell_atom(u)

         f      = f + 1
         res(f) = a

      end

   end

   crystal_frag_atom_indices result (res)
   ! Return the *crystal* fragment atom indices of the fragment atoms
   ! in the *cluster* (the two are not necessarily the same!)
      self :: IN
      res :: VEC{INT}(.n_fragment_atoms)

   ENSURE(.n_fragment_atoms>0,      "no fragment atoms")
   ENSURE(.is_fragment_atom.associated,"no is_fragment_atom")
   ENSURE(.occupation_list.associated, "no occupation_list")
   ENSURE(.crystal.associated        , "no crystal")

      f,i,code,u,a :: INT

      f = 0

      ! Loop over atoms
      do  i = 1,.n_atoms

         if (NOT .is_fragment_atom(i)) cycle

         code = .occupation_list(i)
         u    = CLUSTER_UA_FROM_CODE(code)
         a    = .crystal.frag_atom_for_unit_cell_atom(u)

         f      = f + 1
         res(f) = a

      end

   end


   create_atom_list(atom) ::: leaky
   ! Create and make a new atom list for the cluster
   ! NOTE: basis sets are pointer copied!
      self :: IN
      atom :: VEC{ATOM}*

   ENSURE(.fragment_geometry.associated, "no crystal fragment geometry")
   ENSURE(.crystal.associated, "no crystal data")
   ENSURE(.asymmetric_unit_atom.associated, "no atom data")
   ENSURE(.n_atoms>0,"no atoms in cluster")

      atom.create(.n_atoms)
      .make_atom_list(atom)

   end

   make_atom_list(atom)
   ! Make a new atom list for the cluster. Note that the .asymmetric_unit_atom's
   ! must have ADP (thermal) tensors in the cartesian axis system; this will normally
   ! be the case for Tonto's internal representation ....
   ! NOTE: basis sets are pointer copied!
      self :: IN
      atom :: VEC{ATOM}, OUT

   ENSURE(.n_atoms>0,"no atoms in cluster")
   ENSURE(atom.dim==.n_atoms,"wrong size, atomsr")
   ENSURE(.geometry.associated,"no geometry")
   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.crystal.associated, "no crystal data")
   ENSURE(.crystal.fragment_info_made,"no crystal fragment info")
   ENSURE(.asymmetric_unit_atom.associated, "no asymmetric_unit_atom data")
   ENSURE(.asymmetric_unit_atom.has_cartesian_axes, "asymmetric_unit_atom not in cartesian axes")
   ENSURE(.molecule_for_atom.associated, "no molecule_for_atom info")

      ulist :: VEC{INT}*
      seitz :: MAT3{REAL}*
      a,u,p,s :: INT

      ! Unit cell atoms which correspond to the fragment atoms
      ulist.create(.occupation_list.dim)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list)

      ! Seitz matrices
      seitz => .crystal.xyz_seitz_matrices

      ! Loop over cluster atoms "a"
      do a = 1,.n_atoms

         ! Extract unit cell atom, asymmetric parent and symop
         u = ulist(a)
         p = .crystal.asym_atom_for_unit_cell_atom(u)
         s = .crystal.asym_symop_for_unit_cell_atom(u)

         ! Copy the parent atom
         ! NOTE: .basis is a ptr copy
         atom(a).copy(.asymmetric_unit_atom(p))

         ! Transform the pADPs (which must be in cartesians)
         atom(a).transform_pADP_vector_with(seitz(:,:,s))

         ! Reset cluster atom pos from .geometry(:,a)
         atom(a).set_position(.geometry(:,a))
         atom(a).set_axis_system_to("crystal")
         atom(a).set_group(.molecule_for_atom(a))

      end

      ! Clean
      seitz.destroy
      ulist.destroy

      ! Change pos to cartesian
      ! Errors (if any) are changed straightforwardly
      atom.change_axis_system_to("cartesian",.crystal.unit_cell,FALSE)

      ! Update labels/groups
      atom.update

   end

   make_atom_list(atom,list)
   ! Make a new atom list for the cluster from the indices in "list".
   ! Note that the .asymmetric_unit_atom's must have ADP tensors
   ! in the cartesian axis system; this will normally be the case for
   ! Tonto's internal representation ....
   ! NOTE: basis sets are pointer copied!
      self :: IN
      atom :: VEC{ATOM}, target, OUT
      list :: VEC{INT}, IN

   ENSURE(atom.dim==list.dim,"wrong size, atomsr")
   ENSURE(.geometry.associated,"no geometry")
   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.crystal.associated, "no crystal data")
   ENSURE(.crystal.fragment_info_made,"no crystal fragment info")
   ENSURE(.asymmetric_unit_atom.associated, "no asymmetric_cell_atom data")
   ENSURE(.asymmetric_unit_atom.has_cartesian_axes, "pADPs must be in cartn axis system")

      ulist :: VEC{INT}*
      seitz :: MAT3{REAL}*
      a,u,p,s :: INT
      atom_p, atom_a :: ATOM*

      ! Unit cell atoms which correspond to the *list* fragment atoms
      ulist.create(list.dim)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list(list))

      ! Seitz matrices
      seitz => .crystal.xyz_seitz_matrices

      ! Loop over cluster atoms "a"
      do a = 1, ulist.dim

         ! Extract unit cell atom, asymmetric parent and symop
         u = ulist(a)
         p = .crystal.asym_atom_for_unit_cell_atom(u)
         s = .crystal.asym_symop_for_unit_cell_atom(u)

         ! Cluster and asymmetric atom parent
         atom_a => atom(a)
         atom_p => .asymmetric_unit_atom(p)

         ! Copy the parent atom
         ! NOTE: .basis is a ptr copy
         atom_a.copy(atom_p)

         ! Transform the pADPs (which must be in cartesians)
         atom_a.transform_pADP_vector_with(seitz(:,:,s))

         ! Reset cluster atom pos from .geometry(:,a)
         ! NOTE: .basis is a ptr copy
         atom_a.set_position(.geometry(:,a))
         atom_a.set_axis_system_to("crystal")

      end

      ! Clean
      seitz.destroy
      ulist.destroy

      ! Change pos to cartesian
      ! Errors (if any) are changed straightforwardly
      atom.change_axis_system_to("cartesian",.crystal.unit_cell,FALSE)

      ! Update labels/groups
      atom.update

   end


   make_non_fragment_mu_charges(pos,charge)
   ! Make a list of the non-fragment atom positions and point charges
   ! derived from the atomic charges and dipoles only.
      pos :: MAT{REAL}, OUT
      charge :: VEC{REAL}, OUT

   ENSURE(.n_atoms>0,"no atoms in cluster")
   ENSURE(pos.dim2==3*(.n_atoms-.n_fragment_atoms),"wrong dim2, pos")
   ENSURE(charge.dim==pos.dim2,"wrong dim, charge")
   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.crystal.associated, "no crystal data")
   ENSURE(.crystal.fragment_info_made,"no crystal fragment info")
   ENSURE(.asymmetric_unit_atom.associated, "no asymmetric_cell_atom data")

      seitz  :: MAT3{REAL}*
      dipole :: VEC{REAL}(3)
      d,mu,q :: REAL
      a,i,code,h1,h2,h3,u, p,s :: INT
      r :: VEC{REAL}(3)

      ! Normal XYZ symops
      seitz => .crystal.xyz_seitz_matrices

      i = -2

      ! Loop over cluster atoms "a"
      do a = 1,.n_atoms

         if (.is_fragment_atom(a)) cycle

         ! Get the occ code
         code = .occupation_list(a)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Counter for 3 charges
         i = i + 3

         ! Get the cluster atom position
         r = .crystal.unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
         pos(:,i).to_product_of(.crystal.unit_cell.direct_matrix,r)

         ! Get parent asymmetric atom and symop
         p = .crystal.asym_atom_for_unit_cell_atom(u)
         s = .crystal.asym_symop_for_unit_cell_atom(u)

         ! Atomic charge
         charge(i) = .asymmetric_unit_atom(p).charge

         ! Atomic dipole
         dipole.to_product_of(seitz(:,:,s),.asymmetric_unit_atom(p).dipole)

         ! Make the two charges
         ! Twice the shift along dipole direction
         d = TOL(2)
         mu = dipole.norm
         q = mu/d
         dipole = dipole/mu * d * HALF
         pos(:,i+1) = pos(:,i) + dipole
         pos(:,i+2) = pos(:,i) - dipole
         charge(i+1) =  q
         charge(i+2) = -q

      end

      ! Clean
      seitz.destroy

   end

   make_non_fragment_qq_charges(pos,charge)
   ! Make a list of the non-fragment atom positions and charges
   ! from the atomic charges, dipoles, and *quadrupoles*
      pos :: MAT{REAL}, OUT
      charge :: VEC{REAL}, OUT

   ENSURE(.n_atoms>0,"no atoms in cluster")
   ENSURE(pos.dim2==9*(.n_atoms-.n_fragment_atoms),"wrong dim2, pos")
   ENSURE(charge.dim==pos.dim2,"wrong dim, charge")
   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.crystal.associated, "no crystal data")
   ENSURE(.crystal.fragment_info_made,"no crystal fragment info")
   ENSURE(.asymmetric_unit_atom.associated, "no asymmetric_cell_atom data")

      seitz  :: MAT3{REAL}*
      dipole,eval :: VEC{REAL}(3)
      quadrupole,evec :: MAT{REAL}(3,3)
      d,mu,q :: REAL
      a,i,code,h1,h2,h3,u, p,s :: INT
      r :: VEC{REAL}(3)

      ! NOrmal XYZ symops
      seitz => .crystal.xyz_seitz_matrices

      ! Counter for charges
      i = 1

      do a = 1,.n_atoms

         if (.is_fragment_atom(a)) cycle

         ! The occ code
         code = .occupation_list(a)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Get the cluster atom position
         r = .crystal.unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
         pos(:,i).to_product_of(.crystal.unit_cell.direct_matrix,r)

         ! Get parent asymmetric atom and symop
         p = .crystal.asym_atom_for_unit_cell_atom(u)
         s = .crystal.asym_symop_for_unit_cell_atom(u)

         ! Atomic charge
         charge(i)  = .asymmetric_unit_atom(p).charge

         ! Atomic dipole
         dipole.to_product_of(seitz(:,:,s),.asymmetric_unit_atom(p).dipole)

         ! Atomic quadrupole
         .asymmetric_unit_atom(p).quadrupole.back_transform_to(quadrupole,seitz(:,:,s))

         ! Make the two charges
         d = TOL(2) ! Twice the shift along dipole direction
         mu = dipole.norm
         q = mu/d
         dipole = dipole/mu * d * HALF
         pos(:,i+1) = pos(:,i) + dipole
         pos(:,i+2) = pos(:,i) - dipole
         charge(i+1) =  q
         charge(i+2) = -q

         ! Make the diagonal quadrupoles
         ! Charge at d/2 along eigenvectors
         ! Should be x 4 for single charge
         quadrupole.solve_symmetric_eigenproblem(eval,evec)
         evec = d*evec/TWO
         eval = eval/(d*d)

         ! Two charges on axis at +d/2 and -d/2
         pos(:,i+3)   = pos(:,i) + evec(:,1)
         pos(:,i+4)   = pos(:,i) - evec(:,1)
         pos(:,i+5)   = pos(:,i) + evec(:,2)
         pos(:,i+6)   = pos(:,i) - evec(:,2)
         pos(:,i+7)   = pos(:,i) + evec(:,3)
         pos(:,i+8)   = pos(:,i) - evec(:,3)
         charge(i+3)  = TWO*eval(1)
         charge(i+4)  = TWO*eval(1)
         charge(i+5)  = TWO*eval(2)
         charge(i+6)  = TWO*eval(2)
         charge(i+7)  = TWO*eval(3)
         charge(i+8)  = TWO*eval(3)
         charge(i  )  = charge(i) & ! correct monopole charge
                      - FOUR*eval(1) - FOUR*eval(2) - FOUR*eval(3)

!        ! Four charges in the plane at
!        ! (+d/2,+d/2), (-d/2,-d/2)
!        ! (+d/2,-d/2), (-d/2,+d/2)
!        pos(:,i+9 )  = pos(:,i) + unit(:,1) + unit(:,2)
!        pos(:,i+10)  = pos(:,i) - unit(:,1) - unit(:,2)
!        pos(:,i+11)  = pos(:,i) + unit(:,1) - unit(:,2)
!        pos(:,i+12)  = pos(:,i) - unit(:,1) + unit(:,2)
!        charge(i+9 ) =  quadrupole(1,2)
!        charge(i+10) =  quadrupole(1,2)
!        charge(i+11) = -quadrupole(1,2)
!        charge(i+12) = -quadrupole(1,2)
!        pos(:,i+13)  = pos(:,i) + unit(:,1) + unit(:,3)
!        pos(:,i+14)  = pos(:,i) - unit(:,1) - unit(:,3)
!        pos(:,i+15)  = pos(:,i) + unit(:,1) - unit(:,3)
!        pos(:,i+16)  = pos(:,i) - unit(:,1) + unit(:,3)
!        charge(i+13) =  quadrupole(1,3)
!        charge(i+14) =  quadrupole(1,3)
!        charge(i+15) = -quadrupole(1,3)
!        charge(i+16) = -quadrupole(1,3)
!        pos(:,i+17)  = pos(:,i) + unit(:,2) + unit(:,3)
!        pos(:,i+18)  = pos(:,i) - unit(:,2) - unit(:,3)
!        pos(:,i+19)  = pos(:,i) + unit(:,2) - unit(:,3)
!        pos(:,i+20)  = pos(:,i) - unit(:,2) + unit(:,3)
!        charge(i+17) =  quadrupole(2,3)
!        charge(i+18) =  quadrupole(2,3)
!        charge(i+19) = -quadrupole(2,3)
!        charge(i+20) = -quadrupole(2,3)

         ! Increment charge counter
         i = i + 9

      end

      ! Clean
      seitz.destroy

   end

!  ===========
!  Add tensors
!  ===========

   add_uc_tensors(tensor) ::: template
   ! For a unit cell, add up a "tensor" property for one molecule, assumed to be
   ! the fragment_geometry.
      tensor :: TENSOR_TYPE

   ENSURE(.generation_method=="unit_cell","only for unit_cell clusters")
   ENSURE(.n_atoms>0,"no atoms in cluster")
   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.crystal.associated, "no crystal data")
   ENSURE(.crystal.fragment_info_made,"no crystal fragment info")
   ENSURE(.crystal.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")

      ulist :: VEC{INT}*
      seitz :: MAT3{REAL}*
      tensor0,tensor1 :: TENSOR_TYPE
      m,a,u,s :: INT

      tensor0 = tensor
      tensor = ZERO

      ! Unit cell atoms which correspond to the fragment atoms
      ulist.create(.n_atoms)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list)

      ! Inverse XYZ symops
      seitz => .crystal.transposed_xyz_seitz_matrices

      ! stdout.text("Making unit cell tensor")
      ! stdout.text("original tensor")
      ! stdout.put(tensor0)

      do m = 1,.crystal.n_unit_cell_mols
      do a = 1,.n_atoms

         if (.crystal.unit_cell_mol_for_atom(a)/=m) cycle

         ! Get symop for this molecule
         u = ulist(a)
         s = .crystal.asym_symop_for_unit_cell_atom(u)

         ! Use inverse symop  S^T to change U tensor basis
         tensor0.change_basis_to(tensor1,seitz(:,:,s))
         tensor = tensor + tensor1

         ! stdout.show("molecule =",m)
         ! stdout.show("symop    =",s)
         ! stdout.put(seitz(:,:,s))
         ! stdout.text("transformed tensor")
         ! stdout.put(tensor1)

         exit

      end
      end

      ! Clean
      seitz.destroy
      ulist.destroy

   end

   add_uc_tensors(tensor) ::: get_from(CLUSTER, TENSOR_TYPE=>MAT{REAL}(3,3))
   ! For a unit cell, add up a "tensor" property for one molecule, assumed to be
   ! the fragment_geometry.
   end

   add_uc_tensors(tensor) ::: get_from(CLUSTER, TENSOR_TYPE=>MAT3{REAL}(3,3,3))
   ! For a unit cell, add up a "tensor" property for one molecule, assumed to be
   ! the fragment_geometry.
   end

!  ========================================
!  Cluster transformations on matrices, etc
!  ========================================

!   read_partition_factors ::: leaky
!   ! Read the partition factors to be used. Note that the length of this array
!   ! must correspond to the number of atoms in the generated cluster in order to
!   ! be used. This cannot be checked at this point in the code.
!      stdin.read_ptr(.partition_factor)
!   end

!   make_partition_factors(matrix) ::: leaky
!   ! Make the partition factors from the cluster-fragment mapping information.
!     matrix :: MAT{REAL}
!   ENSURE(.asymmetric_unit_atom.associated, "no atom data")
!     n_atom,a1,a2,f1,l1,f2,l2 :: INT
!     first_basis_fn_for_atom,last_basis_fn_for_atom :: VEC{INT}*
!     factor :: REAL
!     .asymmetric_unit_atom.make_atom_basis_fn_limits(first_basis_fn_for_atom,last_basis_fn_for_atom)
!     n_atom = .asymmetric_unit_atom.n_atom
!     do a1 = 1,n_atom
!       f1 = first_basis_fn_for_atom(a1)
!       l1 = last_basis_fn_for_atom(a1)
!       do a2 = 1,n_atom
!         f2 = first_basis_fn_for_atom(a2)
!         l2 = last_basis_fn_for_atom(a2)
!         ! Mulliken partitioning
!         factor = (.partition_factor(a1)+.partition_factor(a2))/TWO
!         matrix(f1:l1,f2:l2) = factor * matrix(f1:l1,f2:l2)
!       end
!     end
!     last_basis_fn_for_atom.destroy
!     first_basis_fn_for_atom.destroy
!   end

!   partition_density(matrix) ::: leaky
!   ! Applies atomic partition factors to the density matrix, useful for zeroing
!   ! out certain atoms.
!     matrix :: MAT{REAL}
!   ENSURE(.asymmetric_unit_atom.associated, "no atom data")
!     n_atom,a1,a2,f1,l1,f2,l2 :: INT
!     first_basis_fn_for_atom,last_basis_fn_for_atom :: VEC{INT}*
!     factor :: REAL
!     .asymmetric_unit_atom.make_atom_basis_fn_limits(first_basis_fn_for_atom,last_basis_fn_for_atom)
!     n_atom = .asymmetric_unit_atom.n_atom
!     do a1 = 1,n_atom
!       f1 = first_basis_fn_for_atom(a1)
!       l1 = last_basis_fn_for_atom(a1)
!       do a2 = 1,n_atom
!         f2 = first_basis_fn_for_atom(a2)
!         l2 = last_basis_fn_for_atom(a2)
!         ! Mulliken partitioning
!         factor = (.partition_factor(a1)+.partition_factor(a2))/TWO
!         matrix(f1:l1,f2:l2) = factor * matrix(f1:l1,f2:l2)
!       end
!     end
!     last_basis_fn_for_atom.destroy
!     first_basis_fn_for_atom.destroy
!   end

!   make_density_matrix(P,D,atom)
!   ! Make a cluster density matrix "P" from a fragment density matrix "D", given
!   ! a new cluster "atom" list (see routine create_atom_list).
!     P,D :: MAT{REAL}
!     atom :: VEC{ATOM}
!   ENSURE(.crystal.associated, "no crystal data")
!   ENSURE(.asymmetric_unit_atom.associated, "no atom data")
!   ENSURE(.asymmetric_unit_atom.bases_are_all_labeled,"unlabelled bases!")
!   ENSURE(D.is_square AND D.dim1==.asymmetric_unit_atom.n_bf,"D wrong shape")
!   ENSURE(P.is_square AND P.dim1==atom.n_bf,"P wrong shape")
!   ENSURE(.partition_factor.associated,"no partition factors")
!     ptr :: MAT3{REAL}*
!     tr :: VEC{MAT3_{REAL}}*
!     tr1,tr2,pc, W :: MAT{REAL}*
!     f1,l1,s1,n1,m1,a1,c1,f2,l2,s2,n2,m2,a2,c2 :: INT
!     n_shell, q,s,f3,l3,f4,l4 :: INT
!     atom_for_shell, first,last, first_fn,last_fn :: VEC{INT}*
!     n_shell = .asymmetric_unit_atom.n_shell
!     atom_for_shell => .asymmetric_unit_atom.atom_for_shell
!     .asymmetric_unit_atom.make_atom_basis_fn_limits(first,last)
!      atom.make_atom_basis_fn_limits(first_fn,last_fn)
!     ptr => .crystal.transposed_xyz_seitz_matrices ! transposes here
!     ptr.transpose_12
!     tr.make_gaussian_xyz_matrices(ptr)
!     ptr.destroy
!     pc => .atom_pair_parent_count
!     do q = 1,.n_symop
!       s = .symop(1,q)
!       ! Transform each shell pair by symop "s"
!       do s1 = 1,n_shell
!         f1 = first(s1); l1 = last(s1); n1 = (l1-f1+1)
!         a1 = atom_for_shell(s1)
!         c1 = .atom_for_cell_atom(a1,q) ! cluster atom index
!         f3 = first_fn(c1); l3 = last_fn(c1)
!         m1 = n1.inverse_triangle_number - 1
!         tr1  => tr(m1)[:,:,s]
!         ! Transform 1st index of density matrix
!         W.create(n1,n2)
!         W = matmul(tr1,D(f1:l1,f2:l2))
!         do s2 = 1, n_shell
!           f2 = first(s2); l2 = last(s2); n2 = (l2-f2+2)
!           a2 = atom_for_shell(s2)
!           c2 = .atom_for_cell_atom(a2,q) ! cluster atom index
!           f4 = first_fn(c2); l4 = last_fn(c2)
!           m2 = n2.inverse_triangle_number - 1
!           ! Transform 2nd index of density matrix
!           tr2  => tr(m2)[:,:,s]
!           P(f3:l3,f4:l4) = P(f3:l3,f4:l4) &
!                          + matmul(W,transpose(tr2))/pc(c1,c2)
!         end
!         W.destroy
!       end
!     end
!     pc.destroy
!     last_fn.destroy; first_fn.destroy
!     last.destroy; first.destroy
!     tr.destroy
!     atom_for_shell.destroy
!   end

!   atom_pair_parent_count result(n2) ::: leaky
!   ! Make the atom pair parent count, i.e. the number of times n2(i,j) a
!   ! particular atom pair (i,j) is *generated from* a fragment atom pair (i',j')
!   ! by the symmerty operations whose indices are stored in .symop. We divide
!   ! by this factor to ensure that the pair effectively appears as being
!   ! generated once, as an average of all the symmetry operations.  This is
!   ! quite similar to the n2 factor in the Dacre-Elder-Dupuis-King symmetry
!   ! method. For insight see:
!   ! P.D. Dacre, CPL (1970) 7, 47
!   ! M. Elder, IJQC (1973) 7, 75
!   ! M. Dupuis and H.F> King, IJQC (1977) 11, 613
!     n2 :: MAT{REAL}*
!   ENSURE(.asymmetric_unit_atom.associated, "no atom data")
!   ENSURE(.atom_for_cell_atom.associated, "no atom_for_cell_atom data")
!     s1,a1,c1,s2,a2,c2 :: INT
!     n_shell,q :: INT
!     atom_for_shell :: VEC{INT}*
!     n2.create(.n_atoms,.n_atoms)
!     n_shell = .asymmetric_unit_atom.n_shell
!     atom_for_shell => .asymmetric_unit_atom.atom_for_shell
!     do q = 1,.n_symop
!       ! Transform each shell pair by symop "s"
!       do s1 = 1,n_shell
!         a1 = atom_for_shell(s1)
!         c1 = .atom_for_cell_atom(a1,q)   ! cluster atom index
!         do s2 = 1, n_shell
!           a2 = atom_for_shell(s2)
!           c2 = .atom_for_cell_atom(a2,q) ! cluster atom index
!           n2(c1,c2) = n2(c1,c2) + 1
!         end
!       end
!     end
!     atom_for_shell.destroy
!   end

!  ==========================
!  Local field factor tensors
!  ==========================

   put_averaged_LFF_tensors
   ! Put the heavy-atom averaged local field factor dipole L tensors
   ! for the molecules in the unit cell. This uses the Reis formula.

   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")
   ENSURE(.asymmetric_unit_atom.associated,"no asymetric cell atoms")

      n_mol,n_H,n,a,i1,i2,j1,j2,k1,k2,m1,m2 :: INT
      pos,pos0,com,L,L0,L1 :: MAT{REAL}*
      symop,non_H,par,mol,mol0 :: VEC{INT}*
      label0 :: VEC{STR}*

      ! Header
      stdout.flush
      stdout.text("Molecule-averaged Dipole L(1) tensor:")

      ! Get the positions, COM's for the molecules in the unit cell.
      ! By construction, the atoms in each molecule occur consecutively.
      .get_uc_molecule_info(mol,symop,par,pos,com)

      ! Get indices of non-Hydrogen-atom positions.
      n_mol = .crystal.n_unit_cell_mols
      n_H   = count(.asymmetric_unit_atom(par).atomic_number>1)
      non_H.create(n_H)
      non_H = pack([(a,a=1,par.dim)],.asymmetric_unit_atom(par).atomic_number>1)

      ! Set the non-Hydrogen-atom positions, molecules.
      label0.create(n_H)
      pos0.create(3,n_H)
      mol0.create(n_H)
      label0 = .asymmetric_unit_atom(par(non_H)).label
      pos0   = pos(:,non_H)
      mol0   = mol(non_H)

      non_H.destroy
      com.destroy; pos.destroy; par.destroy; symop.destroy; mol.destroy

      ! Make the non-Hydrogen-atom Lorentz factor tensors
      L.create(3*n_mol,3*n_mol)
      L0.create(3*n_H,n_H)         ! charge L tensor
      L1.create(3*n_H,3*n_H)       ! dipole L tensor
      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)

      mol0.destroy; pos0.destroy

      ! Print monopole and dipole L tensor out
      n = n_H/n_mol
      stdout.flush
      stdout.text("Heavy-atom monopole L(0) tensor and Dipole L(1) tensor:")
      stdout.flush
      stdout.dash(int_fields=4,real_fields=4)
      stdout.put("Mol. 1",int_width=TRUE)
      stdout.put("Mol. 2",int_width=TRUE)
      stdout.put("Atom 1",int_width=TRUE)
      stdout.put("Atom 2",int_width=TRUE)
      stdout.put("L(0)")
      stdout.tab(real_fields=1)
      stdout.put("L(1)")
      stdout.flush
      stdout.dash(int_fields=4,real_fields=4)
      do i1 = 1,n_mol
      do i2 = 1,n_mol
      do j1 = 1,n
      do j2 = 1,n
         k1 = n*(i1-1) + j1
         k2 = n*(i2-1) + j2
         m1 = 3*(k1-1)
         m2 = 3*(k2-1)
         stdout.put(i1)
         stdout.put(i2)
         stdout.put(trim(j1.to_str)//" "//trim(label0(k1)),int_width=TRUE)
         stdout.put(trim(j2.to_str)//" "//trim(label0(k2)),int_width=TRUE)
         stdout.put(L0(m1+1,k2))
         stdout.put(L1(m1+1,m2+1))
         stdout.put(L1(m1+1,m2+2))
         stdout.put(L1(m1+1,m2+3))
         stdout.flush; stdout.tab(int_fields=4)
         stdout.put(L0(m1+2,k2))
         stdout.put(L1(m1+2,m2+1))
         stdout.put(L1(m1+2,m2+2))
         stdout.put(L1(m1+2,m2+3))
         stdout.flush; stdout.tab(int_fields=4)
         stdout.put(L0(m1+3,k2))
         stdout.put(L1(m1+3,m2+1))
         stdout.put(L1(m1+3,m2+2))
         stdout.put(L1(m1+3,m2+3))
         stdout.flush
      end
      end
      end
      end
      stdout.dash(int_fields=4,real_fields=4)

      label0.destroy

      ! Average the L(1) tensors over molecules
      L = ZERO
      do i1 = 1,n_mol
      do i2 = 1,n_mol
         m1 = 3*(i1-1)
         m2 = 3*(i2-1)
         do j1 = 1,n
         do j2 = 1,n
            k1 = 3*(n*(i1-1)+j1-1)
            k2 = 3*(n*(i2-1)+j2-1)
            L(m1+1:m1+3,m2+1:m2+3) = L(m1+1:m1+3,m2+1:m2+3) + L1(k1+1:k1+3,k2+1:k2+3)
         end
         end
      end
      end
      L = L/real(n*n,kind=REAL_KIND)

      ! Print averaged dipole L tensor
      stdout.flush
      stdout.text("Spackman's molecule-averaged Dipole L(1) tensor:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      stdout.put("Mol. 1",int_width=TRUE)
      stdout.put("Mol. 2",int_width=TRUE)
      stdout.tab(real_fields=1)
      stdout.put("L(1)")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      do k1 = 1,n_mol
      do k2 = 1,n_mol
         m1 = 3*(k1-1)
         m2 = 3*(k2-1)
         stdout.put(k1)
         stdout.put(k2)
         stdout.put(L(m1+1,m2+1))
         stdout.put(L(m1+1,m2+2))
         stdout.put(L(m1+1,m2+3))
         stdout.flush; stdout.tab(int_fields=2)
         stdout.put(L(m1+2,m2+1))
         stdout.put(L(m1+2,m2+2))
         stdout.put(L(m1+2,m2+3))
         stdout.flush; stdout.tab(int_fields=2)
         stdout.put(L(m1+3,m2+1))
         stdout.put(L(m1+3,m2+2))
         stdout.put(L(m1+3,m2+3))
         stdout.flush
      end
      end
      stdout.dash(int_fields=2,real_fields=3)

      ! Clean up
      L1.destroy
      L0.destroy
      L.destroy

   end

   put_centroid_LFF_tensors
   ! Put the local field factor L tensors at the centroids of all
   ! molecules in the unit cell. This uses the Reis formula.
   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")

      n,i,k1,k2,m1,m2 :: INT
      L0,L1 :: MAT{REAL}*
      centroid,W :: MAT{REAL}*
      mol_for  :: VEC{INT}*

      ! Header
      stdout.flush
      stdout.text("Local Field Factor L tensors:")
      stdout.flush
      stdout.show("n_unit_cell_mols =",.crystal.n_unit_cell_mols)

      ! Allocate
      n = .crystal.n_unit_cell_mols
      L0.create(3*n,n)
      L1.create(3*n,3*n)

      ! Get centroids
      centroid.create(3,n)
      .get_uc_molecule_centroids(centroid)
      stdout.flush
      stdout.text("Molecule centroids (cell coordinates):")
      stdout.flush
      stdout.put(transpose(centroid))

      ! Change centroids into cartesian
      W.create_copy(centroid)
      centroid.to_product_of(.crystal.unit_cell.direct_matrix,W)
      W.destroy
      stdout.flush
      stdout.text("Molecule centroids (cartesian/Bohr):")
      stdout.flush
      stdout.put(transpose(centroid))

      ! Make L tensor
      mol_for.create(n);   mol_for = [ (i,i=1,n) ]
      .crystal.unit_cell.make_LFF_tensors(L0,L1,centroid,mol_for)
      mol_for.destroy
      centroid.destroy

      ! Print monopole and dipole L tensor out
      stdout.flush
      stdout.text("Monopole L(0) tensor and Dipole L(1) tensor:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=4)
      stdout.put("k1",int_width=TRUE)
      stdout.put("k2",int_width=TRUE)
      stdout.put("L(0)")
      stdout.tab(real_fields=1)
      stdout.put("L(1)")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=4)
      do k1 = 1,n
      do k2 = 1,k1
         m1 = 3*(k1-1)
         m2 = 3*(k2-1)
         stdout.put(k1)
         stdout.put(k2)
         stdout.put(L0(m1+1,k2))
         stdout.put(L1(m1+1,m2+1))
         stdout.put(L1(m1+1,m2+2))
         stdout.put(L1(m1+1,m2+3))
         stdout.flush; stdout.tab(int_fields=2)
         stdout.put(L0(m1+2,k2))
         stdout.put(L1(m1+2,m2+1))
         stdout.put(L1(m1+2,m2+2))
         stdout.put(L1(m1+2,m2+3))
         stdout.flush; stdout.tab(int_fields=2)
         stdout.put(L0(m1+3,k2))
         stdout.put(L1(m1+3,m2+1))
         stdout.put(L1(m1+3,m2+2))
         stdout.put(L1(m1+3,m2+3))
         stdout.flush
      end
      end
      stdout.dash(int_fields=2,real_fields=4)

      ! Clean up
      L1.destroy
      L0.destroy

   end

   put_centroid_LFF_tensors_old
   ! Put the local field factor L tensors at the centroids of all
   ! molecules in the unit cell. This uses the Cummins code.
   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")
      n,k,k1,k2 :: INT
      L2 :: MAT3{REAL}*
      centroid,W :: MAT{REAL}*

      ! Header
      stdout.flush
      stdout.text("Local Field Factor L tensors:")
      stdout.flush
      stdout.show("n_unit_cell_mols =",.crystal.n_unit_cell_mols)

      ! Allocate space
      n = .crystal.n_unit_cell_mols
      L2.create(3,3,n.triangle)
      centroid.create(3,n)

      ! Get unit cell molecule centroids
      .get_uc_molecule_centroids(centroid)
      stdout.flush
      stdout.text("Molecule centroids (cell coordinates):")
      stdout.flush
      stdout.put(transpose(centroid))

      ! Change centroids into cartesian
      W.create_copy(centroid)
      centroid.to_product_of(.crystal.unit_cell.direct_matrix,W)
      W.destroy
      stdout.flush
      stdout.text("Molecule centroids (cartesian/Bohr):")
      stdout.flush
      stdout.put(transpose(centroid))

      ! Make L tensor
      .crystal.unit_cell.make_LFF_tensors(L2,centroid)

      ! Print L tensor out
      stdout.flush
      stdout.text("L tensors:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=6)
      stdout.put("k1",int_width=TRUE)
      stdout.put("k2",int_width=TRUE)
      stdout.put("L(xx)")
      stdout.put("L(yy)")
      stdout.put("L(zz)")
      stdout.put("L(xy)")
      stdout.put("L(xz)")
      stdout.put("L(yz)")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=6)
      k = 0
      do k1 = 1,n
      do k2 = 1,k1
         k = k + 1
         stdout.put(k1)
         stdout.put(k2)
         stdout.put(L2(1,1,k))
         stdout.put(L2(2,2,k))
         stdout.put(L2(3,3,k))
         stdout.put(L2(1,2,k))
         stdout.put(L2(1,3,k))
         stdout.put(L2(2,3,k))
         stdout.flush
      end
      end
      stdout.dash(int_fields=2,real_fields=6)

      ! Clean up
      centroid.destroy
      L2.destroy

   end

   get_uc_molecule_centroids(centroid)
   ! Get the unit cell molecule centroids; they are transformed back
   ! into the unit cell if the defragmented molecule lies outside the
   ! unit cell.
      centroid :: MAT{REAL}

   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")
   ENSURE(all(shape(centroid)==[3,.crystal.n_unit_cell_mols]),"wrong shape, centroid")

      m,u :: INT
      geometry :: MAT{REAL}*

      centroid = ZERO

      do m = 1,.crystal.n_unit_cell_mols

         nullify(geometry)

         do u = 1,.crystal.n_unit_cell_atoms
            if (.crystal.unit_cell_mol_for_atom(u)/=m) cycle
            .do_defragment_uc_atom(u,geometry)
            exit
         end

         centroid(:,m) = geometry.sum_column_vectors/geometry.dim2
         .crystal.put_to_unit_cell(centroid(:,m))

         ! Clean
         geometry.destroy

      end

   end

!   get_uc_non_H_positions(pos,mol_for)
!   ! Get "pos", the unit cell non hydrogen atom positions; they are
!   ! transformed back into the unit cell if the defragmented molecule
!   ! lies outside the unit cell. Also get "mol_for", the molecule that
!   ! the atom belongs to.
!      centroid :: MAT{REAL}
!   ENSURE(.crystal.associated,"no crystal")
!   ENSURE(.crystal.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")
!   ENSURE(centroid.dim1==3 AND centroid.dim2==.crystal.n_unit_cell_mols,"wrong shape, centroid")
!      m,u :: INT
!      geometry :: MAT{REAL}*
!      centroid = ZERO
!      do m = 1,.crystal.n_unit_cell_mols
!         nullify(geometry)
!         do u = 1,.crystal.n_unit_cell_atoms
!            if (.crystal.unit_cell_mol_for_atom(u)/=m) cycle
!            .do_defragment_uc_atom(u,geometry)
!            exit
!         end
!         centroid(:,m) = geometry.sum_column_vectors/geometry.dim2
!         .crystal.put_to_unit_cell(centroid(:,m))
!         geometry.destroy
!      end
!   end

   put_LFF_info
   ! Put the local field factor L tensors at the centroids of all
   ! molecules in the unit cell.
   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")

      n,k1,k2,m1,m2 :: INT
      L0,L1 :: MAT{REAL}*
      mol,par :: VEC{INT}*
      pos,coc,com,alpha_q :: MAT{REAL}*
      symop,alpha_m :: MAT3{REAL}*

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m)

      ! Make the charge and dipole Lorentz factor tensors
      n = par.dim
      L0.create(3*n,n)
      L1.create(3*n,3*n)
      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos,mol)

      ! Output
      stdout.flush
      stdout.text("Local Field Factor L tensors:")
      stdout.flush
      stdout.show("n_unit_cell_atoms =",par.dim)
      stdout.show("n_unit_cell_mols  =",coc.dim2)
      stdout.flush
      stdout.text("Molecule atom positions:")
      stdout.flush
      stdout.put(transpose(pos))

      stdout.flush
      stdout.text("L tensors:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=6)
      stdout.put("k1",int_width=TRUE)
      stdout.put("k2",int_width=TRUE)
      stdout.put("L(xx)")
      stdout.put("L(yy)")
      stdout.put("L(zz)")
      stdout.put("L(xy)")
      stdout.put("L(xz)")
      stdout.put("L(yz)")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=6)
      do k1 = 1,n
      do k2 = 1,k1
         m1 = 3*(k1-1)
         m2 = 3*(k2-1)
         stdout.put(k1)
         stdout.put(k2)
         stdout.put(L1(m1+1,m2+1))
         stdout.put(L1(m1+2,m2+2))
         stdout.put(L1(m1+3,m2+3))
         stdout.put(L1(m1+1,m2+2))
         stdout.put(L1(m1+1,m2+3))
         stdout.put(L1(m1+2,m2+3))
         stdout.flush
      end
      end
      stdout.dash(int_fields=2,real_fields=6)

      ! Clean up
      L1.destroy
      L0.destroy
      alpha_m.destroy
      alpha_q.destroy
      com.destroy
      coc.destroy
      par.destroy
      symop.destroy
      mol.destroy

   end

!   make_averaged_LFF_tensor(L)
!   ! Put the heavy-atom averaged local field factor dipole L tensor L1
!   ! for the molecules in the unit cell. This uses the Reis formula.
!
!      L :: MAT{REAL}
!
!   ENSURE(.crystal.associated,"no crystal")
!   ENSURE(.crystal.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")
!   ENSURE(.asymmetric_unit_atom.associated,"no asymetric cell atoms")
!   ENSURE(L.is_square,"L is square")
!   ENSURE(L.dim1==.crystal.n_unit_cell_mols,"wrong size, L")
!
!      n_mol,n_H,n,a,i1,i2,j1,j2,k1,k2,m1,m2 :: INT
!      pos,pos0,com, L0,L1 :: MAT{REAL}*
!      symop,non_H,par,mol,mol0 :: VEC{INT}*
!
!      ! Get the positions, COM's for the molecules in the unit cell.
!      ! By construction, the atoms in each molecule occur consecutively.
!      .get_uc_molecule_info(mol,symop,par,pos,com)
!
!      ! Get indices of non-Hydrogen-atom positions.
!      n_mol = .crystal.n_unit_cell_mols
!      n_H   = count(.asymmetric_unit_atom(par).atomic_number>1)
!      non_H.create(n_H)
!      non_H = pack([(a,a=1,par.dim)],.asymmetric_unit_atom(par).atomic_number>1)
!
!      ! Set the non-Hydrogen-atom positions, molecules.
!      pos0.create(3,n_H)
!      mol0.create(n_H)
!      pos0 = pos(:,non_H)
!      mol0 = mol(  non_H)
!
!      non_H.destroy
!      com.destroy; pos.destroy; par.destroy; symop.destroy; mol.destroy
!
!      ! Make the non-Hydrogen-atom Lorentz factor tensors
!      L0.create(3*n_H,n_H)         ! charge L tensor
!      L1.create(3*n_H,3*n_H)       ! dipole L tensor
!      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)
!
!      mol0.destroy; pos0.destroy
!
!      ! Print monopole and dipole L tensor out
!      n = n_H/n_mol
!
!      ! Average the L(1) tensors over molecules
!      L = ZERO
!      do i1 = 1,n_mol
!      do i2 = 1,n_mol
!         m1 = 3*(i1-1)
!         m2 = 3*(i2-1)
!         do j1 = 1,n
!         do j2 = 1,n
!            k1 = 3*(n*(i1-1)+j1-1)
!            k2 = 3*(n*(i2-1)+j2-1)
!            L(m1+1:m1+3,m2+1:m2+3) = L(m1+1:m1+3,m2+1:m2+3) + L1(k1+1:k1+3,k2+1:k2+3)
!         end
!         end
!      end
!      end
!      L = L/real(n*n,kind=REAL_KIND)
!
!      ! Clean up
!      L1.destroy; L0.destroy
!
!   end

!  ======================
!  Susceptibility tensors
!  ======================

   make_chi1_naive(chi1,alpha_mol)
   ! Make the naive second order susceptibility from the
   ! polarisability of the molecule.
      chi1 :: MAT{REAL}(3,3), OUT ! Clausius-Mossotti, L=1/3
      alpha_mol :: MAT{REAL}(3,3), IN

      alpha_uc :: MAT{REAL}(3,3)
      D :: MAT{REAL}*
      fac :: REAL

      .make_alpha_uc(alpha_uc,alpha_mol)

      ! fac = factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      fac = FOUR*PI/.crystal.unit_cell.volume

      D.create(3,3)
      D.to_unit_matrix
      D = D - fac*THIRD*alpha_uc
      D.to_inverse_of(D)
      chi1.to_scaled_product_of(alpha_uc,D,fac)
      D.destroy

   end

   make_alpha_uc(alpha_uc,alpha_mol)
   ! Make the unit cell alpha.
      alpha_uc :: MAT{REAL}(3,3), OUT
      alpha_mol :: MAT{REAL}(3,3), IN

   ENSURE(.crystal.associated,"no crystal")

      alpha :: MAT{REAL}(3,3)
      mol,symop,par :: VEC{INT}*
      pos,com :: MAT{REAL}*
      inverse_seitz :: MAT3{REAL}*
      n_mol,m :: INT

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com)
      com.destroy; pos.destroy; par.destroy; mol.destroy

      ! Transposed/Inverse symops
      inverse_seitz => .crystal.transposed_xyz_seitz_matrices

      ! No of molecules
      n_mol = symop.dim

      !    stdout.text("original tensor")
      !    stdout.put(alpha_mol)

      ! Add up the polarisabilities
      alpha_uc = ZERO
      do m = 1,n_mol
         alpha_mol.change_basis_to(alpha,inverse_seitz(:,:,symop(m)))
         alpha_uc = alpha_uc + alpha
       ! stdout.show("molecule =",m)
       ! stdout.show("symop :",symop(m))
       ! stdout.put(symop(m))
       ! stdout.text("transformed tensor")
       ! stdout.put(alpha)
      end

      ! stdout.text("UC alpha")
      ! stdout.put(alpha_uc)

      ! Clean
      inverse_seitz.destroy
      symop.destroy

   end


   make_chi1_ALFFA(chi1,alpha_mol)
   ! Make the ALFFA "chi1" matrix: chi = Tr_block a^1(1 - L^1 a^1)^-1
   ! where L^1 is the dipole L tensor, a^1 is the (symmetry
   ! transformed) molecular dipole polarisability "alpha_mol". The L
   ! tensors are evaluated at the molecular center-of_masses.
   ! The trace is over 3x3 blocks.
      chi1 :: MAT{REAL}(3,3), OUT
      alpha_mol :: MAT{REAL}(3,3), IN

      mol,mol0,symop,par :: VEC{INT}*
      inverse_seitz,alpha :: MAT3{REAL}*
      pos,com, L0,L1, D,Df :: MAT{REAL}*
      alph :: MAT{REAL}(3,3)
      n_mol,dim,a,b,i,j,m :: INT
      fac :: REAL

      ! No. of molecules
      n_mol = .crystal.n_unit_cell_mols

      ! Molecular polarisabilities
      alpha.create(3,3,n_mol)

      ! D matrix: D = (1 - aL)^-1
      dim = 3*n_mol
      D.create(dim,dim)

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com)

      ! Get the molecule indices (they are consecutive by construction)
      mol0.create(n_mol)
      mol0 = [(m,m=1,n_mol)]

      ! Print out centroid info ... important
      stdout.flush
      stdout.text("Center of mass:")
      stdout.put(com(:,1))

      ! Make the centroid charge and dipole Lorentz factor tensors
      L0.create(dim,n_mol)
      L1.create(dim,dim)
      .crystal.unit_cell.make_LFF_tensors(L0,L1,com,mol0)

      ! Get the reduced molecular polarisabilities
      ! fac = factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      inverse_seitz => .crystal.transposed_xyz_seitz_matrices
      fac = FOUR*PI/.crystal.unit_cell.volume
      alph = fac*alpha_mol
      do m = 1,n_mol
         alph.change_basis_to(alpha(:,:,m),inverse_seitz(:,:,symop(m)))
      end
      inverse_seitz.destroy

      ! Print out centroid info ... important
      if (.debugging("make_chi1_ALFFA")) then
      stdout.flush
      stdout.text("Arrays for centroid calculation:")
      stdout.text("com (center of mass):")
      stdout.put(transpose(com))
      stdout.text("mol0:")
      stdout.put(mol0)
      stdout.text("Alpha for each molecule:")
      stdout.put(alpha,by_dim3_matrices=TRUE)
      stdout.text("Dipole L1 tensor:")
      stdout.put(L1)
      end

      ! Make the (inverse) D matrix
      D.to_unit_matrix
      i = 0
      do a = 1,n_mol
         j = 0
         do b = 1,n_mol
            D(i+1:i+3,j+1:j+3).plus_scaled_product_of(L1(i+1:i+3,j+1:j+3),alpha(:,:,b),-ONE)
            j = j + 3
         end
         i = i + 3
      end

      ! Clean up
      L1.destroy
      L0.destroy
      mol0.destroy
      com.destroy
      pos.destroy
      par.destroy
      symop.destroy
      mol.destroy

      ! Invert
      D.to_inverse_of(D)

      ! Make the local field factors
      Df.create(dim,3)
      CLUSTER::make_local_field_factors(Df,D)

      ! Make the chi1 (ALFFA) susceptibility
      chi1 = ZERO
      i = 0
      do a = 1,n_mol
         chi1.plus_product_of(alpha(:,:,a),Df(i+1:i+3,:))
         i = i + 3
      end

      ! Clean up
      Df.destroy; D.destroy; alpha.destroy

   end

   make_chi1_RLFTn(chi1,alpha_mol)
   ! Make the RLFTn "chi1" matrix: chi1 = Tr_block a^1(1 - L^1 a^1)^-1
   ! where L^1 is the dipole L tensor, a^1 is the (symmetry
   ! transformed) molecular dipole polarisability "alpha_mol" divided
   ! by the number of non-Hydrogen atoms in a molecule.  The L tensors
   ! are evaluated at these non H atom sites. The trace is over 3x3 blocks
      chi1 :: MAT{REAL}(3,3), OUT
      alpha_mol :: MAT{REAL}(3,3), IN

      mol,mol0,symop,par,non_H :: VEC{INT}*
      inverse_seitz,alpha :: MAT3{REAL}*
      pos,pos0,com, L0,L1, D,Df :: MAT{REAL}*
      alph :: MAT{REAL}(3,3)
      n,n_mol,n_non_H,n_non_H_per_mol,dim,a,b,i,j,m :: INT
      fac :: REAL

      n = .crystal.n_unit_cell_atoms    ! No. of atoms in unit cell
      n_mol = .crystal.n_unit_cell_mols ! No. of molecules

      ! No of non-hydrogen atoms in unit cell
      par => .crystal.asym_atom_for_unit_cell_atom
      n_non_H = count(.asymmetric_unit_atom(par).atomic_number>1)

      ! No. of non-H hydrogen atoms per molecule
      DIE_IF(mod(n_non_H,n_mol)/=0,"no of non-Hydrogen atoms wrong")
      n_non_H_per_mol = n_non_H/n_mol

      ! Molecular polarisabilities
      alpha.create(3,3,n_mol)

      ! D matrix: D = (1 - aL)^-1
      dim = 3*n_non_H
      D.create(dim,dim)

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com)

      ! Get the reduced averaged site polarisabilities
      ! fac = factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      inverse_seitz => .crystal.transposed_xyz_seitz_matrices
      fac = FOUR*PI/.crystal.unit_cell.volume
      alph = fac*alpha_mol/n_non_H_per_mol
      do m = 1,n_mol
         alph.change_basis_to(alpha(:,:,m),inverse_seitz(:,:,symop(m)))
      end
      inverse_seitz.destroy

      ! Get *indices* for non-H positions
      non_H.create(n_non_H)
      non_H = pack([(a,a=1,n)],.asymmetric_unit_atom(par).atomic_number>1)

      ! Get the non-H positions and molecules
      pos0.create(3,n_non_H)
      mol0.create(  n_non_H)
      pos0 = pos(:,non_H)
      mol0 = mol(  non_H)

      ! Make the non H charge and dipole Lorentz factor tensors
      L0.create(dim,n_non_H)     ! charge L tensor
      L1.create(dim,dim)         ! dipole L tensor
      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)

      ! Print out position info ...
      if (.debugging("make_chi1_RLFTn")) then
      stdout.flush
      stdout.text("Arrays for non H calculation:")
      stdout.text("non_H:")
      stdout.put(non_H)
      stdout.text("pos0:")
      stdout.put(transpose(pos0))
      stdout.text("mol0:")
      stdout.put(mol0)
      stdout.text("symop :")
      stdout.put(symop)
      stdout.text("Alpha for each molecule:")
      stdout.put(n_non_H_per_mol*alpha/fac,by_dim3_matrices=TRUE)
      stdout.text("UC Alpha :")
      stdout.put(sum(n_non_H_per_mol*alpha/fac,dim=3))
      stdout.text("Dipole L1 tensor:")
      stdout.put(L1)
      end

      ! Make the (inverse) D matrix: D = (1 - aL)^-1
      D.to_unit_matrix
      i = 0
      do a = 1,n_non_H
         j = 0
         do b = 1,n_non_H
            m  = (b-1)/n_non_H_per_mol + 1
            D(i+1:i+3,j+1:j+3).plus_scaled_product_of(L1(i+1:i+3,j+1:j+3),alpha(:,:,m),-ONE)
            j = j + 3
         end
         i = i + 3
      end

      ! Clean up
      L1.destroy; L0.destroy
      mol0.destroy; pos0.destroy; non_H.destroy
      com.destroy; pos.destroy; par.destroy; symop.destroy; mol.destroy

      ! Invert
      D.to_inverse_of(D)

      ! Make the local field factors
      Df.create(dim,3)
      CLUSTER::make_local_field_factors(Df,D)

      ! Make the chi1 (RLFTn) susceptibility
      chi1 = ZERO
      i = 0
      do a = 1,n_non_H
         m = (a-1)/n_non_H_per_mol + 1
         chi1.plus_product_of(alpha(:,:,m),Df(i+1:i+3,:))
         i = i + 3
      end

      ! Clean up
      Df.destroy; D.destroy; alpha.destroy

   end

   make_chi1_RLFTn_av_L(chi1,alpha_mol)
   ! Make the RLFTn "chi1" matrix: chi1 = Tr_block a^1(1 - L^1 a^1)^-1
   ! where L^1 is the dipole L tensor, a^1 is the (symmetry
   ! transformed) molecular dipole polarisability "alpha_mol" divided
   ! by the number of non-Hydrogen atoms in a molecule.  The L tensors
   ! are evaluated at these non H atom sites. The trace is over 3x3 blocks
      chi1 :: MAT{REAL}(3,3), OUT
      alpha_mol :: MAT{REAL}(3,3), IN

      mol,mol0,symop,par,non_H :: VEC{INT}*
      inverse_seitz,alpha :: MAT3{REAL}*
      pos,pos0,com, L,L0,L1, D,Df :: MAT{REAL}*
      alph :: MAT{REAL}(3,3)
      n,n_mol,n_non_H,n_non_H_per_mol,dim, i1,i2,j1,j2,k1,k2,m1,m2, a,b,i,j,m :: INT
      fac :: REAL

      n = .crystal.n_unit_cell_atoms    ! No. of atoms in unit cell
      n_mol = .crystal.n_unit_cell_mols ! No. of molecules

      ! Molecular polarisabilities
      alpha.create(3,3,n_mol)

      ! Molecule averaged L1
      dim = 3*n_mol
      L.create(dim,dim)

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com)

      ! Get *indices* for non-H positions
      n_non_H = count(.asymmetric_unit_atom(par).atomic_number>1)
      non_H.create(n_non_H)
      non_H = pack([(a,a=1,n)],.asymmetric_unit_atom(par).atomic_number>1)

      ! No. of non-H hydrogen atoms per molecule
      DIE_IF(mod(n_non_H,n_mol)/=0,"no of non-Hydrogen atoms wrong")
      n_non_H_per_mol = n_non_H/n_mol

      ! Get the non-H positions and molecules
      pos0.create(3,n_non_H)
      mol0.create(  n_non_H)
      pos0 = pos(:,non_H)
      mol0 = mol(  non_H)

      ! Get the reduced molecular polarisabilities
      ! fac = factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      inverse_seitz => .crystal.transposed_xyz_seitz_matrices
      fac = FOUR*PI/.crystal.unit_cell.volume
      alph = fac*alpha_mol
      do m = 1,n_mol
         alph.change_basis_to(alpha(:,:,m),inverse_seitz(:,:,symop(m)))
      end
      inverse_seitz.destroy

      ! Make the non H charge and dipole Lorentz factor tensors
      dim = 3*n_non_H
      L0.create(dim,n_non_H)     ! charge L tensor
      L1.create(dim,dim)         ! dipole L tensor
      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)

      ! Average the L(1) tensors over molecules
      L = ZERO
      do i1 = 1,n_mol
      do i2 = 1,n_mol
         m1 = 3*(i1-1)
         m2 = 3*(i2-1)
         do j1 = 1,n_non_H_per_mol
         do j2 = 1,n_non_H_per_mol
            k1 = 3*(n_non_H_per_mol*(i1-1)+j1-1)
            k2 = 3*(n_non_H_per_mol*(i2-1)+j2-1)
            L(m1+1:m1+3,m2+1:m2+3) = L(m1+1:m1+3,m2+1:m2+3) + L1(k1+1:k1+3,k2+1:k2+3)
         end
         end
      end
      end
      fac = ONE/(n_non_H_per_mol*n_non_H_per_mol)
      L = fac*L

      ! Mini Clean up
      L1.destroy; L0.destroy
      mol0.destroy; pos0.destroy; non_H.destroy
      com.destroy; pos.destroy; par.destroy; symop.destroy; mol.destroy

      ! Print out position info ... important
      if (.debugging("make_chi1_RLFTn_av_L1")) then
      stdout.text("Averaged L1 tensor:")
      stdout.put(L)
      end

      ! Make the (inverse) D matrix: D = (1 - aL)^-1
      dim = 3*n_mol
      D.create(dim,dim)
      D.to_unit_matrix
      i = 0
      do a = 1,n_mol
         j = 0
         do b = 1,n_mol
            D(i+1:i+3,j+1:j+3).plus_scaled_product_of(L(i+1:i+3,j+1:j+3),alpha(:,:,b),-ONE)
            j = j + 3
         end
         i = i + 3
      end

      ! Invert
      D.to_inverse_of(D)

      ! Make the local field factors
      Df.create(dim,3)
      CLUSTER::make_local_field_factors(Df,D)

      ! Make the chi1 (ALFFA-like) susceptibility
      chi1 = ZERO
      i = 0
      do a = 1,n_mol
         chi1.plus_product_of(alpha(:,:,a),Df(i+1:i+3,:))
         i = i + 3
      end

      ! Clean up
      Df.destroy; D.destroy
      L.destroy; alpha.destroy

   end

   make_chi2_RLFTn_av_L(chi2,beta_mol,alpha_mol)
   ! Make the RLFTn "chi2" matrix:
   !   chi2_ijk = \sum_S \beta^S_abc d^S_ai d^S_bj d^S_ck
   ! where d^S are the local field factor tensors and \beta^S are the (symmetry
   ! transformed) molecular dipole site-hyperpolarisability "beta_mol" divided
   ! by the number of non-Hydrogen atoms in a molecule.  The L tensors
   ! are evaluated at these non H atom sites, "S".
      chi2      :: MAT3{REAL}(3,3,3), OUT
      beta_mol  :: MAT3{REAL}(3,3,3), IN
      alpha_mol :: MAT{REAL}(3,3), IN

      alph0 :: MAT{REAL}(3,3)
      beta0 :: MAT3{REAL}(3,3,3)
      inverse_seitz,alpha :: MAT3{REAL}*
      beta :: MAT4{REAL}*
      pos,pos0,com, L,L0,L1, D,Df :: MAT{REAL}*
      mol,mol0,symop,par,non_H :: VEC{INT}*
      n,n_mol,n_non_H,n_non_H_per_mol,dim, i1,i2,j1,j2,k1,k2,m1,m2, a,b,i,j,m :: INT
      fac :: REAL

      n     = .crystal.n_unit_cell_atoms    ! No. of atoms in unit cell
      n_mol = .crystal.n_unit_cell_mols     ! No. of molecules

      ! Molecular polarisabilities
      alpha.create(3,3,n_mol)
      beta.create(3,3,3,n_mol)

      ! Molecule averaged L1
      dim = 3*n_mol
      L.create(dim,dim)

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com)

      ! Get *indices* for non-H positions
      n_non_H = count(.asymmetric_unit_atom(par).atomic_number>1)
      non_H.create(n_non_H)
      non_H = pack([(a,a=1,n)],.asymmetric_unit_atom(par).atomic_number>1)

      ! No. of non-H hydrogen atoms per molecule
      DIE_IF(mod(n_non_H,n_mol)/=0,"no of non-Hydrogen atoms wrong")
      n_non_H_per_mol = n_non_H/n_mol

      ! Get the non-H positions and molecules
      pos0.create(3,n_non_H)
      mol0.create(  n_non_H)
      pos0 = pos(:,non_H)
      mol0 = mol(  non_H)

      ! Get the reduced molecular polarisabilities
      ! fac = factor to reduce polarisabilities = 1/(2 eps_0 V)
      !     = (2 pi/V) ... in au since eps_0 = (4 pi)^{-1}.
      inverse_seitz => .crystal.transposed_xyz_seitz_matrices
      fac = TWO*PI/.crystal.unit_cell.volume
      alph0 = TWO*fac*alpha_mol
      beta0 =     fac*beta_mol
      do m = 1,n_mol
         alph0.change_basis_to(alpha(:,:,m),inverse_seitz(:,:,symop(m)))
         beta0.change_basis_to(beta(:,:,:,m),inverse_seitz(:,:,symop(m)))
      end
      inverse_seitz.destroy

      ! Make the non H charge and dipole Lorentz factor tensors
      dim = 3*n_non_H
      L0.create(dim,n_non_H)     ! charge L tensor
      L1.create(dim,dim)         ! dipole L tensor
      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)

      ! Average the L(1) tensors over molecules
      L = ZERO
      do i1 = 1,n_mol
      do i2 = 1,n_mol
         m1 = 3*(i1-1)
         m2 = 3*(i2-1)
         do j1 = 1,n_non_H_per_mol
         do j2 = 1,n_non_H_per_mol
            k1 = 3*(n_non_H_per_mol*(i1-1)+j1-1)
            k2 = 3*(n_non_H_per_mol*(i2-1)+j2-1)
            L(m1+1:m1+3,m2+1:m2+3) = L(m1+1:m1+3,m2+1:m2+3) + L1(k1+1:k1+3,k2+1:k2+3)
         end
         end
      end
      end
      fac = ONE/(n_non_H_per_mol*n_non_H_per_mol)
      L = fac*L

      ! Mini Clean up
      L1.destroy
      L0.destroy
      mol0.destroy
      pos0.destroy
      non_H.destroy
      com.destroy
      pos.destroy
      par.destroy
      symop.destroy
      mol.destroy

      ! Make the (inverse) D matrix: D = (1 - aL)^-1
      dim = 3*n_mol
      D.create(dim,dim)
      D.to_unit_matrix
      i = 0
      do a = 1,n_mol
         j = 0
         do b = 1,n_mol
            D(i+1:i+3,j+1:j+3).plus_scaled_product_of(L(i+1:i+3,j+1:j+3),alpha(:,:,b),-ONE)
            j = j + 3
         end
         i = i + 3
      end

      ! Invert
      D.to_inverse_of(D)

      ! Make the local field factors
      Df.create(dim,3)
      CLUSTER::make_local_field_factors(Df,D)

      ! Make the chi2 susceptibility
      chi2 = ZERO
      i = 0
      do a = 1,n_mol
         beta(:,:,:,a).change_basis_to(beta0,Df(i+1:i+3,:))
         chi2 = chi2 + beta0
         i = i + 3
      end

      ! Clean up
      Df.destroy
      D.destroy
      L.destroy
      beta.destroy
      alpha.destroy

   end

! Old distributed polarisability code
! This code does the chi2 from hyperpolarizability

   make_susceptibility2(alpha_mol,beta_mol,uc_alpha,chi1_naive,chi1_centr,chi1_nonH,chi2_nonH,chi1_nc,chi1_do,chi1)
   ! Make the second ortder susceptibility from distributed
   ! polarisabilities.
      alpha_mol  :: MAT{REAL}(3,3), IN
      beta_mol   :: MAT3{REAL}(3,3,3), IN
      uc_alpha   :: MAT{REAL}(3,3), OUT ! Unit cell alpha
      chi1_naive :: MAT{REAL}(3,3), OUT ! Clausius-Mossotti, L=1/3
      chi1_centr :: MAT{REAL}(3,3), OUT ! Dipoles at the COM
      chi1_nonH  :: MAT{REAL}(3,3), OUT ! Non-hydrogen model, RLFTn
      chi1_nc    :: MAT{REAL}(3,3), OUT ! No charge contributons to polarisability
      chi1_do    :: MAT{REAL}(3,3), OUT ! Atomic alpha used
      chi1       :: MAT{REAL}(3,3), OUT ! Distributed polarisability
      chi2_nonH  :: MAT3{REAL}(3,3,3)

   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.asymmetric_unit_atom.associated,"no asymetric cell atoms")

      alph,al :: MAT{REAL}(3,3)
      beta,be :: MAT3{REAL}(3,3,3)
      L0,L1,Lm,D,Dnc,Ddo,Dd,AA, df :: MAT{REAL}*
      pos,pos0,coc,com,coc0,alpha_q :: MAT{REAL}*
      mol,mol0,par,non_H :: VEC{INT}*
      r,Lq :: VEC{REAL}*
      symop,alpha_m,alpha :: MAT3{REAL}*
      n,n_m,n_a,n_H,nH,a,b,i,j,m :: INT
      fac :: REAL

      ! Get the unit cell electrical properties for each atom
      .get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m)

      ! Get no of atoms in unit cell
      n = par.dim

      ! Factor to reduce polarisabilities (in au)
      fac = FOUR*PI/.crystal.unit_cell.volume

      ! Make the charge and dipole Lorentz factor tensors
      D.create(3*n,3*n)
      Dnc.create(3*n,3*n)
      Ddo.create(3*n,3*n)
      alpha.create(3,3,n)
      L0.create(3*n,n)
      L1.create(3*n,3*n)
      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos,mol)

      ! Get the atomic alpha's
      alpha = ZERO
      AA.create(3,3)
      r.create(3)
      do a = 1,n
         r = pos(:,a) - coc(:,a)
         AA = r.outer_product_with(alpha_q(:,a)) + alpha_m(:,:,a)
         alpha(:,:,a) = alpha(:,:,a) + AA
      end
      r.destroy; AA.destroy

      ! Make the D matrix
      D.to_unit_matrix
      Dnc.to_unit_matrix
      Ddo.to_unit_matrix
      i = 0
      do a = 1,n
         j = 0
         do b = 1,n
            Lq => L0(i+1:i+3,b)
            Lm => L1(i+1:i+3,j+1:j+3)

            Dd =>   D(i+1:i+3,j+1:j+3)
            Dd = Dd - fac*Lq.outer_product_with(alpha_q(:,b))
            Dd = Dd - fac*matmul(Lm,alpha_m(:,:,b))

            Dd => Dnc(i+1:i+3,j+1:j+3)
            Dd = Dd - fac*matmul(Lm,alpha_m(:,:,b))

            Dd => Ddo(i+1:i+3,j+1:j+3)
            Dd = Dd - fac*matmul(Lm,alpha(:,:,b))

            j = j + 3
         end
         i = i + 3
      end
      D.to_inverse_of(D)
      Dnc.to_inverse_of(Dnc)
      Ddo.to_inverse_of(Ddo)
      L1.destroy
      L0.destroy

      ! Make the distributed polarisability chi1
      chi1 = ZERO
      chi1_nc = ZERO
      chi1_do = ZERO
      uc_alpha = ZERO
      AA.create(3,3)
      r.create(3)
      i = 0
      do a = 1,n
         r = pos(:,a) - coc(:,a)
         AA = r.outer_product_with(alpha_q(:,a)) + alpha_m(:,:,a)
         uc_alpha = uc_alpha + AA
         AA = fac*AA
         j = 0
         do b = 1,n
            Dd =>   D(i+1:i+3,j+1:j+3)
            chi1 = chi1 + matmul(AA,Dd)
            Dd => Dnc(i+1:i+3,j+1:j+3)
            chi1_nc = chi1_nc + matmul(AA,Dd)
            Dd => Ddo(i+1:i+3,j+1:j+3)
            chi1_do = chi1_do + matmul(AA,Dd)
            j = j + 3
         end
         i = i + 3
      end

      ! Clean up
      r.destroy; AA.destroy
      alpha.destroy
      Ddo.destroy; Dnc.destroy; D.destroy

      ! ================================================

      ! Make chi1_naive
      D.create(3,3)
      D.to_unit_matrix
      D = D - fac*THIRD*uc_alpha
      D.to_inverse_of(D)
      chi1_naive = fac*matmul(uc_alpha,D)
      D.destroy

      ! ================================================

      ! Get the no of molecules
      n_m = maxval(mol)
      DIE_IF(mod(n,n_m)/=0,"no of atoms in a molecule is not integral")

      ! Get the no of atoms per molecule
      n_a = n/n_m

      ! Get the molecular alpha's
      alpha.create(3,3,n_m)
      alpha = ZERO
      AA.create(3,3)
      r.create(3)
      a = 0
      do m = 1,n_m
         do i = 1,n_a
            a = a + 1
            r = pos(:,a) - coc(:,a)
            AA = r.outer_product_with(alpha_q(:,a)) + alpha_m(:,:,a)
            alpha(:,:,m) = alpha(:,:,m) + AA
         end
      end
      r.destroy; AA.destroy

      ! Get the centroids, use COM
      coc0.create(3,n_m)
      mol0.create(n_m)
      coc0 = com(:,1:(n_m-1)*n_a+1:n_a)
      mol0 = mol(1:(n_m-1)*n_a+1:n_a)

      ! Print out centroid info ... important
      stdout.flush
      stdout.show("Center of mass =",coc0(:,1))

      ! Make the centroid charge and dipole Lorentz factor tensors
      D.create(3*n_m,3*n_m)
      L0.create(3*n_m,n_m)
      L1.create(3*n_m,3*n_m)
      .crystal.unit_cell.make_LFF_tensors(L0,L1,coc0,mol0)

      ! Print out centroid info ... important

      if (.debugging("make_susceptibility2")) then
      stdout.flush
      stdout.text("Arrays for centroid calculation:")
      stdout.text("coc0 (center of mass):")
      stdout.put(transpose(coc0))
      stdout.text("mol0:")
      stdout.put(mol0)
      stdout.text("Dipole L1 tensor:")
      stdout.put(L1)
      stdout.text("Alpha for each molecule:")
      stdout.put(alpha,by_dim3_matrices=TRUE)
      end

      ! Make the D matrix
      D.to_unit_matrix
      i = 0
      do a = 1,n_m
         j = 0
         do b = 1,n_m
            Dd => D(i+1:i+3,j+1:j+3)
            Lm => L1(i+1:i+3,j+1:j+3)
            Dd = Dd - fac*matmul(Lm,alpha(:,:,b))
            j = j + 3
         end
         i = i + 3
      end
      D.to_inverse_of(D)
      L1.destroy
      L0.destroy

      ! Make the chi1_centr susceptibility
      chi1_centr = ZERO
      AA.create(3,3)
      r.create(3)
      i = 0
      do a = 1,n_m
         AA = alpha(:,:,a)
         AA = fac*AA
         j = 0
         do b = 1,n_m
            Dd => D(i+1:i+3,j+1:j+3)
            chi1_centr = chi1_centr + matmul(AA,Dd)
            j = j + 3
         end
         i = i + 3
      end

      ! Clean up
      r.destroy; AA.destroy
      D.destroy
      mol0.destroy; coc0.destroy

      ! ================================================
      ! RLFTn
      ! ================================================

      ! Get non H positions.
      n_H = count(.asymmetric_unit_atom(par).atomic_number>1)
      non_H.create(n_H)
      non_H = pack([(a,a=1,n)],.asymmetric_unit_atom(par).atomic_number>1)

      ! Get the non H positions, indices, molecules.
      pos0.create(3,n_H)
      mol0.create(n_H)
      pos0 = pos(:,non_H)
      mol0 = mol(non_H)

      ! Make the non H charge and dipole Lorentz factor tensors
      D.create(3*n_H,3*n_H)        ! (1 - aL)^-1
      df.create(3*n_H,3)           ! local field factor tensor
      L0.create(3*n_H,n_H)         ! charge L tensor
      L1.create(3*n_H,3*n_H)       ! dipole L tensor
      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)

      ! Print out position info ... important
      if (.debugging("make_susceptibility2")) then
      stdout.flush
      stdout.text("Arrays for non H calculation:")
      stdout.text("non_H:")
      stdout.put(non_H)
      stdout.text("pos0:")
      stdout.put(transpose(pos0))
      stdout.text("mol0:")
      stdout.put(mol0)
      stdout.text("Dipole L1 tensor:")
      stdout.put(L1)
      end

      ! Get number of Non-H hydrogen atoms per molecule
      DIE_IF(mod(n_H,n_m)/=0,"no of non-Hydrogen atoms wrong")
      nH = n_H/n_m

      ! Average alpha over non-H sites
      alpha = alpha/nH

      ! Get the reduced average molecular polarisabilities
      alph = fac*alpha_mol/nH
      beta = fac*beta_mol/nH

      ! Make the D matrix
      D.to_unit_matrix
      i = 0
      do a = 1,n_H
         j = 0
         do b = 1,n_H
            Dd => D(i+1:i+3,j+1:j+3)
            Lm => L1(i+1:i+3,j+1:j+3)
            m  = (b-1)/nH + 1

            ! Old way
         !  Dd = Dd - fac*matmul(Lm,alpha(:,:,m))

            ! New way -- should be better -- check
            alph.change_basis_to(al,symop(:,:,m))
            Dd = Dd - matmul(Lm,al)

            j = j + 3
         end
         i = i + 3
      end
      D.to_inverse_of(D)
      L1.destroy
      L0.destroy

      ! Make the chi1_nonH susceptibility
      chi1_nonH = ZERO
      AA.create(3,3)
      i = 0
      do a = 1,n_H
         m  = (a-1)/nH + 1
         AA = alpha(:,:,m)
         AA = fac*AA
         j = 0
         do b = 1,n_H
            Dd => D(i+1:i+3,j+1:j+3)
            chi1_nonH = chi1_nonH + matmul(AA,Dd)
            j = j + 3
         end
         i = i + 3
      end

      ! Local field factors
      df = ZERO
      i = 0
      do a = 1,n_H
         j = 0
         do b = 1,n_H
            df(i+1:i+3,:) = df(i+1:i+3,:) + D(i+1:i+3,j+1:j+3)
            j = j + 3
         end
         i = i + 3
      end

      ! Make the chi1_nonH and chi2_nonH susceptibility
      chi1_nonH = ZERO
      chi2_nonH = ZERO
      i = 0
      do a = 1,n_H
         m = (a-1)/nH + 1
         alph.change_basis_to(al,symop(:,:,m))
         chi1_nonH = chi1_nonH + matmul(al,df(i+1:i+3,:))
         beta.change_basis_to(be,symop(:,:,m))
         be.change_basis_using(df(i+1:i+3,:))
         chi2_nonH = chi2_nonH + be
         i = i + 3
      end
      chi2_nonH = HALF*chi2_nonH

      ! Clean up
      df.destroy; D.destroy
      mol0.destroy; pos0.destroy
      non_H.destroy
      alpha.destroy
      alpha_m.destroy; alpha_q.destroy
      com.destroy; coc.destroy; pos.destroy
      par.destroy; symop.destroy; mol.destroy

   end

   make_local_field_factors(Df,D) ::: selfless
   ! Make the second ortder susceptibility from distributed
   ! polarisabilities.
      Df :: MAT{REAL}, OUT
      D  :: MAT{REAL}, IN

   ENSURE(D.is_square,     "non square D")
   ENSURE(mod(D.dim1,3)==0,"D dim1 is not divisible by 3")
   ENSURE(Df.dim1==D.dim1, "wrong dim1, Df")
   ENSURE(Df.dim2==3,      "wrong dim2, Df")

      n,a,b,i,j :: INT

      n = D.dim1/3

      Df = ZERO
      i = 0
      do a = 1,n
         j = 0
         do b = 1,n
            Df(i+1:i+3,:) = Df(i+1:i+3,:) + D(i+1:i+3,j+1:j+3)
            j = j + 3
         end
         i = i + 3
      end

   end

! These are for more complicated calculations

   make_D_matrix(D)
   ! Make the D matrix: D = (1 - L^0 a^0 - L^1 a^1)^-1
   ! where L^0 and L^1 are the monopole and dipole L tensors and
   ! where a^0 and a^1 are the monopole and dipole polarisabilities
   ! for every atom site at which the L tensors are evaluated.
      D :: MAT{REAL}, target

   ENSURE(D.is_square,  "non square D")
   ENSURE(.crystal.associated,"no crystal")

      mol,par :: VEC{INT}*
      symop,alpha_m :: MAT3{REAL}*
      pos,coc,com,alpha_q :: MAT{REAL}*
      L0,L1,Lm, DD :: MAT{REAL}*
      Lq :: VEC{REAL}*
      n,dim,a,b,i,j :: INT
      fac :: REAL

      ! Factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      fac = FOUR*PI/.crystal.unit_cell.volume

      ! Get the electrical properties for each atom
      .get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m)

      com.destroy
      coc.destroy
      pos.destroy
      par.destroy
      symop.destroy
      mol.destroy

      ! Get no of atoms in unit cell
      n   = par.dim
      dim = D.dim1
      ENSURE(dim==3*n,"wrong size, par array")

      ! Make the charge and dipole Lorentz factor tensors
      L0.create(dim,n)
      L1.create(dim,dim)
      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos,mol)

      ! Make the (inverse) D matrix
      D.to_unit_matrix

      i = 0
      do a = 1,n

         j = 0
         do b = 1,n

            Lq => L0(i+1:i+3,b)
            Lm => L1(i+1:i+3,j+1:j+3)

            DD =>   D(i+1:i+3,j+1:j+3)
            DD = DD - fac*Lq.outer_product_with(alpha_q(:,b))
            DD.plus_scaled_product_of(Lm,alpha_m(:,:,b),-fac)

            j = j + 3
         end

         i = i + 3
      end

      ! Clean up
      alpha_m.destroy
      alpha_q.destroy
      L1.destroy
      L0.destroy

      ! Invert
      D.to_inverse_of(D)

   end

   make_Dnc_matrix(Dnc)
   ! Make the Dnc matrix: Dnc = (1 - L^1 a^1)^-1
   ! where L^1 is the dipole L tensors and where a^1 is the dipole
   ! polarisability for every atom site at which the L tensors are
   ! evaluated.  NOTE: Dnc means "no charge dipole terms"
      Dnc :: MAT{REAL}, target

   ENSURE(Dnc.is_square,"non square Dnc")
   ENSURE(.crystal.associated,"no crystal")

      mol,par :: VEC{INT}*
      symop,alpha_m :: MAT3{REAL}*
      pos,coc,com,alpha_q :: MAT{REAL}*
      L0,L1,Lm, DD :: MAT{REAL}*
      n,dim,a,b,i,j :: INT
      fac :: REAL

      ! Factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      fac = FOUR*PI/.crystal.unit_cell.volume

      ! Get the unit cell electrical properties for each atom
      .get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m)

      alpha_q.destroy
      com.destroy
      coc.destroy
      pos.destroy
      par.destroy
      symop.destroy
      mol.destroy

      ! Get no of atoms in unit cell
      n   = par.dim
      dim = Dnc.dim1
      ENSURE(dim==3*n,"wrong size, par array")

      ! Make the charge and dipole Lorentz factor tensors
      L0.create(dim,n)
      L1.create(dim,dim)
      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos,mol)

      ! Make the (inverse) D matrix
      Dnc.to_unit_matrix

      i = 0
      do a = 1,n

         j = 0
         do b = 1,n

            Lm => L1(i+1:i+3,j+1:j+3)

            DD => Dnc(i+1:i+3,j+1:j+3)
            DD.plus_scaled_product_of(Lm,alpha_m(:,:,b),-fac)

            j = j + 3
         end

         i = i + 3
      end

      ! Clean up
      L1.destroy
      L0.destroy

      ! Invert
      Dnc.to_inverse_of(Dnc)

   end

!  ===============
!  Electric fields
!  ===============

   make_Lorentz_fields(F,sphere_sum)
   ! Make the Lorentz electric fields at the unit cell atom sites.
   ! Warning: the asymmetric_unit_atom's should be generated from the
   ! fragment where catomic harges and dipoles have been done.
      F :: MAT{REAL}, OUT
      sphere_sum :: BIN, optional

      mol,frag_atom :: VEC{INT}*
      charge,dipole :: VEC{REAL}*
      pos,L0,L1 :: MAT{REAL}*
      fac :: REAL
      n_atom,dim, u,a, fu,lu :: INT

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,pos,charge,dipole,frag_atom)

      ! Make the Lorentz factor tensors L0, L1
      n_atom = charge.dim
      dim    = dipole.dim
      L0.create(dim,n_atom)      ! charge L0 tensor
      L1.create(dim,dim)         ! dipole L1 tensor
      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos,mol,sphere_sum)
      fac = FOUR*PI/.crystal.unit_cell.volume
      L0 = fac*L0
      L1 = fac*L1

      ! Assign electric fields
      do a = 1,.n_fragment_atoms
         u = frag_atom.index_of_value(a) ! map to unit cell atom
         DIE_IF(u==0,"fragment atom "//trim(a.to_str)//" not found in cell")
         lu = 3*(u-1)
         fu = lu + 1
         lu = lu + 3
         F(:,a).to_product_of(L0(fu:lu,:),charge)
         F(:,a).plus_product_of(L1(fu:lu,:),dipole)
      end

      .put_debug(charge,"make_Lorentz_fields: charge")
      .put_debug(dipole,"make_Lorentz_fields: dipole")
      .put_debug(transpose(pos),"make_Lorentz_fields: pos")
      .put_debug(mol,"make_Lorentz_fields: mol")
      .put_debug(transpose(F),"make_Lorentz_fields: F")
      .put_debug(L0,"make_Lorentz_fields: L0")
      .put_debug(L1,"make_Lorentz_fields: L1")
      .put_debug(matmul(L0,charge),"make_Lorentz_fields: L0 x charge")
      .put_debug(matmul(L1,dipole),"make_Lorentz_fields: L1 x dipole")
      .put_debug(frag_atom,"make_Lorentz_fields: frag_atom")

      ! Clean up
      L1.destroy
      L0.destroy
      frag_atom.destroy
      dipole.destroy
      charge.destroy
      pos.destroy

   end

   make_Lorentz_interactions(I0,I1,sphere_sum)
   ! Make the Lorentz interactions with charges and dipoles due to
   ! dipoles ONLY at the unit cell atom sites. The charge-charge term
   ! is not calculated -- it does not affect the susceptibilities.
   ! Warning: the asymmetric_unit_atom's should be generated from the
   ! fragment where atomic charges and dipoles have been done.
      I0 :: VEC{REAL}, OUT
      I1 :: MAT{REAL}, OUT
      sphere_sum :: BIN, optional

      mol,frag_atom :: VEC{INT}*
      charge,dipole :: VEC{REAL}*
      pos,L0,L1 :: MAT{REAL}*
      fac :: REAL
      n_atom,dim, u,a, fu,lu :: INT

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,pos,charge,dipole,frag_atom)

      ! Create L tensors
      n_atom = charge.dim        ! No of unit cell atoms
      dim    = dipole.dim        ! 3 x the above
      L0.create(dim,n_atom)      ! charge L0 tensor
      L1.create(dim,dim)         ! dipole L1 tensor

      ! Make the Lorentz factor tensors L0, L1
      .crystal.unit_cell.make_LFF_tensors(L0,L1,pos,mol,sphere_sum)

      fac = FOUR*PI/.crystal.unit_cell.volume
      L0 = fac*L0
      L1 = fac*L1

      ! Assign charge and dipole interactions
      ! Needs a minus sign when combined
      do a = 1,.n_fragment_atoms
         u = frag_atom.index_of_value(a) ! map to unit cell atom
         DIE_IF(u==0,"fragment atom "//trim(a.to_str)//" not found in cell")
         lu = 3*(u-1)
         fu = lu + 1
         lu = lu + 3
         I0(a)   = dot_product(L0(:,u),dipole)
         I1(:,a).to_product_of(L1(:,fu:lu),dipole,transpose_a=TRUE)
      end

      ! Clean up
      L1.destroy
      L0.destroy
      frag_atom.destroy
      dipole.destroy
      charge.destroy
      pos.destroy

   end

!  =====================================================
!  Cluster positions, charges, dipoles, polarisabilities
!  =====================================================

   get_uc_molecule_info(mol,symop,par,pos,com) ::: leaky
   ! Get the unit cell molecule information for a distributed local
   ! field factor (LFF) calculation. "mol" is the molecule index for
   ! an atom in the unit cell. "pos" are the positions. "par" is the
   ! asymmetric unit atom parent. "com" are the molecular center of
   ! masses.
      mol,symop,par :: VEC{INT}*
      pos,com :: MAT{REAL}*

   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")

      n_atom,n_mol,n,m,u,a :: INT
      mass,mass0 :: VEC{REAL}*
      cm  :: VEC{REAL}(3)
      par0 :: VEC{INT}*
      pos0 :: MAT{REAL}*
      fac :: REAL

      ! Create the info arrays
      n_mol  = .crystal.n_unit_cell_mols
      n_atom = .crystal.n_unit_cell_atoms

      mol.create(n_atom)
      symop.create(n_mol)
      par.create(n_atom)
      pos.create(3,n_atom)
      com.create(3,n_mol)
      mass.create(n_atom)

      ! Set n_atom to the # of atoms in one molecule
      DIE_IF(mod(n_atom,n_mol)/=0,"# of unit cell atoms is not divisible by number of molecules")
      n_atom = n_atom/n_mol

      n = 0
      do m = 1,n_mol

         ! Find atom "u" on molecule "m", defragment, get the info
         do u = 1,.crystal.n_unit_cell_atoms

            if (.crystal.unit_cell_mol_for_atom(u)/=m) cycle

            mol(n+1:n+n_atom) = m
            par0     => par(  n+1:n+n_atom)
            pos0     => pos(:,n+1:n+n_atom)
            mass0    => mass( n+1:n+n_atom)

            .do_defragment_uc_atom(u,symop(m),par0,pos0,mass0)

            exit

         end

         ! Calculate the center of mass (COM)
         cm = ZERO
         do a = 1,n_atom
            cm = cm + mass0(a)*pos0(:,a)
         end
         fac = VEC{REAL}:sum_elements(mass0)
         fac = ONE/fac
         cm = fac*cm
         com(:,m) = cm

         n = n + n_atom

      end

      mass.destroy

   end

   get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m) ::: leaky
   ! Get the unit cell molecule information for a distributed local field factor
   ! (LFF) calculation. "coc" are the molecular center of charges.
      mol,par :: VEC{INT}*
      pos,coc,com,alpha_q :: MAT{REAL}*
      symop,alpha_m :: MAT3{REAL}*

   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")

      n_atom,n_mol,n,m,u,a :: INT
      charge,charge0,mass,mass0 :: VEC{REAL}*
      e_dipole,cm  :: VEC{REAL}(3)
      par0 :: VEC{INT}*
      symop0,pos0,dipole,dipole0,alpha_q0 :: MAT{REAL}*
      alpha_m0 :: MAT3{REAL}*
      fac :: REAL

      ! Sizes
      n_mol  = .crystal.n_unit_cell_mols
      n_atom = .crystal.n_unit_cell_atoms

      ! Create the info arrays
      mol.create(n_atom)
      symop.create(3,3,n_mol)
      par.create(n_atom)
      pos.create(3,n_atom)
      coc.create(3,n_atom)
      com.create(3,n_atom)
      alpha_q.create(3,n_atom)
      alpha_m.create(3,3,n_atom)
      charge.create(n_atom)
      mass.create(n_atom)
      dipole.create(3,n_atom)

      ! Set n_atom to the # of atoms in one molecule
      DIE_IF(mod(n_atom,n_mol)/=0,"# of unit cell atoms is not divisible by number of molecules")
      n_atom = n_atom/n_mol

      n = 0
      do m = 1,n_mol

         ! Find atom "u" on molecule "m", defragment, get the info
         do u = 1,.crystal.n_unit_cell_atoms

            if (.crystal.unit_cell_mol_for_atom(u)/=m) cycle

            mol(n+1:n+n_atom) = m
            symop0   => symop(:,:,m)
            par0     => par(n+1:n+n_atom)
            pos0     => pos(:,n+1:n+n_atom)
            charge0  => charge(n+1:n+n_atom)
            mass0    => mass(n+1:n+n_atom)
            dipole0  => dipole(:,n+1:n+n_atom)
            alpha_q0 => alpha_q(:,n+1:n+n_atom)
            alpha_m0 => alpha_m(:,:,n+1:n+n_atom)

            .do_defragment_uc_atom(u,symop0,par0,pos0,charge0,mass0,dipole0,alpha_q0,alpha_m0)

            exit

         end

         ! Calculate electronic dipole and center of charge
         e_dipole = ZERO
         do a = 1,n_atom
            e_dipole = e_dipole + dipole0(:,a)
            e_dipole = e_dipole + charge0(a)*pos0(:,a)
         end
         fac = VEC{REAL}:sum_elements(charge0)
         fac = ONE/fac
         e_dipole = fac*e_dipole
         coc(:,n+1:n+n_atom) = spread(e_dipole,2,n_atom)

         ! Calculate the center of mass (COM): make coc the COM
         cm = ZERO
         do a = 1,n_atom
            cm = cm + mass0(a)*pos0(:,a)
         end
         fac = VEC{REAL}:sum_elements(mass0)
         fac = ONE/fac
         cm  = fac*cm
         com(:,n+1:n+n_atom) = spread(cm,2,n_atom)

         n = n + n_atom

      end

         ! Debug
       ! stdout.flush
       ! stdout.text("mol:")
       ! stdout.put(mol)
       ! stdout.text("pos:")
       ! stdout.put(transpose(pos))
       ! stdout.text("coc:")
       ! stdout.put(transpose(coc))
       ! stdout.text("charge:")
       ! stdout.put(charge)
       ! stdout.text("dipole:")
       ! stdout.put(transpose(dipole))
       ! stdout.text("alpha_q:")
       ! stdout.put(transpose(alpha_q))
       ! stdout.text("alpha_m:")
       ! do a = 1,alpha_m.dim3
       ! stdout.put(alpha_m(:,:,a))
       ! end

       dipole.destroy
       mass.destroy
       charge.destroy

   end

!   get_uc_molecule_info(mol,pos,charge,dipole,frag_atom) ::: leaky
!   ! Get the unit cell molecule information for a distributed local field factor
!   ! (LFF) calculation. "coc" are the molecular center of charges.
!      mol :: VEC{INT}*
!      pos :: MAT{REAL}*
!      charge,dipole :: VEC{REAL}*
!      frag_atom :: VEC{INT}*
!
!   ENSURE(.crystal.associated,"no crystal")
!   ENSURE(.crystal.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")
!
!      n_atom,n_mol,n,n3,m,u :: INT
!      charge0,dipole0 :: VEC{REAL}*
!      mol0 :: VEC{INT}*
!      pos0 :: MAT{REAL}*
!
!      ! Create the info arrays
!      n_mol  = .crystal.n_unit_cell_mols
!      n_atom = .crystal.n_unit_cell_atoms
!      mol.create(n_atom)
!      pos.create(3,n_atom)
!      charge.create(n_atom)
!      dipole.create(3*n_atom)
!      frag_atom.create(.crystal.n_fragment_atoms)
!
!
!      ! Set n_atom to the # of atoms in one molecule
!      DIE_IF(mod(n_atom,n_mol)/=0,"# of unit cell atoms is not divisible by number of molecules")
!      n_atom = n_atom/n_mol
!
!      n  = 0
!      n3 = 0
!      do m = 1,n_mol
!
!         ! Find atom "u" on molecule "m", defragment, get the info
!         do u = 1,.crystal.n_unit_cell_atoms
!
!            if (.crystal.unit_cell_mol_for_atom(u)/=m) cycle
!
!            mol(n+1:n+n_atom) = m
!            pos0     => pos(:,n+1:n+n_atom)
!            charge0  => charge(n +1:n +  n_atom)
!            dipole0  => dipole(n3+1:n3+3*n_atom)
!
!            if (m==1) then
!               .do_defragment_uc_atom(u,pos0,charge0,dipole0,frag_atom)
!            else
!               .do_defragment_uc_atom(u,pos0,charge0,dipole0)
!            end
!
!            exit
!
!         end
!
!         n  = n  +   n_atom
!         n3 = n3 + 3*n_atom
!
!      end
!
!   end

   get_uc_molecule_info(mol,pos,charge,dipole,frag_atom) ::: leaky
   ! Get the unit cell molecule information for a distributed local field factor
   ! (LFF) calculation. "coc" are the molecular center of charges.
      mol :: VEC{INT}*
      pos :: MAT{REAL}*
      charge,dipole :: VEC{REAL}*
      frag_atom :: VEC{INT}*

   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")

      n_atom,n_mol, n,n3,m,u :: INT
      charge0,dipole0 :: VEC{REAL}*
      occupation_list,frag_atom0 :: VEC{INT}*
      pos0 :: MAT{REAL}*

      ! Sizes
      n_mol  = .crystal.n_unit_cell_mols
      n_atom = .crystal.n_unit_cell_atoms

      ! Create the info arrays
      mol.create(n_atom)
      pos.create(3,n_atom)
      charge.create(n_atom)
      dipole.create(3*n_atom)
      frag_atom.create(n_atom)

      ! Counters
      n  = 0
      n3 = 0

      ! Loop over molecules m
      do m = 1,n_mol

         ! Find atom "u" on molecule "m", defragment, get the info
         do u = 1,.crystal.n_unit_cell_atoms

            if (.crystal.unit_cell_mol_for_atom(u)/=m) cycle

            ! Get the occ list for molecule m
            occupation_list.create(1)
            occupation_list(1) = CLUSTER_AT_CODE(0,0,0,u)
            .do_defragment(occupation_list)

            ! No of atoms in molecule m
            n_atom = occupation_list.dim

            ! Assign
            mol(n+1:n+n_atom) = m
            pos0       => pos(:,n+1:n+n_atom)
            charge0    => charge(n +1:n +  n_atom)
            dipole0    => dipole(n3+1:n3+3*n_atom)
            frag_atom0 => frag_atom(n +1:n +  n_atom)

            ! Get the info
            .extract_atom_info(occupation_list,pos0,charge0,dipole0,frag_atom0)

            ! Clean
            occupation_list.destroy

            exit

         end

         ! Increment
         n  = n  +   n_atom
         n3 = n3 + 3*n_atom

      end

   end

!   get_atom_LFF_tensors(L2)
!   ! Get the local field factor tensors for the atom centers of all
!   ! molecules in the unit cell.
!      L2 :: MAT3{REAL}*
!   ENSURE(.crystal.associated,"no crystal")
!   ENSURE(.crystal.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")
!      nu,m,u,n,k,k1,k2 :: INT
!      pos :: MAT{REAL}*
!      nu = .crystal.n_unit_cell_atoms
!      L2.create(3,3,nu.triangle)
!      pos.create(3,nu)
!      .get_uc_molecule_positions(pos)
!      pos = matmul(.crystal.unit_cell.direct_matrix,pos)
!      .crystal.unit_cell.make_LFF_tensors(L2,pos)
!      pos.destroy
!    ! L2.destroy
!   end

!   get_uc_molecule_positions(pos)
!   ! Get the unit cell molecule positions as a flat list. It helps if
!   ! there is only one molecule in the unit cell.
!      pos :: MAT{REAL}
!   ENSURE(.crystal.associated,"no crystal")
!   ENSURE(.crystal.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")
!   ENSURE(pos.dim1==3 AND pos.dim2==.crystal.n_unit_cell_atoms,"wrong shape, centroid")
!      m,n,na,u :: INT
!      geometry :: MAT{REAL}*
!      n = 0
!      do m = 1,.crystal.n_unit_cell_mols
!         nullify(geometry)
!         do u = 1,.crystal.n_unit_cell_atoms
!            if (.crystal.unit_cell_mol_for_atom(u)/=m) cycle
!            .do_defragment_uc_atom(u,geometry)
!            exit
!         end
!         na = geometry.dim2
!         pos(:,n+1:n+na) = geometry
!         n  = n + na
!         geometry.destroy
!      end
!   end

!  ==============
!  Debug printing
!  ==============

   read_debug_on ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and add it to the list.
   end

   read_debug_off ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and remove it from the list.
   end

   debugging(name) result (res) ::: get_from(DEBUG)
   ! Return TRUE if the debug switch "name" has been set.
   end

   put_debug_list ::: get_from(DEBUG)
   ! Put of the list of debug switches
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>REAL)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>VEC{INT})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>VEC{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>MAT{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

!  ====
!  Dump
!  ====

   do_dump ::: private
   ! Dump object data as text

      stdout.dump("radius",.radius)
      stdout.dump("atom_density_cutoff",.atom_density_cutoff)
      stdout.dump("generation_method",.generation_method)
      stdout.dump("defragment",.defragment)
      stdout.dump("n_atoms",.n_atoms)
      stdout.dmpp("geometry",.geometry)
      .crystal.dmpp("crystal")
      .asymmetric_unit_atom.dmpp("asymmetric_unit_atom")
      stdout.dump("n_fragment_atoms",.n_fragment_atoms)
      stdout.dmpp("fragment_geometry",.fragment_geometry)
      stdout.dump("fragment_offset",.fragment_offset)
      stdout.dump("unit_cell_offset",.unit_cell_offset)
      stdout.dump("h_min",.h_min)
      stdout.dump("h_max",.h_max)
      stdout.dump("n_shift",.n_shift)
      stdout.dmpp("shift",.shift)
      stdout.dmpp("shift_for_atom",.shift_for_atom)
      stdout.dmpp("is_fragment_atom",.is_fragment_atom)
      stdout.dmpp("occupation_list",.occupation_list)
      stdout.dmpp("molecule_for_atom",.molecule_for_atom)
    ! stdout.dmpp("molecule",.molecule)
      stdout.dmpp("molecule_centroid",.molecule_centroid)
      stdout.dmpp("unique_molecule_for",.unique_molecule_for)
      stdout.dmpp("unique_sycode_for",.unique_symcode_for)
    ! stdout.dmpp("atom_connection",.atom_connection)
      stdout.dump("n_molecules",.n_molecules)
      stdout.dump("info_made",.info_made)

   end

   dump(object_name,ptr) ::: get_from(OBJECT, TYPE?=>CLUSTER)
   ! Dump object data as text
   end

   dmpp(object_name) ::: get_from(OBJECT, TYPE?=>CLUSTER)
   ! Dump pointer object data as text
   end

!  ==============
!  Output methods
!  ==============

   put
   ! Put the list of vertices for the object

   DIE_IF(NOT .info_made,"call make_info first")
   DIE_IF(tonto.disassociated,"no tonto variable")

      stdout.flush
      stdout.text("==============================")
      stdout.text("Cluster generation information")
      stdout.text("==============================")
      stdout.flush

      stdout.show("Cluster generation method       =",.generation_method)
      stdout.show("Complete connected fragments    =",.defragment)
      stdout.show("Radius of cluster               =",.radius)
      stdout.show("No. of molecules                =",.n_molecules)
      stdout.show("No. of atoms                    =",.n_atoms)
      stdout.show("No. of fragment atoms           =",.n_fragment_atoms)
      stdout.show("Fragment offset                 =",.fragment_offset)
      stdout.show("Minimum cell shift for search   =",.h_min)
      stdout.show("Maximum cell shift for search   =",.h_max)

      if (tonto.low_verbosity) then
      if (.fragment_geometry.associated) then
         if (.fragment_geometry.dim>100) return
      end
      end

      if (.fragment_geometry.associated)    .put_fragment_geometry
      if (.occupation_list.associated)      .put_occupation_list
      if (.atom_connection.associated)      .put_atom_connection_table
      if (.occupation_list.associated)      .put_atom_symmetry_table

   end

   put_fragment_geometry
   ! Put the initial fragment geometry information

   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.fragment_geometry.associated,"no fragment_geometry")

      ID :: VEC{STR}*
      ind :: VEC{INT}*
      table :: VEC{TABLE_COLUMN}*

      stdout.flush
      stdout.text("=======================================")
      stdout.text("Central fragment fractional coordinates")
      stdout.text("=======================================")

      stdout.flush
      stdout.show("No. of fragment atoms           =",.n_fragment_atoms)
      stdout.flush

      ! Unique ID tags
      ind.create_copy(.crystal_frag_atom_indices)
      ID => .crystal.fragment_atom(ind).unique_tags

      ! Table
      table.create(4)
      table(1).set_heading("ID");    table(1).set_values(ID)
      table(3).set_heading("Coord")
      table(2).set_subhead("- x -"); table(2).set_values(.fragment_geometry(1,:))
      table(3).set_subhead("- y -"); table(3).set_values(.fragment_geometry(2,:))
      table(4).set_subhead("- z -"); table(4).set_values(.fragment_geometry(3,:))
      table(3).set_sb3head("/frac")
      table.put

      ! Clean
      table.clear_columns
      table.destroy
      ID.destroy
      ind.destroy

   end

!   put_occupation_list
!   ! Put the .occupation_list table
!      self :: IN
!
!   ENSURE(.occupation_list.associated,"no occupation_list")
!   ENSURE(.crystal.associated,"no crystal")
!   ENSURE(.crystal.unit_cell_geometry.associated,"no crystal unit cell geometry")
!
!      fi :: VEC{INT}*
!      h1,h2,h3,hc,ui :: VEC{INT}*
!      r1,r2,r3 :: VEC{REAL}*
!      table :: VEC{TABLE_COLUMN}*
!      a,n :: INT
!
!      stdout.flush
!      stdout.text("=============")
!      stdout.text("Cluster atoms")
!      stdout.text("=============")
!
!      stdout.flush
!      stdout.show("Cluster generation method       =",.generation_method)
!      stdout.show("Complete connected fragments    =",.defragment)
!      stdout.show("Radius of cluster               =",.radius)
!      stdout.show("No. of molecules                =",.n_molecules)
!      stdout.show("No. of atoms                    =",.n_atoms)
!      stdout.show("No. of fragment atoms           =",.n_fragment_atoms)
!      stdout.show("Fragment offset                 =",.fragment_offset)
!      stdout.show("Minimum cell shift for search   =",.h_min)
!      stdout.show("Maximum cell shift for search   =",.h_max)
!
!
!      ! Data
!      a = 1
!      fi => a.sequence_up_to(.n_atoms)
!
!      n = .occupation_list.dim
!      ui.create(n)
!      h1.create(n); h2.create(n); h3.create(n)
!      r1.create(n); r2.create(n); r3.create(n)
!      hc.create(n)
!
!      ui = CLUSTER_UA_FROM_CODE(.occupation_list)
!      h1 = CLUSTER_H1_FROM_CODE(.occupation_list)
!      h2 = CLUSTER_H2_FROM_CODE(.occupation_list)
!      h3 = CLUSTER_H3_FROM_CODE(.occupation_list)
!      r1 = .crystal.unit_cell_geometry(1,ui) + h1
!      r2 = .crystal.unit_cell_geometry(2,ui) + h2
!      r3 = .crystal.unit_cell_geometry(3,ui) + h3
!      hc = 1000*      .crystal.asym_symop_for_unit_cell_atom(ui)
!      hc = 100* (h1+5+.crystal.asym_shift_for_unit_cell_atom(1,ui)) + hc
!      hc = 10*  (h2+5+.crystal.asym_shift_for_unit_cell_atom(2,ui)) + hc
!      hc =      (h3+5+.crystal.asym_shift_for_unit_cell_atom(3,ui)) + hc
!
!      ! Table
!      table.create(9)
!      table(1).set_heading("Cell");  table(1).set_values(ui)
!      table(1).set_subhead("atom")
!      table(2).set_heading("Group"); table(2).set_values(.molecule_for_atom)
!      table(2).set_subhead("(Mol)")
!      table(4).set_heading("Coord")
!      table(3).set_subhead("- x -"); table(3).set_values(r1)
!      table(4).set_subhead("- y -"); table(4).set_values(r2)
!      table(5).set_subhead("- z -"); table(5).set_values(r3)
!      table(4).set_sb3head("/frac")
!      table(7).set_heading("UC")
!      table(6).set_subhead("h1");    table(6).set_values(h1)
!      table(7).set_subhead("h2");    table(7).set_values(h2)
!      table(8).set_subhead("h3");    table(8).set_values(h3)
!      table(9).set_subhead("code");  table(9).set_values(hc)
!      table.put
!
!      ! Clean
!      table.clear_columns
!      table.destroy
!      hc.destroy
!      r3.destroy; r2.destroy; r1.destroy
!      h3.destroy; h2.destroy; h1.destroy
!      fi.destroy
!
!   end

   put_occupation_list
   ! Put the .occupation_list table
      self :: IN

   ENSURE(.occupation_list.associated,"no occupation_list")

      ua,   h1,h2,h3 :: VEC{INT}@
      aa,ay,a1,a2,a3 :: VEC{INT}@
      fa,fy,f1,f2,f3 :: VEC{INT}@
      r1,r2,r3 :: VEC{REAL}@
      ID :: VEC{STR}@
      table :: VEC{TABLE_COLUMN}*
      n :: INT

      stdout.flush
      stdout.text("===========================")
      stdout.text("Cluster atoms and molecules")
      stdout.text("===========================")

      stdout.flush
      stdout.text("This table shows the coordinates of the atoms in the cluster")
      stdout.text("and their relationship to the unit cell atoms, asymmetric")
      stdout.text("unit atoms, and the QM fragment atoms via symmetry opeerators")
      stdout.text("and translational shifts.")
      stdout.flush
      stdout.text(". The first atoms correspond to the fragment geometry which")
      stdout.text("  was used to generate the cluster.")
      if (.defragment) then
      stdout.flush
      stdout.text(". The molecules are ordered so that the atoms in each are")
      stdout.text("  generated in a consistent order by the stated symop.")
      end

      stdout.flush
      stdout.show("Cluster generation method     =",.generation_method)
      stdout.show("Complete connected fragments  =",.defragment)
      stdout.show("Radius of cluster             =",.radius)
      stdout.show("Fragment offset               =",.fragment_offset)
      stdout.show("Minimum cell shift for search =",.h_min)
      stdout.show("Maximum cell shift for search =",.h_max)
      stdout.flush
      stdout.show("No. of fragment atoms         =",.crystal.n_fragment_atoms)
      stdout.show("No. of cluster atoms          =",.n_atoms)
      stdout.show("No. of molecules              =",.n_molecules)
      stdout.show("No. of unique molecules       =",.n_unique_molecules)
      stdout.show("No. of unit cell atoms        =",.crystal.n_unit_cell_atoms)

      stdout.flush
      stdout.text("The table headings are as follows:")
      stdout.flush
      stdout.text("  #          = Cluster atom index")
      stdout.text("  Mol        = Molecule index")
      stdout.text("  (UA xyz)   = Cluster atom coord (fractional)")
      stdout.text("  UA         = Unit cell atom index which generates (xyz)")
      stdout.text("  FA         = Fragment  atom index which generates (xyz)")
      stdout.text("  AA         = Asym cell atom index which generates (xyz)")
      stdout.flush              
      stdout.text("where:")      
      stdout.flush              
      stdout.text("  (UA xyz)   = (FA Op) (UA xyz) + (f1 f2 f3) + (h1 h2 h3)")
      stdout.text("             =              (FA xyz)         + (h1 h2 h3)")
      stdout.flush
      stdout.text("             = (AA Op) (UA xyz) + (a1 a2 a3) + (h1 h2 h3)")
      stdout.text("             =              (UA xyz)         + (h1 h2 h3)")
      stdout.flush
      stdout.text("  (h1 h2 h3) = Unit cell atom shift = US")
      stdout.flush
      stdout.text("  (FA xyz)   = Fragment  atom coord")
      stdout.text("  (f1 f2 f3) = Fragment  atom shift = FS")
      stdout.flush
      stdout.text("  (AA xyz)   = Unit cell atom coord")
      stdout.text("  (a1 a2 a3) = Asym cell atom shift = US")
      stdout.flush
    ! stdout.text("  AA code    = Asym atom code to make (xyz) from AA")
    ! stdout.text("             = Op | h1+s1+5 | h2+s2+5 | h3+s3+5")
    ! stdout.text("  AO code    = AA | Op")
      stdout.flush



      ! Data
      n = .occupation_list.dim

      ua.create(n)
      ID.create(n)
      h1.create(n); h2.create(n); h3.create(n)
      r1.create(n); r2.create(n); r3.create(n)
      fa.create(n); fy.create(n)
      f1.create(n); f2.create(n); f3.create(n)
      aa.create(n); ay.create(n)
      a1.create(n); a2.create(n); a3.create(n)
    ! ac.create(n)
    ! ao.create(n)

      ua = CLUSTER_UA_FROM_CODE(.occupation_list)

      h1 = CLUSTER_H1_FROM_CODE(.occupation_list) + .fragment_offset(1)
      h2 = CLUSTER_H2_FROM_CODE(.occupation_list) + .fragment_offset(2)
      h3 = CLUSTER_H3_FROM_CODE(.occupation_list) + .fragment_offset(3)

      r1 = .crystal.unit_cell_geometry(1,ua) + h1
      r2 = .crystal.unit_cell_geometry(2,ua) + h2
      r3 = .crystal.unit_cell_geometry(3,ua) + h3

      fa = .crystal.frag_atom_for_unit_cell_atom(ua)
      fy = .crystal.frag_symop_for_unit_cell_atom(ua)
      f1 = .crystal.frag_shift_for_unit_cell_atom(1,ua)
      f2 = .crystal.frag_shift_for_unit_cell_atom(2,ua)
      f3 = .crystal.frag_shift_for_unit_cell_atom(3,ua)

      ID = .crystal.fragment_atom(fa).tag

      aa = .crystal.asym_atom_for_unit_cell_atom(ua)
      ay = .crystal.asym_symop_for_unit_cell_atom(ua)
      a1 = .crystal.asym_shift_for_unit_cell_atom(1,ua)
      a2 = .crystal.asym_shift_for_unit_cell_atom(2,ua)
      a3 = .crystal.asym_shift_for_unit_cell_atom(3,ua)

    ! ac = 1000* sy
    ! ac = 100* (h1+5+s1) + ac
    ! ac = 10*  (h2+5+s2) + ac
    ! ac =      (h3+5+s3) + ac

    ! ao = 100* aa
    ! ao = sy + ao


      ! Table
      table.create(19)

      table( 1).set_heading(" UA");   table( 1).set_values(ua)

      table( 2).set_heading("Mol");   table( 2).set_values(.molecule_for_atom)

      table( 3).set_heading("ID");    table( 3).set_values(ID)

      table( 5).set_heading("(UA xyz)")
      table( 4).set_subhead("- x -"); table( 4).set_values(r1)
      table( 5).set_subhead("- y -"); table( 5).set_values(r2)
      table( 6).set_subhead("- z -"); table( 6).set_values(r3)

      table( 8).set_heading("US")
      table( 7).set_subhead("h1");    table( 7).set_values(h1)
      table( 8).set_subhead("h2");    table( 8).set_values(h2)
      table( 9).set_subhead("h3");    table( 9).set_values(h3)


      table(10).set_heading("FA");    table(10).set_values(fa)
      table(11).set_heading("FA");    table(11).set_values(fy)
      table(11).set_subhead("Op")     
      table(13).set_heading("FS")     
      table(12).set_subhead("f1");    table(12).set_values(f1)
      table(13).set_subhead("f2");    table(13).set_values(f2)
      table(14).set_subhead("f3");    table(14).set_values(f3)
                                      
      table(15).set_heading("AA");    table(15).set_values(aa)
      table(16).set_heading("AA");    table(16).set_values(ay)
      table(16).set_subhead("Op")     
      table(16).set_heading("AS")     
      table(17).set_subhead("a1");    table(17).set_values(a1)
      table(18).set_subhead("a2");    table(18).set_values(a2)
      table(19).set_subhead("a3");    table(19).set_values(a3)
                                      
                                      
    ! table(19).set_heading(" AA ");  table(16).set_values(ac)
    ! table(19).set_subhead("code")   
    !                                 
    ! table(20).set_heading(" AO ");  table(17).set_values(ao)
    ! table(20).set_subhead("code")
             
      table.put

      ! Clean
      table.clear_columns
      table.destroy

    ! ao.destroy
    ! ac.destroy
      a3.destroy; a2.destroy; a1.destroy
      ay.destroy; aa.destroy
      f3.destroy; f2.destroy; f1.destroy
      fy.destroy; fa.destroy
      r3.destroy; r2.destroy; r1.destroy
      h3.destroy; h2.destroy; h1.destroy
      ID.destroy
      ua.destroy

   end

   put_atom_connection_table
   ! Put the .atom_connection table

   ENSURE(.atom_connection.associated,"no atom_connection")
   ENSURE(.molecule_for_atom.associated,"no molecule_for_atom")

      m,a,i :: INT
      first :: BIN

      stdout.save
      stdout.set_int_width(5)

      stdout.flush
      stdout.text("Atom connection table:")
      stdout.flush
      stdout.show("n_molecules = ",.n_molecules)

      stdout.flush
      stdout.dash(int_fields=8)
      stdout.put("Cluster",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("Joins",int_width=TRUE)
      stdout.flush

      stdout.put("Mol",int_width=TRUE)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Atom(s)",int_width=TRUE)
      stdout.flush

      stdout.dash(int_fields=8)

      do m = 1,.n_molecules

         ! Molecule label
         stdout.put(m)

         first = TRUE
         do a = 1,.n_atoms

            if (.molecule_for_atom(a)/=m) cycle

            if (NOT first) &
            stdout.tab(int_fields=1)
            stdout.put(a)
            first = FALSE

            if (.atom_connection(a).element.disassociated) then

               stdout.flush

            else

               do i = 1,.atom_connection(a).element.dim
                  stdout.put(.atom_connection(a)[i])
               end
               stdout.flush

            end
         end
      end

      stdout.dash(int_fields=8)

      stdout.unsave

   end

   put_atom_symmetry_table
   ! Put the atom symmetry table i.e. those atoms in the cluste related by
   ! symmetry.

   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.fragment_info_made,"no crystal fragment info")

      asym_atom_for_atom,unique :: VEC{INT}*
      a,u :: INT

      asym_atom_for_atom.create(.n_atoms)
      do a = 1,.n_atoms
           u = CLUSTER_UA_FROM_CODE(.occupation_list(a))
           asym_atom_for_atom(a) = .crystal.asym_atom_for_unit_cell_atom(u)
      end
      unique => asym_atom_for_atom.indices_of_unique_elements

      stdout.flush
      stdout.text("Asymmetric (unique) atoms:")
      stdout.flush
      stdout.show("n_asym_atoms =",unique.dim)
      stdout.put(unique)
      stdout.flush
      stdout.text("Asymmetric (unique) atoms for each atom in the cluster, and associated symop:")
      stdout.flush
      stdout.dash(int_fields=3)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Unique",int_width=TRUE)
      stdout.put("Symop",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=3)
      do a = 1,.n_atoms
         u = CLUSTER_UA_FROM_CODE(.occupation_list(a))
         stdout.put(a)
         stdout.put(asym_atom_for_atom(a))
         stdout.put(.crystal.asym_symop_for_unit_cell_atom(u))
         stdout.flush
      end
      stdout.dash(int_fields=3)

      ! Clean
      unique.destroy
      asym_atom_for_atom.destroy

   end

   put_tonto_input
   ! Outputs the tonto input file for the cluster, given additionally the list
   ! of atoms which was used to generate the fragment_geometry in crystal.
   ! (See routine make_fragment_data).
   ENSURE(.info_made,"call make_info first")
   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.asymmetric_unit_atom.associated,"no atom data")
   ENSURE(.crystal.associated,"no crystal data")

      seitz :: MAT3{REAL}*
      therm :: MAT{REAL}(3,3)
      a,u,p,s :: INT

      stdout.text("   atoms= {")
      stdout.flush
      stdout.text("      keys= { label= ")
      stdout.text('              { axis_system= crystal } pos=')
      stdout.text('              { units= angstrom^2 } ADP_tensor= }')
      stdout.flush
      stdout.text("      data= {")
      seitz => .crystal.transposed_xyz_seitz_matrices ! transposed !
      do a = 1,.n_atoms
         u = CLUSTER_UA_FROM_CODE(.occupation_list(a))
         p = .crystal.asym_atom_for_unit_cell_atom(u)
         s = .crystal.asym_symop_for_unit_cell_atom(u)
         stdout.put(.asymmetric_unit_atom(p).label.trim,int_width=TRUE)
         stdout.put(.geometry(1,a))
         stdout.put(.geometry(2,a))
         stdout.put(.geometry(3,a))
!         stdout.put(.asymmetric_unit_atom(p).basis.label.trim)
         therm = .asymmetric_unit_atom(p).ADP_tensor ! in cartesians?
         therm.change_basis_using(seitz(:,:,s))
         therm.convert_to("angstrom^2")
         stdout.put(therm(1,1))
         stdout.put(therm(2,2))
         stdout.put(therm(3,3))
         stdout.put(therm(1,2))
         stdout.put(therm(1,3))
         stdout.put(therm(2,3))
         stdout.flush
      end
      seitz.destroy
      stdout.text("      }")
      stdout.text("   }")
      stdout.flush

   end

   put_CX(angstrom)
   ! Outputs some information for the Crystal Explorer program: the list of atoms in
   ! the cluster, their positions, and whether they are part of the generating
   ! fragment or not.
      self :: IN
      angstrom :: BIN, optional, IN

   ENSURE(.geometry.associated,"no cluster geometry")
   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.is_fragment_atom.associated,"no is_fragment_atom")
   ENSURE(.asymmetric_unit_atom.associated,"no atom data")
   ENSURE(.crystal.associated,"no crystal data")
   ENSURE(.crystal.fragment_info_made,"no crystal fragment_info")

      u,a,s,n,i,j :: INT
      geometry :: MAT{REAL}*
      ulist :: VEC{INT}*
      therm :: MAT{REAL}(3,3)
      angst :: BIN
      seitz :: MAT3{REAL}*
    ! conn  :: VEC_{VEC_{INT}}*

      angst = FALSE
      if (present(angstrom)) angst = angstrom

      ! Transposed seutz matrices
      seitz => .crystal.transposed_xyz_seitz_matrices

      ! Get uniot cell atom indices
      ulist.create(.n_atoms)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list)

      ! Get unit cell geometry - keep in fractional coordinates
      geometry.create_copy(.crystal.unit_cell_geometry)

      ! Print symops
      stdout.flush
      stdout.show("begin seitz_matrices ",.crystal.spacegroup.n_seitz,dots=FALSE)
      do n = 1,.crystal.spacegroup.n_seitz
         do i = 1,.crystal.spacegroup.seitz.dim1
            do j = 1,.crystal.spacegroup.seitz.dim2
               stdout.put(.crystal.spacegroup.seitz(i,j,n))
            end
         end
         stdout.flush
      end
      stdout.text("end seitz_matrices")

      ! Print inverse symop indices
      stdout.flush
      stdout.show("begin inverse_symops ",.crystal.spacegroup.n_seitz,dots=FALSE)
      do n = 1,.crystal.spacegroup.n_seitz
         stdout.put(.crystal.spacegroup.inverse_of_symops(n))
         stdout.flush
      end
      stdout.text("end inverse_symops")

      ! Print symop produce indices
      stdout.flush
      stdout.show("begin symop_products ",.crystal.spacegroup.n_seitz,dots=FALSE)
      stdout.put(.crystal.spacegroup.product_of_symops(:,:))
      stdout.text("end symop_products")

      ! Print unit_cell
      stdout.flush
      stdout.show("begin unit_cell ",.crystal.n_unit_cell_atoms,dots=FALSE)
      do u = 1,.crystal.n_unit_cell_atoms
         a = .crystal.asym_atom_for_unit_cell_atom(u)
         stdout.put(.asymmetric_unit_atom(a).label)
         stdout.put(.asymmetric_unit_atom(a).chemical_symbol)
         stdout.put(geometry(1,u))
         stdout.put(geometry(2,u))
         stdout.put(geometry(3,u))
         stdout.put(.asymmetric_unit_atom(a).site_disorder_group)
         stdout.put(.asymmetric_unit_atom(a).site_occupancy)
         stdout.flush
      end
      stdout.text("end unit_cell")

      ! Print symops for unit cell atoms
      ! This is printed after unit_cell because CrystalExplorer likes
      ! to check the number of symops matches the number of unit cell
      ! atoms given
      stdout.flush
      stdout.show("begin symops_for_unit_cell_atoms ",.crystal.n_unit_cell_atoms,dots=FALSE)
      do n = 1,.crystal.n_unit_cell_atoms
         stdout.put(.crystal.asym_symop_for_unit_cell_atom(n))
         stdout.flush
      end
      stdout.text("end symops_for_unit_cell_atoms")

      ! Print unit_cell
      stdout.flush
      stdout.show("begin asymmetric_unit_atom_indices ",.crystal.n_asymmetric_unit_atoms,dots=FALSE)
      do a = 1,.crystal.unique_unit_cell_atom.dim
         stdout.put(.crystal.unique_unit_cell_atom(a))
         stdout.put(-.crystal.unique_uc_atom_offset(a)[1])
         stdout.put(-.crystal.unique_uc_atom_offset(a)[2])
         stdout.put(-.crystal.unique_uc_atom_offset(a)[3])
         stdout.flush
      end
      stdout.text("end asymmetric_unit_atom_indices")

      ! Print ADP's
      if (.asymmetric_unit_atom.has_nonzero_ADP_tensors) then
         stdout.flush
         stdout.text("begin adp ")
         do u = 1,.crystal.n_unit_cell_atoms
            a = .crystal.asym_atom_for_unit_cell_atom(u)
            s = .crystal.asym_symop_for_unit_cell_atom(u)
            stdout.put(.asymmetric_unit_atom(a).chemical_symbol)
            therm = .asymmetric_unit_atom(a).ADP_tensor ! This must be in cartesian axes
            therm.change_basis_using(seitz(:,:,s))          ! Use R^T to change U tensor basis
            if (angst) therm = ANGSTROM_PER_BOHR*ANGSTROM_PER_BOHR*therm
            stdout.put(therm(1,1))
            stdout.put(therm(2,2))
            stdout.put(therm(3,3))
            stdout.put(therm(1,2))
            stdout.put(therm(1,3))
            stdout.put(therm(2,3))
            stdout.flush
         end
         stdout.text("end adp")
      end

      ! Cleanup
      geometry.destroy
      ulist.destroy
      seitz.destroy

      ! Don't require these connections tables since CrystalExplorer calculates them itself
      ! Print unit_cell connection table
      !stdout.flush
      !stdout.show("begin unit_cell_connection_table ",.crystal.n_unit_cell_atoms)
      !do u = 1,.crystal.n_unit_cell_atoms
      !   conn => .crystal.unit_cell_connection(u)
      !   n = conn.element.dim
      !   stdout.put(n)
      !   stdout.flush
      !   do a = 1,n
      !      stdout.put(conn[a][4])
      !      stdout.put(-conn[a][1])
      !      stdout.put(-conn[a][2])
      !      stdout.put(-conn[a][3])
      !      stdout.flush
      !   end
      !end
      !stdout.text("end unit_cell_connection_table")

      ! Print unit_cell connection table
      !stdout.flush
      !stdout.show("begin uc_vdw_connection_table ",.crystal.n_unit_cell_atoms)
      !do u = 1,.crystal.n_unit_cell_atoms
      !   conn => .crystal.uc_vdw_connection(u)
      !   n = conn.element.dim
      !   stdout.put(n)
      !   stdout.flush
      !   do a = 1,n
      !      stdout.put(conn[a][4])
      !      stdout.put(-conn[a][1])
      !      stdout.put(-conn[a][2])
      !      stdout.put(-conn[a][3])
      !      stdout.flush
      !   end
      !end
      !stdout.text("end uc_vdw_connection_table")

   end

   make_CX_atoms(inside, outside)
   ! Outputs the cluster information, atoms inside and outside the
   ! surface with their unit cell index and offset, for the Crystal
   ! Explorer program. Should be called only when there is a saved
   ! surface.
      inside, outside :: MAT{INT}*, OUT
   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.n_atoms>=.n_fragment_atoms,"no atoms outside the surface!")
   ENSURE(.asymmetric_unit_atom.associated,"no atom data")
      a,i,code,u,h1,h2,h3 :: INT

      ! Print out atoms and shifts for atoms inside surface
      inside.create(.n_fragment_atoms, 4)
      do a = 1,.n_fragment_atoms

         ! Occupation code
         code = .occupation_list(a)

         ! Extract cell and unit cell ato "u"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Add overall offset
         h1 = h1 + .fragment_offset(1)
         h2 = h2 + .fragment_offset(2)
         h3 = h3 + .fragment_offset(3)

         inside(a, 1) = u
         inside(a, 2) = h1
         inside(a, 3) = h2
         inside(a, 4) = h3
      end

      ! Print out atoms and shifts for atoms outside surface
      if ((.n_atoms - .n_fragment_atoms) == 0) return

      outside.create(.n_atoms - .n_fragment_atoms, 4)
      do a = .n_fragment_atoms+1,.n_atoms
         i = a - .n_fragment_atoms
         ! Occupation code
         code = .occupation_list(a)

         ! Extract cell and unit cell ato "u"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Add overall offset
         h1 = h1 + .fragment_offset(1)
         h2 = h2 + .fragment_offset(2)
         h3 = h3 + .fragment_offset(3)

         outside(i, 1) = u
         outside(i, 2) = h1
         outside(i, 3) = h2
         outside(i, 4) = h3
      end
   end


   put_CX_atoms
   ! Outputs the cluster information, atoms inside and outside the
   ! surface with their unit cell index and offset, for the Crystal
   ! Explorer program. Should be called only when there is a saved
   ! surface.

   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.n_atoms>=.n_fragment_atoms,"no atoms outside the surface!")
   ENSURE(.asymmetric_unit_atom.associated,"no atom data")

      a,code,u,h1,h2,h3 :: INT

      ! Print out atoms and shifts for atoms inside surface
      stdout.flush
      stdout.show("begin atoms_inside_surface",.n_fragment_atoms,dots=FALSE)
      do a = 1,.n_fragment_atoms

         ! Occupation code
         code = .occupation_list(a)

         ! Extract cell and unit cell ato "u"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Add overall offset
         h1 = h1 + .fragment_offset(1)
         h2 = h2 + .fragment_offset(2)
         h3 = h3 + .fragment_offset(3)

         stdout.put(u)
         stdout.put(h1)
         stdout.put(h2)
         stdout.put(h3)
         stdout.flush

      end
      stdout.text("end atoms_inside_surface")

      ! Print out atoms and shifts for atoms outside surface
      stdout.flush
      stdout.show("begin atoms_outside_surface",.n_atoms-.n_fragment_atoms,dots=FALSE)
      do a = .n_fragment_atoms+1,.n_atoms

         ! Occupation code
         code = .occupation_list(a)

         ! Extract cell and unit cell ato "u"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Add overall offset
         h1 = h1 + .fragment_offset(1)
         h2 = h2 + .fragment_offset(2)
         h3 = h3 + .fragment_offset(3)

         stdout.put(u)
         stdout.put(h1)
         stdout.put(h2)
         stdout.put(h3)
         stdout.flush

      end
      stdout.text("end atoms_outside_surface")

   end


end
