!===============================================================================
!
! MOLECULE.READ
!
! An object representation of a molecule.
!
! These are base methods needed by all other submodules.
!
! The submodule hierarchy is shown below.
! . The numbers (if any) indicate (roughly) the number of used
!   procedures from the module at the head of the column. This is
!   useful if you want to decouple the modules even further.
! . The type of routines in each submodule is more-or-less
!   straightforward to understand from the three- or four-letter
!   pneumonic e.g. REL is for relativistic routines.
!
! Updated 2014-12-01
!
! .BASE
!     3 .REL
!    16---24 .GRID
!    14---12---- 1 .XTAL
!     2--- |---- |---- 4 .CE =
!     7--- |---- 1---- |-- | .INTS
!    14--- |---- 5---- |-- |---- 2 .FOCK
!    30--- 5---- 4---- 5-- |----10---- 5 .SCF
!     2--- |---- |---- |-- |---- 1---- 5--- 1 .GEM =     =     =
!    11--- |---- |---- 1-- |----15---- 5---13--- | .PROP =     =
!     4--- |---- 6---- |-- |---- 3---- |--- 2--- |---- | .PLOT =
!     4--- |---- 5---- |-- |---- 4---- 2--- 1--- |---- |---- | .CP
!    12--- |---- 7---- |-- |---- |---- |--- 1--- |---- |---- 1-- | .TAD
!    15--- |---- 5---- 1-- |---- 5---- 6--- 5--- |---- |---- |-- |--- 2 .MISC
!    76--- 3---- 3----13-- 7---- 1---- |---13--- 3----19---- 6-- 9---11----24 .MAIN
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
! Copyright (C) Dylan Jayatilaka 2012-
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!===============================================================================

module MOLECULE.READ

   implicit none

contains

!  ================
!  Molden interface
!  ================

! Combine the next two into a template?

   read_molden_MOs(file_name, print_output) ::: leaky
   ! Read a Molden MOs file
      self :: INOUT
      file_name :: STR, optional, IN
      print_output :: BIN, optional, IN

      molden_file, save :: TEXTFILE@
      archive :: ARCHIVE
      pos :: VEC{REAL}(3)
      orb :: VEC{REAL}@
      fbf,lbf,ang :: VEC{INT}@
      fac,n_e,n_a,n_b,val,energy,occ :: REAL
      name,units,item,label,spin :: STR
      op,cl :: STR(len=1)
      output,found,is_unrestricted :: BIN
      line, a,i,f,Z :: INT

      ! Get file name
      if (present(file_name)) then;              name = file_name
      else if (NOT stdin.buffer_exhausted) then; stdin.read(name)
      else;                                      name = .name
      end

      if (present(print_output)) then; output = print_output
      else;                            output = FALSE
      endif

      ! Constants
      op = achar(91)
      cl = achar(93)

      ! Open Molden file
      molden_file.create(name)
      molden_file.open_for("read")

      ! Find out if this file is using a spherical basis
      line = molden_file.line_number
      molden_file.look_for(op//"5D"//cl,found=found)
      if(found) .use_spherical_basis = TRUE
      molden_file.move_to_line(line)

      ! Find [ATOMS] block
      ! or [Atoms]
      molden_file.look_for(op//"Atoms"//cl,found=found)
      if(NOT found) molden_file.look_for(op//"ATOMS"//cl,found=found)
      DIE_IF(NOT found, "No ATOMS line")
      DIE_IF(molden_file.n_line_items/=2, "Expecting two items on ATOMS line")

      ! Read units
      molden_file.skip_next_item
      molden_file.read(units)
      fac = ONE
      if (units=="Angs") fac = BOHR_PER_ANGSTROM

      ! Store start of atoms list
      molden_file.read_line
      line = molden_file.line_number

      ! Get no. of atoms ...
      .n_atom = 0
      do
         molden_file.read(item)
         if (item(1:1)==op) exit
         DIE_IF(molden_file.end_of_file,"file ended unexpectedly")
         .n_atom = .n_atom + 1
         molden_file.read_line
      end

      ! Create atom list (leaky)
      if (.atom.allocated)  .atom.destroy
      .atom.create(.n_atom)
      .atom_info_made = FALSE

      ! Create basis -- Different one for every atom (leaky)
      if (.basis.allocated) .basis.destroy
      .basis.create(.n_atom)
      if(.use_spherical_basis) .basis.set_spherical(TRUE)

      ! Move back to atoms line
      molden_file.move_to_line(line)

      ! For each atom a: read label, Z, coordinates
      do a = 1,.n_atom

         ! Read label
         molden_file.read(label)

         ! Read Z
         molden_file.skip_next_item
         molden_file.read(Z)

         ! Set
         .atom(a).set_atomic_number(Z)
         .atom(a).set_atom_data_from_label(label)

         ! Read position, change units
         molden_file.read(pos)
         pos = fac*pos
         .atom(a).set_position(pos)

         ! Set basis label
         .atom(a).set_basis_label(trim(.atom(a).generic_chemical_symbol)//":molden")

      end

      ! Read basis set
      molden_file.look_for(op//"GTO"//cl,found=found)
      DIE_IF(NOT found, "No GTO line")
      DIE_IF(molden_file.n_line_items/=1, "Expecting only one item on GTO line")
      molden_file.read_line

      ! Read basis
      save  = stdin
      stdin = molden_file
      do a = 1,.n_atom
         .basis(a).read_molden
         .basis(a).set_label(.atom(a).basis_label)
      end
      stdin = save

      ! Remove repetitions
      .basis.remove_repetitions

    ! if (output) then
    !    .:put_bases
    ! end 

      ! Find [MO] tag
      molden_file.look_for(op//"MO"//cl,found=found)
      DIE_IF(NOT found, "No MO line")
      DIE_IF(molden_file.n_line_items/=1, "Expecting only one item on MO line")
      line = molden_file.line_number + 1

      ! Any Beta tag?
      molden_file.look_for("Beta",found=is_unrestricted)

      ! Move back to [MO]'s
      ! Get no. of electrons
      molden_file.move_to_line(line)
      n_e = ZERO
      do
         molden_file.look_for("Occup=",found=found)
         if (NOT found) exit
         molden_file.move_to_line_item(2)
         molden_file.read(val)
         molden_file.read_line
         n_e = n_e + val
      end

      ! Now set charge
      .n_e    = nint(n_e)
      .charge = .atom.no_of_electrons - .n_e

      if (is_unrestricted) then

         ! Now find no. of alpha electrons (assuming unrestricted)
         molden_file.move_to_line(line)
         n_a = ZERO
         do
            molden_file.look_for("Alpha",found=found)
            if (NOT found) exit
            molden_file.look_for("Occup=",found=found)
            if (NOT found) exit
            molden_file.move_to_line_item(2)
            molden_file.read(val)
            molden_file.read_line
            n_a = n_a + val
         end
        
         ! Set no. of beta electrons
         n_b = n_e - n_a
        
         ! Set multiplicity
         .SET:set_n_a_n_b_and_multiplicity(nint(n_a),nint(n_b))

      else

         ! Restricted
         .spin_multiplicity = .INQ:default_spin_multiplicity

      end

      ! Finalize atom info/basis sets
      .BASE:update_atom_basis_group_info

    ! if (output) then
    !    .atom.put
    ! end

      ! Create scfdata (leaky)
      .scfdata.destroy
      .scfdata.create
      .scfdata.set_output(output)

      ! Create MO arrays (leaky)
      .MO_energies.destroy
      .MOs.destroy

      if (is_unrestricted) then

         .scfdata.set_SCF_kind("uhf")
         .MO_energies.create(.n_bf,"u ")
         .MO_energies.a = ZERO
         .MO_energies.b = ZERO
         .MOs.create(.n_bf,"u ")
         .MOs.a = ZERO
         .MOs.b = ZERO

      else

         .scfdata.set_SCF_kind("rhf")
         .MO_energies.create(.n_bf,"r ")
         .MO_energies.r = ZERO
         .MOs.create(.n_bf,"r ")
         .MOs.r = ZERO

      end

      ! Set occupation numbers (leaky)
      spin = .scfdata.spinorbital_genre(.scfdata.SCF_kind)
      .NO_occ_nos.destroy
      .NO_occ_nos.create(.n_bf,spin)
      .NO_occ_nos.set_to_zero
      .SET:set_SCF_occupations_for_NOs(spin)

      ! Move back to [MO]'s
      molden_file.move_to_line(line)
      orb.create(.n_bf)

      ! Read in orbitals and energies.
      i = 0
      do

         molden_file.look_for("Ene=",found=found)

         if (NOT found) exit

         ! Read energy
         molden_file.skip_next_item
         molden_file.read(energy)

         ! Read spin
         molden_file.skip_next_item
         molden_file.read(spin)

         ! Read occupation
         molden_file.skip_next_item
         molden_file.read(occ)

         ! Read orbital
         do f = 1,.n_bf
            molden_file.skip_next_item
            molden_file.read(orb(f))
         end

         ! Increment orbital
         i = i + 1

         ! Assign MO's
         if (is_unrestricted) then

            DIE_IF(i>2*.n_bf,"too many orbitals specified")
            select case (spin)
            case ("Alpha")
               .MO_energies.a(i) = energy
               .MOs.a(:,i) = orb
            case ("Beta")
               .MO_energies.b(i-.n_bf) = energy
               .MOs.b(:,i-.n_bf) = orb
            case default
               DIE("unknown spin: "//trim(spin))
            end

         else

            DIE_IF(i>.n_bf,"too many orbitals specified")
            select case (spin)
            case ("Alpha")
               .MO_energies.r(i) = energy
               .MOs.r(:,i) = orb
            case default
               DIE("unexpected spin: "//trim(spin))
            end

         end

      end

      ! Clean
      orb.destroy

      ! Swap orbital order
    ! if (output) then
    !    stdout.text("Reordering basis functions into tonto order")
    ! end

      fbf = .first_basis_fn_for_shell
      lbf =  .last_basis_fn_for_shell
      ang = .angular_moment_for_shell

      if (is_unrestricted) then
         GAUSSIAN_DATA:swap_from_Molden_C_order(.MOs.a,"1",fbf,lbf,ang)
         GAUSSIAN_DATA:swap_from_Molden_C_order(.MOs.b,"1",fbf,lbf,ang)
      else
         GAUSSIAN_DATA:swap_from_Molden_C_order(.MOs.r,"1",fbf,lbf,ang)
      end


      ! Make density matrix (leaky)
    ! .:make_SCF_density_mx

      ! Echo what was read
    ! if (output) then
    !    stdout.text("Occupation")
    !    stdout.put(.NO_occ_nos)
    !    ! Print out data
    !    stdout.flush
    !    stdout.text("===========")
    !    stdout.text("Molden data")
    !    stdout.text("===========")
    !    stdout.flush
    !    stdout.text("Below are the molden:")
    !    stdout.text(". Atom coordinates and bases")
    !    stdout.text(". Molecular orbitals and their occupancies")
    !    stdout.flush
    !    if (is_unrestricted) then; stdout.text("The data is for *unrestricted* orbitals")
    !    else;                      stdout.text("The data is for *restricted* orbitals")
    !    end
    !    stdout.flush
    !    stdout.text("Molden atom coordinates and bases:")
    !    .:put_atoms
    !    stdout.flush
    !    stdout.text("Occupation numbers:")
    !    stdout.flush
    !    stdout.put(.NO_occ_nos)
    !    stdout.flush
    !    stdout.text("Orbital energies:")
    !    stdout.flush
    !    stdout.put(.MO_energies)
    !    stdout.flush
    !    stdout.text("MOs:")
    !    stdout.flush
    !    stdout.put(.MOs)
    !    stdout.flush
    !    stdout.text("Density matrix:")
    !    stdout.flush
    !    stdout.put(.density_mx)
    !    stdout.flush
    ! endif

      ! Save data in archive files
    !  archive.set(.name,"density_mx")
    !  archive.write(.density_mx)

      archive.set(.name,"MOs")
      archive.write(.MOs)

      archive.set(.name,"MO_energies")
      archive.write(.MO_energies)

      ! Set crystal data
      if (.crystal.allocated) then
         .SET:resolve_axis_system
         .crystal.update_fragment_info(.atom)
      end

      ! Clean
      molden_file.destroy

   end

   read_molden_NOs(file_name) ::: leaky
   ! Read a Molden natural orbitals file.
   ! Here the occupation numbers are not integers.
      self :: INOUT
      file_name :: STR, optional, IN

   ENSURE(NOT .use_spherical_basis,"not implemented")

      molden_file, save :: TEXTFILE@
      archive :: ARCHIVE
      pos :: VEC{REAL}(3)
      orb :: VEC{REAL}@
      fbf,lbf,ang :: VEC{INT}@
      fac,n_e,val,energy,occ :: REAL
      name,units,item,label,spin :: STR
      op,cl :: STR(len=1)
      found,is_unrestricted :: BIN
      line, a,i,f,Z :: INT

      ! Get file name
      if (present(file_name)) then;              name = file_name
      else if (NOT stdin.buffer_exhausted) then; stdin.read(name)
      else;                                      name = .name
      end

      ! Constants
      op = achar(91)
      cl = achar(93)

      ! Open Molden file
      molden_file.create(name)
      molden_file.open_for("read")

      ! Find [ATOMS] block
      molden_file.look_for(op//"ATOMS"//cl,found=found)
      DIE_IF(NOT found, "No ATOMS line")
      DIE_IF(molden_file.n_line_items/=2, "Expecting two items on ATOMS line")

      ! Read units
      molden_file.read(units)
      fac = ONE
      if (units=="Angs") fac = BOHR_PER_ANGSTROM

      ! Store start of atoms list
      molden_file.read_line
      line = molden_file.line_number

      ! Get no. of atoms ...
      .n_atom = 0
      do
         molden_file.read(item)
         if (item==op//"Molden") exit
         DIE_IF(molden_file.end_of_file,"file ended unexpectedly")
         .n_atom = .n_atom + 1
         molden_file.read_line
      end

      ! Create atom list (leaky)
      if (.atom.allocated)  .atom.destroy
      .atom.create(.n_atom)
      .atom_info_made = FALSE

      ! Create basis -- Different one for every atom (leaky)
      if (.basis.allocated) .basis.destroy
      .basis.create(.n_atom)

      ! Move back to atoms line
      molden_file.move_to_line(line)

      ! For each atom a: read label, Z, coordinates
      do a = 1,.n_atom

         ! Read label
         molden_file.read(label)

         ! Read Z
         molden_file.skip_next_item
         molden_file.read(Z)

         ! Set
         .atom(a).set_atomic_number(Z)
         .atom(a).set_atom_data_from_label(label)

         ! Read position, change units
         molden_file.read(pos)
         pos = fac*pos
         .atom(a).set_position(pos)

         ! Set basis label
         .atom(a).set_basis_label("molden-"//trim(.atom(a).generic_chemical_symbol))

      end

      ! Read basis set
      molden_file.look_for(op//"GTO"//cl,found=found)
      DIE_IF(NOT found, "No GTO line")
      DIE_IF(molden_file.n_line_items/=1, "Expecting only one item on GTO line")
      molden_file.read_line

      ! Read basis
      save  = stdin
      stdin = molden_file
      do a = 1,.n_atom
         .basis(a).read_molden
         .basis(a).put
         .basis(a).set_label(.atom(a).basis_label)
      end
      stdin = save

      ! Find [MO] tag
      molden_file.look_for(op//"MO"//cl,found=found)
      DIE_IF(NOT found, "No MO line")
      DIE_IF(molden_file.n_line_items/=1, "Expecting only one item on MO line")
      line = molden_file.line_number + 1

      ! Any Beta tag?
      molden_file.look_for("Beta",found=is_unrestricted)

      ! Move back to [MO]'s
      molden_file.move_to_line(line)

      ! Get no. of electrons
      n_e = ZERO
      do
         molden_file.look_for("Occup=",found=found)
         if (NOT found) exit
         molden_file.move_to_line_item(2)
         molden_file.read(val)
         molden_file.read_line
         n_e = n_e + val
      end

      ! Now set charge
      .charge = .atom.no_of_electrons - nint(n_e)

      ! Set multiplicity
      .spin_multiplicity = .INQ:default_spin_multiplicity

      ! Finalize atom info/basis sets
      .BASE:update_atom_basis_group_info

      ! Create MO arrays (leaky)
      .density_mx.destroy
      .NO_occ_nos.destroy
      .NOs.destroy

      if (is_unrestricted) then

         .NO_occ_nos.create(.n_bf,"u ")
         .NO_occ_nos.a = ZERO
         .NO_occ_nos.b = ZERO

         .density_mx.create(.n_bf,"u ")
         .NOs.create(.n_bf,"u ")
         .NOs.a = ZERO
         .NOs.b = ZERO

      else

         .NO_occ_nos.create(.n_bf,"r ")
         .NO_occ_nos.r = ZERO

         .density_mx.create(.n_bf,"u ")
         .NOs.create(.n_bf,"r ")
         .NOs.r = ZERO

      end

      ! Move back to [MO]'s
      molden_file.move_to_line(line)
      orb.create(.n_bf)

      ! Read in orbitals and energies.
      i = 0
      do

         molden_file.look_for("Ene=",found=found)

         if (NOT found) exit

         ! Read energy
         molden_file.skip_next_item
         molden_file.read(energy)

         ! Read spin
         molden_file.skip_next_item
         molden_file.read(spin)

         ! Read occupation
         molden_file.skip_next_item
         molden_file.read(occ)

         ! Read orbital
         do f = 1,.n_bf
            molden_file.skip_next_item
            molden_file.read(orb(f))
         end

         ! Increment orbital
         if (spin=="Alpha") i = i + 1
         DIE_IF(i>.n_bf,"too many orbitals specified")

         ! Assign MO's
         if (is_unrestricted) then

            select case (spin)

            case ("Alpha")
               .NO_occ_nos.a(i) = occ
               .NOs.a(:,i) = orb

            case ("Beta")
               .NO_occ_nos.b(i) = occ
               .NOs.b(:,i) = orb

            case default
               DIE("unknown spin: "//trim(spin))

            end

         else

            select case (spin)

            case ("Alpha")
               .NO_occ_nos.r(i) = occ
               .NOs.r(:,i) = orb

            case default
               DIE("unexpected spin: "//trim(spin))

            end

         end

      end

      ! Clean
      orb.destroy

      ! Swap orbital order
      fbf = .first_basis_fn_for_shell
      lbf =  .last_basis_fn_for_shell
      ang = .angular_moment_for_shell

      if (is_unrestricted) then
         GAUSSIAN_DATA:swap_from_Molden_C_order(.NOs.a,"1",fbf,lbf,ang)
         GAUSSIAN_DATA:swap_from_Molden_C_order(.NOs.b,"1",fbf,lbf,ang)
      else
         GAUSSIAN_DATA:swap_from_Molden_C_order(.NOs.r,"1",fbf,lbf,ang)
      end


      ! Make density matrix
    ! if (is_unrestricted) then
    !    .:make_density_mx_from(.NOs,.NO_occ_nos,"u ")
    ! else
    !    .:make_density_mx_from(.NOs,.NO_occ_nos,"r ")
    ! end

      ! Print out data
    ! stdout.flush
    ! stdout.text("===========")
    ! stdout.text("Molden data")
    ! stdout.text("===========")
    ! stdout.flush
    ! stdout.text("Below are the data read from the molden file:")
    ! stdout.text(". Atom coordinates and bases")
    ! stdout.text(". Natural orbitals and their occupancies")
    ! stdout.flush
    ! if (is_unrestricted) then; stdout.text("The data is for *restricted* orbitals")
    ! else;                      stdout.text("The data is for *unrestricted* orbitals")
    ! end

    ! stdout.flush
    ! stdout.text("Molden atom coordinates and bases:")
    ! .:put_atoms

    ! stdout.flush
    ! stdout.text("Occupation numbers:")
    ! stdout.flush
    ! stdout.put(.NO_occ_nos)

    ! stdout.flush
    ! stdout.text("Natural orbitals:")
    ! stdout.flush
    ! stdout.put(.NOs)

    ! ! Save data in archive files
    ! archive.set(.name,"density_mx")
    ! archive.write(.density_mx)

      archive.set(.name,"NOs")
      archive.write(.NOs)

      archive.set(.name,"NO_occ_nos")
      archive.write(.NO_occ_nos)

      ! Set crystal data
      if (.crystal.allocated) then
         .SET:resolve_axis_system
         .crystal.update_fragment_info(.atom)
      end

      ! Clean
      molden_file.destroy

   end

!   swap_molden_orbital_order(X,swap) ::: private, PURE
!   ! Swap the order of orbitals on matrix "X" after reading a
!   ! molden input file, for "swap" equal to "row" or "1", or
!   ! "coloumn" or "2".  This is nearly the same as gaussian.
!   !
!   ! The molden orderring is as follows:
!   !  5D: D 0, D+1, D-1, D+2, D-2
!   !  6D: xx, yy, zz, xy, xz, yz
!   !  7F: F 0, F+1, F-1, F+2, F-2, F+3, F-3
!   ! 10F: xxx, yyy, zzz, xyy, xxy, xxz, xzz, yzz, yyz, xyz
!   !  9G: G 0, G+1, G-1, G+2, G-2, G+3, G-3, G+4, G-4
!   ! 15G: xxxx yyyy zzzz xxxy xxxz yyyx yyyz zzzx zzzy,
!   !      xxyy xxzz yyzz xxyz yyxz zzxy
!      self :: IN
!      X :: MAT{REAL}, INOUT
!      swap :: STR, IN
!
!      s,f,l,ls,fg,lg,i,j :: INT
!      fac :: VEC{REAL}@
!      ff  :: VEC{INT}(10)
!      sph_reorder :: VEC{INT}@
!
!      ff = [1, 2, 3, 5, 6, 4, 9, 7, 8, 10]
!
!      select case (swap)
!
!      case("row","1")
!         do s = 1,.n_shell
!            f  = .first_basis_fn_for_shell(s)
!            l  = .last_basis_fn_for_shell(s)
!            ls = .angular_moment_for_shell(s)
!            if(.atom(.atom_for_shell(s)).basis.is_spherical) then
!               ! do spherical test
!               sph_reorder = GAUSSIAN_DATA:tonto_to_gaussian_spherical_indices(ls)
!               if (ls>=1) then ! swap f functions
!                  X(f:l,:) = X(f-1+sph_reorder,:)
!               end
!               if (ls>1) then  ! normalisation factors
!                  lg  = GAUSSIAN_DATA:n_comp_up_to(ls-1)
!                  fg  = lg + 1
!                  lg  = lg + GAUSSIAN_DATA:n_comp(ls)
!                  fac = GAUSSIAN_DATA::unnormalizing_factors(fg:lg)
!                  do i = f,l
!                     X(i,:) = X(i,:)*fac(i-f+1)
!                  end
!               end
!            else
!               ENSURE(ls<=4,"cannot yet convert order for h shells")
!               ! fix for nwchem molden MOs, PGTO normalization for xy, xy, yz
!               if (ls == 2) then
!                  X(f+3:l,:) = X(f+3:l,:) / sqrt(3d0)
!               end
!               if (ls==3) then ! swap f functions
!                  X(f:l,:) = X(f-1+ff,:)
!                  ! if the same trend from D is true for F above these may be needed
!                  ! X(f+3:l-1,:) = X(f+3:l-1,:) / sqrt(3d0)
!                  ! X(l-1:l,:) = X(l-1:l,:) / sqrt(15d0)
!               end
!               if (ls>1) then  ! normalisation factors
!                  lg  = GAUSSIAN_DATA:n_comp_up_to(ls-1)
!                  fg  = lg + 1
!                  lg  = lg + GAUSSIAN_DATA:n_comp(ls)
!                  fac = GAUSSIAN_DATA::unnormalizing_factors(fg:lg)
!                  do i = f,l
!                     X(i,:) = X(i,:)*fac(i-f+1)
!                  end
!               end
!            end
!         end
!
!      case("column","2")
!         do s = 1,.n_shell
!            f  = .first_basis_fn_for_shell(s)
!            l  = .last_basis_fn_for_shell(s)
!            ls = .angular_moment_for_shell(s)
!            ENSURE(ls<=4,"cannot yet convert order for h shells")
!            if (ls==3) then ! swap f functions
!               X(:,f:l) = X(:,f-1+ff)
!            end
!            if (ls>1) then  ! normalisation factors
!               lg  = GAUSSIAN_DATA:n_comp_up_to(ls-1)
!               fg  = lg + 1
!               lg  = lg + GAUSSIAN_DATA:n_comp(ls)
!               fac = GAUSSIAN_DATA::unnormalizing_factors(fg:lg)
!               do j = f,l
!                  X(:,j) = X(:,j)*fac(j-f+1)
!               end
!            end
!         end
!
!    ! case default
!    !    DIE("unknown swap kind, "//trim(swap))
!
!      end
!
!   end

!   swap_from_molden_order(X,swap) ::: private, PURE
!   ! Swap the order of orbitals on matrix "X" after reading a
!   ! molden input file, for "swap" equal to "row" or "1", or
!   ! "coloumn" or "2". The molden orderring is as follows:
!   !  5D: D 0, D+1, D-1, D+2, D-2
!   !  6D: xx, yy, zz, xy, xz, yz
!   !  7F: F 0, F+1, F-1, F+2, F-2, F+3, F-3
!   ! 10F: xxx, yyy, zzz, xyy, xxy, xxz, xzz, yzz, yyz, xyz
!   !  9G: G 0, G+1, G-1, G+2, G-2, G+3, G-3, G+4, G-4
!   ! 15G: xxxx yyyy zzzz xxxy xxxz yyyx yyyz zzzx zzzy,
!   !      xxyy xxzz yyzz xxyz yyxz zzxy
!      self :: IN
!      X :: MAT{REAL}, INOUT
!      swap :: STR, IN
!
!      s,i,f,l,ls,fg,lg :: INT
!      fac :: VEC{REAL}@
!      reorder :: VEC{INT}@
!
!      ff = [1, 2, 3, 5, 6, 4, 9, 7, 8, 10]
!
!      select case (swap)
!
!      case("row","1")
!
!         do s = 1,.n_shell
!
!            f  = .first_basis_fn_for_shell(s)
!            l  = .last_basis_fn_for_shell(s)
!            ls = .angular_moment_for_shell(s)
!
!            if(.atom(.atom_for_shell(s)).basis.is_spherical) then
!               reorder = GAUSSIAN_DATA::molden_spherical_order(ls)
!               X(f:l,:) = X(f-1+reorder,:)
!               if (ls>1) then  ! normalisation factors
!                  lg  = GAUSSIAN_DATA:n_comp_up_to(ls-1)
!                  fg  = lg + 1
!                  lg  = lg + GAUSSIAN_DATA:n_comp(ls)
!                  fac = GAUSSIAN_DATA::unnormalizing_factors(fg:lg)
!                  do i = f,l
!                     X(i,:) = X(i,:)*fac(i-f+1)
!                  end
!               end
!
!            else
!
!               ! Cartesian
!               ENSURE(ls<=4,"cannot yet convert order for h shells")
!               ! fix for nwchem molden MOs, PGTO normalization for xy, xy, yz
!               if (ls == 2) then
!                  X(f+3:l,:) = X(f+3:l,:) / sqrt(3d0)
!               end
!               if (ls==3) then ! swap f functions
!                  X(f:l,:) = X(f-1+ff,:)
!                  ! if the same trend from D is true for F above these may be needed
!                  ! X(f+3:l-1,:) = X(f+3:l-1,:) / sqrt(3d0)
!                  ! X(l-1:l,:) = X(l-1:l,:) / sqrt(15d0)
!               end
!               if (ls>1) then  ! normalisation factors
!                  lg  = GAUSSIAN_DATA:n_comp_up_to(ls-1)
!                  fg  = lg + 1
!                  lg  = lg + GAUSSIAN_DATA:n_comp(ls)
!                  fac = GAUSSIAN_DATA::unnormalizing_factors(fg:lg)
!                  do i = f,l
!                     X(i,:) = X(i,:)*fac(i-f+1)
!                  end
!               end
!            end
!         end
!
!      case("column","2")
!
!         do s = 1,.n_shell
!
!            f  = .first_basis_fn_for_shell(s)
!            l  = .last_basis_fn_for_shell(s)
!            ls = .angular_moment_for_shell(s)
!
!            ENSURE(ls<=4,"cannot yet convert order for h shells")
!            if (ls==3) then ! swap f functions
!               X(:,f:l) = X(:,f-1+ff)
!            end
!            if (ls>1) then  ! normalisation factors
!               lg  = GAUSSIAN_DATA:n_comp_up_to(ls-1)
!               fg  = lg + 1
!               lg  = lg + GAUSSIAN_DATA:n_comp(ls)
!               fac = GAUSSIAN_DATA::unnormalizing_factors(fg:lg)
!               do j = f,l
!                  X(:,j) = X(:,j)*fac(j-f+1)
!               end
!            end
!
!         end
!
!    ! case default
!    !    DIE("unknown swap kind, "//trim(swap))
!
!      end
!
!   end

!  ======================
!  Crystal XML etc. files
!  ======================

   process_CIF_AND_C23_XML ::: leaky
   ! Process both a CIF and an XML output from C23 to
   ! read the density matrix, and unit cell.
   ! NOTE: the CIF should have been processed beforehand!
      self :: INOUT

    ENSURE(.crystal23.allocated,"There is no C23 xml file name!")
    ENSURE(.crystal23.xml_file_name /= " ","There is no C23 xml file name!")
  ! ENSURE(.atom.allocated,"Oi! Start with input CIF")
  ! ENSURE(.atom.dim==.crystal.n_unit_cell_atoms,"Oi!")
 
      base :: STR
      xuc,cuc,dm,cuc_prm :: MAT{REAL}(3,3)
      W :: MAT{REAL}(3,3)
      W_inv :: MAT{REAL}(3,3)
      xml_atom, cif_atom :: VEC{ATOM}@ 
      vol_ratio_m1 :: REAL
      a,f,s,i,j :: INT
      same :: BIN
      cif_pos, xml_pos, tmp_vec :: VEC{REAL}(3)
      adp2, cif_adp2, tmp_adp2 :: MAT{REAL}(3,3)     ! Kang
      seitz :: MAT3{REAL}@           ! Kang for ADP transform

! Kang's note. 2024 Jun 19
! " cif_atom " contains the information of cif atoms
!             - It has ADP data.             
! 
! " xml_atom " will update "(molecule).atom" 
!             - All atoms in the PRIMITIVE unit cell defined in the xml file.
!             - W (X_to_P) matrix provide the conversion between the primitive cell and 
!               the crystallographic cell. ( See Crystal23 manual chapter A.5 )           
!             - "(molecule).atom" is used for ED calculation (.GRID:make_CRYSTAL23_ED_grid_v1 )

  !***** << Stage 1/4 : Cell comparison: Crystallographic cell vs Primitive cell, are they agree? >>
      if (.crystal.deallocated) .crystal.create

      ! Read cif and update .crystal object
      .cif.open
      .cif.find_data_block
      .crystal.unit_cell.read_smCIF(.cif)
      .crystal.spacegroup.read_smCIF(.cif) ! ".crystal.spacegroup" & ".crystal.unit_cell" are updated

      cif_atom.read_smCIF(.cif)            ! "cif_atom" is updated. i

      .cif.close
      ! The (temporary) Cartesian lattice vectors created from the cif file.
      !   "cuc" and ".crystal.unit_cell" will be updated after the comparison of METRIC TENSORs (dm)
      !   based on the lattice vectors provided by the XML file.
      !   It is important to keep our crystal's orientation be consistent with 
      !   the cartesian coordinate of XML file, but at this stage, "cuc" may not be consistent
        
      cuc = .crystal.unit_cell.direct_mx      

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! Read xml and update .CRYSTAL23 object !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      ! Get C23 XML file name
      base = .crystal23.xml_file_name
      .READ:read_CRYSTAL23_xml(base, xml_atom) ! This read in xml atom's "Cartesian coordinate"

      ! "xuc" is Cartesian Lattice vectors (or the primitive cell) from the xml file.       
      xuc = .crystal23.Primitive_unit_cell.direct_mx

      ! Kang 2024.10.23 comment
      !     If lamaGOET makes Crystal23 to keep the conventional cell
      !   using "KEEPSYMM" and "SUPERCON" \n 1 0 0 \n 0 1 0 \n 0 0 1
      !   then .XML contains a conventional information.

      ! Lattice consistency checking 1): "cell volume ratio" minus ONE = should be ZERO
      vol_ratio_m1 = ( xuc.determinant ) / (cuc.determinant) - ONE

      if ( vol_ratio_m1.is_zero(TOL(4)) ) then 
         ! volume test pass. Orientation checking is coming
         do i =1,3
         do j =1,3
            dm(i,j)=  dot_product(xuc(:,i),xuc(:,j)) &
                    - dot_product(cuc(:,i),cuc(:,j))
         end
         end
         
         DIE_IF( NOT dm.is_ZERO(TOL(3)) , "Inconsistent lattice vector Ordering between the xml cell and the cif cell" )
         
         cuc = xuc ! All test passed. overwrite cif cell lattice vectors from the xml cell
         W = ZERO  ! W and W_inv are initialized to be Identity for later use (Stage 2/4)
         do i =1,3
            W(i,i) = ONE ! Kang's memo: Is there a better way to set W and W_inv as 3x3 Identity matrices?
         end
         W_inv = W       ! W_inv is also identity matrix

      else
        !--- If you enter here, there is high chance of xml cell is a primitive cell and 
        !    cif cell is a conventional cell. Or really working on inconsistent cells
        !
        ! Conversion matrix and its inverse between crystallogrphic and primitive cells
        ! provided by Crystal23  (See Crystal23 manual)
        CRYSTAL23:WC23_to( .crystal.spacegroup.lattice_symbol , W)  

        W_inv.to_inverse_of( W )
        W_inv = nint( W_inv )    ! W^-1 always has integer elements only

        if (.crystal.spacegroup.lattice_symbol /= "P" ) then
            stdout.text("  Info: Centering detected.")
            stdout.text("  |  Conversion matrix W (Crystallographic to Primitive) matrix" )  
            stdout.put( W )
            stdout.text("  |")  
            stdout.text("  |  Inverse conversion matrix")  
            stdout.put(W_inv) 
            stdout.text("  |- Refer to Crystal23 manual chapter A5 for more details ")  
            stdout.flush
        else ! Kang comment 24.Oct 2024 It is unlikely to enter here. Shall I remove?
            stdout.text( " Info: The XML unit cell and the cif unit cell are the same. ")
            stdout.flush  
        end

        ! Primitive lattice vectors of the (temporary) unit cell created from .cif
        cuc_prm = matmul( cuc, W ) 

        ! Lattice consistency checking 1*) (primitive) cell volume comparison. If both cells are consistent, then "volume_ratio_minus_ONE" is ZERO
        vol_ratio_m1 = ( xuc.determinant ) / ( cuc_prm.determinant ) - ONE
        
        DIE_IF( NOT vol_ratio_m1.is_zero(TOL(4)), "Inconsistent cell volumes between the .XML and .cif cells" )
        
        ! Lattice consistency checking 2) dm = Difference in two metric tensors of primitive cells
        do i =1,3
        do j =1,3
           dm(i,j)=  dot_product(xuc(:,i)    ,xuc(:,j)    ) &
                   - dot_product(cuc_prm(:,i),cuc_prm(:,j))
        end
        end

        DIE_IF( NOT dm.is_ZERO(TOL(3)) , "Inconsistent lattice vector Ordering between the primitive xml cell and the cif cell" )

        cuc = matmul( xuc , W_inv ) ! All test passed. make cif cell lattice vectors from the primitive XML cell

     end
      

  !****** << Stage 2/4 : Create a unit cell that is consistent with the XML unit cell >
  !        <             Find the atom pair list of  cif atoms and the XML atoms      >>

      ! Update crsytallographic cell lattice vectors from the Crystal23 .xml primitive cell
      ! k-points of reflection data is constructed based on this.
 
      .crystal.unit_cell.make_direct_mx_from( cuc(:,1), cuc(:,2), cuc(:,3) )  ! Updated "cuc" is re-oriented based on "xuc"
                !! Kang's note
                ! At this stage, cif_atom(a).pADP_vector has 
                ! - positions in fractional coordinates 
                ! -      ADPs in crystal coordinate in bohr^2 unit 
                ! Don't invoke .XTAL:update_CIF_crystal_atoms(.cif) here
                ! This make positions in cartesian coord. Keep them in fractional coordinate for now
                ! > Kang's 2nd note
                ! >   The metric tensor comparison is made for robustness, but maybe someone can simplify
                ! >   the above part by starting from reading in "xuc" and create corresponding "cuc"

      .crystal23.xml_atom_for_cif_atom.create(cif_atom.dim)
      .crystal23.xml_atom_for_cif_atom = 0
      .crystal23.cif_atom_for_xml_atom.create(xml_atom.dim)
      .crystal23.cif_atom_for_xml_atom = 0

          !!
          ! Search the same atom pairs from
          !   1) cif cell (crysallographic)   
          !   2) xml cell (primitive)          
          !  
          ! Each atom's fractional coordinate satisfies the following relation
          !   
          !   W * x_primitive = x_crystallographic  <==>  x_prm   = W^-1 * x_cry
          !        (xml cell)       (cif cell)          (xml cell)       (cif cell)
          !   
      do a = 1,cif_atom.dim ! loop over cif atoms
         !
         cif_pos = cif_atom(a).position         !      cif_pos in the Crystallographic crystal coordinate
         cif_pos = matmul( W_inv , cif_pos ) ! Now, cif_pos in the    PRIMITIVE     crystal coordinate
         !
         do f = 1,xml_atom.dim ! loop over xml_atom (future fragment_atom)
            ! 
            xml_pos = xml_atom(f).position  ! xml_pos is in Cartesian coordinate
            xml_pos = matmul(.crystal23.Primitive_unit_cell.inverse_mx, xml_pos) ! xml_pos in fractional coordinate of the Primitive cell (from the Crystal23 XML file)
            !
            tmp_vec = cif_pos - xml_pos     !      tmp_vec is difference in PRIMITIVE crystal coordinate
            tmp_vec = MOD(tmp_vec + HALF + ONE, ONE ) - HALF ! Stable "modulo 1" function whose range is [-0.5, 0.5)    
            tmp_vec = matmul( xuc ,tmp_vec )! Now, tmp_vec in Cartensian coordinate ([Bohr] unit)
            !
            same = tmp_vec.is_zero(0.1d0)   ! same atom criteria: distance < 0.1 Bohr
            !
            if (same) then
               !  Assign information arrays       
               .crystal23.xml_atom_for_cif_atom(a) = f
               .crystal23.cif_atom_for_xml_atom(f) = a 

               ! - Overwrite the fractional coordinate of cif atom (.atom) by using xml_atom.
               ! - By this way, we can use more precise numbers written in the XML file,
               !   and prevent precision-originated coordinate discrepancy between cif atoms and xml atom.
               ! - It may happen that, the modulo 1 operation in the PRIMITIVE fractional coordinate results in 
               !   different but symmetrically equivalent number in the Crystallographic fractional coordinate.
               ! - To prevent the confusion, we need some additional steps of tracking boundary crossing of modulo 1 operation

               tmp_vec = matmul(W_inv,cif_atom(a).position) - xml_pos ! Abusing variable "tmp_vec" to track boundary crossing
               tmp_vec = nint( tmp_vec )
               !
               cif_pos = matmul(W, xml_pos+tmp_vec) ! this "cif_pos" is more consistent with the xml file
               !
               cif_atom(a).set_position( cif_pos ) 
               exit       
            end ! end if (same) then
            !    
         end ! end do f=1,xml_atom.dim
         !
         DIE_IF( NOT same, "A cif atom is not found among the XML atoms ")
         !
      end ! end do a=1,cif_atom.dim

  ! **** << Stage 3/4 : Symmetrizing ADPs of cif atoms using the stabilizers of each unique atom >
  !       <              which are obtained by a FALSE update of ".fragment_atom"                >>

      do f = 1,xml_atom.dim ! Change each xml_atom coordinate system (Primitive cell)
         xml_atom(f).change_axis_system_to("cartesian", .crystal23.Primitive_unit_cell) 
      end
    
! stdout.text("(molecule)-crystal23-xml_atom_for_cif_atom")
! stdout.put( .crystal23.xml_atom_for_cif_atom )
! stdout.put( .crystal23.cif_atom_for_xml_atom )

    !! Preliminary RUN updata_fragment_info(xml_atom) 
    !!    > This step is needed to find the stabilizers or relavant symmetry operators of each atom
    !!    > Using those information, we will update the ADPs of "xml_atom" 
    !! 
      .crystal.update_fragment_info(xml_atom) ! ".atom" has ADPs but not "xml_atom" at this stage
                                              ! .crystal.fragment_atom order is the same to xml_atom
    !! First, symmetrize the ADPs of each cif atom (=".atom")
     ! Symmetrize ADP tensor : First written Kang 16.May. 2024 
     !                         Updated            24.Jun. 2024 

      seitz = .crystal.xyz_seitz_matrices  ! cartesian sym ops- Kang

      do a = 1,cif_atom.dim   ! cif_atom(a) (a-th cif atom) 
          cif_atom(a).change_axis_system_to("cartesian", .crystal.unit_cell, change_ESDs=TRUE )
          cif_adp2 = cif_atom(a).ADP_tensor

          tmp_adp2 = ZERO

          f = .crystal23.xml_atom_for_cif_atom(a) ! f is xml_atom index corresponding to cif_atom(i)
        
          do i = 1,.crystal.frag_atom_sym_factor(f)
             s = .crystal.frag_atom_stabilizer(f).element(i) ! Transform by s-th seitz matrix 
             adp2 = matmul(seitz(:,:,s) , cif_adp2                         )
             adp2 = matmul(                 adp2  , transpose(seitz(:,:,s))) 
              !   new cartesian ADP = Rotation_mx * old cartesian ADP * tanspose( Rot._mx )
             tmp_adp2 = tmp_adp2 + adp2 
          end  !  do a=1,#stabilizer
          adp2 = tmp_adp2 / .crystal.frag_atom_sym_factor(f)
  
          cif_atom(a).set_ADP_tensor( adp2 ) ! i-th cif atom's ADP is symmetrized

          ! Kang's note. It will be more efficient to skip the averaging process and head to overwriting
          !              in case of "crystal.frag_atom_sym_fractor(j) == 1" 
      end ! cif atom ADP symmetrization completed. now move on to the xml_atom

  !<< Stage 4/4 : True update of ".atom" & ".fragment_atom" with symmetrized ADPs  >>

      ! Now we are going to update ADPs "xml_atom" based on cif atom stored in ".atom"

      do f=1,xml_atom.dim  ! Index example for NH3 f = 14 Nitrogen atom
         ! f-th xml_atom(=frag._atom)-> find its unique_atom (Let say the i-th frag.atom) 
         !                                   its relavant sym op (Let say the s-th symop)
         ! for that unique_atom      -> find cif_atom (=.atom)             (mostly they are the same) 

         i = .crystal.unique_atom_for_frag_atom(f) ! i = 13
         s = .crystal.asym_symop_for_frag_atom(f)  ! s = 2
         
         a = .crystal23.cif_atom_for_xml_atom(i) ! find the cif atom "a" for a unique atom "i" 
                                                 ! a = cry23.cafxa(i=13) = 2
         DIE_IF ( a==0, "Fail to find the cif atom for a unique atom" ) 
         ! Kang's note. 
         !  In fact this is not an actual problem for the most cases,
         !  If there is exceptional cases that the unique atoms cannot found 
         !  in the cif atom list, overwriting ADP to the xml_atom will be a bit more tricky but doable
         !  because it would require a step for transforming cif atom's ADP into unique atom's ADP
         !  Then rest of the other xml_atom(or .fragment_atom)'s ADPs are updated using the unique atom's ADP
         adp2 = cif_atom(a).ADP_tensor
         adp2 = matmul( seitz(:,:,s) , adp2 )
         adp2 = matmul( adp2, transpose(seitz(:,:,s)) ) ! ADP transformed

         xml_atom(f).set_ADP_tensor( adp2 ) ! adp2 is cartesian ADP tensor with Bohr^2 unit        
      end
      ! xml_atom is ready for updating .fragment_atom

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!
    !! TRUE Update .atom & .fragment_atom with symmetrized ADPs for all atoms !
    !!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      .n_atom = xml_atom.dim
      .atom.create( .n_atom ) 
      do f = 1,.n_atom
         .atom(f).set_axis_system_to("cartesian")
         .atom(f).set_label( xml_atom(f).label )
         .atom(f).set_position( xml_atom(f).position )
         .atom(f).set_ADP_tensor( xml_atom(f).ADP_tensor )
      end
      ! Destroy existing basis, and atom list
      if (.basis.allocated) .basis.destroy

      ! Make sure basis set is spherical etc.
      .use_spherical_basis = TRUE
      .use_CRYSTAL23_order = TRUE

      ! Finalize atom info and esnsure it has basis set
      ! (Assuming basis set was set before this)
      .BASE:update_atom_basis_group_info

      .crystal.asymmetric_unit_atom.destroy
      .crystal.asymmetric_unit_geometry.destroy 

      .crystal.update_fragment_info(.atom) ! ".atom" = "xml_atom" has ADP data now
      
      .crystal.finalize = TRUE 

      xml_atom.destroy
      cif_atom.destroy
!!  Kang debug
!.crystal.put
!
! stdout.text("Kang debug::: cif atom ADPs ")
!.atom.put_ADPs
!
!stdout.text("Kang debug: : frag atom ADPs")
!.crystal.fragment_atom.put_ADPs
!
!stdout.text("Kang debug___ asym atom ADPs")
!.crystal.asymmetric_unit_atom.put_ADPs 
!stdout.flush
   end

   read_CRYSTAL23_xml(base, xml_atom) ::: private, leaky
   ! Read the xml file and update .crystal23 object
   ! Kang 2024.Jun.11
   ! Testing
      self :: INOUT
      base :: STR, IN
      xml_atom :: VEC{ATOM}@, INOUT
 
   ENSURE(.crystal23.allocated,"crystal23 object is not allocated!")

      XMLfile  :: TEXTFILE@
      tmp  :: STR
      replace :: MAT{STR}@
      W   :: MAT{REAL}@
      av,bv,cv   :: VEC{REAL}(3)
      igv :: VEC{INT}(3)
      pos :: VEC{REAL}(3)
      n_atoms,n_bf,n_g :: INT
      a,g  :: INT 

      if ( .crystal.fragment_atom.allocated ) .crystal.fragment_atom.destroy

      ! Open XML file
      XMLfile.create(base)
      replace.create(3,2)
      replace(:,1) = [  "<" ,  ">",   "=" ]
      replace(:,2) = [ '" "', '" "', '" "' ]
      XMLfile.set_replacement_list(replace)
      XMLfile.open_for("read")
      XMLfile.move_to_line(1)

      ! Read in unit cell
      ! IMPORTANT - could be different to standard one!
      XMLfile.look_for("CELL_VECTOR_A")
      XMLfile.read_line
      XMLfile.move_to_line_item(1)
      XMLfile.read(av)

      XMLfile.look_for("CELL_VECTOR_B")
      XMLfile.read_line
      XMLfile.move_to_line_item(1)
      XMLfile.read(bv)

      XMLfile.look_for("CELL_VECTOR_C")
      XMLfile.read_line
      XMLfile.move_to_line_item(1)
      XMLfile.read(cv)

      .crystal23.Primitive_unit_cell.make_direct_mx_from(av,bv,cv)

      ! Read in atoms from XML
      XMLfile.look_for("NUMBER_OF_ATOMS")
      XMLfile.move_to_line_item(2)
      XMLfile.read(n_atoms)
      ! update number of xml atoms (= number of atoms in a primitive cell)
      !  Store the xml atom list in xml_atom. xml_atom will update ".atom" object.
      !  (.atom are used for the electron density(ED) calculation in .GRID:make_CRYSTAL23_ED_grid_v1)

      ! Read atomic numbers & set
      ! These are a different order to how LamaGOET had them
      xml_atom.create(n_atoms)

!      XMLfile.look_for("FRACTIONARY_COORDINATES") ! Find the fractional coordinate block in the XML file
!      xml_atom.set_axis_system_to("crystal")
      XMLfile.look_for( "CARTESIAN_COORDINATES")
      xml_atom.set_axis_system_to("cartesian")
      XMLfile.look_for("ATOM.1")
      do a = 1,n_atoms
         XMLfile.move_to_line_item(3)
         XMLfile.read(tmp)
         xml_atom(a).set_label(tmp)
         XMLfile.read_line
         XMLfile.read(pos)
         xml_atom(a).set_position(pos) ! pos is in fractional coordinate
         XMLfile.read_line
         XMLfile.read_line
      end

      ! Read number of atomic orbitals (# of basis function PER primitive cell)
      XMLfile.look_for("NUMBER_OF_ATOMIC_ORBITALS") 
      XMLfile.move_to_line_item(2)
      XMLfile.read( n_bf )
      .crystal23.n_bf = n_bf
      stdout.flush 
      stdout.text("=============")
      stdout.text("Crystal23 XML")
      stdout.text("=============")
      stdout.show("  Number of basis function per unit cell      n_bf=" , n_bf)

      ! Read number of IVDL (Integer Vectors Direct Lattice) (List of the relavant neighboring cells)
      XMLfile.look_for("INTEGER_VECTORS_INFO")
      XMLfile.move_to_line_item(3)
      XMLfile.read( n_g )
      stdout.show("  Number of neighbor cells for ED calculation n_g =" ,n_g)
      .crystal23.n_g = n_g

      ! Read the neighbor cell information
      .crystal23.g_latt.create(3,n_g)
      XMLfile.look_for("IVDL.1")
      do g = 1,n_g
         XMLfile.move_to_line_item(2)
         XMLfile.read(igv)
         .crystal23.g_latt(:,g) = igv
         XMLfile.read_line
      end

     ! Read overlap matrices
    ! n_tri = n_bf*(n_bf+1)/2
    ! S.create(n_tri,n_g)
    ! do g = 1,n_g
    !    tmp = g.to_str
    !    XMLfile.look_for("DIRECT_OVERLAP_MATRIX__IVDL."//trim(tmp))
    !    XMLfile.read_line
    !    XMLfile.move_to_line_item(1)
    !    XMLfile.read(S(:,g)) ! <-- ignore new lines
    !  ! stdout.text("Stri"//trim(tmp)//":")
    !  ! stdout.put(S(1:4,g))
    ! end

    ! ! Copy into full S matrices
    ! .crystal23.overlap_mx.create(n_bf,n_bf,n_g)
    ! .crystal23.overlap_mx(:,:,1).symmetric_unzip_triangle(S(:,1))
    ! do g = 2,n_g,2
    !    .crystal23.overlap_mx(:,:,g  ).unzip_triangles(S(:,g+1),S(:,g  ))
    !    .crystal23.overlap_mx(:,:,g+1).unzip_triangles(S(:,g  ),S(:,g+1))
    !  ! stdout.text("Check S:")
    !  ! stdout.text("S"//trim(g.to_str))
    !  ! stdout.put(.crystal23.overlap_mx(:,:,g  ))
    !  ! g1 = g + 1
    !  ! stdout.text("S"//trim(g1.to_str))
    !  ! stdout.put(.crystal23.overlap_mx(:,:,g1 ))
    ! end

      ! Read full density matrices
      .crystal23.density_mx.create(n_bf,n_bf,n_g)
      W.create(n_bf,n_bf)
      do g = 1,n_g
         tmp = g.to_str
         XMLfile.look_for("DIRECT_DENSITY_MATRIX__IVDL."//trim(tmp))
         XMLfile.read_line
         XMLfile.move_to_line_item(1)
         XMLfile.read(W)
         .crystal23.density_mx(:,:,g) = W
       ! if (g==2 OR g==3) then
       ! stdout.text("P"//trim(tmp)//":")
       ! stdout.put(.crystal23.density_mx(:,:,g))
       ! end
      end

      stdout.text("  Reading Crystal23 Density matrix complete" )
      stdout.flush
    ! do g = 2,n_g,2
    !    stdout.text("Check:")
    !    stdout.text("P"//trim(g.to_str))
    !    stdout.put(.crystal23.density_mx(:,:,g  ))
    !    g1 = g + 1
    !    stdout.text("P"//trim(g1.to_str))
    !    stdout.put(.crystal23.density_mx(:,:,g1 ))
    ! end

      ! Check number of electrons
    ! val = ZERO
    ! do g = 1,n_g
    !    S = .crystal23.overlap_mx(:,:,g)
    !    W = .crystal23.density_mx(:,:,g)
    !    zmp = S.trace_product_with(W)
    !    val = val + zmp
    !    stdout.show("g   = ",g)
    !    stdout.show("tmp = ",zmp)
    ! end
    ! stdout.show("N_e = ",val)
      XMLfile.close
      XMLfile.destroy
   end

!  ======================
!  Gaussian chk interface
!  ======================

! Read *only* Tonto MO's and density from g09

   read_tonto_FChk_file(name) ::: leaky
   ! Read the MO's and density matrix from a g09 checkpoint file
   ! as if these were just placed there in TONTO format.
   ! WARNING: only works for restricted
      self :: INOUT
      name :: STR, optional, IN

   DIE_IF(NOT .basis_info_made,"must be a tonto basis set!")

      chkfile :: TEXTFILE@
      fchk :: STR

      ! Get FChk file name
      if (present(name)) then
         fchk = name
      else if (NOT stdin.buffer_exhausted) then
         stdin.read(fchk) ! specified on stdin
      else
         fchk = .name
      end

      ! Create FChk file
      chkfile.create(name)

    ! ! Create orbital energies.
    ! .MO_energies.destroy
    ! .MO_energies.create(.n_bf,"r ")

    ! ! Find & read orbital energies.
    ! chkfile.look_for("Alpha Orbital Energies",from=1)
    ! chkfile.read(.MO_energies)

      ! Create MOs
      .MOs.destroy
      .MOs.create(.n_bf,"r ")

      ! Find & read in orbitals
      chkfile.look_for("Alpha MO",from=1)
      chkfile.read(.MOs,by_column=TRUE)

      ! Create DM 
      .density_mx.destroy
      .density_mx.create(.n_bf,"r ")

      ! Find & read in DM
      chkfile.look_for("SCF density",from=1)
      chkfile.read(.density_mx,by_column=TRUE)

   end

! Can thesed be condensed into one?

   read_g09_FChk_file(name) ::: leaky
   ! Read a g09 checkpoint file (after fchk conversion to ASCII) into TONTO
      self :: INOUT
      name :: STR, optional, IN

   DIE_IF(.use_spherical_basis,"spherical basis not implemented")

      fchk,label  :: STR
      chkfile     :: TEXTFILE@
      fbf,lbf,ang :: VEC{INT}@
      shell_l,n_prim_for_shell,atom_for_shell,atom_p :: VEC{INT}@
      G_n_prim_for_shell,G_atom_for_shell,G_shell_type :: VEC{INT}@
      G_ex,G_cc,G_cp, ex,cc,orb_energy,fc :: VEC{REAL}@
      pos :: VEC{REAL}(3)
      temp_mat :: MAT{REAL}@
      Z, a,s,t, f,l,g,h,n3n,ntr :: INT
      n_prim_shells,n_shell,n_prim,n_independent :: INT
      restricted :: BIN
      archive :: ARCHIVE
      Nc :: REAL

      ! Destroy existing basis, and atom list
      if (.basis.allocated) .basis.destroy
      if (.atom.allocated)  .atom.destroy

      ! Create scfdata
      .scfdata.destroy
      .scfdata.create
      .scfdata.set_output(FALSE)

      ! Get FChk file name
      if (present(name)) then
         fchk = name
      else if (NOT stdin.buffer_exhausted) then
         stdin.read(fchk) ! specified on stdin
      else
         fchk = .name
      end

      ! Open FChk file
      chkfile.create(fchk)
      chkfile.open_for("read")
      chkfile.move_to_line(1)

      ! Read in basic stuff.
      chkfile.look_for("Number of atoms",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_atom)

      chkfile.look_for("Charge",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.charge)

      chkfile.look_for("Multiplicity",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.spin_multiplicity)

      chkfile.look_for("Number of electrons",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_e)

      chkfile.look_for("Number of alpha electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_a)

      chkfile.look_for("Number of beta electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_b)

      chkfile.look_for("Number of basis functions",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_bf)

      n_independent = .n_bf
      chkfile.look_for("Number of independ",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_independent)
      WARN_IF(.n_bf/=n_independent,"No. of basis fns /= no. of independent fns")
      WARN_IF(.n_bf/=n_independent,"MO's are wrong, but density matrix is correct")

      ! Read atomic numbers & set
      chkfile.look_for("Atomic numbers",from=1)
      chkfile.read_line
      .atom.create(.n_atom)
      do a = 1,.n_atom
         chkfile.read(Z)
         .atom(a).set_atomic_number(Z)
         .atom(a).set_nuclear_charge(REALIFY(Z))
      end

      ! Assign core electrons if any
      chkfile.look_for("Nuclear charges",from=1)
      chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(Nc)
         Z = .atom(a).atomic_number
         if (nint(Nc)/=Z) then
            Z = Z - nint(Nc)
            .atom(a).set_n_core_electrons(Z)
         end
      end

      ! Read in coordinates
      chkfile.look_for("Current cartesian coordinates",from=1)
      chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(pos)
         .atom(a).set_position(pos)
      end

      ! Set a name?
      if (.name=="unknown") .name = .atom.chemical_formula

      ! Read gaussian shell info.
      label = "Number of contracted shells"
      chkfile.look_for(label,from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_shell)

      chkfile.look_for("Number of primitive shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_prim_shells)

      G_shell_type.create(n_shell)
      G_n_prim_for_shell.create(n_shell)
      G_atom_for_shell.create(n_shell)
      G_ex.create(n_prim_shells)
      G_cc.create(n_prim_shells)

      chkfile.look_for("Shell types",from=1); chkfile.read_line
      chkfile.read(G_shell_type)
      DIE_IF(any(G_shell_type<-1),"unknown shell types exist")

      chkfile.look_for("Number of primitives per shell",from=1); chkfile.read_line
      chkfile.read(G_n_prim_for_shell)

      chkfile.look_for("Shell to atom map",from=1); chkfile.read_line
      chkfile.read(G_atom_for_shell)

      chkfile.look_for("Primitive exponents",from=1); chkfile.read_line
      chkfile.read(G_ex)

      chkfile.look_for("Contraction coefficients",from=1); chkfile.read_line
      chkfile.read(G_cc)

      chkfile.look_for("Total Energy",from=1)
      chkfile.move_to_line_item(4); chkfile.read(.scfdata.energy)

      ! SP type shells
      G_cp.create(n_prim_shells); G_cp = 0
      atom_p.create(.n_atom);     atom_p = 0
      if (any(G_shell_type==-1)) then
        do s = 1,n_shell
           if (G_shell_type(s)/=-1) cycle
           a = G_atom_for_shell(s)
           atom_p(a) = atom_p(a) + 1
           n_prim_shells = n_prim_shells + G_n_prim_for_shell(s)
        end
        chkfile.look_for("P(S=P)",from=1); chkfile.read_line
        chkfile.read(G_cp)
      end

      ! Get correct number of shells
      .n_shell = n_shell + atom_p.sum_elements
      atom_p.destroy

      ! Create basis set arrays
      shell_l.create(.n_shell)
      n_prim_for_shell.create(.n_shell)
      atom_for_shell.create(.n_shell)
      ex.create(n_prim_shells)
      cc.create(n_prim_shells)

    ! stdout.show(" n_shell =", n_shell)
    ! stdout.show(".n_shell =",.n_shell)

    ! stdout.text("Shell types:")
    ! stdout.put(G_shell_type)

    ! stdout.text("Number of prims for:")
    ! stdout.put(G_n_prim_for_shell)

    ! stdout.text("Atom for shell:")
    ! stdout.put(G_atom_for_shell)

    ! stdout.text("Primitive exponents:")
    ! stdout.put(G_ex)

    ! stdout.text("Contractions:")
    ! stdout.put(G_cc)

    ! stdout.text("P(SP) contractions:")
    ! stdout.put(G_cp)

      ! Copy the basis. Expand out L shells.
      t = 0
      l = 0; h = 0

      do s = 1,n_shell

        t = t + 1
        n_prim = G_n_prim_for_shell(s)
        f = l + 1; l = l + n_prim
        g = h + 1; h = h + n_prim

        if (G_shell_type(s)==-1) then

           shell_l(t) = 0                    ! S part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)

           t = t + 1
           f = l + 1
           l = l + n_prim
           shell_l(t) = 1                    ! P part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cp(g:h)

        else

           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)
           shell_l(t) = abs(G_shell_type(s)) ! WARNING: sometimes this can be -2
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)

        end

      end

      G_cp.destroy
      G_shell_type.destroy
      G_atom_for_shell.destroy
      G_n_prim_for_shell.destroy
      G_ex.destroy
      G_cc.destroy

      ENSURE(.n_shell==t,"wrong number of shells")

      ! Set basis
      .SET:set_basis_from_gX_data(shell_l,n_prim_for_shell,atom_for_shell,ex,cc)

      cc.destroy
      ex.destroy
      atom_for_shell.destroy
      n_prim_for_shell.destroy
      shell_l.destroy

      ! Finalize atom info/basis sets
      .BASE:update_atom_basis_group_info

      ! Read in orbital energies.
      orb_energy.create(n_independent)
      chkfile.look_for("Alpha Orbital Energies",from=1)
      chkfile.read_line; chkfile.read(orb_energy)
      .MO_energies.destroy
      if (trim(chkfile.next_str)=="Beta") then
         restricted = FALSE
         .scfdata.set_SCF_kind("uhf")
         .MO_energies.create(.n_bf,"u ")
         .MO_energies.a = ZERO
         .MO_energies.a(1:n_independent) = orb_energy
         chkfile.read_line; chkfile.read(orb_energy)
         .MO_energies.b = ZERO
         .MO_energies.b(1:n_independent) = orb_energy
         orb_energy.destroy
      else
         restricted = TRUE
         .scfdata.set_SCF_kind("rhf")
         .MO_energies.create(.n_bf,"r ")
         .MO_energies.r = ZERO
         .MO_energies.r(1:n_independent) = orb_energy
         orb_energy.destroy
      end

      ! Read in molecular orbitals.
      temp_mat.create(n_independent,.n_bf)
      chkfile.look_for("Alpha MO",from=1)
      chkfile.read_line
      chkfile.read(temp_mat)

      fbf = .first_basis_fn_for_shell
      lbf =  .last_basis_fn_for_shell
      ang = .angular_moment_for_shell

      .MOs.destroy

      if (trim(chkfile.next_str)=="Beta") then
         .MOs.create(.n_bf,"u ")
         .MOs.a = ZERO
         .MOs.a(1:.n_bf,1:n_independent) = transpose(temp_mat)
         chkfile.read_line; chkfile.read(temp_mat)
         .MOs.b = ZERO
         .MOs.b(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         GAUSSIAN_DATA:swap_from_Gaussian_C_order(.MOs.a,"row",fbf,lbf,ang)
         GAUSSIAN_DATA:swap_from_Gaussian_C_order(.MOs.b,"row",fbf,lbf,ang)
      else
         .MOs.create(.n_bf,"r ")
         .MOs.r = ZERO
         .MOs.r(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         GAUSSIAN_DATA:swap_from_Gaussian_C_order(.MOs.r,"row",fbf,lbf,ang)
      end

      ! Read in density matrix.
      .READ:read_gX_SCF_dm(chkfile,restricted,.density_mx)

      ! Extract MP2 density matrix to file.  UHF untested
      .READ:read_gX_MP2_dm(chkfile,restricted,.density_mx)

      ! Extract MP3 density matrix to file.  UHF untested
      .READ:read_gX_MP3_dm(chkfile,restricted,.density_mx)

      ! Extract CC density matrix to file.  UHF untested
      .READ:read_gX_CC_dm(chkfile,restricted,.density_mx)

      ! Read in force constants
      if (chkfile.has_string("Cartesian Force Constants")) then
         n3n = 3*.atom.dim
         ntr = n3n.triangle_number
         .force_constants.create(n3n,n3n)
         fc.create(ntr)
         chkfile.look_for("Cartesian Force Constants",from=1)
         chkfile.read_line
         chkfile.read(fc)
         .force_constants.symmetric_unzip_triangle(fc)
         fc.destroy
      end

      ! Close chkfile
      chkfile.close; chkfile.destroy

      ! Save data in archive files
      ! NOTE: MO's & density matrix are wrt unnormalized basis fn's
      archive.set(.name,"density_mx")
      archive.write(.density_mx)

      archive.set(.name,"MOs")
      archive.write(.MOs)

      archive.set(.name,"MO_energies")
      archive.write(.MO_energies)

      if (.crystal.allocated) then
         .SET:resolve_axis_system
         .crystal.update_fragment_info(.atom)
      end

   end

   read_gX_dm(chkfile,restricted,dm) ::: template, private
   ! Read a gaussian density matrix with TAG? which may be
   ! "r " (or not) from "chkfile". Archive it as NAME?.
   ! If "dm" is present it is created to be the density matrix.
      self :: INOUT
      chkfile :: TEXTFILE, INOUT
      restricted :: BIN, IN
      dm :: OPMATRIX@, optional

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.n_bf>0,"no basis functions")

      D,spin,total :: OPMATRIX@
      fbf,lbf,ang :: VEC{INT}@
      archive :: ARCHIVE

      ! Extract density matrix
      if (NOT chkfile.has_string("TAG? Density")) return

      fbf = .first_basis_fn_for_shell
      lbf =  .last_basis_fn_for_shell
      ang = .angular_moment_for_shell

      if (restricted) then

         ! Read restricted density (triangle) "name" into "D"
         D.create(.n_bf, "r ")
         D.tri.create(D.l_compress("r "))
         chkfile.look_for("Total TAG? Density")
         chkfile.read_line
         chkfile.read(D.tri)
         D.uncompress

         ! Swap orbital order
         GAUSSIAN_DATA:swap_from_Gaussian_C_order(D.r,"1",fbf,lbf,ang)
         GAUSSIAN_DATA:swap_from_Gaussian_C_order(D.r,"2",fbf,lbf,ang)

      else

         ! Create
         D.create(.n_bf,"u ")
         total.create(.n_bf, "r ")
         spin.create(.n_bf, "r ")

         ! Read total density (triangle) TAG? into "total"
         total.tri.create(total.l_compress("r "))
         chkfile.look_for("Total TAG? Density")
         chkfile.read_line
         chkfile.read(total.tri)
         total.uncompress

         ! Read spin density (triangle) trim(tag) into "spin"
         spin.tri.create(spin.l_compress("r "))
         chkfile.look_for("Spin TAG? Density")
         chkfile.read_line
         chkfile.read(spin.tri)
         spin.uncompress

         ! Define alpha and beta densities
         D.b  = (total.r - spin.r)/2
         D.a = (spin.r  + total.r)/2

         ! Clean
         spin.destroy
         total.destroy

         ! Swap orbital order
         GAUSSIAN_DATA:swap_from_Gaussian_C_order(D.a,"1",fbf,lbf,ang)
         GAUSSIAN_DATA:swap_from_Gaussian_C_order(D.a,"2",fbf,lbf,ang)
         GAUSSIAN_DATA:swap_from_Gaussian_C_order(D.b,"1",fbf,lbf,ang)
         GAUSSIAN_DATA:swap_from_Gaussian_C_order(D.b,"2",fbf,lbf,ang)

      end

      ! Archive the density "D"
      archive.set(.name,NAME?)
      archive.write(D)

      ! Clean
      if (present(dm)) then
         dm.destroy
         dm = D
      end

      D.destroy

   end

   read_gX_SCF_dm(chkfile,restricted,dm) ::: get_from(read_gX_dm, TAG?=>SCF, NAME?=>"SCF_density_mx"), private
   ! Read a gaussian density matrix with TAG? which may be
   ! "r " (or not) from "chkfile". Archive it as NAME?.
   ! If "dm" is present it is created to be the density matrix.
   end

   read_gX_MP2_dm(chkfile,restricted,dm) ::: get_from(read_gX_dm, TAG?=>MP2,  NAME?=>"MP2_density_mx"), private
   ! Read a gaussian density matrix with TAG? which may be
   ! "r " (or not) from "chkfile". Archive it as NAME?.
   ! If "dm" is present it is created to be the density matrix.
   end

   read_gX_MP3_dm(chkfile,restricted,dm) ::: get_from(read_gX_dm, TAG?=>MP3,  NAME?=>"MP3_density_mx"), private
   ! Read a gaussian density matrix with TAG? which may be
   ! "r " (or not) from "chkfile". Archive it as NAME?.
   ! If "dm" is present it is created to be the density matrix.
   end

   read_gX_CC_dm(chkfile,restricted,dm) ::: get_from(read_gX_dm, TAG?=>CC,  NAME?=>"CC_density_mx"), private
   ! Read a gaussian density matrix with TAG? which may be
   ! "r " (or not) from "chkfile". Archive it as NAME?.
   ! If "dm" is present it is created to be the density matrix.
   end

!  ========
!  WFN file
!  ========

   read_wfn_file(filename) ::: leaky
   ! Open and read a file named "name", either a 
   ! . gaussian .FChk file
   ! . A tonto .sbf file
   ! . A .molden file
      self :: INOUT
      filename :: STR, IN

      if (filename.ends_in("fchk", case_sensitive=FALSE)) then
         .READ:read_g09_FChk_file(filename)
      else if (filename.ends_in("sbf", case_sensitive=FALSE)) then
         .READ:deserialize(filename)
      else if (filename.ends_in("molden", case_sensitive=FALSE)) then
         .READ:read_molden_MOs(filename)
      else
         DIE("unknown file format for file '"//trim(filename)//"'")
      end

   end

!  ========
!  Read SBF
!  ========

   deserialize(filename)
   ! Read in data from sbf file
      self :: INOUT
      filename :: STR, IN

      datafile :: DATAFILE
      tmp_str :: STR(len=:)@
      atomic_labels :: STR(len=1), dimension(:,:), allocatable
      atomic_numbers :: VEC{INT}@
      atomic_coordinates :: VEC{REAL}@
      charge_multiplicity :: VEC{INT}@
      tmp_mat :: MAT{REAL}@
      labels :: VEC{STR}@
      i, err :: INT
      success = 1 :: INT

      datafile.open(filename)

      call datafile%sbf%deserialize

      call datafile%sbf%get("name", tmp_str, err)
      DIE_IF(err /= success, sbf_strerr(err))

      .name = tmp_str
      call datafile%sbf%get("basis_name", tmp_str, err)
      DIE_IF(err /= success, sbf_strerr(err))

      .basis_name = tmp_str

      call datafile%sbf%get("atomic_labels", atomic_labels, err)
      DIE_IF(err /= success, sbf_strerr(err))

      ! convert back
      allocate(labels(size(atomic_labels, 1)))
      do i = 1, size(atomic_labels, dim=1)
         labels(i) = trim(VEC{STR}:char_array_to_str(atomic_labels(i,:)))
      end do

      call datafile%sbf%get("atomic_numbers", atomic_numbers, err)
      DIE_IF(err /= success, sbf_strerr(err))
      .atom.create(size(atomic_numbers))

      call datafile%sbf%get("atomic_coordinates", atomic_coordinates, err)
      DIE_IF(err /= success, sbf_strerr(err))
      .atom.set_positions_from_vector(atomic_coordinates)

      .atom.set_atom_data_from_labels(labels)

      call datafile%sbf%get("charge_multiplicity", charge_multiplicity, err)
      if(err /= success) then
          stderr.show("Error reading charge_multiplicity from file, not setting:", sbf_strerr(err))
      else
          .SET:set_charge(charge_multiplicity(1))
          .SET:set_spin_multiplicity(charge_multiplicity(2))
      endif

      ! Update atom info/basis sets
      .BASE:update_atom_basis_group_info

      call datafile%sbf%get("scf_kind", tmp_str, err)

      ! TODO CHECK FOR ERRORS
      if (err == success) then
         .scfdata.create
         .scfdata.set_output(FALSE)
         .density_mx.create(.n_bf)
         .MOs.create(.n_bf)

         select case (tmp_str)
         !select case (.scfdata.spinorbital_genre)

         case ("r","restricted")
            .scfdata.set_SCF_kind("rhf")
            call datafile%sbf%get("density_mx", tmp_mat, err)
            DIE_IF(err /= success, sbf_strerr(err))
            .density_mx.create("r ")
            .density_mx.r = tmp_mat
            deallocate(tmp_mat)
            call datafile%sbf%get("MOs", tmp_mat, err)
            DIE_IF(err /= success, sbf_strerr(err))
            .MOs.create("r ")
            .MOs.r = tmp_mat
            deallocate(tmp_mat)

         case ("u","unrestricted")
            .scfdata.set_SCF_kind("uhf")
            .density_mx.create("u ")
            call datafile%sbf%get("density_mx,a", tmp_mat, err)
            DIE_IF(err /= success, sbf_strerr(err))
            .density_mx.a= tmp_mat
            deallocate(tmp_mat)
            call datafile%sbf%get("density_mx,b", tmp_mat, err)
            DIE_IF(err /= success, sbf_strerr(err))
            .density_mx.b = tmp_mat
            deallocate(tmp_mat)
            .MOs.create("u ")
            call datafile%sbf%get("MOs,a", tmp_mat, err)
            DIE_IF(err /= success, sbf_strerr(err))
            .MOs.a = tmp_mat
            deallocate(tmp_mat)
            call datafile%sbf%get("MOs,b", tmp_mat, err)
            DIE_IF(err /= success, sbf_strerr(err))
            .MOs.b = tmp_mat
            deallocate(tmp_mat)

         case default
            DIE("Serializing these orbitals is not implemented")

         end

      else


      end if

      datafile.close

   end

!  ============
!  Read archive
!  ============

   read_archive ::: leaky
   ! Read the archive called "name" with "genre", e.g.  "r ".
   ! For use with TONTO generated archives.
      self :: INOUT

   ENSURE(stdin.n_line_items==3, "must specify an archive and a kind")
   ENSURE(.n_bf>0, "need to already know the number of basis functions")

      name,genre :: STR

      stdin.read(name)
      stdin.read(genre)

      stdout.text("reading archive : " // trim(name))
      .READ:read_archive(name,genre)

   end

   read_archive(name,genre) ::: leaky
   ! Read the archive called "name" with "genre", e.g. "r ".
   ! For use with TONTO generated archives. Handle specific
   ! lambda's in the name (if the name is of the form ....,lambda=...)
      self :: INOUT
      name :: STR, IN
      genre :: STR, IN

   ENSURE(.n_bf>0, "need to already know the number of basis functions")

      i  :: INT
      nm :: STR
      normalize :: STR
      fbf,lbf,ang :: VEC{INT}@
      do_norm :: BIN
      arch :: ARCHIVE

      ! Set the archive "name" & "genre"
      arch.set(.name,name,genre=genre)

      ! Now remove any lambda in the "name"
      nm = name
      i  = nm.index_of_character_in(",")
      if (i>0) then
         nm = name(1:i-1)
      end

      ! Second word on line is normalize?
      normalize = " "
      if (stdin.buffer.n_items==2) stdin.read(normalize)
      do_norm = normalize(1:9)=="normalise" OR normalize(1:9)=="normalize"
      ! Tell them
      if (do_norm) then
         stdout.flush
         stdout.text("Writing normalized "//trim(nm))
         stdout.flush
      end

      fbf = .first_basis_fn_for_shell
      lbf =  .last_basis_fn_for_shell
      ang = .angular_moment_for_shell

      ! Read the archive
      select case (nm)

      case ("covalent_orbitals ","RG_COs            ")
         if (.NOs.deallocated) .NOs.create(.n_bf)
         arch.read(.NOs)
         if (do_norm) .NOs.unnormalize("1",fbf,lbf,ang)

      case ("ionic_orbitals    ","RG_IOs            ")
         if (.NOs.deallocated) .NOs.create(.n_bf)
         arch.read(.NOs)
         if (do_norm) .NOs.unnormalize("1",fbf,lbf,ang)

      case ("molecular_orbitals","MOs               ", &
            "HF_MOs            ","KS_MOs            ")
         if (.MOs.deallocated) .MOs.create(.n_bf)
         arch.read(.MOs)
         if (do_norm) .MOs.unnormalize("1",fbf,lbf,ang)

      case ("MO_energies       ", &
            "HF_MO_energies    ","KS_MO_energies    ")
         if (.MO_energies.deallocated) .MO_energies.create(.n_bf)
         arch.read(.MO_energies)

      case ("natural_orbitals  ","NOs               ")
         if (.NOs.deallocated) .NOs.create(.n_bf)
         arch.read(.NOs)
         if (do_norm) .NOs.unnormalize("1",fbf,lbf,ang)

      case ("occupation_nos    ","NO_occ_nos        ")
         if (.NO_occ_nos.deallocated) .NO_occ_nos.create(.n_bf)
         arch.read(.NO_occ_nos)

      case ("density_matrix    ","density_mx        ", &
            "hf_density_matrix ","HF_density_mx     ", &
            "ks_density_matrix ","KS_density_mx     ", &
            "mp2_density_matrix","MP2_density_mx    ", &
            "mp3_density_matrix","MP3_density_mx    ")
         if (.density_mx.deallocated) .density_mx.create(.n_bf)
         arch.read(.density_mx)
         if (do_norm) then
            .density_mx.unnormalize(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
         end

      case ("fock_matrix       ", &
            "Fock_mx           ","Kohn-Sham_mx      ")
         if (.fock_mx.deallocated) .fock_mx.create(.n_bf)
         arch.read(.fock_mx)
         if (do_norm) .fock_mx.unnormalize(fbf,lbf,ang)

      case ("U_electric_dipole ")
         if (.U_electric_dipole.deallocated) .U_electric_dipole.create(.n_bf,.n_bf,3)
         arch.read(.U_electric_dipole)

      case ("U2_electric_dipole ")
         if (.U2_electric_dipole.deallocated) .U2_electric_dipole.create(.n_bf,.n_bf,6)
         arch.read(.U2_electric_dipole)

      case default
         UNKNOWN(nm)

      end

      ! Clean up
      arch.close

   end

   read_ascii_archive ::: leaky
   ! Read the archive called "name" with "genre", e.g. "r ".
      self :: INOUT

   ENSURE(stdin.buffer.n_items==3, "must specify an archive and a kind")
   ENSURE(.n_bf>0, "need to already know the number of basis functions")

      name,genre :: STR
      arch :: ARCHIVE

      ! Read archive name & genre
      stdin.read(name)
      stdin.read(genre)

      ! Set archive "name", "genre" & ascii format
      arch.set(.name,name,genre=genre,format="ascii")

      ! Read the archive
      select case (name)

      case ("covalent_orbitals ","RG_COs            ")
         if (.NOs.deallocated)   .NOs.create(.n_bf)
         arch.read(.NOs,by_column=TRUE)

      case ("ionic_orbitals    ","RG_IOs            ")
         if (.NOs.deallocated)   .NOs.create(.n_bf)
         arch.read(.NOs,by_column=TRUE)

      case ("molecular_orbitals","MOs               ", &
            "HF_MOs            ","KS_MOs            ")
         if (.MOs.deallocated) .MOs.create(.n_bf)
         arch.read(.MOs,by_column=TRUE)

      case ("MO_energies       ", &
            "HF_MO_energies    ","KS_MO_energies    ")
         if (.MO_energies.deallocated)   .MO_energies.create(.n_bf)
         arch.read(.MO_energies)

      case ("natural_orbitals  ","NOs               ")
         if (.NOs.deallocated)   .NOs.create(.n_bf)
         arch.read(.NOs,by_column=TRUE)

      case ("no_occupation_nos ","NO_occ_nos        ")
         if (.NO_occ_nos.deallocated) .NO_occ_nos.create(.n_bf)
         arch.read(.NO_occ_nos)

      case ("density_matrix    ","density_mx        ", &
            "hf_density_matrix ","HF_density_mx     ", &
            "ks_density_matrix ","KS_density_mx     ", &
            "mp2_density_matrix","MP2_density_mx    ", &
            "mp3_density_matrix","MP3_density_mx    ")
         if (.density_mx.deallocated)     .density_mx.create(.n_bf)
         arch.read(.density_mx,by_column=TRUE)

      case ("fock_matrix       ", &
            "Fock_mx           ","Kohn-Sham_mx      ")
         if (.fock_mx.deallocated)        .fock_mx.create(.n_bf)
         arch.read(.fock_mx,by_column=TRUE)

      case default
         UNKNOWN(name)

      end

      ! Clean up
      arch.close

   end

   read_archive(opmatrix,archive_name,genre) ::: leaky
   ! Recover the "opmatrix" from an archive on disk with name "archive_name".
   ! The kind is guessed from "opmatrix".
      self :: INOUT
      opmatrix :: OPMATRIX@, OUT
      archive_name :: STR, IN
      genre :: STR, optional, IN

   ENSURE(opmatrix.has_any_genre,"no opmatrix genre created")

      archive :: ARCHIVE

      archive.set(.name,archive_name)
      archive.read(opmatrix,genre)

   end

   read_archive(opvector,archive_name,genre) ::: leaky
   ! Recover the "opvector" from an archive on disk with name "archive_name".
   ! The kind is guessed from "opvector".
      self :: INOUT
      opvector :: OPVECTOR, OUT
      archive_name :: STR, IN
      genre :: STR, optional, IN

   ENSURE(opvector.has_any_genre,"no opvector genre created")

      archive :: ARCHIVE

      archive.set(.name,archive_name)
      archive.read(opvector,genre)

   end

   read_archive(item,archive_name,genre) ::: leaky
   ! Recover the "item" from an archive on disk with name "archive_name".
      self :: INOUT
      item :: REAL, OUT
      archive_name :: STR, IN
      genre :: STR, optional, IN

      archive :: ARCHIVE

      archive.set(.name,archive_name)
      archive.read(item,genre)

   end

   read_SCF_archives ::: leaky
   ! Copy the natural orbitals to be the MOs.
   ! If thw MO's are not there, try and read them from disk.
   ! The occupation numbers are the MO ones.
      self :: INOUT

      genre :: STR
      arch :: ARCHIVE

      ! Get MO's 
      if (.MOs.allocated) then
         ! Already there
         genre = .MOs.genre
      else if (.scfdata.allocated) then
         ! Does it exist as on disk?
         genre = .scfdata.spinorbital_genre
         arch.set(.name,"MOs",genre)
         if (arch.exists) then
            .MOs.create(.n_bf)
            arch.read(.MOs)
            arch.close
         end
      end
      
      ! Get density matrix
      if (.density_mx.allocated) then
         ! Already there
         genre = .density_mx.genre
      else if (.scfdata.allocated) then
         ! Does it exist on disk?
         genre = .scfdata.spinorbital_genre
         arch.set(.name,"density_mx",genre)
         if (arch.exists) then
            .density_mx.create(.n_bf)
            arch.read(.density_mx)
            arch.close
         end
      end

      ! Get orbital energies
      if (.MO_energies.deallocated) then
      if (.scfdata.allocated) then
         genre = .scfdata.spinorbital_genre
         .MO_energies.create(.n_bf,genre)
         ! Does it exist on disk?
         arch.set(.name,"MO_energies",genre)
         if (arch.exists) then
            arch.read(.MO_energies)
            arch.close
         end
      end
      end
      
      ! Clone the MO's
      if (.MOs.allocated) then
         .NOs = .MOs
         .NO_occ_nos.create(.n_bf,genre)
         .NO_occ_nos.set_to_zero
         .SET:set_SCF_occupations_for_NOs(genre)
      end

   end

!  ===================
!  Redirect and revert
!  ===================

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input. (This code is for non-pointer self objects).
   end

   redirect_stdout ::: leaky
   ! Redirect stdout to the file whose name is the following string
   ! in the current input file.

      name :: STR

      if (FALSE) self = self

      stdin.read(name)
      stdout.redirect(name)

   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file. (This code is for non-pointer self
   ! objects).
   end

   revert_stdout ::: leaky
   ! Revert stdout back to the previously stored input file
      if (FALSE) self = self
      stdout.revert
   end

end
