!-------------------------------------------------------------------------------
!
! MAT{RMS2_INDICES}
!
! This object is used to store precalculated information pertaining to the
! reduced multiplication scheme (RMS) used in electron repulsion integral 
! evaluation.
!
! Copyright (C) Dylan Jayatilaka, 2000
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module MAT{RMS2_INDICES}

   implicit none

contains

! =================
! Memory allocation
! =================

   create(dim1,dim2) ::: get_from(MAT{OBJECT}), leaky
   ! Create space for object. This version does not set defaults.
   end

   create(lb1,ub1,lb2,ub2) ::: get_from(MAT{OBJECT}), leaky
   ! Create a matrix with the given dimensions
   ! This version does not set defaults.
   end

   destroy ::: get_from(MAT{OBJECT}), leaky
   ! Destroy the object
   end

   nullify_ptr_part ::: get_from(MAT{OBJECT})
   ! Nullify the pointer parts of self
   end

   destroy_ptr_part ::: get_from(MAT{OBJECT}), leaky
   ! Destroy the pointer parts of self
   end

! ===========
! Set indices
! ===========

   set_indices(l_max,rms_indices,nx,ny,nz) ::: leaky
   ! Set the rms indices. 
      self :: PTR
      l_max :: INT, IN
      rms_indices :: MAT{RMS_INDICES}*
      nx,ny,nz :: VEC{INT}, IN

   ENSURE(.associated,"no self object")
   ENSURE(.dim1==(l_max+1)*(l_max+2)/2,"upper bound 1 wrong")
   ENSURE(.dim2==(l_max+1)*(l_max+2)/2,"upper bound 2 wrong")
   ENSURE(lbound(rms_indices,1)==0,"rms_indices, lower bound 1 wrong")
   ENSURE(lbound(rms_indices,2)==0,"rms_indices, lower bound 2 wrong")
   ENSURE(ubound(rms_indices,1)==l_max,"rms_indices, upper bound 1 wrong")
   ENSURE(ubound(rms_indices,2)==l_max,"rms_indices, upper bound 2 wrong")
   ENSURE(nx.dim==MAT{RMS2_INDICES}::n_comp_up_to(2*l_max),"wrong size, nx")
   ENSURE(ny.dim==nx.dim,"wrong size, ny")
   ENSURE(nz.dim==nx.dim,"wrong size, nz")

      ab_lmax,ab_lmin,ab_ltri,fe,le :: INT
      cd_lmax,cd_lmin,cd_ltri,ff,lf :: INT
      ab_ltri = 0
      do ab_lmax = 0,l_max   ! Maximum l for a shell
      do ab_lmin = 0,ab_lmax ! l for the b shell
        ab_ltri = ab_ltri + 1
        fe = MAT{RMS2_INDICES}::n_comp_up_to(ab_lmax-1)+1
        le = MAT{RMS2_INDICES}::n_comp_up_to(ab_lmin+ab_lmax)
        cd_ltri = 0
        do cd_lmax = 0,l_max   ! Maximum l for c shell
        do cd_lmin = 0,cd_lmax ! l for the d shell
           cd_ltri = cd_ltri + 1
           ff = MAT{RMS2_INDICES}::n_comp_up_to(cd_lmax-1)+1
           lf = MAT{RMS2_INDICES}::n_comp_up_to(cd_lmin+cd_lmax)
           self(ab_ltri,cd_ltri).set_indices( &
              rms_indices(ab_lmax,ab_lmin),  & 
              rms_indices(cd_lmax,cd_lmin),  &
              nx(fe:le),ny(fe:le),nz(fe:le), &
              nx(ff:lf),ny(ff:lf),nz(ff:lf), &
              ab_lmax+ab_lmin )
           !  ab_lmax+ab_lmin,cd_lmax+cd_lmin )
           !  ab_lmax,ab_lmin,cd_lmax,cd_lmin )
        end
        end
      end
      end
   end

   n_comp_up_to(l) result (res) ::: selfless, pure, private
   ! No. of gaussian cartesian component functions up to and including the shell
   ! with momentum "l".
      l :: INT, IN
      res :: INT
      res = (l+1)*(l+2)*(l+3)/6
   end

end
