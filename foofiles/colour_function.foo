!====================================================================
!
! COLOUR_FUNCTION:
!
! For generating an RGB colour triple from a given data value.
!
! The module takes as input a series of data values with their
! assigned RGB colours. Any data value is then assigned an RGB colour
! by interpolation from the colour table.
!
! The default data range is [0...1]. The colours assigned are:
! Blue-Green for the range [0...0.5
! Green-Red  for the range [0.5...1].
!
! Copyright (C) Dylan Jayatilaka, 2002
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!====================================================================

module COLOUR_FUNCTION

   implicit none

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Allocate an object
   end

   create(range) ::: leaky, PURE
   ! Create the object
      self :: allocatable, OUT
      range :: VEC{REAL}(2), IN
      .create
      .set_defaults(range)
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts
      self :: INOUT
      .data.destroy
      .RGB.destroy
   end

!  ===========
!  Set methods
!  ===========

   set_defaults(range) ::: leaky, PURE
   ! Set up a defaults
      self :: INOUT
      range :: VEC{REAL}(2), optional, IN

      .n_data = 3

      .data.destroy
      .data.create(3)
      .data     = [ZERO,HALF, ONE]

      .RGB.destroy
      .RGB.create(3,3)
      .RGB(:,1) = [ZERO,ZERO, ONE]
      .RGB(:,2) = [ZERO, ONE,ZERO]
      .RGB(:,3) = [ ONE,ZERO,ZERO]

      if (present(range)) .rescale_data(range)

      .finalized = TRUE

   end

   set_reverse_defaults(range) ::: PURE
   ! Set up reversed defaults
      self :: INOUT
      range :: VEC{REAL}(2), optional, IN

      .n_data = 3

      .data.destroy
      .data.create(3)
      .data     = [ZERO,HALF, ONE]

      .RGB.destroy
      .RGB.create(3,3)
      .RGB(:,1) = [ ONE,ZERO,ZERO]
      .RGB(:,2) = [ZERO, ONE,ZERO]
      .RGB(:,3) = [ZERO,ZERO, ONE]

      if (present(range)) .rescale_data(range)

      .finalized = TRUE

   end

!  =============
!  Input methods
!  =============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      self :: INOUT
      keyword :: STR, IN

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
      case ("}               ")  ! exit case
    ! case ("data_and_colour="); .read_data_and_colour
      case ("data_and_rgb=   "); .read_data_and_RGB
      case ("put             "); .put
      case ("units=          "); .read_units
      case default;         UNKNOWN(word)
      end
   
   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_data_and_RGB ::: leaky
   ! Read in the data-colour pair. The colour must be an RGB real triple
   ! And the list of data and colour triples, a list of four real numbers, must
   ! be entered as a single vector.
      self :: INOUT

      length,i,k :: INT
      data_and_colour :: VEC{REAL}@

      stdin.read_all(data_and_colour)
      ENSURE(mod(data_and_colour.dim,4)==0,"data and colour array must be divisible by 4")

      length = data_and_colour.dim/4

      .RGB.destroy
      .data.destroy

      .data.create(length)
      .RGB.create(3,length)

      k = 0
      do i = 1,length
         .data(i)  = data_and_colour(k+1)
         .RGB(1,i) = data_and_colour(k+2)
         .RGB(2,i) = data_and_colour(k+3)
         .RGB(3,i) = data_and_colour(k+4)
         k = k + 4
      end

      data_and_colour.destroy

   end

   update ::: leaky, PURE
   ! Check everything is OK after reading data. Saturation must exist
   ! but it is applied into the RGB triples and then destroyed.
      self :: INOUT

   ENSURE(.data.allocated,"no data values")
   ENSURE(.RGB.allocated,"no RGB values")
   ENSURE(.data.dim==.RGB.dim2,"incompatible #: data and RGB")
   ENSURE(all(.RGB>=ZERO),"negative RGB values exist")
   ENSURE(all(.RGB<=ONE),"some RGB values greater than 1")
   ENSURE(all(.RGB.column_norms<=THREE),"some RGB norms larger than 3")

      order :: VEC{INT}@

      .n_data = .data.dim

      ! Re-order from smallest to largest
      order.create(.n_data)
      .data.quick_sort(order)
      .data = .data(order)
      .RGB  = .RGB(:,order)
      order.destroy

      .finalized = TRUE

   end

!  ============
!  Set routines
!  ============

   set_data(data) ::: leaky, PURE
   ! Set the data. Make sure that .finalize is called after all set
   ! routines.
      self :: INOUT
      data :: VEC{REAL}, IN
      .data = data
   end

   set_RGB(RGB) ::: leaky, PURE
   ! Set the RGB's. Make sure that .finalize is called after all set
   ! routines.
      self :: INOUT
      RGB :: MAT{REAL}, IN
      .RGB = RGB
   end

!  ================
!  Colours for data
!  ================

   RGB_for(value,truncate_to_range) result (res) ::: PURE
   ! Return the RGB triple corresponding to a certain "value".
      self :: IN
      value :: REAL, IN
      truncate_to_range :: BIN, optional, IN
      res :: VEC{REAL}(3)

   ENSURE(.finalized,"not finalized")

      colour :: VEC{REAL}(3)
      frac,thevalue :: REAL
      i1,i2 :: INT
      truncate :: BIN

      thevalue = value

      truncate = TRUE
      if (present(truncate_to_range)) truncate = truncate_to_range

      if (NOT truncate) then
         ENSURE(thevalue.is_in_range(.data.element_range),"value out of range")
      else
         thevalue = min(thevalue,maxval(.data))
         thevalue = max(thevalue,minval(.data))
      end

      i1 = count(.data<=thevalue) ! assuming .data is ordered !
      i1 = min(i1,.n_data-1)
      i2 = i1 + 1

      frac   = (thevalue - .data(i1))/(.data(i2)-.data(i1))
      colour = .RGB(:,i2) - .RGB(:,i1)
      res    = .RGB(:,i1) + frac*colour

   end

   RGB255_for(value) result (res) ::: PURE
   ! Return the RGB255 triple corresponding to a certain "value".
      self :: IN
      value :: REAL, IN
      res :: VEC{INT}(3)

   ENSURE(.finalized,"not finalized")
   ENSURE(value.is_in_range(.data.element_range),"value out of range")

      colour :: VEC{REAL}(3)
      frac :: REAL
      i1,i2 :: INT

      i1 = count(.data<=value) ! assuming .data is ordered !
      i1 = min(i1,.n_data-1)
      i2 = i1 + 1

      frac   = (value - .data(i1))/(.data(i2)-.data(i1))
      colour = .RGB(:,i2) - .RGB(:,i1)
      res    = nint(255*(.RGB(:,i1) + frac*colour))

   end

   get_RGB_for(values,RGB) ::: PURE
   ! Return the "RGB" triples corresponding to a set of "values".
      self :: IN
      values :: VEC{REAL}, IN
      RGB :: MAT{REAL}, OUT

   ENSURE(.finalized,"not finalized")
   ENSURE(RGB.dim1==3,"first dimension of RGB array must be 3")
   ENSURE(RGB.dim2==values.dim,"values and RGB are incompatible")

      i :: INT

      do i = 1,values.dim
         RGB(:,i) = .RGB_for(values(i))
      end

   end

   get_RGB_for(values,RGB) ::: PURE
   ! Return the "RGB" triples corresponding to a set of "values".
      self :: IN
      values :: VEC{REAL}, IN
      RGB :: MAT{INT}, OUT

   ENSURE(.finalized,"not finalized")
   ENSURE(RGB.dim1==3,"first dimension of RGB array must be 3")
   ENSURE(RGB.dim2==values.dim,"values and RGB are incompatible")

      i :: INT

      do i = 1,values.dim
         RGB(:,i) = nint(.RGB_for(values(i)))
      end

   end


   get_RGB255_for(values,RGB255) ::: PURE
   ! Return the "RGB255" triples corresponding to a set of "values".
      self :: IN
      values :: VEC{REAL}, IN
      RGB255 :: MAT{INT}, OUT

   ENSURE(.finalized,"not finalized")
   ENSURE(RGB255.dim2==values.dim,"values and RGB255 are incompatible")

      i :: INT

      do i = 1,values.dim
         RGB255(:,i) = .RGB255_for(values(i))
      end

   end

   rescale_data(range) ::: PURE
   ! Rescale the .data so that the lowest value corresponds to
   ! range(1), and the largest value corresponds to range(2).
      self :: INOUT
      range :: VEC{REAL}(2), IN

   ENSURE(.data.allocated,"no data")
   ENSURE(.n_data>1,"not enough data")

      data1,del,frac :: REAL
      i :: INT

      data1 = .data(1)
      del   = .data(.n_data) - data1

      do i = 1,.n_data
         frac = (.data(i) - data1)/del
         .data(i) = range(1) + frac*(range(2)-range(1))
      end

   end

  rescale_RGB(range) ::: PURE
  ! Rescale the .RGB so that the lowest value corresponds to
  ! range(1), and the largest value corresponds to range(2).
     self :: INOUT
     range :: VEC{REAL}(2), IN

  ENSURE(.RGB.allocated,"no data")
  ENSURE(.n_data>1,"not enough data")

     minv,maxv,del,frac :: VEC{REAL}(3)
     i :: INT
    
     minv = [ minval(.RGB(:,1)),minval(.RGB(:,2)),minval(.RGB(:,3)) ]
     maxv = [ maxval(.RGB(:,1)),maxval(.RGB(:,2)),maxval(.RGB(:,3)) ]
    
     del  = maxv - minv
    
     do i = 1,.n_data
        frac = (.RGB(i,:) - minv)/del
        .RGB(i,:) = range(1) + frac*(range(2)-range(1))
     end

  end

   set_default_colours(values) ::: leaky, PURE
   ! Set up default colours for a set of "values".
      self :: INOUT
      values :: VEC{REAL}(2), IN
      .rescale_data(values.element_range)
   end

!  ==============
!  Output methods
!  ==============

   put
   ! Put the list of interpolating colours.
      self :: IN

      i :: INT

      stdout.flush
      stdout.text("Colour function data")
      stdout.flush
      stdout.show("No. of interpolating data points =",.n_data)
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      stdout.put("#",int_width=TRUE)
      stdout.put("Data")
      stdout.put("Red")
      stdout.put("Green")
      stdout.put("Blue")

      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      do i = 1,.n_data
         stdout.put(i)
         stdout.put(.data(i))
         stdout.put(.RGB(1,i))
         stdout.put(.RGB(2,i))
         stdout.put(.RGB(3,i))
         stdout.flush
      end

      stdout.dash(int_fields=1,real_fields=4)

   end

end

