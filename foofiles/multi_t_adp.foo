!-------------------------------------------------------------------------------
!
! MULTI_T_ADP
!
! An object to fit normal modes to multi-temperature ADP's.
!
! NOTE: an associated crystal and atom list should be supplied. It is
! intended that these will come from the molecule which generates the
! cluster (perhaps a cluster should contain a molecule?). 
!
! Copyright (C) Dylan Jayatilaka, 2008
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: $
!-------------------------------------------------------------------------------

module MULTI_T_ADP

   implicit none


   debug_list :: VEC{STR}*, private  DEFAULT_NULL

contains

   create ::: get_from(OBJECT), leaky
   ! Create an object. This version does not set defaults.
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   nullify_ptr_part
   ! Nullify the pointer parts

      nullify(.cif_file_name)
      nullify(.equality_constraints)
      nullify(.decoupled_parameters)
      nullify(.atom)
      nullify(.temperature)
      nullify(.temperature_sigma)
      nullify(.unit_cell)
      nullify(.unit_cell_sigma)
      nullify(.ADP)
      nullify(.ADP_cov)
      nullify(.ADP_wt)
      nullify(.V_coeff)
      nullify(.Delta_V_on_V)
      nullify(.parameter_description)
      nullify(.L)
      nullify(.lambda)
      nullify(.omega)
      nullify(.amplitude)
      nullify(.gamma_G)
      nullify(.near_0_eigenvalues)
      nullify(.near_0_eigenvectors)
      nullify(.delta_p)
      nullify(.covariance_matrix)
      nullify(.correlation_matrix)

   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts

      .cif_file_name.destroy
      .equality_constraints.destroy
      .decoupled_parameters.destroy

      .destroy_data_ptr_part

   end

   destroy_data_ptr_part ::: leaky
   ! Destroy the pointer parts

      .atom.destroy
      .temperature.destroy
      .temperature_sigma.destroy
      .unit_cell.destroy
      .unit_cell_sigma.destroy
      .ADP.destroy
      .ADP_cov.destroy
      .ADP_wt.destroy
      .V_coeff.destroy
      .Delta_V_on_V.destroy
      .parameter_description.destroy
      .L.destroy
      .lambda.destroy
      .omega.destroy
      .amplitude.destroy
      .gamma_G.destroy
      .near_0_eigenvalues.destroy
      .near_0_eigenvectors.destroy
      .delta_p.destroy
      .covariance_matrix.destroy
      .correlation_matrix.destroy

   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(object) ::: leaky
   ! Copy an object
      object :: MULTI_T_ADP, IN

      self = object

      .nullify_ptr_part

      COPY_FROM_OBJECT(equality_constraints)
      COPY_FROM_OBJECT(decoupled_parameters)
      COPY_FROM_OBJECT(atom)
      COPY_FROM_OBJECT(cif_file_name)
      COPY_FROM_OBJECT(temperature)
      COPY_FROM_OBJECT(temperature_sigma)
      COPY_FROM_OBJECT(unit_cell)
      COPY_FROM_OBJECT(unit_cell_sigma)
      COPY_FROM_OBJECT(ADP)
      COPY_FROM_OBJECT(ADP_cov)
      COPY_FROM_OBJECT(ADP_wt)
      COPY_FROM_OBJECT(V_coeff)
      COPY_FROM_OBJECT(Delta_V_on_V)
      COPY_FROM_OBJECT(parameter_description)
      COPY_FROM_OBJECT(L)
      COPY_FROM_OBJECT(lambda)
      COPY_FROM_OBJECT(omega)
      COPY_FROM_OBJECT(amplitude)
      COPY_FROM_OBJECT(gamma_G)
      COPY_FROM_OBJECT(near_0_eigenvalues)
      COPY_FROM_OBJECT(near_0_eigenvectors)
      COPY_FROM_OBJECT(delta_p)
      COPY_FROM_OBJECT(covariance_matrix)
      COPY_FROM_OBJECT(correlation_matrix)

   end

!  ===========
!  Set methods
!  ===========

   set_defaults
   ! Set up defaults. 

      ! Program options

      .fit_method                 =  "second-order-least-squares"

      .V_expansion_order          = MULTI_T_ADP_V_EXPANSION_ORDER

      .use_V_linear_term          = TRUE
      .use_translations           = TRUE
      .use_librations             = TRUE
      .use_fixed_H_modes          = FALSE
      .use_fixed_non_H_modes      = FALSE
      .n_internal                 = 0
      .project_onto_initial_modes = FALSE
      .n_project                  = -1

      .max_iterations             = MULTI_T_ADP_MAX_ITER
      .min_iterations             = MULTI_T_ADP_MIN_ITER  
      .tol_shift_convergence      = MULTI_T_ADP_TOL_SHIFT_CONV
      .max_allowed_shift          = MULTI_T_ADP_MAX_SHIFT

      .show_correlations          = FALSE
      .min_correlation            = MULTI_T_ADP_MIN_CORRELATION
      .show_near_0_eigenvectors   = FALSE
      .tol_0                    = MULTI_T_ADP_TOL_0
      .tol_near_0               = MULTI_T_ADP_TOL_NEAR_0

      .cif_files_read             = FALSE
      .initialised                = FALSE

      ! Experimental data

      .n_T         = 0
      .n_atom      = 0
      .n3N         = 0
      .n6N         = 0
      .n9N         = 0

      ! Model info

      .n_modes                  = 0

      .iteration                = ZERO
      .chi2                     = ZERO
      .chi2_old                 = ZERO
      .n_0                      = 0
      .n_near_0                 = 0

   end

   set_fit_method(method)
   ! Set the fit method
      method :: STR
      .fit_method = method
      .fit_method.to_lower_case
      select case (.fit_method)
         case("first-order-least-squares")
         case("second-order-least-squares")
         case default;   UNKNOWN(.fit_method)
      end
   end

   set_tol_shift_convergence(val)
   ! Set "val", the tolerance for deciding when the normal equations
   ! are converged.
      val :: REAL
      stdin.read(val)
      ENSURE(val>ZERO,"tol_near_0 must be positive")
      .tol_shift_convergence = val
   end

   set_use_translations(val)
   ! Set whether to use translational normal modes
      val :: BIN
      .use_translations = val
   end

   set_use_librations(val)
   ! Set whether to use translational normal modes
      val :: BIN
      .use_librations = val
   end

   set_use_V_linear_term(val)
   ! Set whether to use the linear term in fitting the
   ! volume of the unit cell.
      val :: BIN
      .use_V_linear_term = val
   end

   set_use_fixed_H_modes(val)
   ! Set whether to use fixed H modes
   ! i.e. "epsilon" tensors for H atoms
      val :: BIN
      .use_fixed_H_modes = val
   end

   set_use_fixed_non_H_modes(val)
   ! Set whether to use fixed non H modes
   ! i.e. "epsilon" tensors for H atoms
      val :: BIN
      .use_fixed_non_H_modes = val
   end

   set_n_internal(n)
   ! Set the number of internal modes to use
      n :: INT
      .n_internal = n
   end

   set_n_project(n)
   ! Set the number of initial modes to project
      n :: INT
      .n_project = n
   end

   set_project_onto_init_modes(val)
   ! Set whether to project onto the initial
   ! normal modes.
      val :: BIN
      .project_onto_initial_modes = val
   end

   set_max_allowed_shift(val)
   ! Set the maximum allowed shift
      val :: REAL
      .max_allowed_shift = val
   end

   set_max_iterations(m)
   ! Set the maximum no of allowed least-squares iterations
      m :: INT
      .max_iterations = m
   end

   set_min_iterations(m)
   ! Set the minimum no of allowed least-squares iterations
      m :: INT
      .min_iterations = m
   end

   set_min_correlation(val)
   ! Set the minimum correlation between parameters to display
      val :: REAL
      .min_correlation = val
   end

   set_show_correlations(val)
   ! Set whether to show correlations between parameters
      val :: BIN
      .show_correlations = val
   end

   set_V_expansion_order(n)
   ! Set the order of the polynomial to fit
   ! the T-dependent unit cell volume.
      n :: INT
      ENSURE(n>=0,"n must be non-negative")
      .V_expansion_order = n
   end

!  =============
!  Input methods
!  =============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      keyword :: STR
      word :: STR
      word = keyword
      word.to_lower_case
      select case (word)
         case ("}                             ")  ! exit case
         case ("cif_file_names=               "); .read_CIF_file_names
         case ("fit_method=                   "); .read_fit_method
         case ("initialise_modes              "); .initialise_modes
         case ("least_squares                 "); .least_squares
         case ("make_v_expansion_coeffs       "); .make_V_expansion_coeffs
         case ("max_allowed_shift=            "); .read_max_allowed_shift
         case ("max_iterations=               "); .read_max_iterations
         case ("min_iterations=               "); .read_min_iterations
         case ("n_internal=                   "); .read_n_internal
         case ("n_project=                    "); .read_n_project
         case ("project_onto_initial_modes=   "); .read_project_onto_init_modes
         case ("put                           "); .put
         case ("put_debug_list                "); .put_debug_list
         case ("read_cifs                     "); .read_CIFs
         case ("show_correlations=            "); .read_show_correlations
         case ("tolerance_shift_convergence=  "); .read_tol_shift_convergence
         case ("units=                        "); MULTI_T_ADP::read_units
         case ("use_fixed_h_modes=            "); .read_use_fixed_H_modes
         case ("use_fixed_non_h_modes=        "); .read_use_fixed_non_H_modes
         case ("use_librations=               "); .read_use_librations
         case ("use_translations=             "); .read_use_translations
         case ("use_v_linear_term=            "); .read_use_V_linear_term
         case ("v_expansion_order=            "); .read_V_expansion_order
         case default;     UNKNOWN(word)
      end
   end

   read_units ::: get_from(OBJECT), selfless, private
   ! Read a string which describes the units to be used
   end

   read_CIF_file_names ::: leaky
   ! Read the cif file names containing the multi-temperature ADP data
      stdin.read_ptr(.cif_file_name)
   end

   read_fit_method
   ! Read the method used to do the ADP fit
      fit_method :: STR
      stdin.read(fit_method)
      .set_fit_method(fit_method)
   end

   read_max_allowed_shift
   ! Read the number of internal modes
      val :: REAL
      stdin.read(val)
      .set_max_allowed_shift(val)
   end

   read_max_iterations
   ! Read the maximum allowed least-squares iterations
      m :: INT
      stdin.read(m)
      .set_max_iterations(m)
   end

   read_min_iterations
   ! Read the minimum allowed least-squares iterations
      m :: INT
      stdin.read(m)
      .set_min_iterations(m)
   end

   read_n_internal
   ! Read the number of internal modes
      n :: INT
      stdin.read(n)
      .set_n_internal(n)
   end

   read_n_project
   ! Read the number of initial modes to project
      n :: INT
      stdin.read(n)
      .set_n_project(n)
   end

   read_show_correlations
   ! Read whether to show correlations between parameters
      val :: BIN
      stdin.read(val)
      .set_show_correlations(val)
   end

   read_tol_shift_convergence
   ! Read the tolerance for deciding when the normal equations are converged.
      val :: REAL
      stdin.read(val)
      .set_tol_shift_convergence(val)
   end

   read_use_librations
   ! Read the number of librational modes
      val :: BIN
      stdin.read(val)
      .set_use_librations(val)
   end

   read_use_translations
   ! Read the number of internal modes
      val :: BIN
      stdin.read(val)
      .set_use_translations(val)
   end

   read_use_fixed_H_modes
   ! Read whether tyo use fixed H modes
   ! i.e. "epsilon" tesnors for H atoms
      val :: BIN
      stdin.read(val)
      .set_use_fixed_H_modes(val)
   end

   read_use_fixed_non_H_modes
   ! Read whether to use fixed non H modes
   ! i.e. "epsilon" tensors for heavy atoms
      val :: BIN
      stdin.read(val)
      .set_use_fixed_non_H_modes(val)
   end

   read_project_onto_init_modes
   ! Set whether to project onto the initial
   ! normal modes.
      val :: BIN
      stdin.read(val)
      .set_project_onto_init_modes(val)
   end

   read_use_V_linear_term
   ! Set whether to use the linear term in fitting the
   ! volume of the unit cell.
      val :: BIN
      stdin.read(val)
      .set_use_V_linear_term(val)
   end

   read_V_expansion_order
   ! Read the order of the T-dependent polynomial to
   ! expans the unit cell volumes
      n :: INT
      stdin.read(n)
      .set_V_expansion_order(n)
   end

!  ==================
!  Output information
!  ==================

   put
   ! Put the list of vertices for the object
   ENSURE(.initialised,"not initialised")

      t,a :: INT

      stdout.flush
      stdout.text("MULTI_T_ADP object:")
      stdout.flush
      stdout.show("Fit method              =",.fit_method)
      stdout.show("Number of temperatures  =",.n_T)
      stdout.show("Number of atoms         =",.atom.dim)

      ! Loop over temperaures and echo the data
      do t = 1,.n_T

         stdout.flush
         stdout.show("Data set =",t)
         stdout.show("T        =",.temperature(t))
         stdout.show("sigma(T) =",.temperature_sigma(t))
         stdout.flush

         stdout.text("Cell information (in Angstrom and Degrees):")

         stdout.dash(int_fields=1,real_fields=2)
         stdout.tab(int_fields=1)
         stdout.put("cell data",int_width=TRUE)
         stdout.put("value")
         stdout.put("sigma")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=2)

         stdout.put("a",int_width=TRUE)
         stdout.put(.unit_cell(t).length(1).to_units("angstrom"))
         stdout.put(.unit_cell_sigma(t).length(1).to_units("angstrom"))
         stdout.flush

         stdout.put("b",int_width=TRUE)
         stdout.put(.unit_cell(t).length(2).to_units("angstrom"))
         stdout.put(.unit_cell_sigma(t).length(2).to_units("angstrom"))
         stdout.flush

         stdout.put("c",int_width=TRUE)
         stdout.put(.unit_cell(t).length(3).to_units("angstrom"))
         stdout.put(.unit_cell_sigma(t).length(3).to_units("angstrom"))
         stdout.flush

         stdout.put("alpha",int_width=TRUE)
         stdout.put(.unit_cell(t).angle(1).to_units("degree"))
         stdout.put(.unit_cell_sigma(t).angle(1).to_units("degree"))
         stdout.flush

         stdout.put("beta",int_width=TRUE)
         stdout.put(.unit_cell(t).angle(2).to_units("degree"))
         stdout.put(.unit_cell_sigma(t).angle(2).to_units("degree"))
         stdout.flush

         stdout.put("gamma",int_width=TRUE)
         stdout.put(.unit_cell(t).angle(3).to_units("degree"))
         stdout.put(.unit_cell_sigma(t).angle(3).to_units("degree"))
         stdout.flush

         stdout.dash(int_fields=1,real_fields=2)

         stdout.flush
         stdout.text("ADP information (in Angstrom^2, cartesian axis system):")

         stdout.dash(int_fields=1,real_fields=6)
         stdout.put("U(11)")
         stdout.put("U(21)")
         stdout.put("U(22)")
         stdout.put("U(31)")
         stdout.put("U(32)")
         stdout.put("U(33)")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=6)

         do a = 1,.n_atom

            stdout.flush
            stdout.put(trim(.atom(a).label)//"("//trim(a.to_str)//")",int_width=TRUE)
            stdout.flush
            stdout.flush
   
            stdout.put(.ADP(t)[1,a].to_units("angstrom^2"))
            stdout.put(.ADP(t)[2,a].to_units("angstrom^2"))
            stdout.put(.ADP(t)[3,a].to_units("angstrom^2"))
            stdout.put(.ADP(t)[4,a].to_units("angstrom^2"))
            stdout.put(.ADP(t)[5,a].to_units("angstrom^2"))
            stdout.put(.ADP(t)[6,a].to_units("angstrom^2"))
            stdout.flush

         end

         stdout.dash(int_fields=1,real_fields=6)

      end

      stdout.flush
      stdout.text("Covariance matrices (in bohr, cartesian axis system):")

      ! Loop over temperaurea and echo the data
      do t = 1,.n_T

         stdout.flush
         stdout.show("Data set =",t)
         stdout.show("T        =",.temperature(t))
         stdout.flush

         stdout.text("Covariance:")
         stdout.put(.ADP_cov(t).element)

      end

   end

!  ==========
!  Initialise
!  ==========

! Process the cif files

   read_CIFs ::: leaky
   ! Set up the starting info
   ENSURE(.cif_file_name.created,"no cif_files")

      cif :: CIF*
      atom :: VEC{ATOM}*
      cov :: MAT{REAL}*
      found :: BIN
      name :: STR
      i,a :: INT

      ! Clean everything except the cif files
      .destroy_data_ptr_part

      ! Set the number of temperatures
      ENSURE(.cif_file_name.created,"no cif file names provided")
      ENSURE(.cif_file_name.dim>1,"no cif file names provided")
      .n_T = .cif_file_name.dim

      ! Read atom positions from the first CIF
      .atom.read_CIF(.cif_file_name(1))
      .n_atom = .atom.dim
      .n3N    = 3*.n_atom
      .n6N    = 6*.n_atom
      .n9N    = 9*.n_atom
      ENSURE(.n_atom>=3,"must have at least three atoms")

      ! Create space for the needed info
      .temperature.create(.n_T)
      .temperature_sigma.create(.n_T)
      .unit_cell.create(.n_T)
      .unit_cell_sigma.create(.n_T)
      .ADP.create(.n_T)
      .ADP_cov.create(.n_T)
      .ADP_wt.create(.n_T)

      ! Process the cif files
      do i = 1,.n_T

         ! Space for the covariances
         .ADP(i).element.create(6,.n_atom)
         .ADP_cov(i).element.create(.n6N,.n6N)
         .ADP_wt(i).element.create(.n6N,.n6N)

         ! Open the CIF and find the data ... 
         ! It must be the first data block
         name = .cif_file_name(i)
         cif.create(name)
         cif.open
         cif.find_crystal_data_block(found)
         ENSURE(found,"no crystal data block found") 

         ! Read the temperature
         cif.read_item("_cell_measurement_temperature",.temperature(i),.temperature_sigma(i))

         ! Read the unit cell
         .unit_cell(i).read_CIF(cif,.unit_cell_sigma(i))

         ! Read the atoms
         atom.read_CIF(.cif_file_name(i))
         atom.change_axis_system_to("cartesian",.unit_cell(i))
         ENSURE(atom.dim==.n_atom,"file "//trim(name)//" has inconsistent no. of atoms")

         ! Set the ADP tensor 
         do a = 1,.n_atom
            .ADP(i).element(1,a) = atom(a).ADP_tensor(1,1)
            .ADP(i).element(2,a) = atom(a).ADP_tensor(2,1)
            .ADP(i).element(3,a) = atom(a).ADP_tensor(2,2)
            .ADP(i).element(4,a) = atom(a).ADP_tensor(3,1)
            .ADP(i).element(5,a) = atom(a).ADP_tensor(3,2)
            .ADP(i).element(6,a) = atom(a).ADP_tensor(3,3)
         end

         ! Read covariance matrix and extract ADP block and weights
         cov.create(.n9N,.n9N)
         cif.read_item("_covariance_matrix",cov)
         cov.put_sub_blocks_to(.ADP_cov(i).element,block_dim=9,X_block_dim=6,X_block_offset=3)
         .ADP_wt(i).element.to_inverse_of(.ADP_cov(i).element)
         cov.destroy

         ! Read the number of normal modes
         cif.read_item("_n_ADP_modes",.n_modes,found)

         ! Read in the modes
         if (found) then
            .L.create(.n3N,.n_modes)
            .omega.create(.n_modes)
            .gamma_G.create(.n_modes)
            cif.read_item("_ADP_cartesian_modes",.L)
            cif.read_item("_ADP_mode_frequencies",.omega)
            cif.read_item("_ADP_mode_Grueneisens",.gamma_G)
         end

         ! Clean up
         atom.destroy
         cif.destroy

      end

      .cif_files_read = TRUE

   end

! Get the initial modes

   initialise_modes ::: leaky
   ! Initialise modes
      .initialise_modes(.use_translations,.use_librations,.use_fixed_H_modes,.n_internal)
      .initialised = TRUE
   end

   initialise_modes(translations,librations,fixed_H_modes,n_internal) ::: leaky
   ! Set up the starting model for the normal modes.
   ! If translations is TRUE then set those three up
   ! If libration is TRUE then set the next three to be those
   ! If n_internal is greater than zero then a series of random
   ! vectors orthogonal to the others is started up.
      translations,librations,fixed_H_modes :: BIN
      n_internal :: INT

      n,n_H :: INT

      ! Clean the modes
      .L.destroy
      n = 0

      ! Make translational modes
      if (translations) then
         .L.expand(.n3N,3)
         .initialise_translations(.L(:,n+1:n+3))
         n = n + 3
      end

      ! Make librational modes
      if (librations) then
         .L.expand(.n3N,3)
         .initialise_librations(.L(:,n+1:n+3))
         n = n + 3
      end

      ! Make fixed H modes
      if (fixed_H_modes) then
         n_H = count(.atom.atomic_number==1)
         .L.expand(.n3N,3*n_H)
         .atom.initialise_local_H_modes(.L(:,n+1:n+3*n_H))
         n = n + 3*n_H
      end

      ! Make librational modes
      if (n_internal>0) then
         .initialise_random_internal(.L(:,n+1:n+n_internal),n_internal)
         n = n + n_internal
         DIE_IF(n>.n3N,"too many initial normal modes!")
      end

      ! Orthnormalise
      .L.schmidt_orthonormalise

      ! Assign modes
      .n_modes = n

      ENSURE(.L.created,"no modes were created")

   end

   initialise_translations(L)
   ! Set up the starting model for the normal modes.
   ! If translations is TRUE then set those three up
   ! If libration is TRUE then set the next three to be those
   ! If n_internal is greater than zero then a series of random
   ! vectors orthogonal to the others is started up.
      L :: MAT{REAL}(.n3N,3)

      i,k :: INT
            
      ! Expand and zero
      L = ZERO

      ! Assign the x,y,z modes
      k =  0
      do i = 1,.n_atom
         L(k+1,1) = ONE
         L(k+2,2) = ONE
         L(k+3,3) = ONE
         k = k + 3
      end

      ! Normalise columns
      L(:,1).normalise
      L(:,2).normalise
      L(:,3).normalise

   end

   initialise_librations(L)
   ! Set up the starting model for the normal modes.
   ! If translations is TRUE then set those three up
   ! If libration is TRUE then set the next three to be those
   ! If n_internal is greater than zero then a series of random
   ! vectors orthogonal to the others is started up.
      L :: MAT{REAL}(.n3N,3)

      unit :: MAT{REAL}(3,3)
      r,com :: VEC{REAL}(3)
      i,k :: INT

      ! Unit vectors
      unit.to_unit_matrix

      ! Center of mass
      com = .atom.center_of_mass

      ! Assign the x,y,z modes
      ! Warning: will not work for linear molecules
      k = 0
      do i = 1,.n_atom
         r = .atom(i).position - com
         L(k+1:k+3,1).to_cross_product_of(unit(:,1),r)
         L(k+1:k+3,2).to_cross_product_of(unit(:,2),r)
         L(k+1:k+3,3).to_cross_product_of(unit(:,3),r)
         k = k + 3
      end

      ! Orthonormalise 
      L.schmidt_orthonormalise

   end

   initialise_random_internal(L,n_internal)
   ! Set up the starting model for the normal modes.
   ! If translations is TRUE then set those three up
   ! If libration is TRUE then set the next three to be those
   ! If n_internal is greater than zero then a series of random
   ! vectors orthogonal to the others is started up.
      L :: MAT{REAL}(.n3N,n_internal)
      n_internal :: INT

      ! Get the vectors
      call random_number(L)

      ! Orthonormalise
      L.schmidt_orthonormalise

   end

   put_model_parameters_into(X) 
   ! Put the model parameters into parameter vector "X".
      X :: VEC{REAL}(.n_total_parameters), OUT

      g,i,p :: INT

      ! Parameter count
      p = 0

      ! Set from .L
      do i = 1,.n_modes
      do g = 1,.n3N
         p = p + 1
         X(p) = .L(g,i)
      end
      end

      ! Set from .omega
      do i = 1,.n_modes
         p = p + 1
         X(p) = .omega(i)
      end

      ! Set from .omega
      do i = 1,.n_modes
         p = p + 1
         X(p) = .gamma_G(i)
      end

   end

   set_model_parameters_from(X) 
   ! Set the model parameters from parameter vector "X".
      X :: VEC{REAL}(.n_total_parameters), IN

      g,i,p :: INT

      ! Parameter count
      p = 0

      ! Set from .L
      do i = 1,.n_modes
      do g = 1,.n3N
         p = p + 1
         .L(g,i) = X(p)
      end
      end

      ! Set from .omega
      do i = 1,.n_modes
         p = p + 1
         .omega(i) = X(p)
      end

      ! Set from .omega
      do i = 1,.n_modes
         p = p + 1
         .gamma_G(i) = X(p)
      end

   end

!  Volume coefficients

   make_V_expansion_coeffs ::: leaky
   ! Expansion coefficients for change in volume for data at
   ! temperature "t"
   ENSURE(.unit_cell.created,"no unit_cells")
   ENSURE(.temperature.created,"no temperatures")

      Y :: VEC{REAL}*
      X,M :: MAT{REAL}*
      n,fi, t,i,j :: INT

      ! Expansion order
      n = .V_expansion_order

      ! Matrix of fit function values
      .V_coeff.destroy
      if (.use_V_linear_term) then
         .V_coeff.create(n+1)
         X.create(.n_T,n+1)
         fi = 1
      else
         .V_coeff.create(n)
         X.create(.n_T,n)
         fi = 2
      end
      Y.create(.n_T)

      ! Make fit function values
      do t = 0,.n_T

         ! RHS to be fitted
         Y(t) = .unit_cell(t).volume

         ! Unit basis function
         X(t,1) = ONE

         ! Remaining polynomials
         j = 1
         do i = fi,.V_expansion_order
            j = j + 1
            X(t,j) = .temperature(t)==i
         end
      end

      ! Make the LHS and solve
      M.create(.n_T,.n_T)
      M.to_product_of(X,X,transpose_a=TRUE)
      M.to_inverse_of(M)
      M = matmul(M,transpose(X))

      ! Get the fit coefficients 
      .V_coeff = matmul(M,Y)

      ! Get relative volume changes
      .Delta_V_on_V.destroy
      .Delta_V_on_V.create(.n_T)
      do t = 1,.n_T
         .Delta_V_on_V(t) = (.fitted_V(t) - .V_coeff(1))/.V_coeff(1)
      end

      ! Clean
      M.destroy
      Y.destroy
      X.destroy

   end

   fitted_V(t) result (res)
   ! Return the fitted volume at temperature for data set "t"
      t :: INT, IN
      res :: REAL

   ENSURE(.V_coeff.created,"no V coefficients")
   ENSURE(.temperature.created,"no V coefficients")
   ENSURE(t>=1,"wrong t value")
   ENSURE(t<=.n_T,"wrong t value")

      fi,i,j :: INT

      ! Matrix of fit function values
      if (.use_V_linear_term) then
         fi = 1
      else
         fi = 2
      end

      res = .V_coeff(1)
      j = 1
      do i = fi,.V_expansion_order
         j = j + 1
         res = res + .V_coeff(j)*.temperature(t)==i
      end

   end

   Delta_V(t) result (res)
   ! Return the fitted volume minus observed at temperature for data
   ! set "t"
      t :: INT, IN
      res :: REAL
      res = .fitted_V(t) - .unit_cell(t).volume
   end

   fitted_V_residual2 result (res)
   ! Return the fitted volume residual squared summed over all
   ! temperatures.
      res :: REAL

      del :: REAL
      t :: INT

      res = ZERO
      do t = 1,.n_T
         del = .Delta_V(t)
         res = res + del*del
      end

   end

   put_unit_cell_volumes
   ! Put the unit cell volumes and fitting results
   ENSURE(.V_coeff.created,"no .V_coeffs")
   ENSURE(.Delta_V_on_V.created,"no .Delta_V_on_V")

      coeff :: VEC{REAL}*
      t :: INT

      stdout.flush
      stdout.text("Fitted unit cell volumes:")

      stdout.flush
      stdout.show("# of fit parameters =",.V_coeff.dim)
      stdout.show("chi2                =",.fitted_V_residual2/.V_coeff.dim)
      stdout.show("Linear term in fit? =",.use_V_linear_term)

      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      stdout.put("Cell")
      stdout.put("T")
      stdout.put("V")
      stdout.put("V(fit)")
      stdout.put("Delta")
      stdout.put("Delta V/V")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)

      do t = 1,.n_T

         stdout.put(t)
         stdout.put(.temperature(t))
         stdout.put(.unit_cell(t).volume)
         stdout.put(.fitted_V(t))
         stdout.put(.Delta_V(t))
         stdout.put(.Delta_V_on_V(t))
         stdout.flush

      end

      stdout.dash(int_fields=1,real_fields=5)


      stdout.flush
      stdout.text("Volume fit polynomial coefficients:")

      stdout.flush
      stdout.show("Linear term in fit? =",.use_V_linear_term)
      stdout.flush

      if (.use_V_linear_term) then
         coeff.create_copy(.V_coeff)
      else
         coeff.create(.V_coeff.dim+1)
         coeff(1)  = .V_coeff(1)
         coeff(2)  = ZERO
         coeff(3:) = .V_coeff(2:)
      end

      do t = 1,coeff.dim
         stdout.put(t-1)
         stdout.put(coeff(t))
         stdout.flush
      end

      coeff.destroy

   end

!  =============
!  Least squares
!  =============

   least_squares
   ! Do the least squares fitting procedure
   ENSURE(.cif_files_read,"no cif files read")
   ENSURE(.initialised,"no initial guess")
   ENSURE(.V_coeff.created,"no V_coeff's")

      .use_fixed_H_modes,LL,fac :: REAL
      XX,X0,dX, GG :: VEC{REAL}*
      HH :: MAT{REAL}*
      MM :: MAT3{REAL}*
      np,nt :: INT
      finished,chi2_increased :: BIN


      ! Constants
      np = .n_parameters
      nt = .n_total_parameters

      ! Create space
      X0.create(nt)
      XX.create(nt)
      dX.create(nt)
      GG.create(nt)
      HH.create(nt,nt)
      MM.create(np,.n6N,.n_T)
      .covariance_matrix.create(nt,nt)
      .correlation_matrix.create(nt,nt)

      ! Get the initial parameters
      .initialise_modes(.use_translations,.use_librations,.use_fixed_H_modes,.n_internal)

      ! Store initial parameter vector
      .put_model_parameters_into(X0) 

      ! Banner and initialise refinement
      .put_iteration_header

      ! Begin refinement loop
      .iteration = 0
      .n_ind_params = .n_independent_parameters
      .chi2_old = huge(ONE)

      do
 
         ! Increment iteration count
         .iteration = .iteration + 1

         ! Make the least squares matrices
         .make_least_squares(LL,GG,HH,MM) 
   
         ! Solve for the shifts (leaky)
         HH.solve_ill_linear_equations(GG,dX,.tol_0,.n_0,.tol_near_0,.n_near_0 &
                                      ,.near_0_eigenvalues,.near_0_eigenvectors &
                                      ,.delta_p,.covariance_matrix,.correlation_matrix)
         dX = -dX
   
         ! Set the number of independent parameters
         .n_ind_params = dX.dim - .n_near_0 

         ! Set parameters
         XX = X0 + dX
         .set_model_parameters_from(XX) 

         ! Set the chi2
         .chi2 = .the_chi2

         ! Get the standard deviations and covariances
         .delta_p           = sqrt(abs(.chi2*.delta_p))
         .covariance_matrix = .chi2*.covariance_matrix
   
         ! Get the maximum shift
         .max_shift        = maxval(abs(dX))
         .max_shift_on_esd = maxval(abs(dX/.delta_p))
   
         if (.debugging("least_squares:")) then 
            stdout.text("shifts dX:")
            stdout.put(dX,"column")
            stdout.show("Normal equations check =",maxval(abs(matmul(HH,dX)+GG)))
            stdout.show("Smallest eigenvalue    =",minval(abs(.near_0_eigenvalues)))
            stdout.show("tol_0                  =",.tol_0)
            stdout.show("n_0                    =",.n_0)
            stdout.show("tol_near_0             =",.tol_near_0)
            stdout.show("n_near_0               =",.n_near_0)
         end
   
         ! Renormalise shift if too big
         if (.max_shift>.max_allowed_shift) then
            fac = .max_allowed_shift/.max_shift
            dX = fac * dX
         end
   
         if (.debugging("solve_normal_equations")) then 
            stdout.text("shifts dX after renormalisation:")
            stdout.put(dX,"column")
            stdout.text("delta:")
            stdout.put(.delta_p,"column")
         end

         ! Put the results
         .put_iteration_results
 
         ! Finished?
         finished = .refinement_finished(chi2_increased)

         ! Roll back the parameters if necessary ...
         if (chi2_increased) then 
            XX = X0 
            .set_model_parameters_from(XX) 
            .chi2 = .chi2_old
         end

         if (finished) exit

         ! Store old parameters, add shift
         .chi2_old = .chi2
         X0 = XX
 
      end

      ! Banner and finalise refinement
      .put_iteration_footer

      ! Clean
      MM.destroy
      HH.destroy
      GG.destroy

   end

   make_least_squares(LL,GG,HH,MM) 
   ! Make "LL" the Lagrangian, "GG" the 1st derivative, and
   ! "HH" the 2nd derivative of the Lagrangian wrt all parameters.
   ! Make "MM" the mixed second derivatives for sensitivity analysis
   ! Note all parameters are done at this stage even if there are
   ! constraints on some of them.

      LL :: REAL
      GG :: VEC{REAL}(.n_total_parameters)
      HH :: MAT{REAL}(.n_total_parameters,.n_total_parameters)
      MM :: MAT3{REAL}(.n_parameters,.n6N,.n_T)

      Delta,Welta :: MAT{REAL}*
      d_Delta,d_Welta :: MAT3{REAL}*
      nL,nw,nG,nt :: INT

      ! No of parameters
      nL = .n3N*.n_modes
      nw = nL + .n_modes
      nG = nw + .n_modes
      nt = nG + .n_modes.triangle_number
   
      ! Make Delta: differences between calc & obs
      Delta.create(.n6N,.n_T)
      .make_Delta(Delta) 
   
      ! Make weighted Delta's
      Welta.create(.n6N,.n_T)
      .make_Welta(Welta,Delta) 

      ! Evaluate the Lagrangian
      LL = .Lagrangian(Delta,Welta)

      ! Make derivative Delta's wrt all parameters
      d_Delta.create(nG,.n6N,.n_T)
      .make_d_Delta_d_L(d_Delta(   1:nL,:,:)) 
      .make_d_Delta_d_w(d_Delta(nL+1:nw,:,:))
      .make_d_Delta_d_G(d_Delta(nw+1:nG,:,:))

      ! Make weighted derivative Delta's
      d_Welta.create(nG,.n6N,.n_T)
      .make_d_Welta(d_Welta,d_Delta) 

      !!! Gradient !!!
      GG = ZERO

      ! Make gradient from derivative Delta terms
      .add_d_Delta_gradient(GG(1:nG),d_Delta,Welta) 

      ! Add any constraint derivatives (only L needed)
      .add_d_C_d_L(GG(1:nL)) 

      ! Make gradient wrt to lagrange multipliers
      .add_d_C_d_lambda(GG(nG+1:nt)) 

      !!! Hessian !!!
      HH = ZERO

      ! Make the hessian wrt all parameters
      .add_d_Delta_hessian(HH(1:nG,1:nG),d_Delta,d_Welta) 

      ! Add diagonal 2nd derivative parts
      .add_d2_Delta_d2_L(HH(   1:nL,   1:nL),Welta) 
      .add_d2_Delta_d2_w(HH(nL+1:nw,nL+1:nw),Welta) 
      .add_d2_Delta_d2_G(HH(nw+1:nG,nw+1:nG),Welta) 

      ! Add mixed 2nd derivative parts
      .add_d2_Delta_d_L_d_w(HH(nL+1:nw,   1:nL),Welta) 
      .add_d2_Delta_d_L_d_G(HH(nw+1:nG,   1:nL),Welta) 
      .add_d2_Delta_d_w_d_G(HH(nw+1:nG,nL+1:nw),Welta) 

      ! Make Lagrange multiplier part
      .add_d2_C_d_L_d_lambda(HH(nG+1:nt,1:nL)) 

      ! Symmetrise
      HH.symmetric_reflect

      !!! Mixed parameter-data derivatives !!!
      MM = -(TWO/(.n6N - .n_independent_parameters)) * d_Welta

      ! Clean
      d_Welta.destroy
      d_Delta.destroy
      Welta.destroy
      Delta.destroy

      if (.debugging("make_least_squares")) then 
         stdout.show("LL =",LL)
         stdout.text("Gradient GG:")
         stdout.put(GG,"column")
         stdout.text("Hessian HH:")
         stdout.put(HH)
         stdout.text("Mixed derivatives, MM:")
         stdout.put(MM)
      end

   end

   put_refinement_params
   ! Put the refinement parameters

      stdout.flush
      stdout.text("==========================")
      stdout.text("ADP normal mode refinement")
      stdout.text("==========================")
      stdout.flush
      stdout.text("Initialisation for modes:")
      stdout.show("Use translations            =",.use_translations)
      stdout.show("Use librations              =",.use_translations)
      stdout.show("No of random internal modes =",.n_internal)
      stdout.show("No of modes                 =",.n_modes)
      stdout.flush
      stdout.show("Shift convergence criteria  =",.tol_shift_convergence)
      stdout.show("Max allowed parameter shift =",.max_allowed_shift)
      stdout.show("Zero eigenvalue tolerance   =",.tol_0)
      stdout.show("Nearly zero tolerance       =",.tol_near_0)
      stdout.show("Max iterations              =",.max_iterations)
      stdout.show("Min iterations              =",.min_iterations)

   end

   put_iteration_header
   ! Put the interation table header

      stdout.flush
      stdout.text("================")
      stdout.text("Start refinement")
      stdout.text("================")

      stdout.flush
      stdout.dash(int_fields=3,real_fields=3)
      stdout.put("Iter",int_width=TRUE)
      stdout.put("chi2")
      stdout.put("MaxShft")
      stdout.put("MaxShft/ESD")
      stdout.put("n_ind_params",int_width=TRUE)
      stdout.put("n_near_0",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=3,real_fields=3)

   end

   put_iteration_results
   ! Print out the current iterations results

      ! Iteration results
      stdout.put(.iteration)
      stdout.put(.chi2)
      stdout.put(.max_shift)
      stdout.put(.max_shift_on_esd)
      stdout.put(.n_ind_params)
      stdout.put(.n_near_0)
      stdout.flush

   end

   put_iteration_footer
   ! Put the iteration footer
      chi2_increased :: BIN
      finished,converged,too_many_iters :: BIN

      ! Table footer
      stdout.dash(int_fields=3,real_fields=3)

      stdout.flush
      stdout.text("==================")
      stdout.text("Refinement results")
      stdout.text("==================")
      stdout.flush

      ! How did it finish?
      finished = .refinement_finished(chi2_increased,too_many_iters,converged)
      DIE_IF(NOT finished,"Structure refinement seems not finished?")

      ! Print how it finished
      if (converged) then;           stdout.text("Refinement converged.")
      else if (chi2_increased) then; stdout.text("WARNING: Refinement stopped: chi2 has increased.")
      else if (too_many_iters) then; stdout.text("WARNING: Refinement stopped: too many iterations.")
      end

      ! Put final fitting statistics
      stdout.show("# of fit parameters, N_p    =", .n_ind_params)
      stdout.show("chi^2(N_p)                  =",.chi2)
      stdout.show("Goodness of fit (N_p)       =", sqrt(.chi2))

   end
 
   refinement_finished(chi2_increased,too_many,converged) result (res)
   ! Return whether the refinement has finished
      chi2_increased,too_many,converged :: BIN, OUT, optional

      res :: BIN
      tmp :: BIN

      ! If shifts less that tolerance - converged
      tmp = .max_shift_on_esd<.tol_shift_convergence
      if (present(converged)) converged = tmp
      res = tmp

      ! If chi2 increases - stop
      tmp = .chi2>.chi2_old AND .iteration>.min_iterations
      if (present(chi2_increased)) chi2_increased = tmp
      res = res OR tmp

      ! If too many iterations - stop
      tmp = .iteration>.max_iterations
      if (present(too_many)) too_many = tmp
      res = res OR tmp

   end

!  ================
!  Parameter counts
!  ================

   n_parameters result (res) ::: pure
   ! Return the number of parameters in the model
   ! NOT including lagrange multipliers
      self :: IN
      res :: INT

      res = .n3N*.n_modes                  ! L modes
      res = res + 2*.n_modes               ! omega & Grueneisen's

   end

   n_total_parameters result (res) ::: pure
   ! Return the total number of parameters in the model
   ! including lagrange multipliers
      self :: IN
      res :: INT

      res = .n3N*.n_modes                  ! L modes
      res = res + 2*.n_modes               ! omega & Grueneisen's
      res = res + .n_modes.triangle_number ! Lagrange multipliers

   end

   n_independent_parameters result (res) ::: pure
   ! Return the number of independent parameters in the model
   ! Zero eigenvalues are not accounted for yet ...
      self :: IN
      res :: INT

      res = .n3N*.n_modes                  ! L modes
      res = res + 2*.n_modes               ! omega & Grueneisen's
      res = res - .n_modes.triangle_number ! Subtract constraints

   end

!  ============================
!  0th derivative intermediates
!  ============================

   omega_bar(i,t) result (res)
   ! The omega bar value for mode "i" at temperature of data set "t"
      i,t :: INT, IN
      res :: REAL

   ENSURE(.Delta_V_on_V.created,"no Delta_V_on_V")
   ENSURE(.omega.created,"no omega")
   ENSURE(.omega.dim==.n_modes,"wrong size, omega")
   ENSURE(.gamma_G.created,"no gamma_G")
   ENSURE(.gamma_G.dim==.n_modes,"wrong size, gamma_G")
   ENSURE(i>=1,"wrong i value")
   ENSURE(i<=.n_modes,"wrong i value")
   ENSURE(t>=1,"wrong t value")
   ENSURE(t<=.n_T,"wrong t value")

      res = .omega(i)*(ONE-.gamma_G(i)*.Delta_V_on_V(t))

   end

   amplitude(i,t) result (res)
   ! The amplitude for mode "i" at temperature of data set "t"
      i,t :: INT, IN
      res :: REAL

   ENSURE(.omega.created,"no omega")
   ENSURE(.omega.dim==.n_modes,"wrong size, omega")
   ENSURE(i>=1,"wrong i value")
   ENSURE(i<=.n_modes,"wrong i value")
   ENSURE(t>=1,"wrong t value")
   ENSURE(t<=.n_T,"wrong t value")

      wb,val :: REAL

      wb  = .omega_bar(i,t)
      val = HALF*wb/(TWO*BOLTZMANN_SI*.temperature(i)/HARTREE_SI)
      res = (HALF/wb) * cosh(val)/sinh(val)

   end

   Delta(a,b,c,t) result (res)
   ! The calculated Delta U(a,b) for atom c at temp. of data set "t"
      a,b,c,t :: INT, IN
      res :: REAL

   ENSURE(a>=1,"wrong a value")
   ENSURE(a<=3,"wrong a value")
   ENSURE(b>=1,"wrong b value")
   ENSURE(a>=b,"b must not be larger than a")
   ENSURE(t>=1,"wrong t value")
   ENSURE(t<=.n_T,"wrong t value")
   ENSURE(.L.created,"no L")
   ENSURE(.L.dim1==.n3N,"wrong shape, L")
   ENSURE(.L.dim2==.n_modes,"wrong shape, L")

      ab,aa,bb,cc,i :: INT

      ! Index offsets into normal modes L
      cc = 3*(c-1)
      aa = cc + a
      bb = cc + b

      ! Make the calculated U(a,b,t)
      res = ZERO
      do i = 1,.n_modes
         res = res + .L(aa,i) * .amplitude(i,t) *.L(bb,i)
      end

      ! Get the delta: subtract observed ADP
      ab = a*(a-1)/2 + b 
      res = res - .ADP(t).element(ab,c)

   end


   make_Delta(Delta) 
   ! Make "Delta" the differences between the calculated and observed
   ! ADP elements at temeperature "t".
      Delta :: MAT{REAL}(.n6N,.n_T), OUT

      t, c,a,b,ab :: INT

      ! Loop over temperatures "t"
      do t = 1,.n_T

         ! Loop over ADP's on each atom "c"
         ab = 0
         do c = 1,.n_atom
         do a = 1,3
         do b = 1,a
            ab = ab + 1
            Delta(ab,t) = .Delta(a,b,c,t)
         end
         end
         end

      end

   end

   make_Welta(Welta,Delta)
   ! Make "Welta" the weighted Delta elements for all temperatures "t"
      Welta :: MAT{REAL}(.n6N,.n_T), OUT
      Delta :: MAT{REAL}(.n6N,.n_T), IN

      t :: INT

      ! Loop over temperatures "t"
      do t = 1,.n_T

         ! Weighted Delta's
         Welta(:,t).to_product_of(.ADP_wt(t).element,Delta(:,t))

      end

   end


   Lagrangian(Delta,Welta) result (res)
   ! Return the value of the Lagrangian
      Delta,Welta :: MAT{REAL}(.n6N,.n_T), IN
      res :: REAL

   ENSURE(.lambda.created,"no lambda")
   ENSURE(.lambda.dim==.n_modes.triangle_number,"wrong size, lambda")
   ENSURE(.L.created,"no L")
   ENSURE(.L.dim1==.n3N,"wrong shape, L")
   ENSURE(.L.dim2==.n_modes,"wrong shape, L")

      p,q,pq :: INT
      val :: REAL

      ! Get the chi2
      res = .the_chi2(Delta,Welta)

      ! Add the orthogonality constraint term
      pq = 0
      do p = 1,.n_modes
      do q = 1,p
         pq = pq + 1
         val = dot_product(.L(:,p),.L(:,q))
         if (p==q) val = val - ONE
         res = res - .lambda(pq)*val
      end
      end

   end

   the_chi2(Delta,Welta) result (res)
   ! Return the value of the chi2
      Delta,Welta :: MAT{REAL}(.n6N,.n_T), IN
      res :: REAL

      t :: INT

      ! Function value
      res = ZERO

      ! Loop over temperatures "t"
      do t = 1,.n_T

         ! Sum over t
         res = res + dot_product(Delta(:,t),Welta(:,t))

      end

      ! No of parameters part ...
      res = res/(.n6N*.n_T - .n_independent_parameters)

   end

   the_chi2 result (res)
   ! Return the value of the chi2
      res :: REAL

      Delta,Welta :: MAT{REAL}*
   
      ! Make Delta: differences between calc & obs
      Delta.create(.n6N,.n_T)
      .make_Delta(Delta) 
   
      ! Make weighted Delta's
      Welta.create(.n6N,.n_T)
      .make_Welta(Welta,Delta) 

      ! Work it out
      res = .the_chi2(Delta,Welta)

      ! Clean
      Welta.destroy
      Delta.destroy

   end


!  ============================
!  1st Derivative intermediates
!  ============================

   make_d_Welta(d_Welta,d_Delta) 
   ! Make "w_Delta" the covariance weighted *derivative* Delta's
      d_Welta :: MAT3{REAL}, OUT
      d_Delta :: MAT3{REAL}, IN

      t :: INT

      ! Loop over temperatures "t"
      do t = 1,.n_T

         ! Multiply by the weights
         d_Welta(:,:,t).to_product_of(d_Delta(:,:,t),.ADP_wt(t).element)

      end

   end

   add_d_Delta_gradient(GG,d_Delta,Welta) 
   ! Multiply weighted derivative Delta by Delta and add to gradient GG
      GG :: VEC{REAL}
      d_Delta :: MAT3{REAL}, IN
      Welta :: MAT{REAL}, IN

      t :: INT
      fac :: REAL

      fac = TWO/(.n6N - .n_independent_parameters)

      ! Loop over temperatures "t"
      do t = 1,.n_T

         GG.plus_scaled_product_of(d_Delta(:,:,t),Welta(:,t),fac)

      end

   end


   add_d_C_d_L(GG) 
   ! Add to gradient "GG" the derivative of constraint wrt L(g,i)
      GG :: VEC{REAL}

   ENSURE(GG.dim==.n3N*.n_modes,"wrong size GG")

      g,i,gi :: INT

      ! Add the constraint derivative
      gi = 0
      do i = 1,.n_modes
      do g = 1,.n3N
         gi = gi + 1
         GG(gi) = GG(gi) + .d_C_d_L(g,i)
      end
      end

   end

   add_d_C_d_lambda(GG) 
   ! Add gradient "GG" to the derivative of the Lagrangian 
   ! wrt lambda(p,q)
      GG :: VEC{REAL}(.n_modes.triangle_number)

      p,q,pq :: INT

      pq = 0
      do p = 1,.n_modes
      do q = 1,p
         pq = pq + 1
         GG(pq) = GG(pq) + .d_C_d_lambda(p,q) 
      end
      end

   end


   add_d_Delta_hessian(HH,d_Delta,d_Welta) 
   ! Multiply weighted derivative Delta's, and add to hessian HH
      HH :: MAT{REAL}
      d_Delta,d_Welta :: MAT3{REAL}, IN

      t :: INT
      fac :: REAL

      fac = TWO/(.n6N - .n_independent_parameters)

      ! Loop over temperatures "t"
      do t = 1,.n_T

         HH.plus_scaled_product_of(d_Delta(:,:,t),d_Welta(:,:,t),fac,transpose_b=TRUE)

      end

   end


   make_d_Delta_d_L(d_Delta) 
   ! Make "d_Delta" the derivative of Delta wrt L(g,i)
      d_Delta :: MAT3{REAL}(.n3N*.n_modes,.n6N,.n_T), OUT

      t,d,m,n,mn, g,i,gi :: INT

      ! Loop over temperatures "t"
      do t = 1,.n_T

         ! Get the derivative Delta for temp "t"
         mn = 0
         do d = 1,.n_atom
         do m = 1,3
         do n = 1,m
            mn = mn + 1
            gi = 0
            do i = 1,.n_modes
            do g = 1,.n3N
               gi = gi + 1
               d_Delta(gi,mn,t) = .d_U_d_L(m,n,d,t,g,i) 
            end
            end
            end
         end
         end

      end

   end

   make_d_Delta_d_w(d_Delta) 
   ! Make "d_Delta" the derivative of Delta wrt w(i)
      d_Delta :: MAT3{REAL}(.n_modes,.n6N,.n_T), OUT

      t,a,b,c,ab, i :: INT

      ! Loop over temperatures "t"
      do t = 1,.n_T

         ! Get the derivative Delta for temp "t"
         ab = 0
         do c = 1,.n_atom
         do a = 1,3
         do b = 1,a
            ab = ab + 1
            do i = 1,.n_modes
               d_Delta(i,ab,t) = .d_U_d_w(a,b,c,t,i) 
            end
         end
         end
         end

      end

   end

   make_d_Delta_d_G(d_Delta) 
   ! Make "d_Delta" the derivative of Delta wrt gamma_G(i)
      d_Delta :: MAT3{REAL}(.n_modes,.n6N,.n_T), OUT

      t,d,m,n,mn, i :: INT

      ! Loop over temperatures "t"
      do t = 1,.n_T

         ! Get the derivative Delta for temp "t"
         mn = 0
         do d = 1,.n_atom
         do m = 1,3
         do n = 1,m
            mn = mn + 1
            do i = 1,.n_modes
               d_Delta(i,mn,t) = .d_U_d_G(m,n,d,t,i) 
            end
         end
         end
         end

      end

   end

! L 1st derivatives

   d_U_d_L(a,b,c,t,g,i) result (res)
   ! The derivative of the calculated U(a,b) for atom c at temperature
   ! of data set "t" wrt L(g,i)
      a,b,c,t,g,i :: INT, IN
      res :: REAL

   ENSURE(a>=1,"wrong a value")
   ENSURE(a<=3,"wrong a value")
   ENSURE(b>=1,"wrong b value")
   ENSURE(a>=b,"b must not be larger than a")
   ENSURE(c>=1,"wrong c value")
   ENSURE(c<=.n_atom,"wrong c value")
   ENSURE(g>=1,"wrong g value")
   ENSURE(g<=.n3N,"wrong g value")
   ENSURE(i>=1,"wrong i value")
   ENSURE(i<=.n_modes,"wrong i value")
   ENSURE(.L.created,"no L")
   ENSURE(.L.dim1==.n3N,"wrong shape, L")
   ENSURE(.L.dim2==.n_modes,"wrong shape, L")

      aa,bb,cc :: INT

      ! Index offsets into normal modes L
      cc = 3*(c-1)
      aa = cc + a
      bb = cc + b

      res = ZERO
      if (aa==g) res = res + .L(bb,i)
      if (bb==g) res = res + .L(aa,i)

      res = .amplitude(i,t)*res

   end

! Omega 1st derivatives

   d_U_d_w(a,b,c,t,i) result (res)
   ! The derivative of the calculated U(a,b) for atom c at temperature
   ! of data set "t" wrt omega(i)
      a,b,c,t,i :: INT, IN
      res :: REAL

   ENSURE(a>=1,"wrong a value")
   ENSURE(a<=3,"wrong a value")
   ENSURE(b>=1,"wrong b value")
   ENSURE(a>=b,"b must not be larger than a")
   ENSURE(c>=1,"wrong c value")
   ENSURE(c<=.n_atom,"wrong c value")
   ENSURE(i>=1,"wrong i value")
   ENSURE(i<=.n_modes,"wrong i value")
   ENSURE(.L.created,"no L")
   ENSURE(.L.dim1==.n3N,"wrong shape, L")
   ENSURE(.L.dim2==.n_modes,"wrong shape, L")

      aa,bb,cc :: INT

      ! Index offsets into normal modes L
      cc = 3*(c-1)
      aa = cc + a
      bb = cc + b

      ! Do it ...
      res = .L(aa,i) * .d_amplitude_d_w(i,t) * .L(bb,i)

   end

   d_amplitude_d_w(i,t) result (res)
   ! The derivative of the amplitude(i,t) wrt omega(i)
      i,t :: INT, IN
      res :: REAL

      res = .d_amplitude_d_wb(i,t) * .d_wb_d_w(i,t)

   end

   d_amplitude_d_wb(i,t) result (res)
   ! The derivative of the amplitude(i,t) wrt omega_bar(i)
      i,t :: INT, IN
      res :: REAL

   ENSURE(i>=1,"wrong i value")
   ENSURE(i<=.n_modes,"wrong i value")
   ENSURE(t>=1,"wrong t value")
   ENSURE(t<=.n_T,"wrong t value")

      wb,arg,kT, c,s :: REAL

      wb  = .omega_bar(i,t)
      kT  = BOLTZMANN_SI*.temperature(t)/HARTREE_SI
      arg = HALF*wb/(TWO*kT)
      c   = cosh(arg)
      s   = sinh(arg)
      res = -(HALF/(wb*wb))*(c/s) - QUARTER/(wb*kT*s*s)

   end

   d_wb_d_w(i,t) result (res)
   ! The derivative of omega_bar(i) wrt omega(i)
      i,t :: INT, IN
      res :: REAL


   ENSURE(.Delta_V_on_V.created,"no Delta_V_on_V")
   ENSURE(.gamma_G.created,"no gamma_G")
   ENSURE(.gamma_G.dim==.n_modes,"wrong size, gamma_G")
   ENSURE(i>=1,"wrong i value")
   ENSURE(i<=.n_modes,"wrong i value")
   ENSURE(t>=1,"wrong t value")
   ENSURE(t<=.n_T,"wrong t value")

      res = ONE-.gamma_G(i)*.Delta_V_on_V(t)


   end

! Grueneisen 1st derivatives

   d_U_d_G(a,b,c,t,i) result (res)
   ! The derivative of the calculated U(a,b) for atom c at temperature
   ! of data set "t" wrt gamma_G(i)
      a,b,c,t,i :: INT, IN
      res :: REAL

   ENSURE(a>=1,"wrong a value")
   ENSURE(a<=3,"wrong a value")
   ENSURE(b>=1,"wrong b value")
   ENSURE(a>=b,"b must not be larger than a")
   ENSURE(c>=1,"wrong c value")
   ENSURE(c<=.n_atom,"wrong c value")
   ENSURE(i>=1,"wrong i value")
   ENSURE(i<=.n_modes,"wrong i value")
   ENSURE(.L.created,"no L")
   ENSURE(.L.dim1==.n3N,"wrong shape, L")
   ENSURE(.L.dim2==.n_modes,"wrong shape, L")

      aa,bb,cc :: INT

      ! Index offsets into normal modes L
      cc = 3*(c-1)
      aa = cc + a
      bb = cc + b

      ! Do it ...
      res = .L(aa,i) * .d_amplitude_d_G(i,t) * .L(bb,i)

   end

   d_amplitude_d_G(i,t) result (res)
   ! The derivative of the amplitude(i,t) wrt omega(i)
      i,t :: INT, IN
      res :: REAL

      res = .d_amplitude_d_wb(i,t) * .d_wb_d_G(i,t)

   end

   d_wb_d_G(i,t) result (res)
   ! The derivative of omega_bar(i) wrt gamma_G(i)
      i,t :: INT, IN
      res :: REAL


   ENSURE(.Delta_V_on_V.created,"no Delta_V_on_V")
   ENSURE(.omega.created,"no omega")
   ENSURE(.omega.dim==.n_modes,"wrong size, omega")
   ENSURE(i>=1,"wrong i value")
   ENSURE(i<=.n_modes,"wrong i value")
   ENSURE(t>=1,"wrong t value")
   ENSURE(t<=.n_T,"wrong t value")

      res = -.omega(i)*.Delta_V_on_V(t)


   end

! Constraint 1st derivatives: wrt L & lambda

   d_C_d_L(g,i) result (res)
   ! The derivative of the constraint C wrt L(g,i)
      g,i :: INT, IN
      res :: REAL

   ENSURE(g>=1,"wrong g value")
   ENSURE(g<=.n3N,"wrong g value")
   ENSURE(i>=1,"wrong i value")
   ENSURE(i<=.n_modes,"wrong i value")
   ENSURE(.lambda.created,"no lambda")
   ENSURE(.lambda.dim==.n_modes.triangle_number,"wrong size, lambda")
   ENSURE(.L.created,"no L")
   ENSURE(.L.dim1==.n3N,"wrong shape, L")
   ENSURE(.L.dim2==.n_modes,"wrong shape, L")

      p,q,pq :: INT
      val :: REAL

      res = ZERO
      pq  = 0
      do p = 1,.n_modes
      do q = 1,p
         pq = pq + 1
         val = ZERO
         if (p==i) val = val + .L(g,q)
         if (q==i) val = val + .L(g,p)
         res = res - .lambda(pq)*val
      end
      end

   end

   d_C_d_lambda(p,q) result (res)
   ! The derivative of the constraint C wrt lambda(p,q)
      p,q :: INT, IN
      res :: REAL

   ENSURE(p>=1,"wrong p value")
   ENSURE(p<=.n_modes,"wrong p value")
   ENSURE(q>=1,"wrong q value")
   ENSURE(p>=q,"q must not be larger than p")
   ENSURE(.L.created,"no L")
   ENSURE(.L.dim1==.n3N,"wrong shape, L")
   ENSURE(.L.dim2==.n_modes,"wrong shape, L")

      res = -dot_product(.L(:,p),.L(:,q))
      if (p==q) res = res + ONE

   end

!  ============================
!  2nd derivative intermediates
!  ============================

! Diagonal 2nd derivatives

   add_d2_Delta_d2_L(HH,Welta) 
   ! Add to hessian "HH" the 2nd derivative of constraint 
   ! wrt L(g,i) and L(h,j)
      HH :: MAT{REAL}(.n3N*.n_modes,.n3N*.n_modes)
      Welta :: MAT{REAL}(.n6N,.n_T), IN

      t,c,a,b,ab, g,i,gi, h,j,hj :: INT
      fac,wD :: REAL

      ! No of parameters part ...
      fac = TWO/(.n6N*.n_T - .n_independent_parameters)

      ! Loop over temperatures "t"
      do t = 1,.n_T

         ! Loop over ADP's on each atom "c"
         ab = 0
         do c = 1,.n_atom
         do a = 1,3
         do b = 1,a
            ab = ab + 1
            wD = fac*Welta(ab,t) 

            ! Add the 2nd derivative, somewhat optimised
            gi = 0
            do i = 1,.n_modes
            do g = 1,.n3N
               gi = gi + 1
               hj = 0
                  j = i
               do h = 1,.n3N
                  hj = .n3N*(j-1) + h
                  HH(hj,gi) = HH(hj,gi) + wD * .d2_U_d2_L(a,b,c,t,g,i,h,j) 
               end
            end
            end

         end
         end
         end

      end

   end

   add_d2_Delta_d2_w(HH,Welta) 
   ! Add to hessian "HH" the 2nd derivative of constraint 
   ! wrt omega(i) and omega(j=i)
      HH :: MAT{REAL}(.n_modes,.n_modes)
      Welta :: MAT{REAL}(.n6N,.n_T), IN

      t,c,a,b,ab, i :: INT
      fac,wD :: REAL

      ! No of parameters part ...
      fac = TWO/(.n6N*.n_T - .n_independent_parameters)

      ! Loop over temperatures "t"
      do t = 1,.n_T

         ! Loop over ADP's on each atom "c"
         ab = 0
         do c = 1,.n_atom
         do a = 1,3
         do b = 1,a
            ab = ab + 1
            wD = fac*Welta(ab,t) 

            ! Add the 2nd derivative, somewhat optimised
            do i = 1,.n_modes
               HH(i,i) = HH(i,i) + wD * .d2_U_d2_w(a,b,c,t,i) 
            end

         end
         end
         end

      end

   end

   add_d2_Delta_d2_G(HH,Welta) 
   ! Add to hessian "HH" the 2nd derivative of constraint 
   ! wrt gamma_G(i) and gamma_G(j=i)
      HH :: MAT{REAL}(.n_modes,.n_modes)
      Welta :: MAT{REAL}(.n6N,.n_T), IN

      t,c,a,b,ab, i :: INT
      fac,wD :: REAL

      ! No of parameters part ...
      fac = TWO/(.n6N*.n_T - .n_independent_parameters)

      ! Loop over temperatures "t"
      do t = 1,.n_T

         ! Loop over ADP's on each atom "c"
         ab = 0
         do c = 1,.n_atom
         do a = 1,3
         do b = 1,a
            ab = ab + 1
            wD = fac*Welta(ab,t) 

            ! Add the 2nd derivative, somewhat optimised
            do i = 1,.n_modes
               HH(i,i) = HH(i,i) + wD * .d2_U_d2_G(a,b,c,t,i) 
            end

         end
         end
         end

      end

   end

! Mixed 2nd derivatives

   add_d2_Delta_d_L_d_w(HH,Welta) 
   ! Add to hessian "HH" the 2nd derivative of constraint 
   ! wrt L(g,i) and omega(j=i)
      HH :: MAT{REAL}(.n_modes,.n3N*.n_modes)
      Welta :: MAT{REAL}(.n6N,.n_T), IN

      t,c,a,b,ab, g,i,gi :: INT
      fac,wD :: REAL

      ! No of parameters part ...
      fac = TWO/(.n6N*.n_T - .n_independent_parameters)

      ! Loop over temperatures "t"
      do t = 1,.n_T

         ! Loop over ADP's on each atom "c"
         ab = 0
         do c = 1,.n_atom
         do a = 1,3
         do b = 1,a
            ab = ab + 1
            wD = fac*Welta(ab,t) 

            ! Add the 2nd derivative
            gi = 0
            do i = 1,.n_modes
            do g = 1,.n3N
               gi = gi + 1
               HH(i,gi) = HH(i,gi) + wD * .d2_U_d_L_d_w(a,b,c,t,g,i) 
            end
            end

         end
         end
         end

      end

   end

   add_d2_Delta_d_L_d_G(HH,Welta) 
   ! Add to hessian "HH" the 2nd derivative of constraint 
   ! wrt L(g,i) and gamma_G(j=i)
      HH :: MAT{REAL}(.n_modes,.n3N*.n_modes)
      Welta :: MAT{REAL}(.n6N,.n_T), IN

      t,c,a,b,ab, g,i,gi :: INT
      fac,wD :: REAL

      ! No of parameters part ...
      fac = TWO/(.n6N*.n_T - .n_independent_parameters)

      ! Loop over temperatures "t"
      do t = 1,.n_T

         ! Loop over ADP's on each atom "c"
         ab = 0
         do c = 1,.n_atom
         do a = 1,3
         do b = 1,a
            ab = ab + 1
            wD = fac*Welta(ab,t) 

            ! Add the 2nd derivative
            gi = 0
            do i = 1,.n_modes
            do g = 1,.n3N
               gi = gi + 1
               HH(i,gi) = HH(i,gi) + wD * .d2_U_d_L_d_G(a,b,c,t,g,i) 
            end
            end

         end
         end
         end

      end

   end

   add_d2_Delta_d_w_d_G(HH,Welta) 
   ! Add to hessian "HH" the 2nd derivative of constraint 
   ! wrt omega(i) and gamma_G(j=i)
      HH :: MAT{REAL}(.n_modes,.n_modes)
      Welta :: MAT{REAL}(.n6N,.n_T), IN

      t,c,a,b,ab, i :: INT
      fac,wD :: REAL

      ! No of parameters part ...
      fac = TWO/(.n6N*.n_T - .n_independent_parameters)

      ! Loop over temperatures "t"
      do t = 1,.n_T

         ! Loop over ADP's on each atom "c"
         ab = 0
         do c = 1,.n_atom
         do a = 1,3
         do b = 1,a
            ab = ab + 1
            wD = fac*Welta(ab,t) 

            ! Add the 2nd derivative
            do i = 1,.n_modes
               HH(i,i) = HH(i,i) + wD * .d2_U_d_w_d_G(a,b,c,t,i) 
            end

         end
         end
         end

      end

   end

! Mixed constraint 2nd derivatives

   add_d2_C_d_L_d_lambda(HH) 
   ! Add hessian "HH" to the derivative of the Lagrangian 
   ! wrt L(g,i) and lambda(p,q)
      HH :: MAT{REAL}(.n_modes.triangle_number,.n3N*.n_modes)

      g,i,gi, p,q,pq :: INT

      gi = 0
      do i = 1,.n_modes
      do g = 1,.n3N
         gi = gi + 1

         pq = 0
         do p = 1,.n_modes
         do q = 1,p
            pq = pq + 1
            HH(pq,gi) = HH(pq,gi) + .d2_C_d_L_d_lambda(g,i,p,q) 
         end
         end

      end
      end

   end

! L 2nd derivatives

   d2_U_d2_L(a,b,c,t,g,i,h,j) result (res)
   ! The second derivative of the calculated U(a,b) for atom c at
   ! temperature of data set "t" wrt L(g,i) and L(h,j)
      a,b,c,t,g,i,h,j :: INT, IN
      res :: REAL

   ENSURE(a>=1,"wrong a value")
   ENSURE(a<=3,"wrong a value")
   ENSURE(b>=1,"wrong b value")
   ENSURE(a>=b,"b must not be larger than a")
   ENSURE(c>=1,"wrong c value")
   ENSURE(c<=.n_atom,"wrong c value")
   ENSURE(g>=1,"wrong g value")
   ENSURE(g<=.n3N,"wrong g value")
   ENSURE(i>=1,"wrong i value")
   ENSURE(i<=.n_modes,"wrong i value")
   ENSURE(h>=1,"wrong h value")
   ENSURE(h<=.n3N,"wrong h value")
   ENSURE(j>=1,"wrong j value")
   ENSURE(j<=.n_modes,"wrong j value")

      aa,bb,cc :: INT

      res = ZERO

      if (i/=j) return

      ! Index offsets into normal modes L
      cc = 3*(c-1)
      aa = cc + a
      bb = cc + b

      if (aa==g AND bb==h) res = res + ONE
      if (aa==h AND bb==g) res = res + ONE
      res = .amplitude(i,t)*res

   end

! Omega 2nd derivatives

   d2_U_d2_w(a,b,c,t,i) result (res)
   ! The second derivative of the calculated U(a,b) for atom c at
   ! temperature of data set "t" wrt omega(i) and omega(j=i)
      a,b,c,t,i :: INT, IN
      res :: REAL

   ENSURE(a>=1,"wrong a value")
   ENSURE(a<=3,"wrong a value")
   ENSURE(b>=1,"wrong b value")
   ENSURE(a>=b,"b must not be larger than a")
   ENSURE(c>=1,"wrong c value")
   ENSURE(c<=.n_atom,"wrong c value")
   ENSURE(i>=1,"wrong i value")
   ENSURE(i<=.n_modes,"wrong i value")
   ENSURE(.L.created,"no L")
   ENSURE(.L.dim1==.n3N,"wrong shape, L")
   ENSURE(.L.dim2==.n_modes,"wrong shape, L")

      aa,bb,cc :: INT

      ! Index offsets into normal modes L
      cc = 3*(c-1)
      aa = cc + a
      bb = cc + b

      ! Do it ...
      res = .L(aa,i) * .d2_amplitude_d2_w(i,t) * .L(bb,i)

   end

   d2_amplitude_d2_w(i,t) result (res)
   ! The second derivative of the amplitude(i,t) wrt omega(i)
      i,t :: INT, IN
      res :: REAL

      fac :: REAL

      fac = .d_wb_d_w(i,t)
      res = .d2_amplitude_d2_wb(i,t) * fac*fac

   end

   d2_amplitude_d2_wb(i,t) result (res)
   ! The secnd derivative of the amplitude(i,t) wrt omega_bar(i)
      i,t :: INT, IN
      res :: REAL

   ENSURE(i>=1,"wrong i value")
   ENSURE(i<=.n_modes,"wrong i value")
   ENSURE(t>=1,"wrong t value")
   ENSURE(t<=.n_T,"wrong t value")

      wb,arg,kT, c,s :: REAL

      wb  = .omega_bar(i,t)
      kT  = BOLTZMANN_SI*.temperature(t)/HARTREE_SI
      arg = HALF*wb/(TWO*kT)
      c   = cosh(arg)
      s   = sinh(arg)
      res = (ONE/(wb*wb*wb))*(c/s) -QUARTER/(wb*kT)/(s*s) &
          + HALF/(wb*wb*kT*s*s) &
          + (QUARTER/(wb*kT*kT*s*s))*(c/s) 

   end

! Grueneisen 2nd derivatives

   d2_U_d2_G(a,b,c,t,i) result (res)
   ! The second derivative of the calculated U(a,b) for atom c at
   ! temperature of data set "t" wrt gamma_G(i)
      a,b,c,t,i :: INT, IN
      res :: REAL

   ENSURE(a>=1,"wrong a value")
   ENSURE(a<=3,"wrong a value")
   ENSURE(b>=1,"wrong b value")
   ENSURE(a>=b,"b must not be larger than a")
   ENSURE(c>=1,"wrong c value")
   ENSURE(c<=.n_atom,"wrong c value")
   ENSURE(i>=1,"wrong i value")
   ENSURE(i<=.n_modes,"wrong i value")

      aa,bb,cc :: INT

      ! Index offsets into normal modes L
      cc = 3*(c-1)
      aa = cc + a
      bb = cc + b

      ! Do it ...
      res = .L(aa,i) * .d2_amplitude_d2_G(i,t) * .L(bb,i)

   end

   d2_amplitude_d2_G(i,t) result (res)
   ! The second derivative of the amplitude(i,t) wrt gamma_G(i)
      i,t :: INT, IN
      res :: REAL

      fac :: REAL

      fac = .d_wb_d_G(i,t)
      res = .d2_amplitude_d2_wb(i,t) * fac*fac

   end

! L-Omega & L-Grueneisen mixed 2nd derivatives

   d2_U_d_L_d_w(a,b,c,t,g,i) result (res)
   ! The second derivative of the calculated U(a,b) for atom c at
   ! temperature of data set "t" wrt L(g,i) and omega(j=i)
      a,b,c,t,g,i :: INT, IN
      res :: REAL

   ENSURE(a>=1,"wrong a value")
   ENSURE(a<=3,"wrong a value")
   ENSURE(b>=1,"wrong b value")
   ENSURE(a>=b,"b must not be larger than a")
   ENSURE(c>=1,"wrong c value")
   ENSURE(c<=.n_atom,"wrong c value")
   ENSURE(g>=1,"wrong g value")
   ENSURE(g<=.n3N,"wrong g value")
   ENSURE(i>=1,"wrong i value")
   ENSURE(i<=.n_modes,"wrong i value")
   ENSURE(.L.created,"no L")
   ENSURE(.L.dim1==.n3N,"wrong shape, L")
   ENSURE(.L.dim2==.n_modes,"wrong shape, L")

      aa,bb,cc :: INT

      ! Index offsets into normal modes L
      cc = 3*(c-1)
      aa = cc + a
      bb = cc + b

      res = ZERO
      if (aa==g) res = res + .L(bb,i)
      if (bb==g) res = res + .L(aa,i)

      res = .d_amplitude_d_w(i,t)*res

   end

   d2_U_d_L_d_G(a,b,c,t,g,i) result (res)
   ! The second derivative of the calculated U(a,b) for atom c at
   ! temperature of data set "t" wrt L(g,i) and gamma_G(i)
      a,b,c,t,g,i :: INT, IN
      res :: REAL

   ENSURE(a>=1,"wrong a value")
   ENSURE(a<=3,"wrong a value")
   ENSURE(b>=1,"wrong b value")
   ENSURE(a>=b,"b must not be larger than a")
   ENSURE(c>=1,"wrong c value")
   ENSURE(c<=.n_atom,"wrong c value")
   ENSURE(g>=1,"wrong g value")
   ENSURE(g<=.n3N,"wrong g value")
   ENSURE(i>=1,"wrong i value")
   ENSURE(i<=.n_modes,"wrong i value")
   ENSURE(.L.created,"no L")
   ENSURE(.L.dim1==.n3N,"wrong shape, L")
   ENSURE(.L.dim2==.n_modes,"wrong shape, L")

      aa,bb,cc :: INT

      ! Index offsets into normal modes L
      cc = 3*(c-1)
      aa = cc + a
      bb = cc + b

      res = ZERO
      if (aa==g) res = res + .L(bb,i)
      if (bb==g) res = res + .L(aa,i)

      res = .d_amplitude_d_G(i,t)*res

   end

! Omega-Grueneisen mixed 2nd derivatives

   d2_U_d_w_d_G(a,b,c,t,i) result (res)
   ! The second derivative of the calculated U(a,b) for atom c at
   ! temperature of data set "t" wrt omega(i) and gamma_G(j=i)
      a,b,c,t,i :: INT, IN
      res :: REAL

   ENSURE(a>=1,"wrong a value")
   ENSURE(a<=3,"wrong a value")
   ENSURE(b>=1,"wrong b value")
   ENSURE(a>=b,"b must not be larger than a")
   ENSURE(c>=1,"wrong c value")
   ENSURE(c<=.n_atom,"wrong c value")
   ENSURE(i>=1,"wrong i value")
   ENSURE(i<=.n_modes,"wrong i value")
   ENSURE(.L.created,"no L")
   ENSURE(.L.dim1==.n3N,"wrong shape, L")
   ENSURE(.L.dim2==.n_modes,"wrong shape, L")

      aa,bb,cc :: INT

      ! Index offsets into normal modes L
      cc = 3*(c-1)
      aa = cc + a
      bb = cc + b

      ! Do it ...
      res = .L(aa,i) * .d2_amplitude_d_w_d_G(i,t) * .L(bb,i)

   end

   d2_amplitude_d_w_d_G(i,t) result (res)
   ! The second derivative of the amplitude(i,t) wrt omega(i) and
   ! gamma_G(i)
      i,t :: INT, IN
      res :: REAL

      res = .d2_amplitude_d2_wb(i,t) * .d_wb_d_w(i,t) * .d_wb_d_G(i,t) &
          + .d_amplitude_d_wb(i,t) * .d2_wb_d_w_d_G(t)

   end

   d2_wb_d_w_d_G(t) result (res)
   ! The second derivative of omega_bar(i) wrt omega(i) and gamma_G(i)
   ! NOTE: it does not depends on i
      t :: INT, IN
      res :: REAL

   ENSURE(.Delta_V_on_V.created,"no Delta_V_on_V")
   ENSURE(t>=1,"wrong t value")
   ENSURE(t<=.n_T,"wrong t value")

      res = -.Delta_V_on_V(t)


   end

! Constraint 2nd derivatives: L

   d2_C_d2_L(g,i,h,j) result (res)
   ! The 2nd derivative of the constraint C wrt L(g,i) and L(h,j)
      g,i,h,j :: INT, IN
      res :: REAL

   ENSURE(g>=1,"wrong g value")
   ENSURE(g<=.n3N,"wrong g value")
   ENSURE(i>=1,"wrong i value")
   ENSURE(i<=.n_modes,"wrong i value")
   ENSURE(h>=1,"wrong h value")
   ENSURE(h<=.n3N,"wrong h value")
   ENSURE(j>=1,"wrong j value")
   ENSURE(j<=.n_modes,"wrong j value")

      p,q,pq :: INT
      val :: REAL

      res = ZERO

      if (g/=h) return

      pq  = 0
      do p = 1,.n_modes
      do q = 1,p
         pq = pq + 1
         val = ZERO
         if (p==i AND q==j) val = val + ONE
         if (p==j AND q==i) val = val + ONE
         res = res - .lambda(pq)*val
      end
      end

   end

! Constraint mixed 2nd derivatives: L-lambda

   d2_C_d_L_d_lambda(g,i,p,q) result (res)
   ! The second derivative of the constraint term 
   ! wrt L(g,i) and lambda(p,q)
      g,i,p,q :: INT, IN
      res :: REAL

   ENSURE(g>=1,"wrong g value")
   ENSURE(g<=.n3N,"wrong g value")
   ENSURE(i>=1,"wrong i value")
   ENSURE(i<=.n_modes,"wrong i value")
   ENSURE(p>=1,"wrong p value")
   ENSURE(p<=.n_modes,"wrong p value")
   ENSURE(q>=1,"wrong q value")
   ENSURE(p>=q,"q must not be larger than p")
   ENSURE(.L.created,"no L")
   ENSURE(.L.dim1==.n3N,"wrong shape, L")
   ENSURE(.L.dim2==.n_modes,"wrong shape, L")

      res = ZERO
      if (p==i) res = res - .L(g,q)
      if (q==i) res = res - .L(g,p)

   end


!  ==============
!  Debug printing
!  ==============

   read_debug_on ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and add it to the list.
   end

   read_debug_off ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and remove it from the list.
   end

   debugging(name) result (res) ::: get_from(DEBUG)
   ! Return TRUE if the debug switch "name" has been set.
   end

   put_debug_list ::: get_from(DEBUG)
   ! Put of the list of debug switches
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>REAL)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>VEC{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>MAT{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end


end
