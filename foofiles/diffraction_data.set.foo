!====================================================================
!
! DIFFRACTION_DATA: Diffraction data structure for crystals
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1999
! Copyright (C) Dylan Jayatilaka 2023
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!====================================================================

module DIFFRACTION_DATA.SET

   implicit none

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Allocate an object
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

   destroy_ptr_part ::: leaky, PURE
   ! Erase all pointer information
      self :: INOUT

      ! Reflection related data
      .SET:destroy_reflection_data

      .refine_U_iso_for_atom.destroy
      ! Refinement/fit related data

      .refine_3rd_order_for_atom.destroy
      .refine_4th_order_for_atom.destroy
      .refine_atom_parameters.destroy
      .SET:destroy_fit_data
      .SET:destroy_refinement_data

   end

   destroy_reflection_data ::: leaky, PURE
   ! Erase all reflection data
      self :: INOUT

      if (.INQ:reflection_data_exists) then

         .scale_factor      =  ONE
         .exp_scale_factor  = -ONE
         .extinction_factor =  ZERO

         .reflection0.destroy
         .reflections.destroy
         .hkl_range.destroy

         .scale_factors.destroy

      end

   end

   destroy_fit_data ::: leaky, PURE
   ! Erase all generated fit arrays
      self :: INOUT

      .fit_table.destroy

      .dX.destroy
      .X_fit.destroy
      .X_fit0.destroy

      .fragment_covariance_mx.destroy
      .correlation_mx.destroy
      .covariance_mx.destroy
      .esd.destroy

   end

   destroy_refinement_data ::: leaky, PURE
   ! Erase all generated refinement arrays
      self :: INOUT

      .ref_table.destroy

      .X_ref.destroy
      .X_ref0.destroy

   end

!  ===========
!  Set methods
!  ===========

   set_defaults ::: leaky, PURE
   ! Set up a default diffraction_data object
      self :: INOUT

      .SET:destroy_reflection_data

      .data_kind              = "x-ray"

      ! Experimental data
      .wavelength             = -ONE
      .temperature            = ZERO
      .NKA_T_sequence_no      = 0

      ! Data treatment options
      .F_sigma_cutoff         = -TWO
      .I_sigma_cutoff         = -FOUR
      .F_z_cutoff             = -ONE
      .I_z_cutoff             = -ONE
      .F_calc_cutoff          = TOL(3)
      .F_pred_cutoff          = -ONE
      .I_pred_cutoff          = -ONE
      .stl_high_cutoff        = -ONE
      .stl_low_cutoff         = -ONE
      .stl_limit              = -ONE
      .show_rejects           = FALSE
      .synthesize_sigma_I     = FALSE
      .SF_mixing_parameter    = ZERO

      ! Structure factor calculation parameters
      .partition_model          = "oc-hirshfeld"
      .temperature_factor_model = "atom-based"
      .use_Voronoi_atoms        = FALSE
      .use_KM_atoms             = FALSE
      .use_IAM_density          = FALSE
      .use_IAM_ITC_FFs          = TRUE
      .use_zero_overlap         = FALSE

      ! Invarioms
      .invariom_database_directory = " "
      .invariom_refinement         = FALSE

      ! Experimental corrections
      .refine_scale           = TRUE
      .scale_factor           =  ONE
      .exp_scale_factor       = -ONE
      .refine_extinction      = FALSE
      .extinction_factor      = ZERO
      .add_dispersion_to_F_calc = FALSE
      .remove_dispersion_from_F_exp = FALSE

      ! Agreement statistics
      .n_param                  = 0
      .n_param_manually_set     = FALSE
      .chi2                     = ZERO
      .max_residual             = ZERO
      .min_residual             = ZERO
      .rms_residual             = ZERO
      .max_atom_residual        = ZERO
      .max_atom_residual_tag    = " "
      .min_atom_residual        = ZERO
      .min_atom_residual_tag    = " "
      .rms_atom_residual        = ZERO

      ! Refine/fit switches
      .fit_structure                = FALSE
      .refine_structure             = FALSE
      .refine_F                     = TRUE
      .refine_positions_only        = FALSE
      .refine_ADPs_only             = FALSE
      .refine_H_ADPs                = TRUE
      .refine_H_positions           = TRUE 
      .refine_H_U_iso               = FALSE
      .refine_anharmonicity         = FALSE
      .refine_4th_order_only        = FALSE
      .restart_HAR_with_promolecule = FALSE
      .XCW                          = FALSE

      ! Refine/fit iteration termination
      .max_iterations           = DIFFRACTION_DATA_MAX_ITER
      .min_iterations           = DIFFRACTION_DATA_MIN_ITER
      .max_allowed_param_shift  = DIFFRACTION_DATA_MAX_ALLOWED_SHIFT

      ! Least squares options (zero/near zero eigenvalues)
      .tol_for_shift_on_esd     = DIFFRACTION_DATA_TOL_FOR_SHIFT_ON_ESD
      .near_0_tol               = DIFFRACTION_DATA_TOL_NEAR_0

      ! Refinement/fit output control
      .show_fit_output          = FALSE
      .show_near_0_eigenvectors = FALSE
      .min_correlation          = DIFFRACTION_DATA_MIN_CORRELATION

      ! Set the internal variables for a refine/fit data
      .SET:destroy_fit_data
      .SET:set_fit_data

      .SET:destroy_refinement_data
      .SET:set_refinement_data

   end

   set_fit_data ::: pure
   ! Set the defaults internal variables for a fit
      self :: INOUT

      ! Refinement/fit iteration data
      .fit_iteration           = 0
      .chi2_fit                = ZERO
      .chi2_fit0               = ZERO
      .max_shift               = ZERO
      .max_esd                 = ZERO
      .max_shift_on_esd        = ZERO
      .max_shift_on_esd_ind    = 0
      .max_shift_on_esd_par    = " "
      .fit_finished            = FALSE ! <<<<
      .fit_converged           = FALSE
      .chi2_increased          = FALSE
      .too_many_fit_iterations = FALSE

      ! Near zero eigenvalues in the least-squares
      .n_0                     = 0
      .near_0                  = 0

   end

   set_refinement_data ::: pure
   ! Set the defaults internal variables for a refinement
      self :: INOUT

      ! Refinement/fit iteration data
      .ref_iteration           = 0
      .chi2_ref                = ZERO
      .chi2_ref0               = ZERO
      .max_refshift            = ZERO
      .max_refesd              = ZERO
      .max_refshift_on_esd     = ZERO
      .max_refshift_on_esd_ind = 0
      .max_refshift_on_esd_par = " "
      .refinement_finished     = FALSE ! <<<
      .refinement_converged    = FALSE
      .too_many_ref_iterations = FALSE

   end

   set_add_dispersion_to_F_calc(val) ::: pure
   ! Set whether to correct dispersion in the refinement by adding the
   ! anomalous dispersion into F_calc and calculating the derivatives
   ! of the dispersion correction.
      self :: INOUT
      val :: BIN, IN
      .add_dispersion_to_F_calc = val
   end

   set_data_kind(val) ::: PURE
   ! Read the data kind of crystal experiment
      self :: INOUT
      val :: STR, IN

   ENSURE(val.is_one_of(["x-ray","pnd  "]),"unknown data_kind, "//trim(val))

      .data_kind = val

      .data_kind.to_lower_case

   end

   set_fcf_file_name(val)
   ! Set the name of the fcf file from which to read in a unique set
   ! of reflections.
      self :: INOUT
      val  :: STR, IN

      file :: TEXTFILE

      .fcf_file_name = val

      file.set_name(val)
      DIE_IF(NOT file.exists,"the specified fcf file does not exist")

   end

   set_fit_structure(val) ::: pure
   ! Set whether to rigid-fit the structure
      self :: INOUT
      val :: BIN, IN

      .fit_structure = val

      ! If fitting, you can't be refining
      if (NOT val) .refine_structure = NOT val

   end

   set_max_shift_on_esd(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.max_shift_on_esd), pure
   ! Generic set
   end

   set_max_shift_on_esd_par(val) ::: get_from(OBJECT:set, VAL?=>STR, ARG?=>.max_shift_on_esd_par), pure
   ! Generic set
   end

   set_max_refshift_on_esd(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.max_refshift_on_esd), pure
   ! Generic set
   end

   set_max_refshift_on_esd_par(val) ::: get_from(OBJECT:set, VAL?=>STR, ARG?=>.max_refshift_on_esd_par), pure
   ! Generic set
   end

   set_n_data_sets(val) ::: PURE
   ! Set the number of data sets in a multiple-data-set refinement.
      self :: INOUT
      val :: INT, IN

   ENSURE(val>1,"n_data_sets must be non negative")

      .n_data_sets = val

   end

   set_n_param(val) ::: PURE
   ! Set the number of paramters in the model "by hand"
      self :: INOUT
      val :: INT, IN

   ENSURE(val>1,"n_param must be non negative")

      .n_param = val
      .n_param_manually_set = TRUE

   end

   set_n_worst_reflections(val) ::: pure
   ! Set the no. of worst reflections to show
      self :: INOUT
      val :: INT, IN
      .n_worst_reflections = val
   end

   set_partition_model(val) ::: PURE
   ! Read the partition model to use to calculate the structure
   ! factors. So far, only "oc-hirshfeld" and "oc-tanaka" correspond
   ! to one-center atom-based partioning. The others are two-center
   ! basis-function-based partitionings which use all parts of the
   ! fragment density matrix (with 'repetition factors') to calculate
   ! the structure factors, and these two-center may not be used for
   ! geometric structure refinement.
      self :: INOUT
      val :: STR, IN

   ENSURE(val.is_one_of(["none        ","oc-crystal23","oc-hirshfeld","oc-tanaka   ","tc-mulliken ","tc-tanaka   "]),"unknown data_kind, "//trim(val))

      .partition_model = val
      .partition_model.to_lower_case

      ! One-center partitions go with one-center TF models
      ! NOTE: for crystal23 density matrices it is assuned you are 
      ! doing an atom-based i.e. OC model
      select case (.partition_model)
      case ("oc-crystal23"); .SET:set_temperature_factor_model("atom-based")
      case ("oc-hirshfeld"); .SET:set_temperature_factor_model("atom-based")
      case ("oc-tanaka   "); .SET:set_temperature_factor_model("atom-based")
      end

   end

   set_refine_extinction(val) ::: pure
   ! Set whether to correct extinction or not according to the Larson formula
      self :: INOUT
      val :: BIN, IN
      .refine_extinction = val
   end

   set_refine_fragments(val) ::: pure
   ! Set whether to refine fragments
      self :: INOUT
      val :: BIN, IN

      .refine_fragments = val

      ! If refining you can't be fitting
      if (val) .fit_structure = NOT val

   end

   set_refine_structure(val) ::: pure
   ! Set whether to refine the structure
      self :: INOUT
      val :: BIN, IN

      .refine_structure = val

      ! If refining you can't be fitting
      if (val) .fit_structure = NOT val

   end

   set_refine_H_positions(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.refine_H_positions), pure
   ! Generic set
   end

   set_refine_H_ADPs(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.refine_H_ADPs), pure
   ! Generic set
   end

   set_refine_H_U_iso(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.refine_H_U_iso), pure
   ! Generic set
   end

   set_refine_4th_order(val) ::: leaky, PURE
   ! Read the list of atoms for which fourth-order anharmonicty
   ! parameters are to be refined.
      self :: INOUT
      val :: VEC{STR}, IN

      .refine_4th_order_for_atom = val

      .refine_anharmonicity = TRUE

   end

   set_refine_4th_order_only(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.refine_4th_order_only), pure
   ! Generic set
   end

   set_refine_anharmonicity(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.refine_anharmonicity), pure
   ! Generic set
   end

   set_restart_HAR_with_promolecule(val) ::: PURE
   ! Set whether to restart HAR with promolecule every time.
      self :: INOUT
      val :: BIN, IN
      .restart_HAR_with_promolecule = val
   end

   set_remove_disp_from_F_exp(val) ::: pure
   ! Set whether to correct dispersion in the refinement by removing
   ! the anomalous dispersion from F_exp. This is an "XD_style"
   ! dispersion correction.
      self :: INOUT
      val :: BIN, IN
      .remove_dispersion_from_F_exp = val
   end

   set_temperature_factor_model(val) ::: PURE
   ! Read the temperature factor model to use to correct for thermal
   ! vibration in the calculated structure factors. Use "atom-based"
   ! or "one-center" for usual ADP based model. Use "none" for static
   ! structure factors. The remaining options are different
   ! two-center models, see Jayatilaka & Grimwood (2001) Acta Cryst A.
      self :: INOUT
      val :: STR, IN

   ENSURE(val.is_one_of(["none      ","one-center","atom-based","tc-coppens","tc-stewart","tc-tanaka "]),"unknown data_kind, "//trim(val))

      .temperature_factor_model = val
      .temperature_factor_model.to_lower_case

   end

   set_wavelength(val)
   ! Read the experimental wavelength
      self :: INOUT
      val :: REAL, IN
      .wavelength = val
   end

   set_XCW(val) ::: PURE
   ! Set if doing an XCW calculation - needed for calculating
   ! n_param, which is incremented by 1 for lambda.
      self :: INOUT
      val :: BIN, IN
      .XCW = val
   end

!  Cutoffs

   set_F_sigma_noise(val) ::: PURE
   ! Set noise to add to F_exp and F_sigma, in units of F_sigma.
      self :: INOUT
      val :: REAL, IN
      .F_sigma_noise = val
   end

   set_F_sigma_cutoff(val) ::: PURE
   ! Set the minimum acceptable value for F_exp/sigma
   ! NOTE: make sure zero is not entered ... just leave it off!
      self :: INOUT
      val :: REAL, IN

   ENSURE(val>ZERO,"cutoff must be positive")

      .F_sigma_cutoff = val

   end

   set_I_sigma_cutoff(val) ::: PURE
   ! Set the minimum acceptable value for F2_exp/sigma
      self :: INOUT
      val :: REAL, IN

   ENSURE(val>ZERO,"cutoff must be positive")

      .I_sigma_cutoff = val

   end

   set_F_z_cutoff(val) ::: PURE
   ! Set the F_z_cutoff (in sigma units) for prune_bad_reflections
      self :: INOUT
      val :: REAL, IN

   ENSURE(val>ZERO,"cutoff must be positive")

      .F_z_cutoff = val

   end

   set_I_z_cutoff(val) ::: PURE
   ! Set the I_z_cutoff (in sigma units) for prune_bad_reflections
      self :: INOUT
      val :: REAL, IN

   ENSURE(val>ZERO,"cutoff must be positive")

      .I_z_cutoff = val

   end

   set_F_calc_cutoff(val) ::: PURE
   ! Set the F_calc_cutoff
      self :: INOUT
      val :: REAL, IN

   ENSURE(val>ZERO,"cutoff must be positive")

      .F_calc_cutoff = val

   end

   set_F_pred_cutoff(val) ::: PURE
   ! Set the F_pred_cutoff
      self :: INOUT
      val :: REAL, IN

   ENSURE(val>ZERO,"cutoff must be positive")

      .F_pred_cutoff = val

   end

   set_I_pred_cutoff(val) ::: PURE
   ! Set the I_pred_cutoff
      self :: INOUT
      val :: REAL, IN

   ENSURE(val>ZERO,"cutoff must be positive")

      .I_pred_cutoff = val

   end

!  Show switches

   set_show_rejects(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.show_rejects), pure
   ! Generic set
   end

   set_show_refinement_output(val) ::: pure
   ! Set whether to show refinement output
      self :: INOUT
      val :: BIN, IN
      .show_refinement_output  = val
      .show_refinement_results = val
   end

   set_show_refinement_results(val) ::: pure
   ! Set whether to show refinmenet statistics results
      self :: INOUT
      val :: BIN, IN
      .show_refinement_results = val
   end

   set_show_fit_output(val) ::: pure
   ! Set whether to show fit output
      self :: INOUT
      val :: BIN, IN
      .show_fit_output  = val
      .show_fit_results = val
   end

   set_show_fit_results(val) ::: pure
   ! Set whether to show fit statistics results
      self :: INOUT
      val :: BIN, IN
      .show_fit_results = val
   end

!   Use switches

   set_use_equivalents(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.use_equivalents), pure
   ! Generic set
   end

   set_use_disk_SFs(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.use_disk_SFs), pure
   ! Generic set
   end

   set_use_IAM_density(val) ::: pure
   ! Set
      self :: INOUT
      val :: BIN, IN

      .use_IAM_density = val

      ! By default use tabulated FFs
      .use_IAM_ITC_FFs = val

   end

   set_use_IAM_ITC_FFs(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.use_IAM_ITC_FFs), pure
   ! Generic set
   end

   set_use_Ryde_capping(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.use_Ryde_capping), pure
   ! Generic set
   end

   set_use_text_SFs(val)
   ! Set whether to use text format structure factors
      self :: INOUT
      val :: BIN

      .use_text_SFs = val
      .use_disk_SFs = val

   end

!  ==============
!  Update methods
!  ==============

   update(unit_cell,spacegroup) ::: leaky
   ! Update the crystal information after setting values. If the
   ! "unit_cell" is provided, then that is used to define the
   ! reflection .theta values.
      self :: INOUT
      unit_cell :: UNIT_CELL, IN
      spacegroup :: SPACEGROUP, IN

      if (.reflections.deallocated) then

         ! Set hkl range ?
         if (.hkl_range.allocated) .reflections.set_hkl_range(.hkl_range)

         ! Set hkl up to stl_limit?
         if (.stl_limit>ZERO) .reflections.set_hkl_up_to_stl_limit(.stl_limit,unit_cell)

      else

         ! Keep original reflections
         .reflection0 = .reflections
        
         ! Set d, stl, theta 
         .reflection0.set_d_and_theta(unit_cell,.wavelength)
         .reflections.set_d_and_theta(unit_cell,.wavelength)
        
         ! Equivalence factors
         .reflection0.set_equivalence_factors(spacegroup)
         .reflections.set_equivalence_factors(spacegroup)
        
         ! Prune & sort !!!
         .SET:prune_reflections
         .SET:sort_reflections
         !!!!!!!!!!!!!!!!!!

         if (.INQ:have_F_exp) then

            ENSURE(.reflections.have_nonzero_F_sigma,"no experimental F_sigma's")

            ! Explicit scaling
            if (.exp_scale_factor>ZERO) then

               .reflection0.scale_F_exp(.exp_scale_factor)
               .reflections.scale_F_exp(.exp_scale_factor)
               .reflection0.scale_F_sigma(.exp_scale_factor)
               .reflections.scale_F_sigma(.exp_scale_factor)

               ! Turn off next time
               .exp_scale_factor = -ONE

            end

         else

            .refine_scale        = FALSE
            .refine_extinction = FALSE

         end
        

      end

      if (.show_rejects) then
      if (.reflection0.dim>.reflections.dim) then

         stdout.flush
         stdout.text("==========================")
         stdout.text("Reflections before pruning")
         stdout.text("==========================")
         .reflection0.put

         stdout.flush
         stdout.text("=========================")
         stdout.text("Reflections after pruning")
         stdout.text("=========================")
         .reflections.put

      end
      end

      if (.use_IAM_density) then
      DIE_IF(.use_Voronoi_atoms  ,"cannot use Voronoi and IAM_density together")
      DIE_IF(.invariom_refinement,"cannot use invarioms and IAM_density together")
      DIE_IF(.use_KM_atoms       ,"cannot use KM_atomsand IAM_density together")
      end

   end

   process_fcf_file ::: leaky
   ! Process tge specified fcf_file and read the reflections.
      self :: INOUT

      cif :: CIF@
      found :: BIN

      ! Read the fcf file if requested
      if (.fcf_file_name/=" ") then

         cif.create(trim(.fcf_file_name))
         cif.open
         cif.find_data_block(found)
         DIE_IF(NOT found,"no data block found in your fcf file: "//trim(.fcf_file_name))

         found = VEC{REFLECTION}:has_smCIF_F_meas_only(cif)
         if (found) then
            .reflections.read_smCIF_F_meas_only(cif) ! leaky
         else
            found = VEC{REFLECTION}:has_smCIF_F2_reflections(cif)
            DIE_IF(NOT found,"no F or F_squared reflections in your fcf file: "//trim(.fcf_file_name))
            .reflections.read_smCIF_F2_reflections(cif) ! leaky
         end

         cif.destroy

      end

   end

   sort_reflections ::: leaky, private
   ! I sorted according to one data set that I saw. --Dylan
      self :: IN

   ENSURE(.reflections.allocated,"no reflection data")

      n_refl,i, hc :: INT
      hi,list,indx :: VEC{INT}@

      n_refl = .reflections.dim

      hi.create(3)
      list.create(n_refl)
      indx.create(n_refl)

      ! Sort according to H index code
#     define CLUSTER_H_MAX 127
      do i = 1,n_refl
         hi = .reflections(i).Miller_indices
         hc = CLUSTER_H_CODE(hi(3),hi(2),hi(1))
         list(i) = hc
      end
#     define CLUSTER_H_MAX 7

      indx.destroy
      list.destroy
      hi.destroy

   end

! ===================
! Pruning reflections
! ===================

   prune_reflections
   ! Zero negative reflections adding appropriate error to sigma
   ! If random errors are to be added, process and add error to sigma.
   ! Then prune all the reflections, as requested by cutoffs.
      self :: INOUT

      n_refl,n_prun :: INT

      ! Prune small I's and define F's
      if (.INQ:have_I_exp) then
         DIE_IF(NOT .INQ:have_nonzero_I_sigma,"I_exp present but no I_sigma?")
         .SET:prune_small_I_sigmas ! < TOL(6)
         ! -I_exp => I_sigma <- I_sigma + |-I_exp| AND I_exp <- 0
       ! .reflections.reset_I_exp_I_sigma
      end

      if (.I_sigma_cutoff >ZERO) then
      if (.INQ:have_I_exp) then
         .SET:prune_weak_Is
      else
         WARN("I_sigma_cutoff specified but no I_exp data")
      end
      end

      ! Next prune small F's
      if (.INQ:have_F_exp) then
         DIE_IF(NOT .INQ:have_nonzero_F_sigma,"F_exp present but no F_sigma?")
         .SET:prune_small_F_sigmas ! < TOL(3)
         ! -F_exp => F_sigma <- F_sigma + |-F_exp| AND F_exp <- 0
       ! .reflections.reset_F_exp_F_sigma
      end

      ! Add noise
      if (.F_sigma_noise/=ZERO AND .INQ:have_F_exp) then
         DIE_IF(NOT .INQ:have_nonzero_F_sigma,"F_exp present but no F_sigma?")
         .reflections.add_noise(.F_sigma_noise)
      end

      ! Prune small F_exp/F_sigma
      if (.F_sigma_cutoff >ZERO) then
      if (.INQ:have_F_exp AND .INQ:have_nonzero_F_sigma) then
         .SET:prune_weak_Fs
      else
         WARN("F_sigma_cutoff specified but no F_exp/F_sigma data") 
      end 
      end 
      
      ! NOTE if doing below, do it repeatedly
      ! because the scale factor will change
      if (.F_z_cutoff     >ZERO) then
      if (.INQ:have_F_exp AND .INQ:have_F_pred) then
         do
            n_refl = .reflections.dim
            ! Prune
            .SET:prune_bad_F_reflections
            n_prun = .reflections.dim
            ! Redo?
            if (n_prun==n_refl) then; exit
            else;        .SET:make_F_predicted
            end
         end
      else
         WARN("F_z_cutoff specified but no F_exp/F_pred data")
      end
      end

      ! Prune F_calc's which are zero
      if (.F_calc_cutoff  >ZERO) then
      if (.INQ:have_F_calc) then
         .SET:prune_zero_F_calcs
      end
      end

      ! Prune F_pred's which are zero
      if (.F_pred_cutoff  >ZERO) then
      if (.INQ:have_F_pred) then
         .SET:prune_zero_F_preds
      else
         WARN("F_pred_cutoff specified but no F_pred data")
      end
      end


      if (.stl_high_cutoff>ZERO) then
         .SET:prune_high_angle_reflections
      end

      if ( .stl_low_cutoff>ZERO) then
         .SET:prune_low_angle_reflections
      end

   end

   prune ::: template
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
      self :: INOUT

   ENSURE(.reflections.allocated,"No reflection data")

      new_reflections :: VEC{REFLECTION}@
      good,bad,h1,h2,h3 :: VEC{INT}@
      val :: VEC{REAL}@
      table :: VEC{TABLE_COLUMN}@
      n_refl,n,i,g,b :: INT
      title :: STR

      ! No. of old reflections
      n_refl = .reflections.dim

      ! Find out how many rejects "n" there are
      n = 0
      do i = 1,n_refl
         if (NOT .reflections(i).TEST?(CUTOFF?)) cycle
         n = n + 1
      end

      ! Are there any weak reflections?
      if (n==0) return

      ! Are there any weak reflections?
      if (n==n_refl) then
      DIE("All reflection data has been rejected!")
      end

      ! Create the "good" and "bad" lists and how many of each
      bad.create(n)
      good.create(n_refl-n)
      g = 0
      b = 0
      do i = 1,n_refl
         if (.reflections(i).TEST?(CUTOFF?)) then
            b = b + 1
            bad(b) = i
         else
            g = g + 1
            good(g) = i
         end
      end

      ! Print out
      stdout.flush
      title = "Reflections pruned"

      stdout.text(repeat("=",len_trim(title)))
      stdout.text(trim(title))
      stdout.text(repeat("=",len_trim(title)))

      ! Banner
      stdout.flush
      stdout.show("Rejection criteria      =","TEST?")
      stdout.flush
      stdout.show("No. of reflections      =",n_refl)
      stdout.show("No. of rejects          =",b)
      stdout.show("No. of kept reflections =",g)
      stdout.show("Wavelength (Bohr)       =",.wavelength)
      stdout.show("Wavelength (Angstrom)   =",.wavelength*ANGSTROM_PER_BOHR)
      if ("SHOW?"=="stl") then
      stdout.show("Cutoff (Bohr^-1)        =",CUTOFF?)
      stdout.show("Cutoff (Angstrom^-1)    =",CUTOFF?/ANGSTROM_PER_BOHR)
      else
      stdout.show("Cutoff                  =",CUTOFF?)
      end

      if (.show_rejects) then

         stdout.flush
         stdout.text("Rejects:")

         ! Get data
         n_refl = bad.dim
         h1.create(n_refl);       h1  = .reflections(bad(:)).h1
         h2.create(n_refl);       h2  = .reflections(bad(:)).h2
         h3.create(n_refl);       h3  = .reflections(bad(:)).h3
         val.create(n_refl);      val = REFLECTION:SHOW?(.reflections(bad(:)))

         ! Table
         table.create(4)
         table(1).set_heading("h");     table(1).set_values(h1)
         table(2).set_heading("k");     table(2).set_values(h2)
         table(3).set_heading("l");     table(3).set_values(h3)
         table(4).set_heading("SHOW?"); table(4).set_values(val)
         table.put

         ! Clean
         table.destroy
         h3.destroy
         h2.destroy
         h1.destroy
         val.destroy

         stdout.flush
         stdout.text("Kept:")

         ! Get data
         n_refl = good.dim
         h1.create(n_refl);       h1  = .reflections(good(:)).h1
         h2.create(n_refl);       h2  = .reflections(good(:)).h2
         h3.create(n_refl);       h3  = .reflections(good(:)).h3
         val.create(n_refl);      val = REFLECTION:SHOW?(.reflections(good(:)))

         ! Table
         table.create(4)
         table(1).set_heading("h");     table(1).set_values(h1)
         table(2).set_heading("k");     table(2).set_values(h2)
         table(3).set_heading("l");     table(3).set_values(h3)
         table(4).set_heading("SHOW?"); table(4).set_values(val)
         table.put

         ! Clean
         table.destroy
         h3.destroy
         h2.destroy
         h1.destroy
         val.destroy

      end

      ! Copy the non-rejects
      new_reflections.create(g)
      new_reflections = .reflections(good)
      .reflections = new_reflections
      !!!!!!!!!!!!!!!!!!!!!!

      ! Clean
      bad.destroy
      good.destroy

   end

   prune_bad_F_reflections ::: get_from(prune, TEST?=>has_large_abs_F_z, CUTOFF?=>.F_z_cutoff, SHOW?=>abs_F_z), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_high_angle_reflections ::: get_from(prune, TEST?=>has_high_stl, CUTOFF?=>.stl_high_cutoff, SHOW?=>stl), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_low_angle_reflections ::: get_from(prune, TEST?=>has_low_stl, CUTOFF?=>.stl_low_cutoff SHOW?=>stl), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_weak_Fs ::: get_from(prune, TEST?=>has_weak_F_exp, CUTOFF?=>.F_sigma_cutoff, SHOW?=>F_exp_on_sigma), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_weak_Is ::: get_from(prune, TEST?=>has_weak_I_exp, CUTOFF?=>.I_sigma_cutoff, SHOW?=>I_exp_on_sigma), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_zero_F_preds ::: get_from(prune, TEST?=>has_small_F_pred, CUTOFF?=>TOL(3), SHOW?=>F_pred), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_zero_F_calcs ::: get_from(prune, TEST?=>has_zero_F_calc_abs, CUTOFF?=>.F_calc_cutoff, SHOW?=>F_calc_abs), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_small_F_sigmas ::: get_from(prune, TEST?=>has_small_F_sigma, CUTOFF?=>TOL(3), SHOW?=>F_sigma), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_small_I_sigmas ::: get_from(prune, TEST?=>has_small_I_sigma, CUTOFF?=>TOL(6), SHOW?=>I_sigma), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

! ==============================
! Set scale & extinction factors
! ==============================

   get_F_optimum_parameters ::: PUREp
   ! Get the scale factors, extinction parameters, etc, which minimise
   ! the chi2.  (To get the corrections cooresponding to these
   ! parameters see routine .extinction_correction)
      self :: INOUT

      if (.refine_extinction) then

         ENSURE(NOT .INQ:use_multiple_scale_factors,"must use refine_extinction= no")
         .SET:optimize_F_extinction_factor

      else if (.refine_scale) then

         if (.INQ:use_multiple_scale_factors) then; .SET:optimize_F_scale_factors
         else;                                      .SET:optimize_F_scale_factor
         end

      end

   end

   get_I_optimum_parameters ::: PURE
   ! Get the scale factors, extinction parameters, etc, which minimise
   ! the chi2.  (To get the corrections cooresponding to these
   ! parameters see routine .extinction_correction)
      self :: INOUT

      if (.refine_extinction) then

       ! DIE_IF(.INQ:use_multiple_scale_factors,"must use refine_extinction= no")
       ! DIE("Not yet implemented")
         .SET:optimize_I_extinction_factor

      else if (.refine_scale) then

         if (.INQ:use_multiple_scale_factors) then; .SET:optimize_I_scale_factors
         else;                                      .SET:optimize_I_scale_factor
         end

      end

   end

   optimize_F_scale_factor ::: PURE
   ! Determine the structure factor scale factor to scale the
   ! calculated structure factors .F_calc by in order to minimise the
   ! chi2 against F_corr, normally F_exp. (But it does not do any
   ! scaling; see .extinction_correction routine for that)
      self :: INOUT

   ENSURE(.INQ:have_F_exp, "no experimental structure factors")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")

      top,bot,sg2,F_calc :: REAL
      n   :: INT
      ref :: REFLECTION


      top = ZERO
      bot = ZERO
      do n = 1,.reflections.dim

         ref = .reflections(n)

         if (.data_kind=="pnd") then; F_calc = REALIFY(ref.F_calc)
         else;                        F_calc = abs(ref.F_calc)
         end
       ! ENSURE(ref.F_sigma/=ZERO,"Structure factor has zero error!")

         sg2 = ONE / (ref.F_sigma * ref.F_sigma)
         top = top + F_calc * ref.F_corr * sg2
         bot = bot + F_calc * F_calc * sg2

      end

      .scale_factor = top/bot

   end

   optimize_I_scale_factor ::: PURE
   ! Determine the structure factor scale factor to scale the calculated
   ! structure factors .F_calc by in order to minimise the chi2. (But it does
   ! not do any scaling; see .extinction_correction routine for that)
      self :: INOUT

   ENSURE(.INQ:have_I_exp, "no experimental I's")
   ENSURE(.reflections.have_I_calc, "no calculated I's")
   ENSURE(.data_kind/="pnd", "sorry, noy yet ...")

      top,bot,sg2,I_calc :: REAL
      n,n_refl :: INT
      ref :: REFLECTION

      n_refl = .reflections.dim

      top = ZERO
      bot = ZERO

      do n = 1,n_refl

         ref = .reflections(n)

         I_calc = ref.I_calc
       ! ENSURE(ref.I_sigma/=ZERO,"Structure factor has zero error!")

         sg2 = ONE / (ref.I_sigma * ref.I_sigma)
       ! top = top + I_calc * ref.I_corr * sg2
         top = top + I_calc * ref.I_exp * sg2
         bot = bot + I_calc * I_calc * sg2

      end

      .scale_factor = top/bot

   end

   optimize_F_scale_factors ::: leaky, PURE
   ! Multiple scale factors are determined here ...
   ! Determine the structure factor scale factors to scale the calculated
   ! structure factors .F_calc by in order to minimise the chi2. (But it does
   ! not do any scaling; see .extinction_correction routine for that)
      self :: INOUT

   ENSURE(.INQ:have_F_exp, "no experimental structure factors")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(.INQ:use_multiple_scale_factors, "no reflection group numbers")

      top,bot,F_calc :: REAL
      g,n,n_refl,n_group :: INT
      ref :: REFLECTION

      n_group = maxval(.reflections.group)
      n_refl = .reflections.dim

      .scale_factors.destroy
      .scale_factors.create(n_group)

      do g = 1,n_group

         top = ZERO
         bot = ZERO

         do n = 1,n_refl

            ref = .reflections(n)

            if (ref.group/=g) cycle

            if (.data_kind=="pnd") then; F_calc = REALIFY(ref.F_calc)
            else;                        F_calc = abs(ref.F_calc)
            end

          ! These guys need to be pruned out at the start!
          ! ENSURE(ref.F_sigma/=ZERO,"Structure factor has zero error!")

            top = top + F_calc * ref.F_corr / (ref.F_sigma * ref.F_sigma)
            bot = bot + F_calc * F_calc / (ref.F_sigma * ref.F_sigma)

         end

         .scale_factors(g) = top/bot

      end

   end

   optimize_I_scale_factors ::: leaky, PURE
   ! Multiple scale factors are determined here ...
   ! Determine I scale factors to scale the calculated
   ! .I_calc by in order to minimise the chi2I. (But it does
   ! not do any scaling; see .extinction_correction routine for that)
      self :: INOUT

   ENSURE(.INQ:have_I_exp, "no experimental I's")
   ENSURE(.reflections.have_I_calc, "no calculated I's")
   ENSURE(.INQ:use_multiple_scale_factors, "no reflection group numbers")
   ENSURE(.data_kind/="pnd", "sorry, noy yet ...")

      top,bot,I_calc :: REAL
      g,n,n_refl,n_group :: INT
      ref :: REFLECTION

      n_group = maxval(.reflections.group)
      n_refl = .reflections.dim

      .scale_factors.create(n_group)

      do g = 1,n_group

         top = ZERO
         bot = ZERO
        
         do n = 1,n_refl
        
           ref = .reflections(n)
        
           if (ref.group/=g) cycle
        
           I_calc = ref.I_calc
        
         ! These guys need to be pruned out at the start!
         ! ENSURE(ref.I_sigma/=ZERO,"Structure factor has zero error!")
        
         ! top = top + I_calc * ref.I_corr / (ref.I_sigma * ref.I_sigma)
           top = top + I_calc * ref.I_exp  / (ref.I_sigma * ref.I_sigma)
           bot = bot + I_calc * I_calc / (ref.I_sigma * ref.I_sigma)

        end

        .scale_factors(g) = top/bot

      end

   end

   optimize_F_extinction_factor ::: PURE
   ! Optimize .scale_factor and .extinction_factor with Larson's method.
   ! NOTE: the corrections are not applied to .F_pred; use the routine
   ! .extinction_corrections to do that.
   ! See: Larson, A. C., in Crystallographic Computin
   !      Ed. Ahmed, F. R. (Copenhagen, Munksgaard 1970), pp. 291-294.
      self :: INOUT

      p :: VEC{REAL}(2)
      chi2_min :: REAL

      ! Get starting scale factor
      .SET:optimize_F_scale_factor

      ! Do a 2-variable minimisation
      ! p(2) is the .extinction_factor
      p(1) = .scale_factor
      p(2) = ZERO          

      VEC{REAL}:min_BFGS(self &
                        ,DIFFRACTION_DATA.INQ::chi2F   &
                        ,DIFFRACTION_DATA.INQ::d_chi2F &
                        ,p,chi2_min,tol=TOL(7),gtol=TOL(7),step=TOL(4))

      .scale_factor      = p(1)
      .extinction_factor = p(2)

   end

   optimize_I_extinction_factor ::: PURE
   ! Optimize .scale_factor and .extinction_factor with Larson's method.
   ! NOTE: the corrections are not applied to .F_pred; use the routine
   ! .extinction_corrections to do that.
   ! See: Larson, A. C., in Crystallographic Computing
   !      Ed. Ahmed, F. R. (Copenhagen, Munksgaard 1970), pp. 291-294.
      self :: INOUT

      p :: VEC{REAL}(2)
      chi2_min :: REAL

      ! Get starting scale factor
      .SET:optimize_I_scale_factor

      ! Do a 2-variable minimisation
      ! p(2) is the .extinction_factor
      p(1) = .scale_factor
      p(2) = ZERO

      VEC{REAL}:min_BFGS(self &
                        ,DIFFRACTION_DATA.INQ::chi2I   &
                        ,DIFFRACTION_DATA.INQ::d_chi2I &
                        ,p,chi2_min,tol=TOL(7),gtol=TOL(7),step=TOL(6))

      .scale_factor      = p(1)
      .extinction_factor = p(2)

   end

!  ========================================
!  Initialize or update fit/refinement info
!  ========================================

   initialize_fit_data(n_p,n_f,labels) ::: leaky, PURE
   ! Create the fit data arrays & initialize if needed.
   ! "n_p" is the number of unique pADP's to refine.
   ! "n_f" is the number of non-unique fragment atom pADP's.
   ! Some of these arrays will already be created if refining.
      self :: INOUT
      n_p,n_f :: INT, IN
      labels :: VEC{STR}, IN

      ! Reset fit data
      .SET:destroy_fit_data
      .SET:set_fit_data

      ! Set fitting
      if (NOT .refine_structure) .SET:set_fit_structure(TRUE)

      ! Initially chi^2 is as big as you can get
      .chi2_fit0 = huge(ONE)

      ! Set the uique # of parameters. Used for getting the correct
      ! chi^2 statistic. Note: zero eigenvalues in the least squares
      ! will modify this value.
      .n_param = n_p
      .n_param_manually_set = FALSE ! Ignore manually set n_p

      ! Create parameter vectors & shifts (leaky)
      .dX.create(n_p)
      .X_fit.create(n_p)
      .X_fit0.create(n_p)

      ! Create esd's and covariances
      .esd.create(n_p)
    ! .covariance_mx.create(n_p,n_p)
    ! .correlation_mx.create(n_p,n_p)
      .fragment_covariance_mx.create(n_f,n_f)

      ! Set esd's to zero
      .esd = ZERO

      ! Create the table (leaky)
      .fit_table.create(9)

      ! Fit table headings
      .fit_table(1).set_heading("Fit")
      .fit_table(1).set_subhead("Iter")
      .fit_table(2).set_heading("chi2")
      .fit_table(3).set_heading("R")
      .fit_table(4).set_heading("R_w")
      .fit_table(5).set_heading("Max.")
      .fit_table(5).set_subhead("Shift")
      .fit_table(5).set_sb3head("/esd")
      .fit_table(6).set_heading("Max.")
      .fit_table(6).set_subhead("Shift")
      .fit_table(6).set_sb3head("/au")
      .fit_table(7).set_heading("Max.")
      .fit_table(7).set_subhead("Shift")
      .fit_table(7).set_sb3head("param")
      .fit_table(8).set_heading("No. of")
      .fit_table(8).set_subhead("params")
      .fit_table(9).set_heading("No. of")
      .fit_table(9).set_subhead("eig's")
      .fit_table(9).set_sb3head("near 0")

      ! Table widths (here because of label width)
      .fit_table(1).set_width_from(.max_iterations) ! Iter
      .fit_table(2).set_width_from(TEN**3)          ! chi2
      .fit_table(3).set_width_from(ONE)             ! R
      .fit_table(4).set_width_from(ONE)             ! Rw
      .fit_table(5).set_width_from(-TEN)            ! Max shift/esd
      .fit_table(6).set_width_from(-TEN)            ! Max shift
      .fit_table(7).set_width_from(labels)          ! Max shift par label
      .fit_table(8).set_width(3)                    ! n_param
      .fit_table(9).set_width(3)                    ! near_0

   end

   initialize_refinement_data(n_p,labels) ::: leaky, PURE
   ! Create the refinement data arrays & initialize if needed
   ! "n_p" is the number of unique pADP's to refine.
      self :: INOUT
      n_p :: INT, IN
      labels :: VEC{STR}, IN

   ENSURE(.ref_iteration==0,"ref_iteration is not 0!")

      ! Destroy existing data (leaky)
      .SET:destroy_refinement_data
      .SET:set_refinement_data

      ! Initially chi^2 is as big as you can get
      .chi2_ref0 = huge(ONE)

      ! Create parameter vectors (leaky)
      .X_ref.create(n_p)
      .X_ref0.create(n_p)

      ! Refinement table headings
      .ref_table.create(11)
      .ref_table(1).set_heading("Ref.")
      .ref_table(1).set_subhead("Iter")
      .ref_table(2).set_heading("No of")
      .ref_table(2).set_subhead("  Fit")
      .ref_table(2).set_sb3head("iters")
      .ref_table(3).set_heading("chi2")
      .ref_table(3).set_subhead("initial")
      .ref_table(4).set_heading("chi2")
      .ref_table(4).set_subhead("final")
      .ref_table(5).set_heading("R")
      .ref_table(6).set_heading("R_w")
      .ref_table(7).set_heading("Max.")
      .ref_table(7).set_subhead("Shift")
      .ref_table(7).set_sb3head(" /esd")
      .ref_table(8).set_heading("Max.")
      .ref_table(8).set_subhead("Shift")
      .ref_table(8).set_sb3head("/au")
      .ref_table(9).set_heading("Max.")
      .ref_table(9).set_subhead("Shift")
      .ref_table(9).set_sb3head("param")
      .ref_table(10).set_heading("No. of")
      .ref_table(10).set_subhead("params")
      .ref_table(11).set_heading("No. of")
      .ref_table(11).set_subhead("eig's")
      .ref_table(11).set_sb3head("near 0")

      ! Table widths (needs to be here because of label width)
      .ref_table(1).set_width_from(.max_iterations) ! Iter
      .ref_table(2).set_width_from(.max_iterations) ! # of fit iters
      .ref_table(3).set_width_from(TEN**3)          ! chi2 initial
      .ref_table(4).set_width_from(TEN**3)          ! chi2 final
      .ref_table(5).set_width_from(ONE)             ! R
      .ref_table(6).set_width_from(ONE)             ! Rw
      .ref_table(7).set_width_from(-TEN)        ! Max shift/esd
      .ref_table(8).set_width_from(-TEN)        ! Max shift/esd
      .ref_table(9).set_width_from(labels)          ! Max shift par
      .ref_table(10).set_width(3)                   ! n_param
      .ref_table(11).set_width(3)                   ! n_param

   end

   update_n_param_and_chi2 ::: PURE
   ! Update the number of parameters and recalculate the chi2
      self :: INOUT
      .SET:update_n_param
      .SET:update_chi2
   end

   update_n_param ::: PURE
   ! Update the number of parameters to include scale
   ! and extinction factors.
      self :: INOUT

      if (NOT .n_param_manually_set) then

         ! The number of params is assumed set in a refinement
         ! So only initialize n_param if this isn't going on
         ! or if not manually set by readinf a CIF
         if (NOT (.refine_structure OR .fit_structure)) then
            .n_param = 0
         end

         ! Add on extra parameters for scale/extinction
         if (.refine_extinction) then

            ENSURE(NOT .INQ:use_multiple_scale_factors,"must use refine_extinction= no")
            .n_param = .n_param + 2

         else if (.refine_scale) then

            if (.INQ:use_multiple_scale_factors) then
               .n_param = .n_param + maxval(.reflections.group)
            else
               .n_param = .n_param + 1
            end

         end

         if (.XCW) then
        
            ! Add lambda as an extra parameter
            ! Not correct - but better than nothing?
            .n_param = .n_param + 1
        
         end

      end

   end

   update_chi2 ::: PURE
   ! Update the number of parameters and recalculate the chi2
      self :: INOUT

   ENSURE(.n_param>0,"n_param must be +ve")

      n_r,n_p :: INT

      ! Update the chi2
      n_r = .reflections.dim - 1
      n_p = .reflections.dim - .n_param
      .chi2      = max(n_r,1)*.reflections.F_chi2/max(n_p,1)
      .chi2_fit  = .chi2

   end

   update_fit_info ::: PURE
   ! Update refinement parameters after fit
      self :: INOUT

      ! Converged
      .fit_converged = abs(.max_shift_on_esd) < .tol_for_shift_on_esd &
                    AND .fit_iteration >= .min_iterations

      ! Florian here: Added TOL(14) due to differences between
      ! machines and also # of CPUs when running tests, as numerical
      ! difference was giving problems, plase tell me if this is
      ! reasonable!!!! (@Dylan and @Peter)
      ! All good, believe you, thanks for the exp. (Dylan)
      .chi2_increased = .chi2_fit > (.chi2_fit0+TOL(14)) &
                    AND .fit_iteration > .min_iterations

      ! Roll back the parameters is chi2 increases
      ! WARNING: covariances are not rolled back ...
    ! if (.chi2_increased) then
    !    .X_fit    = .X_fit0
    !    .chi2_fit = .chi2_fit0
    ! end

      ! Too many fit iterations?
      .too_many_fit_iterations = .fit_iteration > .max_iterations

      ! Done?
      .fit_finished = .fit_converged  &
                   OR .chi2_increased &
                   OR .too_many_fit_iterations

      ! If refining, store initial & final chi2
      if (.refine_structure) then
         if (.fit_iteration==1) .chi2_ref0 = .chi2_fit ! Store initial chi2
         if (.fit_finished)     .chi2_ref  = .chi2_fit ! Stoire final chi2
      end

      ! Fix the number of parameters
      if (.fit_finished) .n_param_manually_set = TRUE

   end

   update_fit_parameters ::: PURE
   ! Update i.e. increment the fit parameters
      self :: INOUT

      ! Next iteration
      .fit_iteration = .fit_iteration + 1

      ! Save and increment parameters
      .X_fit0 = .X_fit
      .X_fit  = .X_fit + .dX

   end

   update_refinement_info ::: PURE
   ! Return whether the refinement has finished
      self :: INOUT

      ! Has fit finished?
      .refinement_converged = abs(.max_refshift_on_esd) < .tol_for_shift_on_esd &
                           AND .ref_iteration >= .min_iterations

      ! chi2 inceased?
      .chi2_increased = .chi2_ref > (.chi2_ref0+TOL(2))

      ! Too many refinement iterations?
      .too_many_ref_iterations = .ref_iteration > .max_iterations

      .refinement_finished = .refinement_converged &
                          OR .chi2_increased       &
                          OR .too_many_ref_iterations

   end

   update_refinement_parameters ::: PURE
   ! Update the refinement parameters
      self :: INOUT

      ! Increment
      .ref_iteration = .ref_iteration + 1

      ! Transfer parameters
      .X_ref0 = .X_ref ! From previous or 1st iteration
      .X_ref  = .X_fit ! This iteration

   end

!  ===========
!  Update ESDs
!  ===========

   update_fit_esds ::: PURE
   ! Set the esd's for the current fit.
   ! WARNING: The order of the parameters is not always the same
   ! between calls of this routine. You *must* call this if the
   ! covariance matrix has been transformed from a unique-fragment
   ! atom ordering to asymmetric-unit ordering.
      self :: INOUT

   ENSURE(.covariance_mx.allocated,"no covariance_mx")
   ENSURE(.esd.allocated,"no esd")
   ENSURE(.dX.allocated,"no dX")
   ENSURE(.esd.dim==.covariance_mx.dim1,"esd, covariance_mx mismatch")
   ENSURE(.esd.dim==.dX.dim,            "esd, dX mismatch")

      indmax,p :: INT
      dX,val,valmax :: REAL

      ! Set variances
      .covariance_mx.put_diagonal_to(.esd)

    ! stdout.text("variances:")
    ! stdout.put(.esd,by_column=TRUE)

      ! Set ESD's
      .esd = sqrt(.esd)

    ! stdout.text("esd:")
    ! stdout.put(.esd,by_column=TRUE)

    ! stdout.text("dX:")
    ! stdout.put(.dX,by_column=TRUE)

    ! W.create(.esd.dim)
    ! where (abs(.esd)<DIFFRACTION_DATA_SMALLEST_SHIFT); W = ZERO
    ! elsewhere;                                         W = .dX/.esd
    ! end
    ! stdout.text("dX/esd:")
    ! stdout.put(W,by_column=TRUE)
    ! W.destroy

      ! Get the location of the maximum shift on esd
      indmax = 1
      valmax = ZERO
      do p = 1,.esd.dim

         dX  = .dX(p)
         val = .esd(p)

         ! Ignore symmetry zero's
         ! WARNING: don't know if this is right
         if (abs(val)<DIFFRACTION_DATA_SMALLEST_SHIFT) cycle
         if (abs(dX )<DIFFRACTION_DATA_SMALLEST_SHIFT) cycle

         ! Shift on esd
         val = .dX(p)/val

         ! Set shift on esd if larger ...
         if (abs(val)<=abs(valmax)) cycle

         valmax = val
         indmax = p

      end

      ! Assign maximum index
      .max_shift_on_esd_ind = indmax
      .max_shift_on_esd     = valmax
      .max_shift            = .dX(indmax)
      .max_esd              = .esd(indmax)

      ! Debug
    ! stdout.show("max_shift_on_esd_ind  =",indmax)
    ! stdout.show("max_shift_on_esd      =",valmax)

   end

   update_refinement_ESDs ::: PURE
   ! Update the esd's for the current fit.
   ! NOTE: must have updated X_ref and X_ref0
      self :: INOUT

   ENSURE(.covariance_mx.allocated,"no covariance_mx")
   ENSURE(.esd.allocated,"no esd")
   ENSURE(.dX.allocated, "no dX")
   ENSURE(.esd.dim==.covariance_mx.dim1,"esd, covariance_mx mismatch")
   ENSURE(.esd.dim==.dX.dim,                "esd, dX mismatch")
   ENSURE(.X_ref.allocated, "no X_ref")
   ENSURE(.X_ref0.allocated,"no X_ref0")

      n_p,indmax,p,n :: INT
      val,valmax,valsum :: REAL
      dX :: VEC{REAL}@

      ! Constants
      n_p = .esd.dim

      ! Change in parameters between refinements
      dX.create(n_p)
      dX = .X_ref - .X_ref0

      ! Get the location of the maximum shift on esd
      n = 0
      indmax = DIFFRACTION_DATA_INDMAX_INIT
      valmax = ZERO
      valsum = ZERO
      do p = 1,n_p

         val = .esd(p)
         if (val==ZERO) cycle

         val = dX(p)/val

         n      = n + 1
         valsum = valsum + abs(val)

         if (abs(val)<=valmax) cycle

         valmax = val
         indmax = p

      end

      ! Assign maximum index
    ! DIE_IF(indmax==0,"no maximum index found!")
      .max_refshift_on_esd_ind = indmax
      .ave_refshift_on_esd     = valsum/n
      .max_refshift_on_esd     = valmax
      .max_refshift            = dX(indmax)
      .max_refesd              = .esd(indmax)

      ! Debug
    ! stdout.show("max_refshift_on_esd_ind  =",indmax)
    ! stdout.show("max_refshift_on_esd      =",valmax)
    ! .max_refshift_on_esd     = valmax
    ! stdout.text(".esd:")
    ! stdout.put(.esd,by_column=TRUE)

      ! Clean
      dX.destroy

   end

!  =================
!  Structure factors
!  =================

   make_F_predicted(update_n_param)
   ! Make the predicted magnitude of the structure factors, including
   ! possibly an overall scale factor and extinction correction.
      self :: INOUT
      update_n_param :: BIN, optional, IN

   ENSURE(.reflections.allocated,"no reflection data")

      F_pred :: VEC{REAL}@
      n_r,n_p :: INT
      update :: BIN

      if (NOT .INQ:have_F_exp) then

         ! No experimental data ...
         F_pred.create(.reflections.dim)
         if (.data_kind=="pnd") then; F_pred = REALIFY(.reflections.F_calc)
         else;                        F_pred =     abs(.reflections.F_calc)
         end

         ! Set F_predicted, uscaled
         .reflections.set_F_pred(F_pred)
         F_pred.destroy
      
      else

         ! Have experimental data ...
         update = TRUE
         if (present(update_n_param)) update = update_n_param

         ! Experimental data exists ...
         if (update) .SET:update_n_param
   
         ! Get optimum scale factors, extinction, etc.
         if (.refine_extinction OR .refine_scale) .SET:get_F_optimum_parameters

         ! Make F_predicted; scale_factor multiplies F_calc
         F_pred.create(.reflections.dim)
         if (.data_kind=="pnd") then; F_pred = REALIFY(.reflections.F_calc) * .INQ:F_scale_and_extn_correction
         else;                        F_pred =     abs(.reflections.F_calc) * .INQ:F_scale_and_extn_correction
         end
   
         ! Mix in some F_exp
         if (.SF_mixing_parameter>ZERO) then
         if (.INQ:have_F_exp) then
            F_pred = (ONE-.SF_mixing_parameter)* F_pred &
                   + .SF_mixing_parameter      * .reflections.F_exp
         end
         end
   
         ! Set F_predicted
         .reflections.set_F_pred(F_pred)
         F_pred.destroy

   
         ! Calculate the chi^2; reset denominator
         n_r = .reflections.dim - 1
         n_p = .reflections.dim - .n_param
         .chi2      = max(n_r,1)*.reflections.F_chi2/max(n_p,1)
         .chi2_fit0 = .chi2_fit
         .chi2_fit  = .chi2

      end

   end

   make_I_predicted(update_n_param)
   ! Make the predicted squared magnitude of the structure factors, including
   ! possibly an overall scale factor and extinction correction.
      self :: INOUT
      update_n_param :: BIN, optional, IN

   ENSURE(.reflections.allocated,"no reflection data")
   ENSURE(NOT .data_kind=="pnd", "sorry, no PND yet")

      I_pred :: VEC{REAL}@
      n_r,n_p :: INT
      update :: BIN

      if (NOT .INQ:have_F_exp) then

         ! Set I_predicted
         .reflections.set_I_pred(.reflections.I_calc)

      else

         update = TRUE
         if (present(update_n_param)) update = update_n_param

         ! Experimental data exists ...
         if (update) .SET:update_n_param

         ! Get optimum scale factors, extinction, etc.
         if (.refine_extinction OR .refine_scale) .SET:get_I_optimum_parameters
       
         ! Make I_predicted
         I_pred.create(.reflections.dim)
         I_pred = .reflections.I_calc * .INQ:I_scale_and_extn_correction
       
         ! Mix in some F_exp
         if (.SF_mixing_parameter>ZERO) then
         if (.INQ:have_I_exp) then
            I_pred = (ONE-.SF_mixing_parameter)* I_pred &
                   + .SF_mixing_parameter      * .reflections.I_exp
         end
         end
       
         ! Set I_predicted
         .reflections.set_I_pred(I_pred)
         I_pred.destroy
       
         ! Calculate the chi^2; reset denominator
         n_r = .reflections.dim - 1
         n_p = .reflections.dim - .n_param
         .chi2      = max(n_r,1)*.reflections.I_chi2/max(n_p,1)
         .chi2_fit0 = .chi2_fit
         .chi2_fit  = .chi2

      end

   end

   make_phased_dF_a(dF) ::: PURE
   ! Get phased structure factor differences from experimental values
   ! (without extinction/scale factor correction) for residual map.
   ! Corrected to remove dispersion 8/1/2019 DJ & HBB
      self :: IN
      dF :: VEC{CPX}, OUT

   ENSURE(.reflections.allocated, "no structure factors")
   ENSURE(dF.dim==.reflections.dim, "incorrect size, dF")

      phase :: VEC{CPX}@
      ext   :: VEC{REAL}@
      n_refl :: INT

      n_refl = .reflections.dim

      phase.create(n_refl)
      ext.create(n_refl)

      ! Phases should not include dispersion (if added)
      phase = REFLECTION:F_phase_without_disp(.reflections)

      ! These are the scale factors & extinction
      ext = .INQ:F_scale_and_extn_correction

      ! Subtract the predicted value (which includes dispersion)
      ! Also, place F_exp on an absolute scale
      dF = (.reflections.F_corr - .reflections.F_pred) * phase / ext

      ext.destroy
      phase.destroy

   end

   make_phased_dF_b(dF) ::: PURE
   ! Get phased structure factor differences from experimental values
   ! (without extinction/scale factor correction) for residual map.
   ! Corrected to remove dispersion 8/1/2019 DJ & HBB
      self :: IN
      dF :: MAT3{CPX}@, OUT

   ENSURE(.reflections.allocated, "no structure factors")

      phase :: VEC{CPX}@
      ext   :: VEC{REAL}@
      n_refl :: INT
      r,h,k,l :: INT

      n_refl = .reflections.dim

      phase.create(n_refl)
      ext.create(n_refl)

      ! Phases should not include dispersion (if added)
      phase = REFLECTION:F_phase_without_disp(.reflections)

      ! These are the scale factors & extinction
      ext   = .INQ:F_scale_and_extn_correction

      ! Subtract the predicted value (which includes dispersion)
      ! Also, place F_exp on an absolute scale
      dF = ZERO
      do r = 1,n_refl
         h = .reflections(r).h1
         k = .reflections(r).h2
         l = .reflections(r).h3
         dF(h,k,l) = (.reflections(r).F_corr - .reflections(r).F_pred) * phase(r) / ext(r)
      end
      
      ! Clean
      ext.destroy
      phase.destroy

   end

   make_symop_generated_dF_a_v2(dF,g1,g2,g3,spacegroup,mult) ::: PURE
   ! Make the full set of symmetry generated reciprocal get phased
   ! structure factor differences from experimental values
   ! (without extinction/scale factor correction) for residual map.
   ! "mult" are themultiplicity factors for the FOurier sythesis.
   ! which should equal to 2 for centro structures.
      self       :: IN
      dF         :: VEC{CPX}, OUT
      g1,g2,g3   :: VEC{INT}, OUT
      spacegroup :: SPACEGROUP, IN
      mult       :: VEC{INT}, IN

   ENSURE(.reflections.allocated,"no reflections")
   ENSURE(dF.dim  ==spacegroup.n_seitz*.reflections.dim,"dF: wrong dim")
   ENSURE(g1.dim  ==spacegroup.n_seitz*.reflections.dim,"g1: wrong dim")
   ENSURE(g2.dim  ==spacegroup.n_seitz*.reflections.dim,"g2: wrong dim")
   ENSURE(g3.dim  ==spacegroup.n_seitz*.reflections.dim,"g3: wrong dim")
   ENSURE(mult.dim==.reflections.dim,"mult: wrong dim")

      R :: MAT{REAL}(3,3)
      ext :: VEC{REAL}@
      t   :: VEC{REAL}(3)
      g,h :: VEC{INT}(3)
      n_refl,n,p0,p,s, ss, Friedel :: INT
      F_calc,F_disp,F_exp,phase,ci :: CPX

      ! No. of reflection
      n_refl = .reflections.dim

      ci = -2*PI*IMAGIFY(ONE)

      ! Per-reflection scale factors & extinction corections
      ext.create(n_refl)
      ext = .INQ:F_scale_and_extn_correction

      ! Make the symmetry-generated Miller indices
      p = 0
      do n = 1,n_refl

         ! F_calc (absolute scale) *including* dispersion
         F_calc = .reflections(n).F_calc

         ! Dispersion contribution only
         F_disp = .reflections(n).F_disp

         ! Complex experimental SF (absolute scale)
         phase  = F_calc/abs(F_calc) 
         F_exp  = .reflections(n).F_exp*phase/ext(n)

         ! Complex experimental SF without dispersion
         F_exp  = F_exp - F_disp     ! Kang comment: F_disp here only?

         ! F_calc withot dispersion
         F_calc = F_calc - F_disp    ! Kang comment:   or here only?

         ! Unique miller indices
         h = .reflections(n).Miller_indices

         ! Friedel multiplicity
         Friedel = mult(n)

         p0 = p
         ss = 0 ! Kang note. Condition all(h==g) alwyas matches for s=1 (id operator)
 
         do s = 1,spacegroup.n_seitz

            ! Symop in fractionals
            R = transpose(spacegroup.seitz(1:3,1:3,s))
            t = spacegroup.seitz(1:3,4,s) 

            ! Index of symmetry generated reflections
            p = p + 1

            ! Symmetry generated miller indices
            g = nint(matmul(R,h))

            ! Count if the same
            if (all(h==g)) ss = ss + 1
            if (all(-h==g)) ss = ss + 1 ! Kang note: Bijvoet pair counting 
                                        ! (g=-h created by symop other than the inversion, for example, 2 (0,0,z) acting on [hk0] )
                                        ! This counting scheme passed the test of F d -3 m (IT#227) system (diamond). 2024.Nov.1 
            ! Return
            g1(p) = g(1)
            g2(p) = g(2)
            g3(p) = g(3)

            ! Symmetry generated (Delta F)
            dF(p) = (F_exp - F_calc)*Friedel ! Kang comment: For now, F_disp will cancel each other out and do nothing
            dF(p) = dF(p)*exp(ci*dot_product(h,t)) ! translation part

         end

         ! Divide by (reciprocal) site symmetry factor
         if (ss>1) dF(p0+1:p) = dF(p0+1:p)/REALIFY(ss)

      end

      ! Clean
      ext.destroy

      ! Divide by the number of data sets
      if (.n_data_sets>1) then
         dF = dF/REALIFY(.n_data_sets)
      end

   end

!   make_symop_generated_dF_a(dF,g1,g2,g3,spacegroup) ::: PURE
!   ! Make the full set of symmetry generated reciprocal get phased
!   ! structure factor differences from experimental values
!   ! (without extinction/scale factor correction) for residual map.
!   ! WARNING: reflections ASSUMED UNIQUE here
!      self :: IN
!      dF :: VEC{CPX}, OUT
!      g1,g2,g3 :: VEC{INT}, OUT
!      spacegroup :: SPACEGROUP, IN
!
!   ENSURE(.reflections.allocated,"no reflections")
!   ENSURE(dF.dim1==spacegroup.n_seitz*.reflections.dim,"dF: wrong dim1")
!   ENSURE(g1.dim1==spacegroup.n_seitz*.reflections.dim,"g1: wrong dim1")
!   ENSURE(g2.dim1==spacegroup.n_seitz*.reflections.dim,"g2: wrong dim1")
!   ENSURE(g3.dim1==spacegroup.n_seitz*.reflections.dim,"g3: wrong dim1")
!
!      R :: MAT{REAL}(3,3)
!      t :: VEC{REAL}(3)
!      g,h :: VEC{INT}(3)
!      n_refl,n,p0,p,s, ss :: INT
!      F_calc,F_disp,F_exp,phase,ci :: CPX
!      ext :: VEC{REAL}@
!
!      ! No. of reflection
!      n_refl = .reflections.dim
!
!      ! These are the scale factors & extinction
!      ext.create(n_refl)
!      ext = .F_scale_and_extn_correction
!
!      ! Make the symmetry-generated k points
!      p = 0
!
!      ci = -2*PI*IMAGIFY(ONE)
!
!      do n = 1,n_refl
!
!         ! F_calc phase including dispersion
!         F_calc = .reflections(n).F_calc
!
!         ! Remove dispersion from F_calc & phase
!         F_disp = .reflections(n).F_disp
!         F_calc = F_calc - F_disp    ! Does disp include TF here?
!         phase  = F_calc/abs(F_calc) ! phase without dispersion
!
!         ! Phase and scale F_exp
!         ! WARNING: this uses (potentially) scale factor with
!         ! dispersion included in F_calc .... this is conservative
!         F_exp  = .reflections(n).F_exp*phase/ext(n)
!
!         ! Unique miller indices
!         h(1) = .reflections(n).h
!         h(2) = .reflections(n).k
!         h(3) = .reflections(n).l
!
!         p0 = p
!         ss = 1
!
!         do s = 1,spacegroup.n_seitz
!
!            ! Symop in fractionals
!            R = transpose(spacegroup.seitz(1:3,1:3,s))
!            t = spacegroup.seitz(1:3,4,s) 
!
!            ! Index of symmetry generated reflections
!            p = p + 1
!
!            ! Symmetry generated miller indices
!            g = nint(matmul(R,h))
!
!            ! Count if the same
!            if (all(h==g)) ss = ss + 1
!
!            ! Return
!            g1(p) = g(1)
!            g2(p) = g(2)
!            g3(p) = g(3)
!
!            ! Symmetry generated (Delta F)
!            dF(p) = F_exp - F_calc
!            dF(p) = dF(p)*exp(ci*dot_product(h,t)) ! translation part
!
!         end
!
!         ! Divide by (reciprocal) site symmetry factor
!         if (ss>1) dF(p0+1:p) = dF(p0+1:p)/REALIFY(ss)
!
!      end
!
!      ! Clean
!      ext.destroy
!
!      ! Divide by the number of data sets
!      if (.n_data_sets>1) then
!         dF = dF/REALIFY(.n_data_sets)
!      end
!
!   end

! ================ 
! Normal equations
! ================ 

   solve_normal_equations(dFdX) ::: leaky
   ! Get the ".dX" in some parameter vector by solving the normal
   ! equations, given "dFdX", the derivatives of the *absolute*
   ! *unscaled* *unextinction corrected* structure factors |F_calc|
   ! w.r.t. those parameters. 
   !    d |F_calc,i| d
   ! This procedure also sets:
   ! -  ".covariance_mx"
   ! - ".correlation_mx"
   ! - ".near_0",       the no. of LSM eigenvalues nearly equal to
   !                    zero, as determined by ".near_0_tol".
   ! - ".near_0_evals", 
   !   ".near_0_evecs", the eigenvalues and eigenvectors of the 
   !                    LSM nearly equal to zero
      self :: INOUT
      dFdX :: MAT{REAL}, INOUT

      dF :: MAT{REAL}@
      sig, del :: VEC{REAL}@
      n_refl,n_p :: INT

      ! Constants
      n_refl = .reflections.dim
      n_p    = dFdX.dim2

      ! LSQ arrays.
      ! In Coppens (1997) equation (4.18) these arrays correspond to:
      ! sig ... the weights w_i, here 1/sigma_i^2
      ! del ... the differences (F_exp,i - s_i*|F_calc,i|) for refine_F
      !     ... the differences (I_exp,i - s_i*|I_calc,i|) for refine_I
      !         where "s_i"
      ! dF  ... the parameter X derivatives s_i* d|F_calc,i|/dX, or
      !             or        X derivatives s_i* d|I_calc,i|/dX, or
      del.create(n_refl)
      sig.create(n_refl)
      dF.create(n_refl,n_p)

      if (.refine_F) then
         ! Refine on |F_exp|
         .INQ:d_F_pred_dX(dF,sig,del,dFdX)
      else
         ! Refine on |I_exp|
         dFdX = TWO*dFdX
         .INQ:d_I_pred_dX(dF,sig,del,dFdX)
      end

      ! Solve the normal equations
      .SET:solve_normal_equations(dF,sig,del)

      dF.destroy
      sig.destroy
      del.destroy

   end

!   solve_I_normal_equations(dIdX) ::: leaky
!   ! Get the ".dX" in some parameter vector by solving the F-normal
!   ! equations, given "dFdX", the derivatives of the square absolute
!   ! structure factors w.r.t. those parameters.
!      self :: INOUT
!      dIdX :: MAT{REAL}, IN
!
!   ENSURE(.INQ:have_I_exp, "no experimental structure factors")
!   ENSURE(.reflections.have_I_pred, "no predicted structure factors")
!   ENSURE(.reflections.have_nonzero_I_sigma, "no structure factor errors")
!   ENSURE(dIdX.dim1==.reflections.dim, "wrong size, dFdX")
!   ENSURE(dIdX.dim2==.dX.dim, "incompatible .dX and dIdX")
!
!      A,dI :: MAT{REAL}@
!      rhs,sig,del, eval :: VEC{REAL}@
!      n_refl,n_p,i,j :: INT
!
!      ! Constants
!      n_refl = .reflections.dim
!      n_p    = dIdX.dim2
!
!      ! Arrays
!      A.create(n_p,n_p)
!      rhs.create(n_p)
!      del.create(n_refl)
!      dI.create(n_refl,n_p)
!      sig.create(n_refl)
!
!      ! Make derivatives of I_pred
!      .INQ:d_I_pred_dX(dI,sig,del,dIdX)
!
!      ! Checked using FD, setting optimize extinction
!      ! and optimise scale OFF
!    ! stdout.text("dI:")
!    ! stdout.put(dI)
!
!      ! Make the normal matrix
!      do i = 1,n_p
!      do j = 1,n_p
!         A(i,j) = sum(sig*dI(:,i)*dI(:,j))
!      end
!      end
!    ! sig.destroy
!
!      ! Make the rhs
!      do i = 1,n_p
!         rhs(i) = sum(del*dI(:,i))
!      end
!
!    ! dI.destroy
!    ! del.destroy
!
!    ! stdout.text("A:")
!    ! stdout.put(A)
!    ! stdout.text("rhs:")
!    ! stdout.put(rhs)
!
!      ! Solve for the shifts .dX (leaky)
!      A.solve_ill_linear_equations( &
!         rhs            &
!        ,.dX            &
!        ,.near_0_tol    &
!        ,.near_0        &
!        ,.near_0_evals  &
!        ,.near_0_evecs  &
!        , eval          &
!        ,.covariance_mx &
!        ,.correlation_mx)
!
!    ! stdout.text("shifts:")
!    ! stdout.put(.dX)
!    ! stdout.show("Normal equations check =",maxval(abs(matmul(A,.dX)-rhs)))
!    ! stdout.show("Smallest eigenvalue    =",minval(abs(.near_0_evals)))
!    ! stdout.show("near_0_tol             =",.near_0_tol)
!    ! stdout.show("near_0                 =",.near_0)    
!    ! if (.near_0>0) then
!    ! stdout.text("Near_0 eigenvalues:")
!    ! stdout.put(.near_0_evals,by_column=TRUE)
!    ! end
!
!    ! eval.destroy
!
!      ! Get the maximum shift
!      where (abs(.dX)<DIFFRACTION_DATA_SMALLEST_SHIFT) 
!         .dX = ZERO
!      end
!      .max_shift = maxval(abs(.dX))
!
!      ! Set the number of parameters
!      .n_param = n_p - .near_0
!
!      ! Update chi2
!      .SET:update_n_param_and_chi2
!
!      ! Set the full covariance matrix
!      .covariance_mx = .chi2*.covariance_mx
!
!      ! Set the fit errors e.g. max(.dX/esd)
!      ! Parameter ordering is unique fragment atom order.
!      .SET:update_fit_esds
!
!    ! rhs.destroy
!    ! A.destroy
!
!    ! stdout.text("shifts before renormalisation:")
!    ! stdout.put(.dX)
!
!      ! Renormalize shift if too big
!    ! if (.max_shift>.max_allowed_param_shift) then
!    !    fac = .max_allowed_param_shift/.max_shift
!    !    .dX = fac * .dX
!    ! end
!
!    ! stdout.text("shifts after renormalisation:")
!    ! stdout.put(.dX)
!
!   end

   solve_normal_equations(dF,sig,del) ::: leaky
   ! Get the ".dX" in some parameter vector by solving the F-normal
   ! equations, given "dF", the derivatives of the absolute structure
   ! factors (or the same squared) w.r.t. those parameters.
      self :: INOUT
      dF   :: MAT{REAL}, IN
      sig  :: VEC{REAL}, IN
      del  :: VEC{REAL}, IN

   ENSURE(dF.dim1 ==.reflections.dim, "wrong size, dFdX")
   ENSURE(dF.dim2 ==.dX.dim, "incompatible .dX and dFdX")
   ENSURE(sig.dim1==.reflections.dim, "wrong size, sig")
   ENSURE(del.dim1==.reflections.dim, "wrong size, del")

      A    :: MAT{REAL}@
      rhs  :: VEC{REAL}@
      eval :: VEC{REAL}@
      nval :: VEC{REAL}@
      n_refl,n_p, i,j :: INT
      fac :: REAL

      ! Constants
      n_refl = .reflections.dim
      n_p    = dF.dim2

      ! Arrays
      A.create(n_p,n_p)
      rhs.create(n_p)

      ! Make the normal matrix
      do i = 1,n_p
      do j = 1,n_p
         A(i,j) = sum(sig*dF(:,i)*dF(:,j))
      end
      end

      ! Symmetrization is needed to machine precision
      A.symmetrize 

      ! Make the rhs
      do i = 1,n_p
         rhs(i) = sum(del*dF(:,i))
      end

      ! Solve for the shifts .dX (leaky)
      A.solve_ill_linear_equations_v1( &
         rhs            &
        ,.dX            &
        ,.near_0_tol    &
        ,.near_0        &
        ,.near_0_evals  &
        ,.near_0_evecs  &
        , eval          &
        ,.covariance_mx &
        ,.correlation_mx)

      rhs.destroy
      A.destroy

      if (.show_near_0_eigenvectors) then
         stdout.text("shifts:")
         stdout.put(.dX)
         stdout.set_real_fortran_fmt("e")
!        stdout.show("Normal equations check =",maxval(abs(matmul(A,.dX)-rhs)))
!        stdout.show("Smallest eigenvalue    =",minval(abs(.near_0_evals)))
         stdout.show("near_0_tol             =",.near_0_tol)
         stdout.show("near_0                 =",.near_0)
         stdout.flush
         stdout.set_real_fortran_fmt("f")
         stdout.text("Distribution of values:")
         ! table.put_log_table(eval,.near_0_tol)
         stdout.set_real_fortran_fmt("e")
         stdout.flush
         stdout.text("All eigenvalues:")
         stdout.put(eval,by_column=TRUE)
         if (.near_0>0) then
         stdout.flush
         stdout.text("Near_0 eigenvalues:")
         stdout.put(.near_0_evals,by_column=TRUE)
         stdout.set_real_fortran_fmt("f")
         stdout.flush
         stdout.text("Near_0 eigenvectors:")
         stdout.put(.near_0_evecs)
         end
      end 


      ! Get the maximum shift
      where (abs(.dX)<DIFFRACTION_DATA_SMALLEST_SHIFT) 
         .dX = ZERO
      end
      .max_shift = maxval(abs(.dX))

      ! Set the number of parameters
      .n_param = n_p - .n_0 - .near_0

      ! Update chi2
      .SET:update_n_param_and_chi2

      ! Set the full covariance matrix
      .covariance_mx = .chi2*.covariance_mx

      ! Set the fit errors e.g. max(.dX/esd)
      ! Parameter ordering is unique fragment atom order.
      .SET:update_fit_esds

      ! Renormalise shift if too big
      if (.max_shift>.max_allowed_param_shift) then
         fac = .max_allowed_param_shift/.max_shift
         .dX = fac * .dX
      end

   end

end
