!===================================================================
!
! CPX: Complex numbers
!
! Copyright (C) Dylan Jayatilaka, 1998
! Copyright (C) Dylan Jayatilaka, 2023
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!===================================================================

module CPX

   implicit none

   interface to_str
      to_str_cpx_0
      to_str_cpx_1
      to_str_cpx_2
   end

contains

! =============
! String widths
! =============
   
   no_of_fields_per_value result (res) ::: pure
   ! Returns the number of fields used to print a "self".
      self :: IN
      res :: INT

      if (FALSE) res = transfer(self,res)
      res = 2

   end 
   
   str_length result (res) ::: get_from(INTRINSIC, FMT=>*), pure
   ! Returns the minimal string length.
   ! Note: for real and complex only
   end 

   str_length(dp,spaces) result (res) ::: pure
   ! Return *twice* the string length from the int part of the REAL
   ! value "self", keeping "dp" decimal places with extra "spaces" 
   ! (if present).  The resuls is twice that for a real number.
      self :: IN
      dp :: INT, IN
      spaces :: INT, optional, IN
      res :: INT

      val :: REAL
      wid :: INT

      val = REALIFY(self)
      wid = val.str_length(dp)
      if (present(spaces)) wid = wid + spaces

      res = .no_of_fields_per_value * wid

   end

   get_str_length(sl,spaces) ::: get_from(INTRINSIC, FMT=>*), pure
   ! Returns the minimal string length.
   ! Note: for real and complex only
   end

   get_str_length_maxdp(sl,max_dp,spaces) ::: pure
   ! Return "sl" as *twice* the string length from the int part of the
   ! REAL value "self", keeping "max_dp" decimal places with extra
   ! "spaces" (if present). The resuls is twice that for a real.
      self :: IN
      sl :: INT, OUT
      max_dp :: INT, IN
      spaces :: INT, IN

      val :: REAL
      wid :: INT

      val = REALIFY(self)
      val.get_str_length_maxdp(wid,max_dp,spaces)

      sl = .no_of_fields_per_value * wid

   end

! =================
! String conversion
! =================

! This is for INTEL_ifort

   to_str_cpx_0 result (string) ::: get_from(INTRINSIC:to_str, FMT=>*), pure
   ! Change self to a string of minimal length
   end

   to_str_cpx_1(fmt,left_justify) result (string) ::: get_from(INTRINSIC:to_str), pure
   ! Change self to a "string" using the specified fortran "fmt".
   end

   to_str_cpx_2(style,width,precision,left_justify) result (string) ::: get_from(INTRINSIC:to_str, NN=>2), pure
   ! Change self to a string with specified fortran "style", in a
   ! field of "width" characters and "precision" decimal points.
   end

! ================
! Equality testing
! ================

   equals(c,eps) result (res) ::: pure
   ! Test to see if "self" is the same as "c"
      self :: IN
      c :: CPX, IN
      eps :: REAL, optional, IN
      res :: BIN

      res = .same_as(c,eps)

   end

   same_as(c,eps) result (res) ::: pure
   ! Test to see if "self" is the same as "c"
      self :: IN
      c :: CPX, IN
      eps :: REAL, optional, IN
      res :: BIN

      tol :: REAL

      tol = REAL_EPSILON
      if (present(eps)) tol = abs(eps)

      res = abs(self-c) < tol

   end

   same_as(r,eps) result (res) ::: pure
   ! Test to see if "self" is the same as "c"
      self :: IN
      r :: REAL, IN
      eps :: REAL, optional, IN
      res :: BIN

      tol :: REAL

      tol = REAL_EPSILON
      if (present(eps)) tol = abs(eps)

      res = abs(self-r) < tol

   end

   is_zero(eps) result (res) ::: pure
   ! Return TRUE if self is near enough zero. If present, "eps" defines how
   ! close to zero before the number is considered zero.
      self :: IN
      eps :: REAL, optional, IN
      res :: BIN

      tol :: REAL

      tol = REAL_EPSILON
      if (present(eps)) tol = abs(eps)

      res = abs(self) < tol

   end

   is_one(eps) result (res) ::: pure
   ! Return TRUE if self is near enough one. If present, "eps" defines how
   ! close to one before the number is considered zero.
      self :: IN
      eps :: REAL, optional, IN
      res :: BIN

      tol :: REAL

      tol = REAL_EPSILON
      if (present(eps)) tol = abs(eps)

      res = abs(self-ONE) < tol

   end

   is_minus_one(eps) result (res) ::: pure
   ! Return TRUE if self is near enough minus one. If present, "eps" defines how
   ! close to minus one before the number is considered zero.
      self :: IN
      eps :: REAL, optional, IN
      res :: BIN

      tol :: REAL

      tol = REAL_EPSILON
      if (present(eps)) tol = abs(eps)

      res = abs(self+ONE) < tol

   end

! ======================
! Complex gamma function
! ======================

   gamma(opt) result (res) ::: pure
   ! Complex gamma function
   ! - opt==0, res =    gamma(self)
   ! - opt/=0, res = ln(gamma(self))
   !
   ! BY ALFRED H. MORRIS, JR., 
   ! NAVAL SURFACE WARFARE CENTER, DAHLGREN, VIRGINIA
   !
   ! This version, in a subset of Fortran 90, prepared by
   ! Alan.Miller @ vic.cmis.csiro.au
   ! http://www.ozemail.com.au/~milleraj
   ! This version was is accurate to within 5 in the 14th significant
   !
   ! Finally, foo-fied by Dylan Jayatilaka (2023)
      self :: IN
      opt  :: INT, IN
      res  :: CPX

      w,z, eta,eta2, sum  :: CPX
      pi2, p2, alpi, hl2p :: REAL
       a, a1, a2, c, cn, cut, d, eps, et, e2t, h1, h2, s, sn :: REAL
      s1, s2, t, t1, t2, u, u1, u2, v1, v2, w1, w2, x, y, y2 :: REAL
      j, k, l, m, max, n, nm1 :: INT
      c0 :: VEC{REAL}(12)

      ! CONSTANTS
      pi2  = TWO*PI
      alpi = 1.14472988584940  ! ALPI = LOG(PI)
      hl2p = 0.918938533204673 ! HL2P = 0.5 * LOG(2*PI)
      
      max = HUGE(3)            ! MAX IS THE LARGEST POSITIVE INTEGER THAT MAY
      eps = EPSILON(ONE)       ! SMALLEST NUMBER SUCH THAT 1.0 + EPS > 1.0.
      
      !!!!!!!!!
      z = self
      x = RE(z)
      y = IM(z)
      !!!!!!!!!

      ! THIS IS THE FAILED VALUE
      res = COMPLEXIFY(huge(ONE), huge(ONE))

      ! SETUP !
      if (x < ZERO) then

         ! Negative case, but y -> |y|
         y   = abs(y)     ! <--- NOTE
         t   = -PI * y
         et  = exp(t)
         e2t = et * et
       
         a1 = HALF * (ONE + e2t)
         t2 = t + t
         if (t2 >= -0.15) then; a2 = -HALF * CPX::rexp(t2)
         else;                  a2 =  HALF * (HALF + (HALF - e2t))
         end
       
         ! Fail
         if (abs(x) >= min(RE(max), ONE/eps)) return

         k = abs(x)
         u = x + k
         k = mod(k,2)
         if (u <= -HALF) then
           u = HALF + (HALF + u)
           k = k + 1
         end    

         u  = PI * u
         sn = sin(u)
         cn = cos(u)
         if (k == 1) then
           sn = -sn
           cn = -cn
         end   
       
         a1 = sn*a1
         a2 = cn*a2
         a  = a1*a1 + a2*a2
        
         ! Fail
         if (a  == ZERO) return
        
         if (opt==0) then
            h1 =  a1/a
            h2 = -a2/a
            c  = PI* et
            h1 = c * h1
            h2 = c * h2
         else
            h1 =  (alpi+t) - HALF*log(a)
            h2 = -atan2(a2,a1)
         end   
        
         ! Change x, reset y back
         x =  ONE - x
         if (IM(z) >= ZERO) then; y  = -y
         else;                    h2 = -h2
         end

      end

      ! y = Im(z) has correct value
      w1 = ZERO
      w2 = ZERO
      n  = 0
      t  = x
      y2 = y*y
      a  = t*t + y2

      cut = 36.0e+00
      if (eps > 1.0e-08) cut = 16.0d0

      if (a < cut) then

         ! Fail
         if (a == ZERO) return
         
         do
            n = n + 1
            t = t + ONE
            a = t * t + y2
            if (a >= cut) return
         end
         
         ! S1 + S2*I IS PRODUCT OF TERMS (Z+J)/(Z+N)
         u1 = (x*t+y2) / a
         u2 = y / a
         s1 = u1
         s2 = n * u2
         if (n >= 2) then
            u   = t / a
            nm1 = n - 1
            do j = 1, nm1
               v1 = u1 + j * u
               v2 = (n-j) * u2
               c  = s1*v1 - s2*v2
               d  = s1*v2 + s2*v1
               s1 = c
               s2 = d
            end
         end   
         
         ! W1 + W2*I = LOG(S1 + S2*I) WHEN OPT/=0
         s = s1*s1 + s2*s2
         if (opt/=0) then
            w1 = HALF * log(s)
            w2 = atan2(s2,s1)
         end

      end
      
      ! SET  V1 + V2*I = (Z - 0.5) * LOG(Z + N) - Z
      t1 = HALF*log(a) - ONE
      t2 = atan2(y,t)
      u  = x - HALF
      v1 = (u*t1 - HALF) - y * t2
      v2 = u*t2 + y*t1
      
      ! A1 + A2*I IS THE ASYMPTOTIC SUM
      c0 = [ 0.833333333333333e-01, &
            -0.277777777777778e-02, &
             0.793650793650794e-03, &
            -0.595238095238095e-03, &
             0.841750841750842e-03, &
            -0.191752691752692e-02, &
             0.641025641025641e-02, &
            -0.295506535947712e-01, &
             0.179644372368831e+00, &
            -0.139243221690590e+01, &
             0.134028640441684e+02, &
            -0.156848284626002e+03  ]
      eta  = COMPLEXIFY(t/a, -y/a)
      eta2 = eta * eta
      m = 12
      if (a   >= 289.0  ) m = 6
      if (eps >  1.0e-08) m = m/2
      sum = COMPLEXIFY(c0(m), ZERO)
      l = m
      do j = 2, m
        l = l - 1
        sum = COMPLEXIFY(c0(l), ZERO) + sum*eta2
      end
      sum = sum*eta
      a1 = RE(sum)
      a2 = IM(sum)

      ! GATHER TOGETHER RESULTS
      w1 = (((a1 + hl2p) - w1) + v1) - n
      w2 = (a2 - w2) + v2
      ! END SETUP !

      ! Cases RE(z) & opt
      if (RE(z) < ZERO) then

         if (opt==0) then
            a  = exp(-w1)
            t1 = a * cos(-w2)
            t2 = a * sin(-w2)
            w1 = h1*t1 - h2*t2
            w2 = h1*t2 + h2*t1
            if (n/=0) then
               c  = w1*s1 - w2*s2
               d  = w1*s2 + w2*s1
               w1 = c
               w2 = d
            end
         else ! opt/=0
            w1 = h1 - w1
            w2 = h2 - w2
         end

      else ! RE(z) >= 0
        
         if (opt==0) then
            a  = exp(w1)
            w1 = a * cos(w2)
            w2 = a * sin(w2)
            if (n/=0) then
               c  = (s1*w1 + s2*w2) / s
               d  = (s1*w2 - s2*w1) / s
               w1 = c
               w2 = d
            end
         end

      end

      if (opt/=0) then
         ! THE ANGLE W2 IS PUT INTO INTERVAL -PI < W2 <= PI.
         if (w2 <= PI) then
            k  = HALF - w2 / pi2
            w2 = w2 + pi2 * k
         else   
            k  = w2 / pi2 - HALF
            w2 = w2 - pi2 * REALIFY(k+1)
            if (w2 <= -PI) w2 = PI
         end
      end

      ! TERMINATION
      res = COMPLEXIFY(w1,w2)

   end

   rexp(x) result (res) ::: selfless, private, pure
   ! Evaluate exp(x) - 1
      x :: REAL, IN
      res :: REAL

      p1,p2, q1,q2,q3,q4, e :: REAL

      if (abs(x) <= 0.15) then
         ! Domain [-0.15,+0.15]
         p1 =  0.914041914819518e-09
         p2 =  0.238082361044469e-01 
         q1 = -0.499999999085958e+00
         q2 =  0.107141568980644e+00 
         q3 = -0.119041179760821e-01
         q4 =  0.595130811860248e-03
         res = x * (((p2*x + p1)*x + ONE) /  &
               ((((q4*x + q3)*x + q2)*x + q1)*x + ONE))
      else if (x >= ZERO) then
         ! Domain [+0.15,+inf]
         e   = exp(x)
         res = e * (HALF + (HALF - ONE/e))
      else if (x >= -37.0) then
         ! Domain [-37.0,-0.15]
         res = (exp(x) - HALF) - HALF
      else
         ! Domain [-inf,-37.0]
         res = -ONE
      end

   end

end
